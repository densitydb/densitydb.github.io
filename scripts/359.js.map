{"version":3,"file":"359.js","sources":["webpack://assets/./src/utils/bitap-selector.ts","webpack://assets/./src/mapper/settings/BetterSelector.tsx","webpack://assets/./src/utils/bitap.ts","webpack://assets/./src/utils/IFrameInput.tsx","webpack://assets/./src/utils/Property.ts"],"sourcesContent":["/**\n * Finds the minimum number of edits between `haystack` and some `needle` in `haystack`\n *\n * Use `bitapAlphabet` to prepare needly\n *\n * Differs from bitap for search in that it doesn't expect needly to be at the beginning of haystack\n *\n * Returns [0, maxErrors + 1], where maxErrors + 1 means a match was not found with lte maxErrors errors\n *\n * Takes scratch buffers, which must be an array of at least length maxErrors + 1 length, filled with Uint32Arrays of at least (needle.length + haystack.length + 1) length\n */\nexport function bitap(haystack: string, needle: { alphabet: Uint32Array, length: number }, maxErrors: number, sb: Uint32Array[]): number {\n    for (let errors = 0; errors <= maxErrors; errors++) {\n        sb[errors].fill(0)\n        sb[errors][0] = (1 << errors) - 1\n    }\n\n    const matchMask = 1 << (needle.length - 1)\n\n    search: for (let j = 1; j <= needle.length + haystack.length; j++) {\n        let charMatch: number\n        if (j - 1 < haystack.length) {\n            charMatch = needle.alphabet[haystack.charCodeAt(j - 1)]\n        }\n        else {\n            charMatch = 0\n        }\n\n        for (let errors = 0; errors <= maxErrors; errors++) {\n            if (errors === 0) {\n                sb[0][j] = ((sb[0][j - 1] << 1) | 1) & charMatch\n            }\n            else {\n                sb[errors][j] = (((sb[errors][j - 1] << 1) | 1) & charMatch) | (((sb[errors - 1][j - 1] | sb[errors - 1][j]) << 1) | 1) | sb[errors - 1][j - 1]\n            }\n\n            if ((sb[errors][j] & matchMask) !== 0) {\n                maxErrors = errors - 1\n                if (errors === 0) {\n                    break search\n                }\n            }\n        }\n    }\n    return maxErrors + 1\n}\n","import stableStringify from 'json-stable-stringify'\nimport React, { ReactNode, useState, useEffect, useRef, useMemo, CSSProperties } from 'react'\n\nimport { useColors } from '../../page_template/colors'\nimport { IFrameInput } from '../../utils/IFrameInput'\nimport { toNeedle } from '../../utils/bitap'\nimport { bitap } from '../../utils/bitap-selector'\nimport { zIndex } from '../../utils/zIndex'\n\nimport '../../common.css'\n\nexport const labelPadding = '4px'\n\nconst maxErrors = 31\n\nexport interface SelectorRenderResult { text: string, node?: (highlighted: boolean) => ReactNode }\n\nfunction PencilButton({ onEdit }: { onEdit: () => void }): ReactNode {\n    const size = { width: '20px', height: '20px' }\n    const colors = useColors()\n    return (\n        <button\n            style={{\n                border: 'none',\n                cursor: 'pointer',\n                padding: '0 0',\n                marginLeft: '4px',\n                opacity: 0.7,\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center',\n                ...size,\n            }}\n            onClick={(e) => {\n                e.preventDefault()\n                e.stopPropagation()\n                onEdit()\n            }}\n            title=\"Edit\"\n        >\n            <img\n                src={colors.pencilIcon}\n                alt=\"Edit\"\n                style={{ ...size }}\n            />\n        </button>\n    )\n}\n\nexport function BetterSelector<T>({ value, onChange, possibleValues, renderValue, onEdit, iframe = false, inputStyle, disabled = false, onBlur }: {\n    value: T\n    onChange: (newValue: T) => void\n    possibleValues: readonly T[] // Memo this for performance\n    renderValue: (v: T) => SelectorRenderResult // Memo this for performance\n    onEdit?: () => void\n    iframe?: boolean\n    inputStyle?: CSSProperties\n    disabled?: boolean\n    onBlur?: () => void\n}): ReactNode {\n    const colors = useColors()\n\n    const selectedRendered = renderValue(value)\n\n    const [searchValue, setSearchValue] = useState(selectedRendered.text)\n    const [isOpen, setIsOpen] = useState(false)\n    const [highlightedIndex, setHighlightedIndex] = useState(0)\n\n    const inputRef = useRef<HTMLInputElement>(null)\n\n    const menuRef = useRef<HTMLDivElement>(null)\n\n    // Needed if this component is reused in a different context\n    useEffect(() => {\n        setSearchValue(selectedRendered.text)\n    }, [selectedRendered.text])\n\n    const { bitapBuffers, options } = useMemo(() => {\n        const optionsResult = possibleValues.map((choice, index) => ({ renderedChoice: renderValue(choice), index }))\n\n        const longestSelectionPossibility = optionsResult.reduce((acc, poss) => Math.max(acc, poss.renderedChoice.text.toLowerCase().length), 0)\n        const bitapBuffersResult = Array.from({ length: maxErrors + 1 }, () => new Uint32Array(31 + longestSelectionPossibility + 1))\n\n        return {\n            options: optionsResult,\n            bitapBuffers: bitapBuffersResult,\n        }\n    }, [possibleValues, renderValue])\n\n    const sortedOptions = useMemo(() => {\n        const needle = toNeedle(searchValue.toLowerCase().slice(0, 31))\n\n        return options.sort((a, b) => {\n            const aScore = bitap(a.renderedChoice.text.toLowerCase(), needle, maxErrors, bitapBuffers)\n            const bScore = bitap(b.renderedChoice.text.toLowerCase(), needle, maxErrors, bitapBuffers)\n            if (aScore === bScore) {\n                return a.renderedChoice.text.length - b.renderedChoice.text.length\n            }\n            return aScore - bScore\n        })\n    }, [bitapBuffers, searchValue, options])\n\n    const handleOptionSelect = (option: typeof sortedOptions[number]): void => {\n        const newValue = possibleValues[option.index]\n        if (stableStringify(newValue) !== stableStringify(value)) {\n            onChange(newValue)\n        }\n        setSearchValue(option.renderedChoice.text)\n        setIsOpen(false)\n        setHighlightedIndex(0)\n    }\n\n    const handleKeyDown = (e: React.KeyboardEvent): void => {\n        if (!isOpen || sortedOptions.length === 0) return\n\n        switch (e.key) {\n            case 'ArrowDown':\n                e.preventDefault()\n                setHighlightedIndex(prev =>\n                    prev < sortedOptions.length - 1 ? prev + 1 : 0,\n                )\n                break\n            case 'ArrowUp':\n                e.preventDefault()\n                setHighlightedIndex(prev =>\n                    prev > 0 ? prev - 1 : sortedOptions.length - 1,\n                )\n                break\n            case 'Enter':\n                e.preventDefault()\n                if (highlightedIndex >= 0 && highlightedIndex < sortedOptions.length) {\n                    handleOptionSelect(sortedOptions[highlightedIndex])\n                }\n                break\n            case 'Escape':\n                e.preventDefault()\n                setIsOpen(false)\n                setHighlightedIndex(0)\n                break\n        }\n    }\n\n    // eslint-disable-next-line no-restricted-syntax -- Dynamic tag name\n    const InputElem = iframe ? IFrameInput : 'input'\n\n    return (\n        <div style={{ position: 'relative', flex: 1, display: 'flex', alignItems: 'center' }}>\n            <InputElem\n                ref={inputRef}\n                type=\"text\"\n                value={searchValue}\n                onChange={(e) => {\n                    setSearchValue(e.target.value)\n                    setIsOpen(true)\n                    setHighlightedIndex(0)\n                    if (menuRef.current) {\n                        menuRef.current.scrollTop = 0\n                    }\n                }}\n                onKeyDown={handleKeyDown}\n                onClick={(e) => {\n                    (e.target as HTMLInputElement).select()\n                }}\n                onFocus={() => {\n                    setIsOpen(true)\n                    setHighlightedIndex(0)\n                }}\n                onBlur={() => {\n                    // Delay closing to allow clicking on options\n                    setTimeout(() => {\n                        setIsOpen(false)\n                        setHighlightedIndex(0)\n                        onBlur?.()\n                    }, 150)\n                }}\n                placeholder=\"Search options...\"\n                style={{\n                    flex: 1,\n                    padding: `${labelPadding} 8px`,\n                    border: `1px solid ${colors.ordinalTextColor}`,\n                    borderRadius: '4px',\n                    fontSize: '14px',\n                    ...inputStyle,\n                }}\n                disabled={disabled}\n            />\n            {onEdit && <PencilButton onEdit={onEdit} />}\n            {isOpen && sortedOptions.length > 0 && (\n                <div\n                    style={{\n                        position: 'absolute',\n                        top: '100%',\n                        left: 0,\n                        right: 0,\n                        backgroundColor: colors.background,\n                        border: '1px solid #ccc',\n                        borderRadius: '4px',\n                        maxHeight: '200px',\n                        overflowY: 'auto',\n                        zIndex: zIndex.betterSelectorMenu,\n                        boxShadow: '0 2px 8px rgba(0,0,0,0.1)',\n                    }}\n                    ref={menuRef}\n                >\n                    {sortedOptions.map((option, index) => (\n                        <div\n                            key={index}\n                            onMouseDown={() => {\n                                handleOptionSelect(option)\n                            }}\n                            onMouseUp={() => {\n                                handleOptionSelect(option)\n                                inputRef.current?.blur()\n                            }}\n                            style={{\n                                cursor: 'pointer',\n                                borderBottom: index < sortedOptions.length - 1 ? '1px solid #eee' : 'none',\n                                overflow: 'hidden',\n                            }}\n                            onMouseEnter={() => { setHighlightedIndex(index) }}\n                        >\n                            {option.renderedChoice.node?.(index === highlightedIndex) ?? <DefaultSelectorOption text={option.renderedChoice.text} highlighted={index === highlightedIndex} />}\n                        </div>\n                    ))}\n                </div>\n            )}\n        </div>\n    )\n}\n\nfunction DefaultSelectorOption(props: { text: string, highlighted: boolean }): ReactNode {\n    const colors = useColors()\n    return (\n        <div style={{\n            padding: '8px 12px',\n            background: (props.highlighted ? colors.slightlyDifferentBackgroundFocused : colors.slightlyDifferentBackground),\n            color: props.text === '' ? colors.ordinalTextColor : colors.textMain,\n        }}\n        >\n            {props.text === '' ? 'No Selection' : props.text}\n        </div>\n    )\n}\n","/**\n * Algorithm for fuzzy string matching and associated utilities.\n *\n * This a modified bitap algorithm that's optimized for matching short strings to short strings.\n * It uses a signature that's based on the count of letters in the needle and haystack to quickly skip combinations that can't match.\n */\n\nimport { assert } from './defensive'\n\nexport interface Needle {\n    alphabet: Uint32Array\n    length: number\n    signature: number\n}\n\nexport function bitapAlphabet(token: string): Uint32Array {\n    assert(token.length <= 31, `Max bitap token length is 31`)\n    const alphabet = new Uint32Array(65535).fill(0)\n    for (let i = 0; i < token.length; i++) {\n        const char = token.charCodeAt(i)\n        alphabet[char] = alphabet[char] | (1 << i)\n    }\n    return alphabet\n}\n\nexport function toNeedle(token: string): Needle {\n    return { alphabet: bitapAlphabet(token), length: token.length, signature: toSignature(token) }\n}\n\nexport interface Haystack {\n    haystack: string\n    signature: number\n}\n\nexport function toHaystack(token: string): Haystack {\n    return {\n        haystack: token,\n        signature: toSignature(token),\n    }\n}\n\nexport function toSignature(str: string): number {\n    const alphabetStart = 'a'.charCodeAt(0)\n    const alphabetEnd = 'z'.charCodeAt(0)\n    // 0 < alphabetEnd - alphabetStart < 26   because of javascript integer size\n    let result = 0\n    for (let i = 0; i < str.length; i++) {\n        const charCode = str.charCodeAt(i)\n        if (charCode >= alphabetStart && charCode <= alphabetEnd) {\n            const firstOccurence = (1 << ((charCode - alphabetStart) * 2))\n            if ((result & firstOccurence) !== 0) {\n                result |= (firstOccurence << 1) // second occurence\n            }\n            else {\n                result |= firstOccurence\n            }\n        }\n    }\n    return result\n}\n\nexport const bitapPerformance = {\n    numBitapSignatureChecks: 0,\n    numBitapSignatureSkips: 0,\n}\n\n/**\n * Finds the minimum number of edits between `haystack` and `needle` (assuming they have the same start position)\n *\n * Returns [0, maxErrors + 1], where maxErrors + 1 means a match was not found with lte maxErrors errors\n *\n * Takes scratch buffers, which must be an array of at least length maxErrors + 1 length, filled with Uint32Arrays of at least (needle.length + maxErrors + 1) length\n *\n */\nexport function bitap(haystack: Haystack, needle: Needle, maxErrors: number, scratchBuffers: Uint32Array[]): number {\n    let bestMatch = maxErrors + 1\n\n    if (maxErrors < 0) {\n        return bestMatch\n    }\n\n    bitapPerformance.numBitapSignatureChecks++\n    if (bitCount(needle.signature ^ (haystack.signature & needle.signature)) > maxErrors) {\n        bitapPerformance.numBitapSignatureSkips++\n        return bestMatch // The letters in the haystack and needle are too different to possibly match\n    }\n\n    for (let errors = 0; errors <= maxErrors; errors++) {\n        scratchBuffers[errors].fill(0)\n        scratchBuffers[errors][0] = (1 << errors) - 1\n    }\n\n    const matchMask = 1 << (needle.length - 1)\n\n    for (let j = 1; j <= (needle.length + maxErrors); j++) {\n        let charMatch: number\n        if (j - 1 < haystack.haystack.length) {\n            charMatch = needle.alphabet[haystack.haystack.charCodeAt(j - 1)]\n        }\n        else {\n            charMatch = 0\n        }\n\n        for (let errors = 0; errors <= maxErrors; errors++) {\n            if (errors === 0) {\n                scratchBuffers[0][j] = ((scratchBuffers[0][j - 1] << 1) | 1) & charMatch\n            }\n            else {\n                scratchBuffers[errors][j] = (((scratchBuffers[errors][j - 1] << 1) | 1) & charMatch) | (((scratchBuffers[errors - 1][j - 1] | scratchBuffers[errors - 1][j]) << 1) | 1) | scratchBuffers[errors - 1][j - 1]\n            }\n\n            if ((scratchBuffers[errors][j] & matchMask) !== 0) {\n                bestMatch = Math.min(bestMatch, Math.max(Math.abs(j - needle.length), errors))\n                maxErrors = Math.min(maxErrors, errors)\n                if (bestMatch === 0) {\n                    return bestMatch // We've found the best match we possibly can\n                }\n            }\n        }\n    }\n    return bestMatch\n}\n\nexport function bitCount(x: number): number {\n    return bitCount32(x) + bitCount32(Math.floor(x / 0x1_0000_0000))\n}\n\n// https://stackoverflow.com/a/109025\nfunction bitCount32(i: number): number {\n    i = i - ((i >> 1) & 0x55555555) // add pairs of bits\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333) // quads\n    i = (i + (i >> 4)) & 0x0F0F0F0F // groups of 8\n    i *= 0x01010101 // horizontal sum of bytes\n    return i >> 24\n}\n","import stableStringify from 'json-stable-stringify'\nimport React, { useRef, useState, useEffect, ReactNode } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useStyleElement } from '../page_template/colors'\n\n// eslint-disable-next-line no-restricted-syntax -- Forward ref\nexport const IFrameInput = React.forwardRef(IFrameInputRef)\n\n// A Drop In replacement for a normal input,\n// except allows selection to persist in the parent window by rendering the input in an iframe (which is technically another page)\nfunction IFrameInputRef(props: React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, ref: React.ForwardedRef<HTMLInputElement>): ReactNode {\n    const frameRef = useRef<HTMLIFrameElement>(null)\n    const [frameDoc, setFrameDoc] = useState<Document | undefined>()\n\n    useEffect(() => {\n        const doc = frameRef.current!.contentWindow!.document\n        for (const style of Array.from(document.head.querySelectorAll('style'))) {\n            doc.head.appendChild(style.cloneNode(true))\n        }\n        setFrameDoc(doc)\n    }, [])\n\n    const styleElement = useStyleElement()\n\n    useEffect(() => {\n        const doc = frameRef.current!.contentWindow!.document\n\n        styleElement(doc.documentElement)\n        doc.body.style.margin = '0px'\n        doc.body.style.backgroundColor = 'transparent'\n    }, [styleElement])\n\n    const [frame, setFrame] = useState({ left: 0, top: 0, width: 0, height: 0 })\n\n    const layoutInputRef = useRef<HTMLInputElement>(null)\n\n    useEffect(() => {\n        const layoutInput = layoutInputRef.current!\n        const updateFrame = (): void => {\n            setFrame((f) => {\n                const newFrame = { left: layoutInput.offsetLeft, top: layoutInput.offsetTop, width: layoutInput.offsetWidth, height: layoutInput.offsetHeight }\n                if (stableStringify(f) === stableStringify(newFrame)) {\n                    return f\n                }\n                return newFrame\n            })\n        }\n        updateFrame()\n        const resizeObserver = new ResizeObserver(updateFrame)\n        let ancestor: HTMLElement | null = layoutInput\n        while (ancestor !== null) {\n            resizeObserver.observe(ancestor)\n            ancestor = ancestor.parentElement\n        }\n        return () => {\n            resizeObserver.disconnect()\n        }\n    }, [])\n\n    return (\n        <>\n            <input ref={layoutInputRef} {...props} style={{ ...props.style, visibility: 'hidden' }} />\n            <iframe\n                ref={frameRef}\n                style={{\n                    border: 'none',\n                    position: 'absolute',\n                    ...frame,\n                }}\n            >\n                {frameDoc && createPortal(<input ref={ref} {...props} style={{ ...props.style, width: '100%', height: '100%' }} />, frameDoc.body)}\n            </iframe>\n        </>\n    )\n}\n","import { useEffect, useState } from 'react'\n\nexport class Property<T> {\n    private _value: T\n    readonly observers = new Set<() => void>()\n\n    readonly id = Math.random().toString(36).substring(2)\n\n    constructor(value: T) {\n        this._value = value\n    }\n\n    get value(): T {\n        return this._value\n    }\n\n    set value(newValue: T) {\n        this._value = newValue\n        this.observers.forEach((observer) => { observer() })\n    }\n\n    /* eslint-disable react-hooks/rules-of-hooks -- Custom hook method */\n    use(): T {\n        const [, setCounter] = useState(0)\n        useEffect(() => {\n            const observer = (): void => {\n                setCounter(counter => counter + 1)\n            }\n            this.observers.add(observer)\n            return () => {\n                this.observers.delete(observer)\n            }\n        // eslint-disable-next-line react-hooks/exhaustive-deps -- Needs this as the property can change around the effect\n        }, [this])\n        return this.value\n    }\n    /* eslint-enable react-hooks/rules-of-hooks */\n}\n"],"names":["bitap","haystack","needle","maxErrors","sb","errors","matchMask","search","j","charMatch","errors1","PencilButton","param","onEdit","size","colors","useColors","e","BetterSelector","value","onChange","possibleValues","renderValue","iframe","inputStyle","disabled","onBlur","selectedRendered","_useState","searchValue","setSearchValue","_useState1","isOpen","setIsOpen","_useState2","highlightedIndex","setHighlightedIndex","inputRef","useRef","menuRef","useEffect","_useMemo","optionsResult","choice","index","longestSelectionPossibility","acc","poss","Math","Array","Uint32Array","bitapBuffers","options","sortedOptions","useMemo","token","bitapAlphabet","assert","alphabet","i","char","toSignature","str","result","charCode","firstOccurence","a","b","aScore","bScore","handleOptionSelect","option","newValue","stableStringify","InputElem","IFrameInput","prev","setTimeout","zIndex","_option_renderedChoice_node1","_inputRef_current","DefaultSelectorOption","props","React","ref","frameRef","frameDoc","setFrameDoc","doc","_iteratorError","document","style","styleElement","useStyleElement","frame","setFrame","layoutInputRef","layoutInput","updateFrame","f","newFrame","resizeObserver","ResizeObserver","ancestor","createPortal","Property","Set","observer","use","setCounter","counter","t"],"mappings":"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"}