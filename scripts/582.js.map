{"version":3,"file":"582.js","sources":["webpack://assets/./node_modules/json-stable-stringify/index.js","webpack://assets/./node_modules/json-stable-stringify/node_modules/isarray/index.js","webpack://assets/./node_modules/jsonify/index.js","webpack://assets/./node_modules/jsonify/lib/parse.js","webpack://assets/./node_modules/jsonify/lib/stringify.js","webpack://assets/./src/utils/bitap-selector.ts","webpack://assets/./src/mapper/settings/BetterSelector.tsx","webpack://assets/./src/utils/bitap.ts","webpack://assets/./src/mapper/settings/SelectionContext.ts","webpack://assets/./src/mapper/settings/CustomEditor.tsx","webpack://assets/./src/mapper/settings/Selector.tsx","webpack://assets/./src/mapper/settings/AutoUXEditor.tsx","webpack://assets/./src/mapper/settings/ConditionEditor.tsx","webpack://assets/./src/mapper/settings/PreambleEditor.tsx","webpack://assets/./src/mapper/settings/TopLevelEditor.tsx","webpack://assets/./src/mapper/settings/parseExpr.ts","webpack://assets/./src/mapper/settings/utils.ts","webpack://assets/./src/urban-stats-script/literal-parser.ts","webpack://assets/./src/utils/Property.ts"],"sourcesContent":["'use strict';\n\n/** @type {typeof JSON.stringify} */\nvar jsonStringify = (typeof JSON !== 'undefined' ? JSON : require('jsonify')).stringify;\n\nvar isArray = require('isarray');\nvar objectKeys = require('object-keys');\nvar callBind = require('call-bind');\nvar callBound = require('call-bound');\n\nvar $join = callBound('Array.prototype.join');\nvar $indexOf = callBound('Array.prototype.indexOf');\nvar $splice = callBound('Array.prototype.splice');\nvar $sort = callBound('Array.prototype.sort');\n\n/** @type {(n: number, char: string) => string} */\nvar strRepeat = function repeat(n, char) {\n\tvar str = '';\n\tfor (var i = 0; i < n; i += 1) {\n\t\tstr += char;\n\t}\n\treturn str;\n};\n\n/** @type {(parent: import('.').Node, key: import('.').Key, value: unknown) => unknown} */\nvar defaultReplacer = function (_parent, _key, value) { return value; };\n\n/** @type {import('.')} */\nmodule.exports = function stableStringify(obj) {\n\t/** @type {Parameters<import('.')>[1]} */\n\tvar opts = arguments.length > 1 ? arguments[1] : void undefined;\n\tvar space = (opts && opts.space) || '';\n\tif (typeof space === 'number') { space = strRepeat(space, ' '); }\n\tvar cycles = !!opts && typeof opts.cycles === 'boolean' && opts.cycles;\n\t/** @type {undefined | typeof defaultReplacer} */\n\tvar replacer = opts && opts.replacer ? callBind(opts.replacer) : defaultReplacer;\n\tif (opts && typeof opts.collapseEmpty !== 'undefined' && typeof opts.collapseEmpty !== 'boolean') {\n\t\tthrow new TypeError('`collapseEmpty` must be a boolean, if provided');\n\t}\n\tvar collapseEmpty = !!opts && opts.collapseEmpty;\n\n\tvar cmpOpt = typeof opts === 'function' ? opts : opts && opts.cmp;\n\t/** @type {undefined | (<T extends import('.').NonArrayNode>(node: T) => (a: Exclude<keyof T, symbol | number>, b: Exclude<keyof T, symbol | number>) => number)} */\n\tvar cmp = cmpOpt && function (node) {\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tvar get = /** @type {NonNullable<typeof cmpOpt>} */ (cmpOpt).length > 2\n\t\t\t&& /** @type {import('.').Getter['get']} */ function get(k) { return node[k]; };\n\t\treturn function (a, b) {\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\treturn /** @type {NonNullable<typeof cmpOpt>} */ (cmpOpt)(\n\t\t\t\t{ key: a, value: node[a] },\n\t\t\t\t{ key: b, value: node[b] },\n\t\t\t\t// @ts-expect-error TS doesn't understand the optimization used here\n\t\t\t\tget ? /** @type {import('.').Getter} */ { __proto__: null, get: get } : void undefined\n\t\t\t);\n\t\t};\n\t};\n\n\t/** @type {import('.').Node[]} */\n\tvar seen = [];\n\treturn (/** @type {(parent: import('.').Node, key: string | number, node: unknown, level: number) => string | undefined} */\n\t\tfunction stringify(parent, key, node, level) {\n\t\t\tvar indent = space ? '\\n' + strRepeat(level, space) : '';\n\t\t\tvar colonSeparator = space ? ': ' : ':';\n\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\tif (node && /** @type {{ toJSON?: unknown }} */ (node).toJSON && typeof /** @type {{ toJSON?: unknown }} */ (node).toJSON === 'function') {\n\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\tnode = /** @type {{ toJSON: Function }} */ (node).toJSON();\n\t\t\t}\n\n\t\t\tnode = replacer(parent, key, node);\n\t\t\tif (node === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (typeof node !== 'object' || node === null) {\n\t\t\t\treturn jsonStringify(node);\n\t\t\t}\n\n\t\t\t/** @type {(out: string[], brackets: '[]' | '{}') => string} */\n\t\t\tvar groupOutput = function (out, brackets) {\n\t\t\t\treturn collapseEmpty && out.length === 0\n\t\t\t\t\t? brackets\n\t\t\t\t\t: (brackets === '[]' ? '[' : '{') + $join(out, ',') + indent + (brackets === '[]' ? ']' : '}');\n\t\t\t};\n\n\t\t\tif (isArray(node)) {\n\t\t\t\tvar out = [];\n\t\t\t\tfor (var i = 0; i < node.length; i++) {\n\t\t\t\t\tvar item = stringify(node, i, node[i], level + 1) || jsonStringify(null);\n\t\t\t\t\tout[out.length] = indent + space + item;\n\t\t\t\t}\n\t\t\t\treturn groupOutput(out, '[]');\n\t\t\t}\n\n\t\t\tif ($indexOf(seen, node) !== -1) {\n\t\t\t\tif (cycles) { return jsonStringify('__cycle__'); }\n\t\t\t\tthrow new TypeError('Converting circular structure to JSON');\n\t\t\t} else {\n\t\t\t\tseen[seen.length] = /** @type {import('.').NonArrayNode} */ (node);\n\t\t\t}\n\n\t\t\t/** @type {import('.').Key[]} */\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\tvar keys = $sort(objectKeys(node), cmp && cmp(/** @type {import('.').NonArrayNode} */ (node)));\n\t\t\tvar out = [];\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\tvar value = stringify(/** @type {import('.').Node} */ (node), key, /** @type {import('.').NonArrayNode} */ (node)[key], level + 1);\n\n\t\t\t\tif (!value) { continue; }\n\n\t\t\t\tvar keyValue = jsonStringify(key)\n\t\t\t\t\t+ colonSeparator\n\t\t\t\t\t+ value;\n\n\t\t\t\tout[out.length] = indent + space + keyValue;\n\t\t\t}\n\t\t\t$splice(seen, $indexOf(seen, node), 1);\n\t\t\treturn groupOutput(out, '{}');\n\t\t}({ '': obj }, '', obj, 0)\n\t);\n};\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","'use strict';\n\nexports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n","'use strict';\n\nvar at; // The index of the current character\nvar ch; // The current character\nvar escapee = {\n\t'\"': '\"',\n\t'\\\\': '\\\\',\n\t'/': '/',\n\tb: '\\b',\n\tf: '\\f',\n\tn: '\\n',\n\tr: '\\r',\n\tt: '\\t'\n};\nvar text;\n\n// Call error when something is wrong.\nfunction error(m) {\n\tthrow {\n\t\tname: 'SyntaxError',\n\t\tmessage: m,\n\t\tat: at,\n\t\ttext: text\n\t};\n}\n\nfunction next(c) {\n\t// If a c parameter is provided, verify that it matches the current character.\n\tif (c && c !== ch) {\n\t\terror(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n\t}\n\n\t// Get the next character. When there are no more characters, return the empty string.\n\n\tch = text.charAt(at);\n\tat += 1;\n\treturn ch;\n}\n\nfunction number() {\n\t// Parse a number value.\n\tvar num;\n\tvar str = '';\n\n\tif (ch === '-') {\n\t\tstr = '-';\n\t\tnext('-');\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tstr += ch;\n\t\tnext();\n\t}\n\tif (ch === '.') {\n\t\tstr += '.';\n\t\twhile (next() && ch >= '0' && ch <= '9') {\n\t\t\tstr += ch;\n\t\t}\n\t}\n\tif (ch === 'e' || ch === 'E') {\n\t\tstr += ch;\n\t\tnext();\n\t\tif (ch === '-' || ch === '+') {\n\t\t\tstr += ch;\n\t\t\tnext();\n\t\t}\n\t\twhile (ch >= '0' && ch <= '9') {\n\t\t\tstr += ch;\n\t\t\tnext();\n\t\t}\n\t}\n\tnum = Number(str);\n\tif (!isFinite(num)) {\n\t\terror('Bad number');\n\t}\n\treturn num;\n}\n\nfunction string() {\n\t// Parse a string value.\n\tvar hex;\n\tvar i;\n\tvar str = '';\n\tvar uffff;\n\n\t// When parsing for string values, we must look for \" and \\ characters.\n\tif (ch === '\"') {\n\t\twhile (next()) {\n\t\t\tif (ch === '\"') {\n\t\t\t\tnext();\n\t\t\t\treturn str;\n\t\t\t} else if (ch === '\\\\') {\n\t\t\t\tnext();\n\t\t\t\tif (ch === 'u') {\n\t\t\t\t\tuffff = 0;\n\t\t\t\t\tfor (i = 0; i < 4; i += 1) {\n\t\t\t\t\t\thex = parseInt(next(), 16);\n\t\t\t\t\t\tif (!isFinite(hex)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuffff = (uffff * 16) + hex;\n\t\t\t\t\t}\n\t\t\t\t\tstr += String.fromCharCode(uffff);\n\t\t\t\t} else if (typeof escapee[ch] === 'string') {\n\t\t\t\t\tstr += escapee[ch];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr += ch;\n\t\t\t}\n\t\t}\n\t}\n\terror('Bad string');\n}\n\n// Skip whitespace.\nfunction white() {\n\twhile (ch && ch <= ' ') {\n\t\tnext();\n\t}\n}\n\n// true, false, or null.\nfunction word() {\n\tswitch (ch) {\n\t\tcase 't':\n\t\t\tnext('t');\n\t\t\tnext('r');\n\t\t\tnext('u');\n\t\t\tnext('e');\n\t\t\treturn true;\n\t\tcase 'f':\n\t\t\tnext('f');\n\t\t\tnext('a');\n\t\t\tnext('l');\n\t\t\tnext('s');\n\t\t\tnext('e');\n\t\t\treturn false;\n\t\tcase 'n':\n\t\t\tnext('n');\n\t\t\tnext('u');\n\t\t\tnext('l');\n\t\t\tnext('l');\n\t\t\treturn null;\n\t\tdefault:\n\t\t\terror(\"Unexpected '\" + ch + \"'\");\n\t}\n}\n\n// Parse an array value.\nfunction array() {\n\tvar arr = [];\n\n\tif (ch === '[') {\n\t\tnext('[');\n\t\twhite();\n\t\tif (ch === ']') {\n\t\t\tnext(']');\n\t\t\treturn arr; // empty array\n\t\t}\n\t\twhile (ch) {\n\t\t\tarr.push(value()); // eslint-disable-line no-use-before-define\n\t\t\twhite();\n\t\t\tif (ch === ']') {\n\t\t\t\tnext(']');\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tnext(',');\n\t\t\twhite();\n\t\t}\n\t}\n\terror('Bad array');\n}\n\n// Parse an object value.\nfunction object() {\n\tvar key;\n\tvar obj = {};\n\n\tif (ch === '{') {\n\t\tnext('{');\n\t\twhite();\n\t\tif (ch === '}') {\n\t\t\tnext('}');\n\t\t\treturn obj; // empty object\n\t\t}\n\t\twhile (ch) {\n\t\t\tkey = string();\n\t\t\twhite();\n\t\t\tnext(':');\n\t\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\t\terror('Duplicate key \"' + key + '\"');\n\t\t\t}\n\t\t\tobj[key] = value(); // eslint-disable-line no-use-before-define\n\t\t\twhite();\n\t\t\tif (ch === '}') {\n\t\t\t\tnext('}');\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\tnext(',');\n\t\t\twhite();\n\t\t}\n\t}\n\terror('Bad object');\n}\n\n// Parse a JSON value. It could be an object, an array, a string, a number, or a word.\nfunction value() {\n\twhite();\n\tswitch (ch) {\n\t\tcase '{':\n\t\t\treturn object();\n\t\tcase '[':\n\t\t\treturn array();\n\t\tcase '\"':\n\t\t\treturn string();\n\t\tcase '-':\n\t\t\treturn number();\n\t\tdefault:\n\t\t\treturn ch >= '0' && ch <= '9' ? number() : word();\n\t}\n}\n\n// Return the json_parse function. It will have access to all of the above functions and variables.\nmodule.exports = function (source, reviver) {\n\tvar result;\n\n\ttext = source;\n\tat = 0;\n\tch = ' ';\n\tresult = value();\n\twhite();\n\tif (ch) {\n\t\terror('Syntax error');\n\t}\n\n\t// If there is a reviver function, we recursively walk the new structure,\n\t// passing each name/value pair to the reviver function for possible\n\t// transformation, starting with a temporary root object that holds the result\n\t// in an empty key. If there is not a reviver function, we simply return the\n\t// result.\n\n\treturn typeof reviver === 'function' ? (function walk(holder, key) {\n\t\tvar k;\n\t\tvar v;\n\t\tvar val = holder[key];\n\t\tif (val && typeof val === 'object') {\n\t\t\tfor (k in value) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(val, k)) {\n\t\t\t\t\tv = walk(val, k);\n\t\t\t\t\tif (typeof v === 'undefined') {\n\t\t\t\t\t\tdelete val[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval[k] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reviver.call(holder, key, val);\n\t}({ '': result }, '')) : result;\n};\n","'use strict';\n\nvar escapable = /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\nvar gap;\nvar indent;\nvar meta = { // table of character substitutions\n\t'\\b': '\\\\b',\n\t'\\t': '\\\\t',\n\t'\\n': '\\\\n',\n\t'\\f': '\\\\f',\n\t'\\r': '\\\\r',\n\t'\"': '\\\\\"',\n\t'\\\\': '\\\\\\\\'\n};\nvar rep;\n\nfunction quote(string) {\n\t// If the string contains no control characters, no quote characters, and no\n\t// backslash characters, then we can safely slap some quotes around it.\n\t// Otherwise we must also replace the offending characters with safe escape sequences.\n\n\tescapable.lastIndex = 0;\n\treturn escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n\t\tvar c = meta[a];\n\t\treturn typeof c === 'string' ? c\n\t\t\t: '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t}) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n\t// Produce a string from holder[key].\n\tvar i; // The loop counter.\n\tvar k; // The member key.\n\tvar v; // The member value.\n\tvar length;\n\tvar mind = gap;\n\tvar partial;\n\tvar value = holder[key];\n\n\t// If the value has a toJSON method, call it to obtain a replacement value.\n\tif (value && typeof value === 'object' && typeof value.toJSON === 'function') {\n\t\tvalue = value.toJSON(key);\n\t}\n\n\t// If we were called with a replacer function, then call the replacer to obtain a replacement value.\n\tif (typeof rep === 'function') {\n\t\tvalue = rep.call(holder, key, value);\n\t}\n\n\t// What happens next depends on the value's type.\n\tswitch (typeof value) {\n\t\tcase 'string':\n\t\t\treturn quote(value);\n\n\t\tcase 'number':\n\t\t\t// JSON numbers must be finite. Encode non-finite numbers as null.\n\t\t\treturn isFinite(value) ? String(value) : 'null';\n\n\t\tcase 'boolean':\n\t\tcase 'null':\n\t\t\t// If the value is a boolean or null, convert it to a string. Note:\n\t\t\t// typeof null does not produce 'null'. The case is included here in\n\t\t\t// the remote chance that this gets fixed someday.\n\t\t\treturn String(value);\n\n\t\tcase 'object':\n\t\t\tif (!value) {\n\t\t\t\treturn 'null';\n\t\t\t}\n\t\t\tgap += indent;\n\t\t\tpartial = [];\n\n\t\t\t// Array.isArray\n\t\t\tif (Object.prototype.toString.apply(value) === '[object Array]') {\n\t\t\t\tlength = value.length;\n\t\t\t\tfor (i = 0; i < length; i += 1) {\n\t\t\t\t\tpartial[i] = str(i, value) || 'null';\n\t\t\t\t}\n\n\t\t\t\t// Join all of the elements together, separated with commas, and wrap them in brackets.\n\t\t\t\tv = partial.length === 0 ? '[]' : gap\n\t\t\t\t\t? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']'\n\t\t\t\t\t: '[' + partial.join(',') + ']';\n\t\t\t\tgap = mind;\n\t\t\t\treturn v;\n\t\t\t}\n\n\t\t\t// If the replacer is an array, use it to select the members to be stringified.\n\t\t\tif (rep && typeof rep === 'object') {\n\t\t\t\tlength = rep.length;\n\t\t\t\tfor (i = 0; i < length; i += 1) {\n\t\t\t\t\tk = rep[i];\n\t\t\t\t\tif (typeof k === 'string') {\n\t\t\t\t\t\tv = str(k, value);\n\t\t\t\t\t\tif (v) {\n\t\t\t\t\t\t\tpartial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Otherwise, iterate through all of the keys in the object.\n\t\t\t\tfor (k in value) {\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\tv = str(k, value);\n\t\t\t\t\t\tif (v) {\n\t\t\t\t\t\t\tpartial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Join all of the member texts together, separated with commas, and wrap them in braces.\n\n\t\t\tv = partial.length === 0 ? '{}' : gap\n\t\t\t\t? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}'\n\t\t\t\t: '{' + partial.join(',') + '}';\n\t\t\tgap = mind;\n\t\t\treturn v;\n\t\tdefault:\n\t}\n}\n\nmodule.exports = function (value, replacer, space) {\n\tvar i;\n\tgap = '';\n\tindent = '';\n\n\t// If the space parameter is a number, make an indent string containing that many spaces.\n\tif (typeof space === 'number') {\n\t\tfor (i = 0; i < space; i += 1) {\n\t\t\tindent += ' ';\n\t\t}\n\t} else if (typeof space === 'string') {\n\t\t// If the space parameter is a string, it will be used as the indent string.\n\t\tindent = space;\n\t}\n\n\t// If there is a replacer, it must be a function or an array. Otherwise, throw an error.\n\trep = replacer;\n\tif (\n\t\treplacer\n\t\t&& typeof replacer !== 'function'\n\t\t&& (typeof replacer !== 'object' || typeof replacer.length !== 'number')\n\t) {\n\t\tthrow new Error('JSON.stringify');\n\t}\n\n\t// Make a fake root object containing our value under the key of ''.\n\t// Return the result of stringifying the value.\n\treturn str('', { '': value });\n};\n","/**\n * Finds the minimum number of edits between `haystack` and some `needle` in `haystack`\n *\n * Use `bitapAlphabet` to prepare needly\n *\n * Differs from bitap for search in that it doesn't expect needly to be at the beginning of haystack\n *\n * Returns [0, maxErrors + 1], where maxErrors + 1 means a match was not found with lte maxErrors errors\n *\n * Takes scratch buffers, which must be an array of at least length maxErrors + 1 length, filled with Uint32Arrays of at least (needle.length + haystack.length + 1) length\n */\nexport function bitap(haystack: string, needle: { alphabet: Uint32Array, length: number }, maxErrors: number, sb: Uint32Array[]): number {\n    for (let errors = 0; errors <= maxErrors; errors++) {\n        sb[errors].fill(0)\n        sb[errors][0] = (1 << errors) - 1\n    }\n\n    const matchMask = 1 << (needle.length - 1)\n\n    search: for (let j = 1; j <= needle.length + haystack.length; j++) {\n        let charMatch: number\n        if (j - 1 < haystack.length) {\n            charMatch = needle.alphabet[haystack.charCodeAt(j - 1)]\n        }\n        else {\n            charMatch = 0\n        }\n\n        for (let errors = 0; errors <= maxErrors; errors++) {\n            if (errors === 0) {\n                sb[0][j] = ((sb[0][j - 1] << 1) | 1) & charMatch\n            }\n            else {\n                sb[errors][j] = (((sb[errors][j - 1] << 1) | 1) & charMatch) | (((sb[errors - 1][j - 1] | sb[errors - 1][j]) << 1) | 1) | sb[errors - 1][j - 1]\n            }\n\n            if ((sb[errors][j] & matchMask) !== 0) {\n                maxErrors = errors - 1\n                if (errors === 0) {\n                    break search\n                }\n            }\n        }\n    }\n    return maxErrors + 1\n}\n","import stableStringify from 'json-stable-stringify'\nimport React, { ReactNode, useState, useEffect, useRef, useMemo } from 'react'\n\nimport { useColors } from '../../page_template/colors'\nimport { toNeedle } from '../../utils/bitap'\nimport { bitap } from '../../utils/bitap-selector'\n\nimport '../../common.css'\n\nexport const labelPadding = '4px'\n\nconst maxErrors = 31\n\nexport interface SelectorRenderResult { text: string, node?: (highlighted: boolean) => ReactNode }\n\nfunction PencilButton({ onEdit }: { onEdit: () => void }): ReactNode {\n    const size = { width: '20px', height: '20px' }\n    const colors = useColors()\n    return (\n        <button\n            style={{\n                border: 'none',\n                cursor: 'pointer',\n                padding: '0 0',\n                marginLeft: '4px',\n                opacity: 0.7,\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center',\n                ...size,\n            }}\n            onClick={(e) => {\n                e.preventDefault()\n                e.stopPropagation()\n                onEdit()\n            }}\n            title=\"Edit\"\n        >\n            <img\n                src={colors.pencilIcon}\n                alt=\"Edit\"\n                style={{ ...size }}\n            />\n        </button>\n    )\n}\n\nexport function BetterSelector<T>({ value, onChange, possibleValues, renderValue, onEdit }: {\n    value: T\n    onChange: (newValue: T) => void\n    possibleValues: readonly T[] // Memo this for performance\n    renderValue: (v: T) => SelectorRenderResult // Memo this for performance\n    onEdit?: () => void\n}): ReactNode {\n    const colors = useColors()\n\n    const selectedRendered = renderValue(value)\n\n    const [searchValue, setSearchValue] = useState(selectedRendered.text)\n    const [isOpen, setIsOpen] = useState(false)\n    const [highlightedIndex, setHighlightedIndex] = useState(0)\n\n    const inputRef = useRef<HTMLInputElement>(null)\n\n    const menuRef = useRef<HTMLDivElement>(null)\n\n    // Needed if this component is reused in a different context\n    useEffect(() => {\n        setSearchValue(selectedRendered.text)\n    }, [selectedRendered.text])\n\n    const { bitapBuffers, options } = useMemo(() => {\n        const optionsResult = possibleValues.map((choice, index) => ({ renderedChoice: renderValue(choice), index }))\n\n        const longestSelectionPossibility = optionsResult.reduce((acc, poss) => Math.max(acc, poss.renderedChoice.text.toLowerCase().length), 0)\n        const bitapBuffersResult = Array.from({ length: maxErrors + 1 }, () => new Uint32Array(31 + longestSelectionPossibility + 1))\n\n        return {\n            options: optionsResult,\n            bitapBuffers: bitapBuffersResult,\n        }\n    }, [possibleValues, renderValue])\n\n    const sortedOptions = useMemo(() => {\n        const needle = toNeedle(searchValue.toLowerCase().slice(0, 31))\n\n        return options.sort((a, b) => {\n            const aScore = bitap(a.renderedChoice.text.toLowerCase(), needle, maxErrors, bitapBuffers)\n            const bScore = bitap(b.renderedChoice.text.toLowerCase(), needle, maxErrors, bitapBuffers)\n            if (aScore === bScore) {\n                return a.renderedChoice.text.length - b.renderedChoice.text.length\n            }\n            return aScore - bScore\n        })\n    }, [bitapBuffers, searchValue, options])\n\n    const handleOptionSelect = (option: typeof sortedOptions[number]): void => {\n        const newValue = possibleValues[option.index]\n        if (stableStringify(newValue) !== stableStringify(value)) {\n            onChange(newValue)\n        }\n        setSearchValue(option.renderedChoice.text)\n        setIsOpen(false)\n        setHighlightedIndex(0)\n    }\n\n    const handleKeyDown = (e: React.KeyboardEvent): void => {\n        if (!isOpen || sortedOptions.length === 0) return\n\n        switch (e.key) {\n            case 'ArrowDown':\n                e.preventDefault()\n                setHighlightedIndex(prev =>\n                    prev < sortedOptions.length - 1 ? prev + 1 : 0,\n                )\n                break\n            case 'ArrowUp':\n                e.preventDefault()\n                setHighlightedIndex(prev =>\n                    prev > 0 ? prev - 1 : sortedOptions.length - 1,\n                )\n                break\n            case 'Enter':\n                e.preventDefault()\n                if (highlightedIndex >= 0 && highlightedIndex < sortedOptions.length) {\n                    handleOptionSelect(sortedOptions[highlightedIndex])\n                }\n                break\n            case 'Escape':\n                e.preventDefault()\n                setIsOpen(false)\n                setHighlightedIndex(0)\n                break\n        }\n    }\n\n    return (\n        <div style={{ position: 'relative', flex: 1, display: 'flex', alignItems: 'center' }}>\n            <input\n                ref={inputRef}\n                type=\"text\"\n                value={searchValue}\n                onChange={(e) => {\n                    setSearchValue(e.target.value)\n                    setIsOpen(true)\n                    setHighlightedIndex(0)\n                    if (menuRef.current) {\n                        menuRef.current.scrollTop = 0\n                    }\n                }}\n                onKeyDown={handleKeyDown}\n                onClick={(e) => {\n                    (e.target as HTMLInputElement).select()\n                }}\n                onFocus={() => {\n                    setIsOpen(true)\n                    setHighlightedIndex(0)\n                }}\n                onBlur={() => {\n                    // Delay closing to allow clicking on options\n                    setTimeout(() => {\n                        setIsOpen(false)\n                        setHighlightedIndex(0)\n                    }, 150)\n                }}\n                placeholder=\"Search options...\"\n                style={{\n                    flex: 1,\n                    padding: `${labelPadding} 8px`,\n                    border: `1px solid ${colors.ordinalTextColor}`,\n                    borderRadius: '4px',\n                    fontSize: '14px',\n                }}\n            />\n            {onEdit && <PencilButton onEdit={onEdit} />}\n            {isOpen && sortedOptions.length > 0 && (\n                <div\n                    style={{\n                        position: 'absolute',\n                        top: '100%',\n                        left: 0,\n                        right: 0,\n                        backgroundColor: colors.background,\n                        border: '1px solid #ccc',\n                        borderRadius: '4px',\n                        maxHeight: '200px',\n                        overflowY: 'auto',\n                        zIndex: 1000,\n                        boxShadow: '0 2px 8px rgba(0,0,0,0.1)',\n                    }}\n                    ref={menuRef}\n                >\n                    {sortedOptions.map((option, index) => (\n                        <div\n                            key={index}\n                            onMouseDown={() => {\n                                handleOptionSelect(option)\n                            }}\n                            onMouseUp={() => {\n                                handleOptionSelect(option)\n                                inputRef.current?.blur()\n                            }}\n                            style={{\n                                cursor: 'pointer',\n                                borderBottom: index < sortedOptions.length - 1 ? '1px solid #eee' : 'none',\n                            }}\n                            onMouseEnter={() => { setHighlightedIndex(index) }}\n                        >\n                            {option.renderedChoice.node?.(index === highlightedIndex) ?? <DefaultSelectorOption text={option.renderedChoice.text} highlighted={index === highlightedIndex} />}\n                        </div>\n                    ))}\n                </div>\n            )}\n        </div>\n    )\n}\n\nfunction DefaultSelectorOption(props: { text: string, highlighted: boolean }): ReactNode {\n    const colors = useColors()\n    return (\n        <div style={{\n            padding: '8px 12px',\n            background: (props.highlighted ? colors.slightlyDifferentBackgroundFocused : colors.slightlyDifferentBackground),\n            color: props.text === '' ? colors.ordinalTextColor : colors.textMain,\n        }}\n        >\n            {props.text === '' ? 'No Selection' : props.text}\n        </div>\n    )\n}\n","/**\n * Algorithm for fuzzy string matching and associated utilities.\n *\n * This a modified bitap algorithm that's optimized for matching short strings to short strings.\n * It uses a signature that's based on the count of letters in the needle and haystack to quickly skip combinations that can't match.\n */\n\nimport { assert } from './defensive'\n\nexport interface Needle {\n    alphabet: Uint32Array\n    length: number\n    signature: number\n}\n\nexport function bitapAlphabet(token: string): Uint32Array {\n    assert(token.length <= 31, `Max bitap token length is 31`)\n    const alphabet = new Uint32Array(65535).fill(0)\n    for (let i = 0; i < token.length; i++) {\n        const char = token.charCodeAt(i)\n        alphabet[char] = alphabet[char] | (1 << i)\n    }\n    return alphabet\n}\n\nexport function toNeedle(token: string): Needle {\n    return { alphabet: bitapAlphabet(token), length: token.length, signature: toSignature(token) }\n}\n\nexport interface Haystack {\n    haystack: string\n    signature: number\n}\n\nexport function toHaystack(token: string): Haystack {\n    return {\n        haystack: token,\n        signature: toSignature(token),\n    }\n}\n\nexport function toSignature(str: string): number {\n    const alphabetStart = 'a'.charCodeAt(0)\n    const alphabetEnd = 'z'.charCodeAt(0)\n    // 0 < alphabetEnd - alphabetStart < 26   because of javascript integer size\n    let result = 0\n    for (let i = 0; i < str.length; i++) {\n        const charCode = str.charCodeAt(i)\n        if (charCode >= alphabetStart && charCode <= alphabetEnd) {\n            const firstOccurence = (1 << ((charCode - alphabetStart) * 2))\n            if ((result & firstOccurence) !== 0) {\n                result |= (firstOccurence << 1) // second occurence\n            }\n            else {\n                result |= firstOccurence\n            }\n        }\n    }\n    return result\n}\n\nexport const bitapPerformance = {\n    numBitapSignatureChecks: 0,\n    numBitapSignatureSkips: 0,\n}\n\n/**\n * Finds the minimum number of edits between `haystack` and `needle` (assuming they have the same start position)\n *\n * Returns [0, maxErrors + 1], where maxErrors + 1 means a match was not found with lte maxErrors errors\n *\n * Takes scratch buffers, which must be an array of at least length maxErrors + 1 length, filled with Uint32Arrays of at least (needle.length + maxErrors + 1) length\n *\n */\nexport function bitap(haystack: Haystack, needle: Needle, maxErrors: number, scratchBuffers: Uint32Array[]): number {\n    let bestMatch = maxErrors + 1\n\n    if (maxErrors < 0) {\n        return bestMatch\n    }\n\n    bitapPerformance.numBitapSignatureChecks++\n    if (bitCount(needle.signature ^ (haystack.signature & needle.signature)) > maxErrors) {\n        bitapPerformance.numBitapSignatureSkips++\n        return bestMatch // The letters in the haystack and needle are too different to possibly match\n    }\n\n    for (let errors = 0; errors <= maxErrors; errors++) {\n        scratchBuffers[errors].fill(0)\n        scratchBuffers[errors][0] = (1 << errors) - 1\n    }\n\n    const matchMask = 1 << (needle.length - 1)\n\n    for (let j = 1; j <= (needle.length + maxErrors); j++) {\n        let charMatch: number\n        if (j - 1 < haystack.haystack.length) {\n            charMatch = needle.alphabet[haystack.haystack.charCodeAt(j - 1)]\n        }\n        else {\n            charMatch = 0\n        }\n\n        for (let errors = 0; errors <= maxErrors; errors++) {\n            if (errors === 0) {\n                scratchBuffers[0][j] = ((scratchBuffers[0][j - 1] << 1) | 1) & charMatch\n            }\n            else {\n                scratchBuffers[errors][j] = (((scratchBuffers[errors][j - 1] << 1) | 1) & charMatch) | (((scratchBuffers[errors - 1][j - 1] | scratchBuffers[errors - 1][j]) << 1) | 1) | scratchBuffers[errors - 1][j - 1]\n            }\n\n            if ((scratchBuffers[errors][j] & matchMask) !== 0) {\n                bestMatch = Math.min(bestMatch, Math.max(Math.abs(j - needle.length), errors))\n                maxErrors = Math.min(maxErrors, errors)\n                if (bestMatch === 0) {\n                    return bestMatch // We've found the best match we possibly can\n                }\n            }\n        }\n    }\n    return bestMatch\n}\n\nexport function bitCount(x: number): number {\n    return bitCount32(x) + bitCount32(Math.floor(x / 0x1_0000_0000))\n}\n\n// https://stackoverflow.com/a/109025\nfunction bitCount32(i: number): number {\n    i = i - ((i >> 1) & 0x55555555) // add pairs of bits\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333) // quads\n    i = (i + (i >> 4)) & 0x0F0F0F0F // groups of 8\n    i *= 0x01010101 // horizontal sum of bytes\n    return i >> 24\n}\n","import { createContext } from 'react'\n\nimport { Range } from '../../urban-stats-script/editor-utils'\nimport { Property } from '../../utils/Property'\n\nexport interface Selection {\n    blockIdent: string\n    range: Range\n}\n\n// eslint-disable-next-line no-restricted-syntax -- React contexts typically are capitalized\nexport const SelectionContext = createContext(new Property<Selection | undefined>(undefined))\n","import React, { ReactNode, useContext, useMemo } from 'react'\n\nimport { Editor } from '../../urban-stats-script/Editor'\nimport { UrbanStatsASTExpression } from '../../urban-stats-script/ast'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { ParseError, parseNoErrorAsCustomNode } from '../../urban-stats-script/parser'\nimport { TypeEnvironment } from '../../urban-stats-script/types-values'\n\nimport { SelectionContext } from './SelectionContext'\n\nexport function CustomEditor({\n    uss,\n    setUss,\n    typeEnvironment,\n    errors,\n    blockIdent,\n    placeholder,\n}: {\n    uss: UrbanStatsASTExpression & { type: 'customNode' }\n    setUss: (u: UrbanStatsASTExpression & { type: 'customNode' }) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n    blockIdent: string\n    placeholder?: string\n}): ReactNode {\n    const ourErrors = useMemo(() => errors.filter((e: ParseError) => e.location.start.block.type === 'single' && e.location.start.block.ident === blockIdent), [errors, blockIdent])\n\n    const selectionContext = useContext(SelectionContext)\n    const selection = selectionContext.use()\n\n    return (\n        <Editor\n            uss={uss.originalCode}\n            setUss={(u: string) => {\n                const parsed = parseNoErrorAsCustomNode(u, blockIdent, uss.expectedType)\n                setUss(parsed)\n            }}\n            typeEnvironment={typeEnvironment}\n            results={ourErrors}\n            placeholder={placeholder}\n            selection={selection?.blockIdent === blockIdent ? selection.range : null}\n            setSelection={(range) => {\n                if (range !== null) {\n                    selectionContext.value = { blockIdent, range }\n                }\n                else if (selectionContext.value?.blockIdent === blockIdent) {\n                    selectionContext.value = undefined\n                }\n            }}\n        />\n    )\n}\n","import ColorLib from 'color'\nimport stableStringify from 'json-stable-stringify'\nimport React, { ReactNode, useMemo, useCallback } from 'react'\n\nimport { colorThemes } from '../../page_template/color-themes'\nimport { useColors } from '../../page_template/colors'\nimport { DisplayResults } from '../../urban-stats-script/Editor'\nimport { UrbanStatsASTExpression } from '../../urban-stats-script/ast'\nimport { hsvToColor, rgbToColor } from '../../urban-stats-script/constants/color'\nimport { Color, doRender, hexToColor, hsvColorExpression, rgbColorExpression } from '../../urban-stats-script/constants/color-utils'\nimport { RampT } from '../../urban-stats-script/constants/ramp'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { emptyLocation, parseNumber } from '../../urban-stats-script/lexer'\nimport { parseNoErrorAsCustomNode, parseNoErrorAsExpression } from '../../urban-stats-script/parser'\nimport { Documentation, TypeEnvironment, USSType } from '../../urban-stats-script/types-values'\nimport { assert } from '../../utils/defensive'\n\nimport * as l from './../../urban-stats-script/literal-parser'\nimport { BetterSelector, SelectorRenderResult } from './BetterSelector'\nimport { parseExpr, possibilities, Selection } from './parseExpr'\n\nexport const labelPadding = '4px'\n\nfunction isCustomConstructor(possibility: Selection, typeEnvironment: TypeEnvironment): boolean {\n    return possibility.type === 'function' && typeEnvironment.get(possibility.name)?.documentation?.customConstructor === true\n}\n\nexport function Selector(props: {\n    uss: UrbanStatsASTExpression\n    setSelection: (selection: Selection) => void\n    setUss: (u: UrbanStatsASTExpression) => void\n    typeEnvironment: TypeEnvironment\n    type: USSType[]\n    blockIdent: string\n    errors: EditorError[]\n}): ReactNode {\n    const { setSelection, typeEnvironment } = props\n    const selected = classifyExpr(props.uss)\n\n    const selectionPossibilities = useMemo(() => {\n        // Combine possibilities from all types\n        const allPossibilities = new Set<Selection>()\n        props.type.forEach((type) => {\n            const typePossibilities = possibilities([type], props.typeEnvironment)\n            typePossibilities.forEach(possibility => allPossibilities.add(possibility))\n        })\n\n        return Array.from(allPossibilities)\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- props.type keeps the same deep value but changes reference. It's simpler to stringify it here than track it down everywhere\n    }, [stableStringify(props.type), props.typeEnvironment])\n\n    const hasCustomConstructor = useMemo(() => {\n        return selectionPossibilities.some(possibility => isCustomConstructor(possibility, props.typeEnvironment)) && !isCustomConstructor(selected, props.typeEnvironment)\n    }, [selectionPossibilities, props.typeEnvironment, selected])\n\n    const renderPossibility = useCallback((selection: Selection) => renderSelection(props.typeEnvironment, selection), [props.typeEnvironment])\n\n    const onEdit = useCallback(() => {\n        const customConstructorOption = selectionPossibilities.find(possibility => isCustomConstructor(possibility, typeEnvironment))\n        if (customConstructorOption) {\n            setSelection(customConstructorOption)\n        }\n    }, [selectionPossibilities, typeEnvironment, setSelection])\n\n    if (selectionPossibilities.length < 2) {\n        return undefined\n    }\n\n    const isNumber = props.type.some(type => type.type === 'number')\n    const isString = props.type.some(type => type.type === 'string')\n    const showConstantInput = selected.type === 'constant' && (isNumber || isString)\n    const currentValue = props.uss.type === 'constant' ? props.uss.value.node.value.toString() : ''\n    const errors = props.errors.filter(e => e.location.start.block.type === 'single' && e.location.start.block.ident === props.blockIdent)\n    const errorComponent = <DisplayResults results={errors} editor={false} />\n\n    const colorValue = props.type.some(type => type.type === 'opaque' && type.name === 'color') ? getColor(props.uss, props.typeEnvironment) : undefined\n\n    const select = (\n        <div style={{ position: 'relative', display: 'flex', alignItems: 'center', gap: '0.5em' }}>\n            <BetterSelector\n                value={selected}\n                possibleValues={selectionPossibilities}\n                renderValue={renderPossibility}\n                onChange={props.setSelection}\n                onEdit={hasCustomConstructor ? onEdit : undefined}\n            />\n            {showConstantInput && (\n                isNumber ? <NumberInput currentValue={currentValue} {...props} /> : <TextInput currentValue={currentValue} {...props} />\n            )}\n            {colorValue !== undefined && (\n                <input\n                    type=\"color\"\n                    value={doRender(colorValue.color, true)}\n                    style={{ width: '200px', height: '30.5px' }}\n                    onChange={(e) => {\n                        const newColor = hexToColor(e.target.value)\n                        const newColorUss = colorValue.kind === 'hsv' ? hsvColorExpression(newColor, { forceAlpha: colorValue.color.a }) : rgbColorExpression(newColor, { forceAlpha: colorValue.color.a })\n                        let newUss: UrbanStatsASTExpression | undefined\n                        switch (props.uss.type) {\n                            case 'customNode':\n                                newUss = parseNoErrorAsCustomNode(\n                                    newColorUss,\n                                    props.blockIdent,\n                                    props.type,\n                                )\n                                break\n                            case 'identifier':\n                            case 'call':\n                                newUss = parseNoErrorAsExpression(\n                                    newColorUss,\n                                    props.blockIdent,\n                                )\n                        }\n                        if (newUss !== undefined) {\n                            newUss = parseExpr(\n                                newUss,\n                                props.blockIdent,\n                                props.type,\n                                props.typeEnvironment,\n                                () => { throw new Error('Should not happen') },\n                                true,\n                            )\n                            props.setUss(newUss)\n                        }\n                    }}\n                />\n            )}\n        </div>\n    )\n    return (\n        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5em' }}>\n            {select}\n            {errorComponent}\n        </div>\n    )\n}\n\nfunction TextInput({ currentValue, blockIdent, setUss }: { currentValue: string, blockIdent: string, setUss: (u: UrbanStatsASTExpression) => void }): ReactNode {\n    return (\n        <textarea\n            value={currentValue}\n            onChange={(e) => {\n                const value = e.target.value\n                setUss({\n                    type: 'constant',\n                    value: {\n                        node: { type: 'string', value },\n                        location: emptyLocation(blockIdent),\n                    },\n                })\n            }}\n            style={{ width: '200px', fontSize: '14px', padding: '4px 8px', resize: 'vertical' }}\n            placeholder=\"Enter string\"\n        />\n    )\n}\n\nfunction NumberInput({ currentValue, blockIdent, setUss }: { currentValue: string, blockIdent: string, setUss: (u: UrbanStatsASTExpression) => void }): ReactNode {\n    return (\n        <input\n            type=\"text\"\n            value={currentValue}\n            onChange={(e) => {\n                const value = e.target.value\n                let node: (UrbanStatsASTExpression & { type: 'constant' })['value']['node']\n                let numberValue\n                if ((numberValue = parseNumber(value)) !== undefined) {\n                    node = { type: 'number', value: numberValue }\n                }\n                else {\n                    node = { type: 'string', value }\n                }\n                const newUss: UrbanStatsASTExpression = {\n                    type: 'constant',\n                    value: {\n                        node,\n                        location: emptyLocation(blockIdent),\n                    },\n                }\n                setUss(newUss)\n            }}\n            style={{ width: '200px', fontSize: '14px', padding: '4px 8px', resize: 'none' }}\n            placeholder=\"Enter number\"\n        />\n    )\n}\n\nexport function classifyExpr(uss: UrbanStatsASTExpression): Selection {\n    if (uss.type === 'customNode') {\n        return { type: 'custom' }\n    }\n    if (uss.type === 'constant') {\n        return { type: 'constant' }\n    }\n    if (uss.type === 'identifier') {\n        return { type: 'variable', name: uss.name.node }\n    }\n    if (uss.type === 'call') {\n        const classifiedFn = classifyExpr(uss.fn)\n        assert(classifiedFn.type === 'variable', 'Function must be a variable or another function')\n        return { type: 'function', name: classifiedFn.name }\n    }\n    if (uss.type === 'vectorLiteral') {\n        return { type: 'vector' }\n    }\n    if (uss.type === 'objectLiteral') {\n        return { type: 'object' }\n    }\n    throw new Error(`Unsupported USS expression type: ${uss.type}`)\n}\n\nexport function renderSelection(typeEnvironment: TypeEnvironment, selection: Selection): SelectorRenderResult {\n    if (selection.type === 'custom') {\n        return { text: 'Custom Expression' }\n    }\n    if (selection.type === 'constant') {\n        return { text: 'Constant' }\n    }\n    if (selection.type === 'vector') {\n        return { text: 'Manual List' }\n    }\n    if (selection.type === 'object') {\n        return { text: 'Properties' }\n    }\n    const doc = typeEnvironment.get(selection.name)?.documentation\n    if (doc?.selectorRendering?.kind === 'subtitleLongDescription') {\n        return {\n            text: doc.humanReadableName,\n            node: highlighted => <LongDescriptionSubtitle doc={doc} highlighted={highlighted} />,\n        }\n    }\n    if (doc?.selectorRendering?.kind === 'gradientBackground') {\n        const ramp = doc.selectorRendering.ramp\n        return {\n            text: doc.humanReadableName,\n            node: highlighted => <RampSelectorOption name={doc.humanReadableName} ramp={ramp} highlighted={highlighted} />,\n        }\n    }\n    else {\n        return { text: doc?.humanReadableName ?? selection.name }\n    }\n}\n\nconst colorSchema = l.transformExpr(l.customNodeExpr(l.deconstruct(l.call({\n    fn: l.union([l.identifier('rgb'), l.identifier('hsv')]),\n    unnamedArgs: [l.number(), l.number(), l.number()],\n    namedArgs: { a: l.optional(l.number()) },\n}))), (call) => {\n    let color: Color | undefined\n    switch (call.fn) {\n        case 'rgb':\n            color = rgbToColor(call.unnamedArgs[0], call.unnamedArgs[1], call.unnamedArgs[2], call.namedArgs.a ?? 1, true)\n            break\n        case 'hsv':\n            color = hsvToColor(call.unnamedArgs[0], call.unnamedArgs[1], call.unnamedArgs[2], call.namedArgs.a ?? 1, true)\n            break\n    }\n    if (color === undefined) {\n        return undefined\n    }\n    return { color, kind: call.fn }\n})\n\nexport function getColor(expr: UrbanStatsASTExpression, typeEnvironment: TypeEnvironment): { color: Color, kind: 'rgb' | 'hsv' } | undefined {\n    try {\n        return colorSchema.parse(expr, typeEnvironment)\n    }\n    catch {\n        return\n    }\n}\n\nfunction LongDescriptionSubtitle(props: { doc: Documentation, highlighted: boolean }): ReactNode {\n    const colors = useColors()\n    return (\n        <div style={{\n            padding: '8px 12px',\n            background: props.highlighted ? colors.slightlyDifferentBackgroundFocused : colors.slightlyDifferentBackground,\n        }}\n        >\n            <div>{props.doc.humanReadableName}</div>\n            <div style={{ fontSize: 'smaller', color: colors.ordinalTextColor }}>\n                {props.doc.longDescription}\n            </div>\n        </div>\n    )\n}\n\nfunction RampSelectorOption(props: { name: string, ramp: RampT, highlighted: boolean }): ReactNode {\n    const colors = useColors()\n    const firstRampColor = ColorLib(props.ramp[0][1])\n    const highlightedColor = `rgb(from ${colors.slightlyDifferentBackgroundFocused} r g b / 1)`\n    return (\n        <div style={{\n            padding: '8px 12px',\n            color: colorThemes[firstRampColor.isLight() ? 'Light Mode' : 'Dark Mode'].textMain,\n            background: props.highlighted ? `${selectionGradient(highlightedColor, 'bottom')}, ${selectionGradient(highlightedColor, 'right')}, ${toCssGradient(props.ramp)}` : toCssGradient(props.ramp),\n        }}\n        >\n            {props.name}\n        </div>\n    )\n}\n\nfunction toCssGradient(ramp: RampT): string {\n    return `linear-gradient(to right, ${ramp.map(([pos, color]) => `${color} ${Math.round(pos * 100)}%`).join(', ')})`\n}\n\nfunction selectionGradient(selectionColor: string, direction: string): string {\n    const border = `5px`\n    return `linear-gradient(to ${direction}, ${selectionColor} ${border}, transparent ${border}, transparent calc(100% - ${border}), ${selectionColor} calc(100% - ${border}))`\n}\n","import stableStringify from 'json-stable-stringify'\nimport React, { ReactNode } from 'react'\n\nimport { CheckboxSettingCustom } from '../../components/sidebar'\nimport { UrbanStatsASTExpression, UrbanStatsASTArg, locationOf } from '../../urban-stats-script/ast'\nimport { hsvColorExpression, rgbColorExpression } from '../../urban-stats-script/constants/color-utils'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { emptyLocation } from '../../urban-stats-script/lexer'\nimport { extendBlockIdKwarg, extendBlockIdObjectProperty, extendBlockIdPositionalArg, extendBlockIdVectorElement } from '../../urban-stats-script/location'\nimport { parseNoErrorAsCustomNode, parseNoErrorAsExpression, unparse } from '../../urban-stats-script/parser'\nimport { USSType, USSFunctionArgType, renderType, USSFunctionType, TypeEnvironment } from '../../urban-stats-script/types-values'\nimport { DefaultMap } from '../../utils/DefaultMap'\nimport { assert } from '../../utils/defensive'\nimport { useMobileLayout } from '../../utils/responsive'\n\nimport { CustomEditor } from './CustomEditor'\nimport { Selector, classifyExpr, getColor, labelPadding } from './Selector'\nimport { maybeParseExpr, parseExpr, Selection, possibilities } from './parseExpr'\n\nfunction createDefaultExpression(type: USSType, blockIdent: string, typeEnvironment: TypeEnvironment): UrbanStatsASTExpression {\n    if (type.type === 'number') {\n        return { type: 'constant', value: { node: { type: 'number', value: 0 }, location: emptyLocation(blockIdent) } }\n    }\n    if (type.type === 'string') {\n        return { type: 'constant', value: { node: { type: 'string', value: '' }, location: emptyLocation(blockIdent) } }\n    }\n    for (const [name, tdoc] of typeEnvironment) {\n        if (!tdoc.documentation?.isDefault) {\n            continue\n        }\n        if (renderType(tdoc.type) === renderType(type)) {\n            return getDefaultVariable({ type: 'variable', name }, typeEnvironment, blockIdent)\n        }\n        if (tdoc.type.type === 'function' && tdoc.type.returnType.type !== 'inferFromPrimitive' && renderType(tdoc.type.returnType.value) === renderType(type)) {\n            return getDefaultFunction({ type: 'function', name }, typeEnvironment, blockIdent)\n        }\n    }\n    if (type.type === 'vector') {\n        return {\n            type: 'vectorLiteral',\n            entireLoc: emptyLocation(blockIdent),\n            elements: [],\n        }\n    }\n    return parseNoErrorAsCustomNode('', blockIdent, [type])\n}\n\nfunction ArgumentEditor(props: {\n    name: string\n    argWDefault: { type: USSFunctionArgType, defaultValue?: UrbanStatsASTExpression }\n    uss: UrbanStatsASTExpression & { type: 'call', fn: UrbanStatsASTExpression & { type: 'identifier' } }\n    setUss: (u: UrbanStatsASTExpression) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n    blockIdent: string\n}): ReactNode {\n    const arg = props.argWDefault.type\n    assert(arg.type === 'concrete', `Named argument ${props.name} must be concrete`)\n\n    const functionUss = props.uss\n    const argValue = functionUss.args.find(a => a.type === 'named' && a.name.node === props.name)\n    const hasDefault = props.argWDefault.defaultValue !== undefined\n    const isEnabled = argValue !== undefined\n    const subident = extendBlockIdKwarg(props.blockIdent, props.name)\n\n    // Get the function's documentation to find human-readable argument names\n    const tdoc = props.typeEnvironment.get(functionUss.fn.name.node)\n    const humanReadableName = tdoc?.documentation?.namedArgs?.[props.name] ?? props.name\n\n    return (\n        <div style={{ display: 'flex', alignItems: 'flex-start', gap: '0.25em', width: '100%', margin: '0.25em 0' }}>\n            <div style={{ flex: 1 }}>\n                <div>\n                    {hasDefault\n                        ? (\n                                <CheckboxSettingCustom\n                                    name={humanReadableName}\n                                    checked={isEnabled}\n                                    onChange={(checked) => {\n                                        if (checked) {\n                                            const defaultExpr = props.argWDefault.defaultValue\n                                            let exprToUse = defaultExpr === undefined || (defaultExpr.type === 'identifier' && defaultExpr.name.node === 'null')\n                                                ? createDefaultExpression(arg.value, subident, props.typeEnvironment)\n                                                : defaultExpr\n                                            exprToUse = deconstruct(exprToUse, props.typeEnvironment, subident, arg.value) ?? parseExpr(exprToUse, subident, [arg.value], props.typeEnvironment, () => {\n                                                throw new Error('Should not happen')\n                                            }, true)\n                                            // Add the argument with default value\n                                            const newArg = {\n                                                type: 'named' as const,\n                                                name: { node: props.name, location: emptyLocation(subident) },\n                                                value: exprToUse,\n                                            }\n                                            const newArgs = [...functionUss.args, newArg]\n                                            props.setUss({ ...functionUss, args: newArgs })\n                                        }\n                                        else {\n                                            // Remove the argument\n                                            const newArgs = functionUss.args.filter(a => !(a.type === 'named' && a.name.node === props.name))\n                                            props.setUss({ ...functionUss, args: newArgs })\n                                        }\n                                    }}\n                                />\n                            )\n                        : <span>{humanReadableName}</span>}\n\n                </div>\n                {isEnabled\n                && (\n                    <AutoUXEditor\n                        uss={argValue.value}\n                        setUss={(newUss) => {\n                            const newArgs = functionUss.args.map(a => a.type === 'named' && a.name.node === props.name ? { ...a, value: newUss } : a)\n                            props.setUss({ ...functionUss, args: newArgs })\n                        }}\n                        typeEnvironment={props.typeEnvironment}\n                        errors={props.errors}\n                        blockIdent={subident}\n                        type={[arg.value]}\n                    />\n                )}\n            </div>\n        </div>\n    )\n}\n\nexport function AutoUXEditor(props: {\n    uss: UrbanStatsASTExpression\n    setUss: (u: UrbanStatsASTExpression) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n    blockIdent: string\n    type: USSType[]\n    label?: string\n    labelWidth?: string\n}): ReactNode {\n    const ussLoc = locationOf(props.uss).start\n    if (ussLoc.block.type !== 'single' || ussLoc.block.ident !== props.blockIdent) {\n        console.warn('USS: ', props.uss)\n        console.warn('USS Location: ', ussLoc)\n        console.warn('Editor blockIdent: ', props.blockIdent)\n        console.error('[failtest] USS expression location does not match block identifier', props.uss, ussLoc.block.type === 'single' ? ussLoc.block.ident : '(multi)', props.blockIdent)\n    }\n    const labelWidth = props.labelWidth ?? '5%'\n    const subcomponent = (): [ReactNode | undefined, 'consumes-errors' | 'does-not-consume-errors'] => {\n        if (props.uss.type === 'constant') {\n            return [undefined, 'does-not-consume-errors']\n        }\n        const uss = props.uss\n        if (uss.type === 'customNode') {\n            const editor = (\n                <CustomEditor\n                    key=\"custom\"\n                    uss={uss}\n                    setUss={props.setUss}\n                    typeEnvironment={props.typeEnvironment}\n                    errors={props.errors}\n                    blockIdent={props.blockIdent}\n                />\n            )\n            return [editor, 'consumes-errors']\n        }\n        if (uss.type === 'identifier') {\n            return [undefined, 'does-not-consume-errors']\n        }\n        if (uss.type === 'call') {\n            assert(uss.fn.type === 'identifier', 'Function must be an identifier')\n            const tdoc = props.typeEnvironment.get(uss.fn.name.node)\n            assert(tdoc !== undefined, `Function ${uss.fn.name.node} not found in type environment`)\n            const type = tdoc.type\n            assert(type.type === 'function', `Function ${uss.fn.name.node} must be a function type`)\n            const subselectors: ReactNode[] = []\n            type.posArgs.forEach((arg, i) => {\n                assert(arg.type === 'concrete', `Positional argument must be concrete`)\n                subselectors.push(\n                    <AutoUXEditor\n                        key={`pos-${i}`}\n                        uss={uss.args[i].value}\n                        setUss={(newUss) => {\n                            const newArgs = [...uss.args]\n                            newArgs[i] = { ...newArgs[i], value: newUss }\n                            props.setUss({ ...uss, args: newArgs })\n                        }}\n                        typeEnvironment={props.typeEnvironment}\n                        errors={props.errors}\n                        blockIdent={extendBlockIdPositionalArg(props.blockIdent, i)}\n                        type={[arg.value]}\n                    />,\n                )\n            })\n            Object.entries(type.namedArgs).forEach(([name, argWDefault]) => {\n                if (argWDefault.documentation?.hide !== true) {\n                    subselectors.push(\n                        <ArgumentEditor\n                            key={`named-${name}`}\n                            name={name}\n                            argWDefault={argWDefault}\n                            // cast is valid because we checked type above\n                            uss={uss as UrbanStatsASTExpression & { type: 'function', fn: UrbanStatsASTExpression & { type: 'identifier' } }}\n                            setUss={props.setUss}\n                            typeEnvironment={props.typeEnvironment}\n                            errors={props.errors}\n                            blockIdent={props.blockIdent}\n                        />,\n                    )\n                }\n            })\n            const element = <div key=\"subselectors\">{...subselectors}</div>\n            return [element, 'does-not-consume-errors']\n        }\n        if (uss.type === 'vectorLiteral') {\n            // Determine the element type\n            let elementType: USSType = { type: 'number' } // fallback\n            if (props.type[0].type === 'vector') {\n                // something of a hack, but this really shouldn't be an issue because we don't support multiple types for vectors\n                elementType = props.type[0].elementType as USSType\n            }\n            const element = (\n                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5em', width: '100%' }}>\n                    {uss.elements.map((el, i) => (\n                        <div key={i} style={{ display: 'flex', alignItems: 'center', gap: '0.5em', width: '100%' }}>\n                            <AutoUXEditor\n                                uss={el}\n                                setUss={(newEl) => {\n                                    const newElements = [...uss.elements]\n                                    newElements[i] = newEl\n                                    props.setUss({ ...uss, elements: newElements })\n                                }}\n                                typeEnvironment={props.typeEnvironment}\n                                errors={props.errors}\n                                blockIdent={extendBlockIdVectorElement(props.blockIdent, i)}\n                                type={[elementType]}\n                                label={`${i + 1}`}\n                            />\n                            <button\n                                style={{ flexShrink: 0 }}\n                                onClick={() => {\n                                    const newElements = uss.elements.filter((_, j) => j !== i)\n                                    props.setUss({ ...uss, elements: newElements })\n                                }}\n                                title=\"Remove element\"\n                            >\n                                \n                            </button>\n                        </div>\n                    ))}\n                    <button\n                        style={{ alignSelf: 'flex-start', marginTop: 4 }}\n                        onClick={() => {\n                            const newElements = [\n                                ...uss.elements,\n                                // Copy the last element if there is one\n                                uss.elements.length > 0\n                                    ? uss.elements[uss.elements.length - 1]\n                                    : createDefaultExpression(elementType, extendBlockIdVectorElement(props.blockIdent, uss.elements.length), props.typeEnvironment),\n                            ]\n                            props.setUss({ ...uss, elements: newElements })\n                        }}\n                    >\n                        + Add element\n                    </button>\n                </div>\n            )\n            return [element, 'does-not-consume-errors']\n        }\n        if (uss.type === 'objectLiteral') {\n            // Determine the element type\n            let propertiesTypes: Map<string, USSType> = new DefaultMap(() => ({ type: 'number' })) // fallback\n            if (props.type[0].type === 'object') {\n                // something of a hack, but this really shouldn't be an issue because we don't support multiple types for objects\n                propertiesTypes = props.type[0].properties\n            }\n            const element = (\n                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5em', width: '100%' }}>\n                    {Array.from(propertiesTypes.keys()).sort().map((key) => {\n                        const propertyType = propertiesTypes.get(key)!\n                        return (\n                            <AutoUXEditor\n                                key={key}\n                                uss={uss.properties.find(([k]) => k === key)?.[1] ?? createDefaultExpression(propertyType, extendBlockIdObjectProperty(props.blockIdent, key), props.typeEnvironment)}\n                                setUss={(newVal) => {\n                                    props.setUss({ ...uss, properties: uss.properties.map(([k, v]) => [k, k === key ? newVal : v]) })\n                                }}\n                                typeEnvironment={props.typeEnvironment}\n                                errors={props.errors}\n                                blockIdent={extendBlockIdObjectProperty(props.blockIdent, key)}\n                                type={[propertyType]}\n                                label={key}\n                            />\n                        )\n                    })}\n                </div>\n            )\n            return [element, 'does-not-consume-errors']\n        }\n        throw new Error(`Unsupported USS expression type: ${props.uss.type}`) // TODO handle other types\n    }\n\n    const wrappedSubcomponent = (): [ReactNode | undefined, 'consumes-errors' | 'does-not-consume-errors'] => {\n        const [subc, doesConsume] = subcomponent()\n        if (subc === undefined) {\n            return [undefined, doesConsume]\n        }\n        const element = (\n            <div style={{ width: '100%', flex: 1 }}>\n                <div style={{ display: 'flex', gap: '1em', marginLeft: labelWidth }}>\n                    {props.label && <span style={{ minWidth: 'fit-content' }}></span>}\n                    <div style={{ flex: 1 }}>\n                        {subc}\n                    </div>\n                </div>\n            </div>\n        )\n        return [element, doesConsume]\n    }\n\n    const [wrapped, doesConsume] = wrappedSubcomponent()\n\n    const leftSegment = props.label === undefined\n        ? undefined\n        : (\n                <div style={{ padding: `${labelPadding} 0px`, display: 'flex', justifyContent: 'flex-end' }}>\n                    <span style={{ minWidth: 'fit-content', marginRight: '5px' }}>{props.label}</span>\n                </div>\n            )\n    const rightSegment = possibilities(props.type, props.typeEnvironment).length < 2\n        ? undefined\n        : (\n                <div style={{ width: `calc(100% - ${labelWidth})` }}>\n                    <Selector\n                        uss={props.uss}\n                        setSelection={(selection: Selection) => {\n                            props.setUss(defaultForSelection(selection, props.uss, props.typeEnvironment, props.blockIdent, props.type[0]))\n                        }}\n                        setUss={props.setUss}\n                        typeEnvironment={props.typeEnvironment}\n                        type={props.type}\n                        blockIdent={props.blockIdent}\n                        errors={doesConsume === 'consumes-errors' ? [] : props.errors}\n                    />\n                </div>\n\n            )\n\n    const twoLines = useMobileLayout() || (props.label?.length ?? 0) > 5\n\n    const component = (): ReactNode => {\n        if (twoLines) {\n            return (\n                <>\n                    <div style={{ display: 'flex', alignItems: 'top' }}>\n                        {leftSegment}\n                    </div>\n                    <div style={{ display: 'flex', alignItems: 'top' }}>\n                        <div style={{ width: labelWidth }} />\n                        {rightSegment}\n                    </div>\n                </>\n            )\n        }\n        else {\n            return (\n                <div style={{ display: 'flex', alignItems: 'top' }}>\n                    <div style={{ width: labelWidth }}>\n                        {leftSegment}\n                    </div>\n                    {rightSegment}\n                </div>\n            )\n        }\n    }\n\n    return (\n        <div style={{ display: 'flex', flexDirection: 'column', width: '100%', flex: 1, margin: '0.25em 0', gap: '0.25em' }} id={`auto-ux-editor-${props.blockIdent}`}>\n            {leftSegment !== undefined || rightSegment !== undefined ? <div style={{ width: '100%', flex: 1 }}>{component()}</div> : undefined}\n            {wrapped}\n        </div>\n    )\n}\n\nfunction getDefaultVariable(selection: Selection & { type: 'variable' }, typeEnvironment: TypeEnvironment, blockIdent: string): UrbanStatsASTExpression {\n    const varType = typeEnvironment.get(selection.name)?.type\n    assert(varType !== undefined, `Variable ${selection.name} not found in type environment`)\n    return { type: 'identifier', name: { node: selection.name, location: emptyLocation(blockIdent) } }\n}\n\n// Returns a function that pulls named or unnamed arguments of the same type and position out of the passed `expr`\n// Returns undefined if incompatible\n// We're assuming the result will have the correct idnet, since we're using the same position, and it's hard to check\nfunction extractCompatiblePreviousArgs(expr: UrbanStatsASTExpression, typeEnvironment: TypeEnvironment): (arg: number | string, type: USSType) => UrbanStatsASTExpression | undefined {\n    let type\n    if (expr.type === 'call' && expr.fn.type === 'identifier' && (type = typeEnvironment.get(expr.fn.name.node)) && type.type.type === 'function') {\n        const foundType: USSFunctionType = type.type\n        return (arg, targetType) => {\n            if (typeof arg === 'number' && arg < foundType.posArgs.length && foundType.posArgs[arg].type === 'concrete' && renderType(targetType) === renderType(foundType.posArgs[arg].value)) {\n                return expr.args.filter(a => a.type === 'unnamed')[arg]?.value\n            }\n            if (typeof arg === 'string' && arg in foundType.namedArgs && foundType.namedArgs[arg].type.type === 'concrete' && renderType(targetType) === renderType(foundType.namedArgs[arg].type.value)) {\n                return expr.args.find(a => a.type === 'named' && a.name.node === arg)?.value\n            }\n            return undefined\n        }\n    }\n    return () => undefined\n}\n\nfunction getDefaultFunction(selection: Selection & { type: 'function' }, typeEnvironment: TypeEnvironment, blockIdent: string, previous?: UrbanStatsASTExpression): UrbanStatsASTExpression {\n    const fn = typeEnvironment.get(selection.name)\n    assert(fn !== undefined && fn.type.type === 'function', `Function ${selection.name} not found or not a function`)\n    const compatiblePreviousArg = previous ? extractCompatiblePreviousArgs(previous, typeEnvironment) : undefined\n    const args: UrbanStatsASTArg[] = []\n    // Only include positional arguments by default, not named arguments with defaults, unless there's an existing value for the named argument\n    for (let i = 0; i < fn.type.posArgs.length; i++) {\n        const arg = fn.type.posArgs[i]\n        assert(arg.type === 'concrete', `Positional argument must be concrete`)\n        args.push({\n            type: 'unnamed',\n            value: compatiblePreviousArg?.(i, arg.value) ?? createDefaultExpression(arg.value, extendBlockIdPositionalArg(blockIdent, i), typeEnvironment),\n        })\n    }\n    for (const [name, argWDefault] of Object.entries(fn.type.namedArgs)) {\n        const arg = argWDefault.type\n        assert(arg.type === 'concrete', `Named argument ${name} must be concrete`)\n        const prev = compatiblePreviousArg?.(name, arg.value)\n        if (prev || argWDefault.defaultValue === undefined) {\n            args.push({\n                type: 'named',\n                name: { node: name, location: emptyLocation(blockIdent) },\n                value: prev ?? createDefaultExpression(arg.value, extendBlockIdKwarg(blockIdent, name), typeEnvironment),\n            })\n        }\n    }\n    return {\n        type: 'call',\n        fn: { type: 'identifier', name: { node: selection.name, location: emptyLocation(blockIdent) } },\n        args,\n        entireLoc: emptyLocation(blockIdent),\n    }\n}\n\nfunction deconstruct(expr: UrbanStatsASTExpression, typeEnvironment: TypeEnvironment, blockIdent: string, type: USSType, selection?: Selection): UrbanStatsASTExpression | undefined {\n    switch (expr.type) {\n        case 'identifier': {\n            const reference = typeEnvironment.get(expr.name.node)\n\n            if (reference === undefined) {\n                return\n            }\n\n            if (reference.documentation?.equivalentExpressions === undefined) {\n                return\n            }\n\n            for (const equiv of reference.documentation.equivalentExpressions) {\n                const valid = maybeParseExpr(equiv, blockIdent, type, typeEnvironment)\n                if (valid !== undefined && (selection === undefined || stableStringify(classifyExpr(valid)) === stableStringify(selection))) {\n                    return valid\n                }\n            }\n\n            return\n        }\n        case 'customNode':\n            if (expr.expr.type === 'expression') {\n                return deconstruct(expr.expr.value, typeEnvironment, blockIdent, type, selection)\n            }\n            return\n        case 'call': {\n            if (type.type === 'opaque' && type.name === 'color' && selection?.type === 'function') {\n                // Conversion between RGB and HSV functions\n                const color = getColor(expr, typeEnvironment)\n                switch (true) {\n                    case color?.kind === 'rgb' && selection.name === 'hsv':\n                        // rgb to hsv\n                        return parseNoErrorAsExpression(hsvColorExpression(color.color), blockIdent)\n                    case color?.kind === 'hsv' && selection.name === 'rgb':\n                        // hsv to rgb\n                        return parseNoErrorAsExpression(rgbColorExpression(color.color), blockIdent)\n                }\n            }\n            return\n        }\n        default:\n            return\n    }\n}\n\nfunction defaultForSelection(\n    selection: Selection,\n    current: UrbanStatsASTExpression,\n    typeEnvironment: TypeEnvironment,\n    blockIdent: string,\n    type: USSType,\n): UrbanStatsASTExpression {\n    const deconstructed = deconstruct(current, typeEnvironment, blockIdent, type, selection)\n    if (deconstructed !== undefined) {\n        return deconstructed\n    }\n\n    const parsed = maybeParseExpr(current, blockIdent, type, typeEnvironment)\n    if (parsed !== undefined && stableStringify(classifyExpr(parsed)) === stableStringify(selection)) {\n        return parsed\n    }\n\n    switch (selection.type) {\n        case 'custom':\n            return parseNoErrorAsCustomNode(unparse(current), blockIdent, [type])\n        case 'constant':\n            return createDefaultExpression(type, blockIdent, typeEnvironment)\n        case 'variable':\n            return getDefaultVariable(selection as Selection & { type: 'variable' }, typeEnvironment, blockIdent)\n        case 'function':\n            return getDefaultFunction(selection as Selection & { type: 'function' }, typeEnvironment, blockIdent, current)\n        case 'vector': {\n            // Create an empty vectorLiteral of the right type\n            return {\n                type: 'vectorLiteral',\n                entireLoc: emptyLocation(blockIdent),\n                elements: [],\n            }\n        }\n        case 'object':\n            return {\n                type: 'objectLiteral',\n                entireLoc: emptyLocation(blockIdent),\n                properties: [],\n            }\n    }\n}\n","import React, { ReactNode } from 'react'\n\nimport { CheckboxSettingCustom } from '../../components/sidebar'\nimport { UrbanStatsASTExpression } from '../../urban-stats-script/ast'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { emptyLocation } from '../../urban-stats-script/lexer'\nimport { unparse, parseNoErrorAsCustomNode } from '../../urban-stats-script/parser'\nimport { TypeEnvironment } from '../../urban-stats-script/types-values'\n\nimport { CustomEditor } from './CustomEditor'\n\nexport function ConditionEditor({\n    condition,\n    setCondition,\n    typeEnvironment,\n    errors,\n    blockIdent,\n}: {\n    condition: UrbanStatsASTExpression\n    setCondition: (conditionExpr: UrbanStatsASTExpression) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n    blockIdent: string\n}): ReactNode {\n    const conditionIsCustom = condition.type === 'customNode'\n\n    return (\n        <div style={{ margin: '0.5em 0' }}>\n            <CheckboxSettingCustom\n                name=\"Filter?\"\n                checked={conditionIsCustom}\n                onChange={(checked) => {\n                    if (checked) {\n                        // Enable condition - keep current condition or set to 'true'\n                        const currentCondition = unparse(condition) || 'true'\n                        const conditionExpr = parseNoErrorAsCustomNode(currentCondition, blockIdent, [{ type: 'vector', elementType: { type: 'boolean' } }])\n                        setCondition(conditionExpr)\n                    }\n                    else {\n                        // Disable condition - set to constant true\n                        const conditionExpr = { type: 'identifier', name: { node: 'true', location: emptyLocation(blockIdent) } } satisfies UrbanStatsASTExpression\n                        setCondition(conditionExpr)\n                    }\n                }}\n            />\n            {conditionIsCustom && (\n                <CustomEditor\n                    uss={condition as UrbanStatsASTExpression & { type: 'customNode' }}\n                    setUss={setCondition}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={blockIdent}\n                />\n            )}\n        </div>\n    )\n}\n","import React, { ReactNode, useEffect, useState } from 'react'\n\nimport { CheckboxSettingCustom } from '../../components/sidebar'\nimport { UrbanStatsASTExpression } from '../../urban-stats-script/ast'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { parseNoErrorAsCustomNode } from '../../urban-stats-script/parser'\nimport { TypeEnvironment } from '../../urban-stats-script/types-values'\n\nimport { CustomEditor } from './CustomEditor'\n\nexport function PreambleEditor({\n    preamble,\n    setPreamble,\n    typeEnvironment,\n    errors,\n    blockIdent,\n}: {\n    preamble: UrbanStatsASTExpression & { type: 'customNode' }\n    setPreamble: (conditionExpr: UrbanStatsASTExpression & { type: 'customNode' }) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n    blockIdent: string\n}): ReactNode {\n    const [showPreamble, setShowPreamble] = useState(preamble.originalCode.trim() !== '')\n\n    useEffect(() => {\n        setShowPreamble(preamble.originalCode.trim() !== '')\n    }, [preamble.originalCode])\n\n    return (\n        <div style={{ margin: '0.5em 0' }}>\n            <CheckboxSettingCustom\n                name=\"Preamble\"\n                checked={showPreamble}\n                onChange={(checked) => {\n                    // Enable/disable preamble\n                    const preambleExpr = parseNoErrorAsCustomNode('', blockIdent)\n                    setPreamble(preambleExpr)\n                    setShowPreamble(checked)\n                }}\n            />\n            {showPreamble && (\n                <CustomEditor\n                    uss={preamble as UrbanStatsASTExpression & { type: 'customNode' }}\n                    setUss={setPreamble}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={blockIdent}\n                    placeholder=\"Variables here can be used by all custom expressions.\"\n                />\n            )}\n        </div>\n    )\n}\n","import assert from 'assert'\n\nimport React, { ReactNode } from 'react'\n\nimport { CheckboxSettingCustom } from '../../components/sidebar'\nimport { DisplayResults } from '../../urban-stats-script/Editor'\nimport { locationOf, UrbanStatsASTExpression, UrbanStatsASTStatement } from '../../urban-stats-script/ast'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { emptyLocation } from '../../urban-stats-script/lexer'\nimport { unparse, parseNoErrorAsCustomNode } from '../../urban-stats-script/parser'\nimport { TypeEnvironment, USSType } from '../../urban-stats-script/types-values'\n\nimport { AutoUXEditor } from './AutoUXEditor'\nimport { ConditionEditor } from './ConditionEditor'\nimport { CustomEditor } from './CustomEditor'\nimport { PreambleEditor } from './PreambleEditor'\nimport { parseExpr } from './parseExpr'\nimport { makeStatements } from './utils'\n\nconst cMap = { type: 'opaque', name: 'cMap', allowCustomExpression: false } satisfies USSType\nconst cMapRGB = { type: 'opaque', name: 'cMapRGB', allowCustomExpression: false } satisfies USSType\nconst pMap = { type: 'opaque', name: 'pMap', allowCustomExpression: false } satisfies USSType\n\nexport const validMapperOutputs = [cMap, cMapRGB, pMap] satisfies USSType[]\n\nexport const rootBlockIdent = 'r'\nconst idPreamble = `${rootBlockIdent}p`\nconst idCondition = `${rootBlockIdent}c`\nexport const idOutput = `${rootBlockIdent}o`\n\nexport type MapUSS = UrbanStatsASTExpression & { type: 'customNode' } |\n    (UrbanStatsASTStatement &\n    {\n        type: 'statements'\n        result: [\n                UrbanStatsASTStatement & { type: 'expression', value: UrbanStatsASTExpression & { type: 'customNode' } },\n                UrbanStatsASTStatement & { type: 'condition', rest: [UrbanStatsASTStatement & { type: 'expression' }] },\n        ]\n    })\n\nexport function TopLevelEditor({\n    uss,\n    setUss,\n    typeEnvironment,\n    errors,\n}: {\n    uss: MapUSS\n    setUss: (u: MapUSS) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n}): ReactNode {\n    const subcomponent = (): ReactNode => {\n        if (uss.type === 'customNode') {\n            return (\n                <CustomEditor\n                    uss={uss}\n                    setUss={setUss}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={rootBlockIdent}\n                />\n            )\n        }\n\n        return (\n            <div>\n                {/* Preamble */}\n                <PreambleEditor\n                    preamble={uss.result[0].value}\n                    setPreamble={(u: UrbanStatsASTExpression & { type: 'customNode' }) => {\n                        const preamble = {\n                            type: 'expression',\n                            value: u,\n                        } satisfies UrbanStatsASTStatement\n                        setUss(makeStatements([preamble, uss.result[1]]))\n                    }}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={idPreamble}\n                />\n                {/* Condition */}\n                <ConditionEditor\n                    condition={uss.result[1].condition}\n                    setCondition={(newConditionExpr) => {\n                        const conditionStatement = {\n                            type: 'condition',\n                            entireLoc: locationOf(newConditionExpr),\n                            condition: newConditionExpr,\n                            rest: uss.result[1].rest,\n                        } satisfies UrbanStatsASTStatement\n                        setUss(makeStatements([uss.result[0], conditionStatement]))\n                    }}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={idCondition}\n                />\n                {/* Output */}\n                <AutoUXEditor\n                    uss={uss.result[1].rest[0].value}\n                    setUss={(u: UrbanStatsASTExpression) => {\n                        const condition = {\n                            type: 'condition',\n                            entireLoc: uss.result[1].entireLoc,\n                            condition: uss.result[1].condition,\n                            rest: [{ type: 'expression', value: u }] as const,\n                        } satisfies UrbanStatsASTStatement\n                        setUss(makeStatements([uss.result[0], condition]))\n                    }}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={idOutput}\n                    type={validMapperOutputs}\n                    labelWidth=\"0px\"\n                />\n            </div>\n        )\n    }\n    return (\n        <div>\n            <div style={{ margin: '0.5em 0px' }} />\n            <CheckboxSettingCustom\n                name=\"Enable custom script\"\n                checked={uss.type === 'customNode'}\n                onChange={(checked) => {\n                    if (checked) {\n                        assert(uss.type === 'statements', 'USS should be statements when enabling custom script')\n                        setUss(parseNoErrorAsCustomNode(unparse(uss, { simplify: true }), rootBlockIdent))\n                    }\n                    else {\n                        assert(uss.type === 'customNode', 'USS should not be a custom node when disabled')\n                        setUss(attemptParseAsTopLevel(uss.expr, typeEnvironment, false))\n                    }\n                }}\n            />\n            { subcomponent() }\n            <DisplayResults\n                editor={false}\n                results={errors.filter(e => e.location.start.block.type === 'multi')}\n            />\n        </div>\n    )\n}\n\nexport function attemptParseAsTopLevel(stmt: MapUSS | UrbanStatsASTStatement, typeEnvironment: TypeEnvironment, preserveCustomNodes: boolean): MapUSS {\n    /**\n     * Splits up the statements into a preamble and a condition statement. Make the body of the condition a custom node.\n     */\n    if (stmt.type === 'customNode') {\n        return stmt\n    }\n    const stmts = stmt.type === 'statements' ? stmt.result : [stmt]\n    const preamble = {\n        type: 'statements',\n        result: stmts.slice(0, -1),\n        entireLoc: locationOf(stmt),\n    } satisfies UrbanStatsASTStatement\n    const conditionStmt = stmts.length > 0 ? stmts[stmts.length - 1] : undefined\n    const { conditionRest, conditionExpr } = attemptParseCondition(conditionStmt)\n    const body = parseExpr(makeStatements(conditionRest, idOutput), idOutput, validMapperOutputs, typeEnvironment, parseNoErrorAsCustomNode, preserveCustomNodes)\n    const condition = {\n        type: 'condition',\n        entireLoc: locationOf(conditionExpr),\n        condition: conditionExpr,\n        rest: [{ type: 'expression', value: body }] as const,\n    } satisfies UrbanStatsASTStatement\n    return {\n        type: 'statements',\n        result: [\n            { type: 'expression', value: parseNoErrorAsCustomNode(unparse(preamble, { simplify: true }), idPreamble) },\n            condition,\n        ] as const,\n        entireLoc: locationOf(stmt),\n    } satisfies UrbanStatsASTStatement\n}\n\nfunction attemptParseCondition(conditionStmt: UrbanStatsASTStatement | undefined): { conditionRest: UrbanStatsASTStatement[], conditionExpr: UrbanStatsASTExpression } {\n    let stmts = conditionStmt !== undefined ? [conditionStmt] : []\n    if (conditionStmt?.type === 'condition') {\n        const conditionText = unparse(conditionStmt.condition, { simplify: true })\n        if (conditionText.trim() !== 'true') {\n            return {\n                conditionExpr: parseNoErrorAsCustomNode(conditionText, idCondition, [{ type: 'vector', elementType: { type: 'boolean' } }]),\n                conditionRest: conditionStmt.rest,\n            }\n        }\n        stmts = conditionStmt.rest\n    }\n    return {\n        conditionExpr: { type: 'identifier', name: { node: 'true', location: emptyLocation(idCondition) } } satisfies UrbanStatsASTExpression,\n        conditionRest: stmts,\n    }\n}\n\nexport function defaultTopLevelEditor(): UrbanStatsASTStatement {\n    const expr = parseNoErrorAsCustomNode('cMap(data=density_pw_1km, scale=linearScale(), ramp=rampUridis)', rootBlockIdent, validMapperOutputs)\n    return expr.expr\n}\n","import { UrbanStatsASTArg, UrbanStatsASTExpression, UrbanStatsASTStatement } from '../../urban-stats-script/ast'\nimport { emptyLocation } from '../../urban-stats-script/lexer'\nimport { extendBlockIdKwarg, extendBlockIdObjectProperty, extendBlockIdPositionalArg, extendBlockIdVectorElement } from '../../urban-stats-script/location'\nimport { parseNoErrorAsCustomNode, unparse } from '../../urban-stats-script/parser'\nimport { renderType, TypeEnvironment, USSObjectType, USSType } from '../../urban-stats-script/types-values'\n\nexport function maybeParseExpr(\n    expr: UrbanStatsASTExpression | UrbanStatsASTStatement,\n    blockIdent: string,\n    type: USSType,\n    typeEnvironment: TypeEnvironment,\n): UrbanStatsASTExpression | undefined {\n    try {\n        return parseExpr(expr, blockIdent, [type], typeEnvironment, () => {\n            throw new Error('parsing failed')\n        }, false)\n    }\n    catch {}\n    return\n}\n\ntype Fallback = (uss: string, i: string, t: USSType[]) => UrbanStatsASTExpression\n\nexport function parseExpr(\n    expr: UrbanStatsASTExpression | UrbanStatsASTStatement,\n    blockIdent: string,\n    types: USSType[],\n    typeEnvironment: TypeEnvironment,\n    fallback: Fallback,\n    preserveCustomNodes: boolean,\n): UrbanStatsASTExpression {\n    const parsed = attemptParseExpr(expr, blockIdent, types, typeEnvironment, fallback, preserveCustomNodes)\n    return parsed ?? fallback(unparse(expr), blockIdent, types)\n}\n\nfunction attemptParseExpr(\n    expr: UrbanStatsASTExpression | UrbanStatsASTStatement,\n    blockIdent: string,\n    types: USSType[],\n    typeEnvironment: TypeEnvironment,\n    fallback: Fallback,\n    preserveCustomNodes: boolean,\n): UrbanStatsASTExpression | undefined {\n    switch (expr.type) {\n        case 'condition':\n        case 'binaryOperator':\n        case 'if':\n        case 'assignment':\n        case 'parseError':\n        case 'attribute':\n            return undefined\n        case 'vectorLiteral':\n            const elementTypes = types\n                .filter(t => t.type === 'vector')\n                .map(t => t.elementType)\n                .filter(t => t.type !== 'elementOfEmptyVector') satisfies USSType[]\n            if (elementTypes.length === 0) {\n                return undefined\n            }\n            return {\n                type: 'vectorLiteral',\n                entireLoc: emptyLocation(blockIdent),\n                elements: expr.elements.map((elem, idx) => parseExpr(elem, extendBlockIdVectorElement(blockIdent, idx), elementTypes, typeEnvironment, fallback, preserveCustomNodes)),\n            }\n        case 'objectLiteral':\n            const exprProps = new Set(expr.properties.map(([key]) => key))\n            const compatibleTypes = types.filter(\n                (t) => {\n                    if (t.type !== 'object') {\n                        return false\n                    }\n                    if (t.properties.size !== expr.properties.length) {\n                        return false\n                    }\n                    if (Array.from(t.properties.keys()).some(key => !exprProps.has(key))) {\n                        return false\n                    }\n                    return true\n                },\n            ) as USSObjectType[]\n            if (compatibleTypes.length === 0) {\n                return undefined\n            }\n            return {\n                type: 'objectLiteral',\n                entireLoc: emptyLocation(blockIdent),\n                properties: expr.properties.map(([key, value]) => [\n                    key,\n                    parseExpr(value, extendBlockIdObjectProperty(blockIdent, key), compatibleTypes.map(t => t.properties.get(key)!) satisfies USSType[], typeEnvironment, fallback, preserveCustomNodes),\n                ]),\n            }\n        case 'do':\n            const stmts = { type: 'statements', result: expr.statements, entireLoc: expr.entireLoc } satisfies UrbanStatsASTStatement\n            return attemptParseExpr(stmts, blockIdent, types, typeEnvironment, fallback, preserveCustomNodes) ?? fallback(unparse(stmts), blockIdent, types)\n        case 'customNode':\n            if (preserveCustomNodes) {\n                return parseNoErrorAsCustomNode(unparse(expr, { simplify: true }), blockIdent, types)\n            }\n            else {\n                return parseExpr(expr.expr, blockIdent, types, typeEnvironment, fallback, preserveCustomNodes)\n            }\n        case 'statements':\n            if (expr.result.length === 1) {\n                return parseExpr(expr.result[0], blockIdent, types, typeEnvironment, fallback, preserveCustomNodes)\n            }\n            return undefined\n        case 'expression':\n            return parseExpr(expr.value, blockIdent, types, typeEnvironment, fallback, preserveCustomNodes)\n        case 'identifier':\n            const validVariableSelections = possibilities(types, typeEnvironment).filter(s => s.type === 'variable') as { type: 'variable', name: string }[]\n            if (validVariableSelections.some(s => s.name === expr.name.node)) {\n                return { type: 'identifier', name: { node: expr.name.node, location: emptyLocation(blockIdent) } }\n            }\n            return undefined\n        case 'constant':\n            if (types.some(type => type.type === expr.value.node.type)) {\n                return { type: 'constant', value: { node: expr.value.node, location: emptyLocation(blockIdent) } }\n            }\n            return undefined\n        case 'unaryOperator':\n            if (expr.operator.node === '-' && expr.expr.type === 'constant' && expr.expr.value.node.type === 'number' && types.some(type => type.type === 'number')) {\n                return {\n                    type: 'constant',\n                    value: { location: emptyLocation(blockIdent), node: { type: 'number', value: -(expr.expr.value.node.value) } },\n                }\n            }\n            return undefined\n        case 'call':\n            const fn = expr.fn\n            if (fn.type !== 'identifier') {\n                return undefined\n            }\n            const validFunctionSelections = possibilities(types, typeEnvironment).filter(s => s.type === 'function') as { type: 'function', name: string }[]\n            if (!validFunctionSelections.some(s => s.name === fn.name.node)) {\n                return undefined\n            }\n            const tdoc = typeEnvironment.get(fn.name.node)\n            if (!tdoc || tdoc.type.type !== 'function') {\n                return undefined\n            }\n            const fnType = tdoc.type\n            let positionals = expr.args.filter(a => a.type === 'unnamed') satisfies (UrbanStatsASTArg & { type: 'unnamed' })[]\n            if (positionals.length !== fnType.posArgs.length) {\n                return undefined\n            }\n            let nameds = expr.args.filter(a => a.type === 'named') satisfies (UrbanStatsASTArg & { type: 'named' })[]\n            const names = new Set(nameds.map(a => a.name.node))\n            const needed = Object.entries(fnType.namedArgs).filter(([, a]) => a.defaultValue === undefined)\n            if (needed.some(([name]) => !names.has(name))) {\n                return undefined\n            }\n            if (fnType.posArgs.some(a => a.type !== 'concrete')) {\n                return undefined\n            }\n            positionals = positionals.map((a, i) => ({\n                type: 'unnamed',\n                value: parseExpr(a.value, extendBlockIdPositionalArg(blockIdent, i), [(fnType.posArgs[i] as { type: 'concrete', value: USSType }).value], typeEnvironment, fallback, preserveCustomNodes),\n            }))\n            if (Object.values(fnType.namedArgs).some(a => a.type.type !== 'concrete')) {\n                return undefined\n            }\n            nameds = nameds.map(a => ({\n                type: 'named',\n                name: a.name,\n                value: parseExpr(a.value, extendBlockIdKwarg(blockIdent, a.name.node), [(fnType.namedArgs[a.name.node].type as { type: 'concrete', value: USSType }).value], typeEnvironment, fallback, preserveCustomNodes),\n            }))\n            return {\n                type: 'call',\n                fn: { type: 'identifier', name: { node: fn.name.node, location: emptyLocation(blockIdent) } },\n                args: [...positionals, ...nameds],\n                entireLoc: emptyLocation(blockIdent),\n            }\n    }\n}\n\nexport type Selection = { type: 'variable' | 'function', name: string } | { type: 'custom' } | { type: 'constant' } | { type: 'vector' } | { type: 'object' }\n\nfunction shouldShowConstant(type: USSType): boolean {\n    return type.type === 'number' || type.type === 'string'\n}\n\nexport function possibilities(target: USSType[], env: TypeEnvironment): Selection[] {\n    const results: Selection[] = []\n    // Add vector option if the type is a vector\n    if (target.some(t => t.type === 'vector')) {\n        results.push({ type: 'vector' })\n    }\n    // Add properties option if the type is an object\n    if (target.some(t => t.type === 'object')) {\n        results.push({ type: 'object' })\n    }\n    // Add custom option for non-opaque or custom-allowed types\n    if (target.some(t => t.type !== 'opaque' || t.allowCustomExpression !== false)) {\n        results.push({ type: 'custom' })\n    }\n    // Add constant option for numbers and strings\n    if (target.some(shouldShowConstant)) {\n        results.push({ type: 'constant' })\n    }\n    else {\n        const renderedTypes = target.map(renderType)\n        // Only add variables and functions if constants are not shown\n        const variables: Selection[] = []\n        const functions: Selection[] = []\n        for (const [name, type] of env) {\n            const t: USSType = type.type\n            // if (renderType(t) === renderType(target)) {\n            if (renderedTypes.includes(renderType(t))) {\n                variables.push({ type: 'variable', name })\n            }\n            else if (t.type === 'function' && t.returnType.type === 'concrete' && renderedTypes.includes(renderType(t.returnType.value))) {\n                functions.push({ type: 'function', name })\n            }\n        }\n        // Sort variables by priority (lower numbers first)\n        variables.sort((a, b) => {\n            const aPriority = a.type === 'variable' ? (env.get(a.name)?.documentation?.priority ?? 1) : 1\n            const bPriority = b.type === 'variable' ? (env.get(b.name)?.documentation?.priority ?? 1) : 1\n            return aPriority - bPriority\n        })\n        // Sort functions by priority (functions get priority 0 by default)\n        functions.sort((a, b) => {\n            const aPriority = a.type === 'function' ? (env.get(a.name)?.documentation?.priority ?? 0) : 0\n            const bPriority = b.type === 'function' ? (env.get(b.name)?.documentation?.priority ?? 0) : 0\n            return aPriority - bPriority\n        })\n        // Functions first, then variables\n        results.push(...functions)\n        results.push(...variables)\n    }\n    return results\n}\n","import { gunzipSync } from 'zlib'\n\nimport { z } from 'zod'\n\nimport valid_geographies from '../../data/mapper/used_geographies'\nimport universes_ordered from '../../data/universes_ordered'\nimport { Universe } from '../../universe'\nimport { locationOf, toStatement, unify, UrbanStatsASTStatement } from '../../urban-stats-script/ast'\nimport { longMessage } from '../../urban-stats-script/editor-utils'\nimport { emptyLocation } from '../../urban-stats-script/lexer'\nimport { parse, parseNoErrorAsCustomNode, unparse } from '../../urban-stats-script/parser'\nimport { defaultTypeEnvironment } from '../context'\n\nimport { attemptParseAsTopLevel, defaultTopLevelEditor, MapUSS, rootBlockIdent } from './TopLevelEditor'\n\nexport type StatisticsForGeography = { stats: number[] }[]\n\n/* eslint-disable no-restricted-syntax -- This represents persitent links */\nexport interface RegressionDescriptor {\n    var_coefficients: string[]\n    var_intercept: string\n    independent: ColorStatDescriptor | undefined | null\n    residual_name?: string\n    var_residue: string\n    weight_by_population: boolean\n    dependents: (ColorStatDescriptor | undefined | null)[]\n}\n/* eslint-enable no-restricted-syntax */\n\nexport type ColorStatDescriptor = (\n    { type: 'single', value: string, name?: string, uss: string }\n    |\n    { type: 'function', value: 'Function', name?: string, uss?: string }\n)\n\nexport interface LineStyle {\n    color: string\n    weight: number\n}\n\nexport type Basemap = {\n    type: 'osm'\n    noLabels?: boolean\n    subnationalOutlines?: LineStyle\n} | { type: 'none', backgroundColor: string, textColor: string }\n\nexport interface FilterSettings {\n    enabled: boolean\n    function: ColorStatDescriptor\n}\n\nexport interface MapperScriptSettings {\n    uss: MapUSS\n}\n\nexport interface MapSettings {\n    geographyKind: typeof valid_geographies[number] | undefined\n    universe: Universe | undefined\n    script: MapperScriptSettings\n}\n\nexport function computeUSS(mapSettings: MapperScriptSettings): UrbanStatsASTStatement {\n    return toStatement(mapSettings.uss)\n}\n\nexport function defaultSettings(addTo: Partial<MapSettings>): MapSettings {\n    const uss = attemptParseAsTopLevel(addTo.script?.uss ?? defaultTopLevelEditor(), defaultTypeEnvironment(addTo.universe ?? 'USA'), true)\n    return {\n        geographyKind: addTo.geographyKind ?? 'Subnational Region',\n        universe: addTo.universe ?? 'USA',\n        script: {\n            uss,\n        },\n    }\n}\n\nexport function makeStatements<const T extends UrbanStatsASTStatement[]>(elements: T, identFallback?: string): UrbanStatsASTStatement & { type: 'statements', result: T } {\n    const locations = [...elements.map(locationOf)]\n    if (identFallback !== undefined) {\n        locations.push(emptyLocation(identFallback))\n    }\n    return {\n        type: 'statements',\n        result: elements,\n        entireLoc: unify(...locations),\n    }\n}\n\nexport const mapperMetaFields = z.object({\n    // Catch statements so we can remove universes/geos in the future and maps will still partially load\n    geographyKind: z.optional(z.enum(valid_geographies)).catch(undefined),\n    universe: z.optional(z.enum(universes_ordered)).catch(undefined),\n})\n\nexport function mapSettingsFromURLParam(encodedSettings: string | undefined): MapSettings {\n    let settings: Partial<MapSettings> = {}\n    if (encodedSettings !== undefined) {\n        const jsonedSettings = gunzipSync(Buffer.from(encodedSettings, 'base64')).toString()\n        const rawSettings = z.object({\n            ...mapperMetaFields.shape,\n            script: z.object({\n                uss: z.string(),\n            }) }).parse(JSON.parse(jsonedSettings))\n        const uss = parse(rawSettings.script.uss)\n        if (uss.type === 'error') {\n            throw new Error(uss.errors.map(error => longMessage({ kind: 'error', ...error }, true)).join(', '))\n        }\n        settings = {\n            ...rawSettings,\n            script: { uss: convertToMapUss(uss) },\n        }\n    }\n    return defaultSettings(settings)\n}\n\nexport function convertToMapUss(uss: UrbanStatsASTStatement): MapUSS {\n    if (uss.type === 'expression' && uss.value.type === 'customNode') {\n        return uss.value\n    }\n    if (\n        uss.type === 'statements'\n        && uss.result.length === 2\n        && uss.result[0].type === 'expression'\n        && uss.result[0].value.type === 'customNode'\n        && uss.result[1].type === 'condition'\n        && uss.result[1].rest.length === 1\n        && uss.result[1].rest[0].type === 'expression'\n    ) {\n        return {\n            ...uss,\n            result: [\n                {\n                    ...uss.result[0],\n                    value: uss.result[0].value,\n                },\n                {\n                    ...uss.result[1],\n                    rest: [uss.result[1].rest[0]],\n                },\n            ],\n        }\n    }\n    // Support arbitrary scripts\n    return parseNoErrorAsCustomNode(unparse(uss), rootBlockIdent)\n}\n","/**\n * A zod-like parser to extract static values from and edit USS ASTs\n */\n\nimport { parseExpr } from '../mapper/settings/parseExpr'\nimport { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTExpression, UrbanStatsASTStatement } from './ast'\nimport { noLocation } from './location'\nimport { unparse } from './parser'\nimport { TypeEnvironment, USSType } from './types-values'\n\nfunction error(message: string, expr: UrbanStatsASTExpression | UrbanStatsASTStatement | undefined | UrbanStatsASTStatement[], childErrors?: Error[]): never {\n    throw new Error(`${message}: ${JSON.stringify(expr)}${childErrors && `\\n${childErrors.map(e => `  ${e.message}`).join('\\n')}`}`)\n}\n\ninterface LiteralExprParser<T> {\n    // Undefined is a non-existent expression, used for optionals\n    parse: (\n        expr: UrbanStatsASTExpression | undefined,\n        typeEnvironment: TypeEnvironment,\n        doEdit?: (newExpr: UrbanStatsASTExpression | undefined) => UrbanStatsASTExpression | UrbanStatsASTStatement | undefined\n    ) => T\n}\n\nexport function string(): LiteralExprParser<string> {\n    return {\n        parse(expr) {\n            if (expr?.type === 'constant' && expr.value.node.type === 'string') {\n                return expr.value.node.value\n            }\n            error(`not a string constant`, expr)\n        },\n    }\n}\n\nexport function boolean(): LiteralExprParser<boolean> {\n    return transformExpr(union([identifier('true'), identifier('false')]), i => i === 'true')\n}\n\nexport function identifier<T extends string>(name: T): LiteralExprParser<T> {\n    return {\n        parse(expr) {\n            if (expr?.type === 'identifier' && expr.name.node === name) {\n                return name\n            }\n            error(`not an identifier with the name ${name}`, expr)\n        },\n    }\n}\n\nexport function union<T>(schemas: LiteralExprParser<T>[]): LiteralExprParser<T> {\n    return {\n        parse(expr, env, doEdit) {\n            const errors: Error[] = []\n            for (const schema of schemas) {\n                try {\n                    return schema.parse(expr, env, doEdit)\n                }\n                catch (e) {\n                    errors.push(e as Error)\n                }\n            }\n            error(`No union schema could be parsed`, expr, errors)\n        },\n    }\n}\n\nexport function number(): LiteralExprParser<number> {\n    return {\n        parse(expr, env) {\n            if (expr?.type === 'unaryOperator' && expr.operator.node === '-') {\n                return -this.parse(expr.expr, env)\n            }\n            if (expr?.type === 'constant' && expr.value.node.type === 'number') {\n                return expr.value.node.value\n            }\n            error('not a number', expr)\n        },\n    }\n}\n\nexport function object<T extends Record<string, unknown>>(schema: { [K in keyof T]: LiteralExprParser<T[K]> }): LiteralExprParser<T> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr?.type === 'objectLiteral') {\n                const result = {} as T\n                for (const key of Object.keys(schema)) {\n                    const match = expr.properties.find(([k]) => k === key)\n                    result[key] = schema[key].parse(\n                        match?.[1], env,\n                        newExpr => doEdit({ ...expr, properties: newExpr === undefined\n                            ? expr.properties.filter(prop => prop[0] !== key)\n                            : match\n                                ? expr.properties.map(prop => prop === match ? [prop[0], newExpr] : prop)\n                                : [...expr.properties, [key as string, newExpr]] }))\n                }\n                return result\n            }\n            error('not an object literal', expr)\n        },\n    }\n}\n\nexport function optional<T>(schema: LiteralExprParser<T>): LiteralExprParser<T | undefined> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr === undefined) {\n                return undefined\n            }\n            return schema.parse(expr, env, doEdit)\n        },\n    }\n}\n\nexport function call<N extends Record<string, unknown>, U extends unknown[], F>(schema: {\n    namedArgs: { [K in keyof N]: LiteralExprParser<N[K]> }\n    unnamedArgs: { [I in keyof U]: LiteralExprParser<U[I]> }\n    fn: LiteralExprParser<F>\n}): LiteralExprParser<{ namedArgs: N, unnamedArgs: U, fn: F }> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr?.type === 'call') {\n                const fn = schema.fn.parse(expr.fn, env,\n                    (newExpr) => {\n                        assert(newExpr !== undefined, 'cannot remove just the callee')\n                        return doEdit({ ...expr, fn: newExpr })\n                    },\n                )\n                const namedResult = {} as N\n                for (const key of Object.keys(schema.namedArgs)) {\n                    const match = expr.args.find(arg => arg.type === 'named' && arg.name.node === key)\n                    namedResult[key] = schema.namedArgs[key].parse(match?.value, env,\n                        newExpr => doEdit({ ...expr, args: match\n                            ? newExpr === undefined ? expr.args.filter(prop => prop !== match) : expr.args.map(prop => prop === match ? { ...prop, value: newExpr } : prop)\n                            : newExpr === undefined ? expr.args : [...expr.args, { type: 'named', name: { node: key as string, location: noLocation }, value: newExpr }] }),\n                    )\n                }\n\n                const unnamedResult = [] as unknown as U\n                argSchemas: for (const [i, argSchema] of schema.unnamedArgs.entries()) {\n                    let j = 0\n                    for (const arg of expr.args) {\n                        if (arg.type === 'named') {\n                            continue\n                        }\n                        if (j === i) {\n                            unnamedResult[i] = argSchema.parse(arg.value, env,\n                                newExpr => doEdit({ ...expr, args: newExpr === undefined ? expr.args.filter(a => a !== arg) : expr.args.map(a => a === arg ? { ...a, value: newExpr } : a) }),\n                            )\n                            continue argSchemas\n                        }\n                        j++\n                    }\n                    error('not enough named args', expr)\n                }\n\n                return { namedArgs: namedResult, unnamedArgs: unnamedResult, fn }\n            }\n            error('not a call expression', expr)\n        },\n    }\n}\n\nexport function vector<T>(schema: LiteralExprParser<T>): LiteralExprParser<T[]> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            return editableVector(schema).parse(expr, env, doEdit).currentValue\n        },\n    }\n}\n\nexport function editableVector<T>(schema: LiteralExprParser<T>): LiteralExprParser<{\n    currentValue: T[]\n    edit: (edits: (oldAst: UrbanStatsASTExpression[]) => UrbanStatsASTExpression[]) => UrbanStatsASTExpression | UrbanStatsASTStatement\n}> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr?.type === 'vectorLiteral') {\n                return {\n                    currentValue: expr.elements.map(elem => schema.parse(elem, env,\n                        newExpr => doEdit({ ...expr, elements: newExpr === undefined ? expr.elements.filter(e => e !== elem) : expr.elements.map(e => e === elem ? newExpr : e) }),\n                    )),\n                    edit(edits) {\n                        return doEdit({\n                            ...expr,\n                            elements: edits(expr.elements),\n                        })!\n                    },\n                }\n            }\n            error('not a vector literal', expr)\n        },\n    }\n}\n\nexport function deconstruct<T>(schema: LiteralExprParser<T>): LiteralExprParser<T> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr?.type === 'identifier') {\n                const type = env.get(expr.name.node)\n                if (type?.documentation?.equivalentExpressions !== undefined && type.documentation.equivalentExpressions.length > 0) {\n                    for (const equivalentExpression of type.documentation.equivalentExpressions) {\n                        try {\n                            return schema.parse(equivalentExpression, env, doEdit)\n                        }\n                        catch {}\n                    }\n                }\n            }\n            return schema.parse(expr, env, doEdit)\n        },\n    }\n}\n\n/**\n * Enables selectively editing an AST (does a shallow copy)\n */\nexport function edit<T>(\n    schema: LiteralExprParser<T>,\n): LiteralExprParser<{\n        currentValue: T\n        edit: (newExpr: UrbanStatsASTExpression | undefined) => UrbanStatsASTExpression | UrbanStatsASTStatement | undefined\n        expr: UrbanStatsASTExpression | undefined\n    }> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            return {\n                currentValue: schema.parse(expr, env, doEdit),\n                edit: doEdit,\n                expr,\n            }\n        },\n    }\n}\n\n/**\n * Reparse the expr when editing\n */\nexport function reparse<T>(blockIdent: string, types: USSType[], schema: LiteralExprParser<T>): LiteralExprParser<T> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            return schema.parse(expr, env,\n                newExpr => doEdit(newExpr === undefined ? undefined : parseExpr(newExpr, blockIdent, types, env, () => { throw new Error('should not happen') }, true)),\n            )\n        },\n    }\n}\n\ninterface LiteralStmtParser<T> {\n    // Undefined is a non-existent expression, used for optionals\n    parse: (\n        stmt: UrbanStatsASTStatement | undefined,\n        typeEnvironment: TypeEnvironment,\n        doEdit?: (newStmt: UrbanStatsASTStatement) => UrbanStatsASTStatement\n    ) => T\n}\n\nexport function expression<T>(schema: LiteralExprParser<T>): LiteralStmtParser<T> {\n    return {\n        parse(stmt, env, doEdit = e => e) {\n            if (stmt?.type === 'expression') {\n                return schema.parse(stmt.value, env,\n                    newExpr => newExpr === undefined ? undefined : doEdit({ ...stmt, value: newExpr }),\n                )\n            }\n            error('not an expression', stmt)\n        },\n    }\n}\n\nfunction parseStatements<T extends unknown[]>(\n    schema: { [I in keyof T]: LiteralStmtParser<T[I]> },\n    stmts: UrbanStatsASTStatement[],\n    env: TypeEnvironment,\n    doEdit: (newStmt: UrbanStatsASTStatement[]) => UrbanStatsASTStatement,\n): T {\n    const result = [] as unknown as T\n    for (const [i, s] of schema.entries()) {\n        if (i >= stmts.length) {\n            error('not enough statements', stmts)\n        }\n        result[i] = s.parse(stmts[i], env,\n            newStmt => doEdit([...stmts.slice(0, i), newStmt, ...stmts.slice(i + 1)]),\n        )\n    }\n    return result\n}\n\nexport function statements<T extends unknown[]>(schema: { [I in keyof T]: LiteralStmtParser<T[I]> }): LiteralStmtParser<T> {\n    return {\n        parse(stmt, env, doEdit = e => e) {\n            if (stmt?.type === 'statements') {\n                return parseStatements(schema, stmt.result, env,\n                    newStmts => doEdit({ ...stmt, result: newStmts }),\n                )\n            }\n            error('not a statements list', stmt)\n        },\n    }\n}\n\nexport function ignore(): LiteralStmtParser<undefined> & LiteralExprParser<undefined> {\n    return {\n        parse() {\n            return undefined\n        },\n    }\n}\n\nexport function condition<C, R extends unknown[]>(schema: { condition: LiteralExprParser<C>, rest: { [I in keyof R]: LiteralStmtParser<R[I]> } }): LiteralStmtParser<{ condition: C, rest: R }> {\n    return {\n        parse(stmt, env, doEdit = e => e) {\n            if (stmt?.type === 'condition') {\n                return {\n                    condition: schema.condition.parse(stmt.condition, env,\n                        (newExpr) => {\n                            assert(newExpr !== undefined, 'cannot remove just the condition from a condition statement')\n                            return doEdit({ ...stmt, condition: newExpr })\n                        },\n                    ),\n                    rest: parseStatements(schema.rest, stmt.rest, env,\n                        newStmts => doEdit({ ...stmt, rest: newStmts }),\n                    ),\n                }\n            }\n            error('not a condition', stmt)\n        },\n    }\n}\nexport function transformExpr<T, U>(schema: LiteralExprParser<T>, map: (t: T) => U): LiteralExprParser<U> {\n    return {\n        parse(ast, env, doEdit = e => e) {\n            return map(schema.parse(ast, env, doEdit))\n        },\n    }\n}\n\nexport function transformStmt<T, U>(schema: LiteralStmtParser<T>, map: (t: T) => U): LiteralStmtParser<U> {\n    return {\n        parse(ast, env, doEdit = e => e) {\n            return map(schema.parse(ast, env, doEdit))\n        },\n    }\n}\n\nexport function customNodeExpr<T>(schema: LiteralExprParser<T>): LiteralExprParser<T> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr?.type === 'customNode' && expr.expr.type === 'expression') {\n                const expressionStatement = expr.expr\n                return schema.parse(expr.expr.value, env, newExpr => newExpr === undefined\n                    ? undefined\n                    : doEdit({\n                        ...expr,\n                        expr: {\n                            ...expressionStatement,\n                            value: newExpr,\n                        },\n                        originalCode: unparse(newExpr),\n                    }))\n            }\n            return schema.parse(expr, env, doEdit)\n        },\n    }\n}\n","import { useEffect, useState } from 'react'\n\nexport class Property<T> {\n    private _value: T\n    readonly observers = new Set<() => void>()\n\n    readonly id = Math.random().toString(36).substring(2)\n\n    constructor(value: T) {\n        this._value = value\n    }\n\n    get value(): T {\n        return this._value\n    }\n\n    set value(newValue: T) {\n        this._value = newValue\n        this.observers.forEach((observer) => { observer() })\n    }\n\n    /* eslint-disable react-hooks/rules-of-hooks -- Custom hook method */\n    use(): T {\n        const [, setCounter] = useState(0)\n        useEffect(() => {\n            const observer = (): void => {\n                setCounter(counter => counter + 1)\n            }\n            this.observers.add(observer)\n            return () => {\n                this.observers.delete(observer)\n            }\n        // eslint-disable-next-line react-hooks/exhaustive-deps -- Needs this as the property can change around the effect\n        }, [this])\n        return this.value\n    }\n    /* eslint-enable react-hooks/rules-of-hooks */\n}\n"],"names":["jsonStringify","JSON","require","isArray","objectKeys","callBind","callBound","$join","$indexOf","$splice","$sort","strRepeat","n","char","str","i","defaultReplacer","_parent","_key","value","module","obj","opts","arguments","undefined","space","cycles","replacer","TypeError","collapseEmpty","cmpOpt","cmp","node","get","k","a","b","seen","stringify","parent","key","level","indent","colonSeparator","_type_of","groupOutput","out","brackets","item","keys","keyValue","toString","Array","arr","exports","at","ch","text","escapee","error","m","next","c","number","num","isFinite","Number","string","hex","uffff","parseInt","String","white","Object","word","source","reviver","result","walk","holder","v","val","gap","rep","escapable","meta","quote","Error","length","partial","mind","bitap","haystack","needle","maxErrors","sb","errors","matchMask","search","j","charMatch","errors1","PencilButton","param","onEdit","size","colors","useColors","e","BetterSelector","onChange","possibleValues","renderValue","selectedRendered","_useState","searchValue","setSearchValue","_useState1","isOpen","setIsOpen","_useState2","highlightedIndex","setHighlightedIndex","inputRef","useRef","menuRef","useEffect","_useMemo","optionsResult","choice","index","longestSelectionPossibility","acc","poss","Math","Uint32Array","bitapBuffers","options","sortedOptions","useMemo","token","bitapAlphabet","assert","alphabet","toSignature","charCode","firstOccurence","aScore","bScore","handleOptionSelect","option","newValue","stableStringify","prev","setTimeout","_option_renderedChoice_node1","_inputRef_current","DefaultSelectorOption","props","SelectionContext","createContext","Property","CustomEditor","uss","setUss","typeEnvironment","blockIdent","placeholder","ourErrors","selectionContext","useContext","selection","Editor","u","parseNoErrorAsCustomNode","range","_selectionContext_value","isCustomConstructor","possibility","_typeEnvironment_get_documentation","Selector","setSelection","selected","classifyExpr","selectionPossibilities","allPossibilities","Set","type","typePossibilities","possibilities","hasCustomConstructor","renderPossibility","useCallback","renderSelection","_typeEnvironment_get","_doc_selectorRendering","_doc_selectorRendering1","_doc_humanReadableName","doc","highlighted","LongDescriptionSubtitle","ramp","RampSelectorOption","customConstructorOption","isNumber","isString","showConstantInput","currentValue","errorComponent","DisplayResults","colorValue","getColor","select","NumberInput","TextInput","doRender","newUss","newColor","hexToColor","newColorUss","hsvColorExpression","rgbColorExpression","parseNoErrorAsExpression","parseExpr","emptyLocation","numberValue","parseNumber","classifiedFn","colorSchema","l","call","color","_call_namedArgs_a","_call_namedArgs_a1","rgbToColor","hsvToColor","expr","firstRampColor","ColorLib","highlightedColor","colorThemes","selectionGradient","toCssGradient","pos","selectionColor","direction","border","createDefaultExpression","_iteratorError","_tdoc_documentation","name","tdoc","renderType","getDefaultVariable","getDefaultFunction","ArgumentEditor","_tdoc_documentation_namedArgs_props_name","arg","functionUss","argValue","hasDefault","isEnabled","subident","extendBlockIdKwarg","humanReadableName","CheckboxSettingCustom","checked","_deconstruct","defaultExpr","exprToUse","newArg","newArgs","newArgs1","AutoUXEditor","_subcomponent","subc","doesConsume","_props_label_length","_props_labelWidth","ussLoc","locationOf","console","labelWidth","_wrappedSubcomponent","subselectors","extendBlockIdPositionalArg","_argWDefault_documentation","argWDefault","elementType","el","newEl","newElements","extendBlockIdVectorElement","_","propertiesTypes","DefaultMap","_uss_properties_find_","propertyType","extendBlockIdObjectProperty","newVal","wrapped","leftSegment","rightSegment","defaultForSelection","current","deconstructed","deconstruct","parsed","maybeParseExpr","unparse","twoLines","useMobileLayout","varType","previous","fn","compatiblePreviousArg","extractCompatiblePreviousArgs","foundType","targetType","_expr_args_filter_arg","_expr_args_find","args","_compatiblePreviousArg","arg1","reference","_reference_documentation","equiv","valid","ConditionEditor","condition","setCondition","conditionIsCustom","currentCondition","PreambleEditor","preamble","setPreamble","showPreamble","setShowPreamble","validMapperOutputs","rootBlockIdent","idPreamble","idCondition","idOutput","TopLevelEditor","attemptParseAsTopLevel","makeStatements","newConditionExpr","conditionStatement","stmt","preserveCustomNodes","stmts","_attemptParseCondition","conditionStmt","conditionText","conditionRest","conditionExpr","body","defaultTopLevelEditor","types","fallback","attemptParseExpr","elementTypes","t","elem","idx","exprProps","compatibleTypes","_attemptParseExpr","validVariableSelections","s","validFunctionSelections","fnType","positionals","nameds","names","needed","shouldShowConstant","target","env","results","renderedTypes","variables","functions","_env_get_documentation_priority","_env_get_documentation_priority1","aPriority","_results","_results1","computeUSS","mapSettings","toStatement","defaultSettings","addTo","_addTo_script_uss","_addTo_universe","_addTo_geographyKind","_addTo_universe1","defaultTypeEnvironment","elements","identFallback","locations","unify","mapperMetaFields","z","valid_geographies","universes_ordered","mapSettingsFromURLParam","encodedSettings","settings","jsonedSettings","gunzipSync","Buffer","rawSettings","parse","longMessage","convertToMapUss","message","childErrors","boolean","transformExpr","union","identifier","schemas","doEdit","schema","object","match","newExpr","prop","optional","namedResult","noLocation","unnamedResult","_iteratorError1","argSchemas","argSchema","_iteratorError2","editableVector","edit","edits","_type_documentation","equivalentExpression","reparse","expression","parseStatements","newStmt","statements","newStmts","ignore","map","ast","transformStmt","customNodeExpr","expressionStatement","observer","use","setCounter","counter"],"mappings":"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"}