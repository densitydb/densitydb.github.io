{"version":3,"file":"191.js","sources":["webpack://assets/./src/mapper/settings/SelectionContext.ts","webpack://assets/./src/mapper/settings/Selector.tsx","webpack://assets/./src/mapper/settings/CustomEditor.tsx","webpack://assets/./src/mapper/settings/AutoUXEditor.tsx","webpack://assets/./src/mapper/settings/ConditionEditor.tsx","webpack://assets/./src/mapper/settings/PreambleEditor.tsx","webpack://assets/./src/mapper/settings/TopLevelEditor.tsx","webpack://assets/./src/mapper/settings/parseExpr.ts","webpack://assets/./src/mapper/settings/utils.ts","webpack://assets/./src/urban-stats-script/literal-parser.ts"],"sourcesContent":["import { createContext } from 'react'\n\nimport { Range } from '../../urban-stats-script/editor-utils'\nimport { Property } from '../../utils/Property'\n\nexport interface Selection {\n    blockIdent: string\n    range: Range\n}\n\n// eslint-disable-next-line no-restricted-syntax -- React contexts typically are capitalized\nexport const SelectionContext = createContext(new Property<Selection | undefined>(undefined))\n","import ColorLib from 'color'\nimport stableStringify from 'json-stable-stringify'\nimport React, { ReactNode, useMemo, useCallback } from 'react'\n\nimport { colorThemes } from '../../page_template/color-themes'\nimport { useColors } from '../../page_template/colors'\nimport { DisplayResults } from '../../urban-stats-script/Editor'\nimport { UrbanStatsASTExpression } from '../../urban-stats-script/ast'\nimport { hsvToColor, rgbToColor } from '../../urban-stats-script/constants/color'\nimport { Color, doRender, hexToColor, hsvColorExpression, rgbColorExpression } from '../../urban-stats-script/constants/color-utils'\nimport { RampT } from '../../urban-stats-script/constants/ramp'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { emptyLocation, parseNumber } from '../../urban-stats-script/lexer'\nimport { parseNoErrorAsCustomNode, parseNoErrorAsExpression } from '../../urban-stats-script/parser'\nimport { Documentation, TypeEnvironment, USSType } from '../../urban-stats-script/types-values'\nimport { assert } from '../../utils/defensive'\n\nimport * as l from './../../urban-stats-script/literal-parser'\nimport { BetterSelector, SelectorRenderResult } from './BetterSelector'\nimport { parseExpr, possibilities, Selection } from './parseExpr'\n\nexport const labelPadding = '4px'\n\nfunction isCustomConstructor(possibility: Selection, typeEnvironment: TypeEnvironment): boolean {\n    return possibility.type === 'function' && typeEnvironment.get(possibility.name)?.documentation?.customConstructor === true\n}\n\nexport function Selector(props: {\n    uss: UrbanStatsASTExpression\n    setSelection: (selection: Selection) => void\n    setUss: (u: UrbanStatsASTExpression) => void\n    typeEnvironment: TypeEnvironment\n    type: USSType[]\n    blockIdent: string\n    errors: EditorError[]\n}): ReactNode {\n    const { setSelection, typeEnvironment } = props\n    const selected = classifyExpr(props.uss)\n\n    const selectionPossibilities = useMemo(() => {\n        // Combine possibilities from all types\n        const allPossibilities = new Set<Selection>()\n        props.type.forEach((type) => {\n            const typePossibilities = possibilities([type], props.typeEnvironment)\n            typePossibilities.forEach(possibility => allPossibilities.add(possibility))\n        })\n\n        return Array.from(allPossibilities)\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- props.type keeps the same deep value but changes reference. It's simpler to stringify it here than track it down everywhere\n    }, [stableStringify(props.type), props.typeEnvironment])\n\n    const hasCustomConstructor = useMemo(() => {\n        return selectionPossibilities.some(possibility => isCustomConstructor(possibility, props.typeEnvironment)) && !isCustomConstructor(selected, props.typeEnvironment)\n    }, [selectionPossibilities, props.typeEnvironment, selected])\n\n    const renderPossibility = useCallback((selection: Selection) => renderSelection(props.typeEnvironment, selection), [props.typeEnvironment])\n\n    const onEdit = useCallback(() => {\n        const customConstructorOption = selectionPossibilities.find(possibility => isCustomConstructor(possibility, typeEnvironment))\n        if (customConstructorOption) {\n            setSelection(customConstructorOption)\n        }\n    }, [selectionPossibilities, typeEnvironment, setSelection])\n\n    if (selectionPossibilities.length < 2) {\n        return undefined\n    }\n\n    const isNumber = props.type.some(type => type.type === 'number')\n    const isString = props.type.some(type => type.type === 'string')\n    const showConstantInput = selected.type === 'constant' && (isNumber || isString)\n    const currentValue = props.uss.type === 'constant' ? props.uss.value.node.value.toString() : ''\n    const errors = props.errors.filter(e => e.location.start.block.type === 'single' && e.location.start.block.ident === props.blockIdent)\n    const errorComponent = <DisplayResults results={errors} editor={false} />\n\n    const colorValue = props.type.some(type => type.type === 'opaque' && type.name === 'color') ? getColor(props.uss, props.typeEnvironment) : undefined\n\n    const select = (\n        <div style={{ position: 'relative', display: 'flex', alignItems: 'center', gap: '0.5em' }}>\n            <BetterSelector\n                value={selected}\n                possibleValues={selectionPossibilities}\n                renderValue={renderPossibility}\n                onChange={props.setSelection}\n                onEdit={hasCustomConstructor ? onEdit : undefined}\n            />\n            {showConstantInput && (\n                isNumber ? <NumberInput currentValue={currentValue} {...props} /> : <TextInput currentValue={currentValue} {...props} />\n            )}\n            {colorValue !== undefined && (\n                <input\n                    type=\"color\"\n                    value={doRender(colorValue.color, true)}\n                    style={{ width: '200px', height: '30.5px' }}\n                    onChange={(e) => {\n                        const newColor = hexToColor(e.target.value)\n                        const newColorUss = colorValue.kind === 'hsv' ? hsvColorExpression(newColor, { forceAlpha: colorValue.color.a }) : rgbColorExpression(newColor, { forceAlpha: colorValue.color.a })\n                        let newUss: UrbanStatsASTExpression | undefined\n                        switch (props.uss.type) {\n                            case 'customNode':\n                                newUss = parseNoErrorAsCustomNode(\n                                    newColorUss,\n                                    props.blockIdent,\n                                    props.type,\n                                )\n                                break\n                            case 'identifier':\n                            case 'call':\n                                newUss = parseNoErrorAsExpression(\n                                    newColorUss,\n                                    props.blockIdent,\n                                )\n                        }\n                        if (newUss !== undefined) {\n                            newUss = parseExpr(\n                                newUss,\n                                props.blockIdent,\n                                props.type,\n                                props.typeEnvironment,\n                                () => { throw new Error('Should not happen') },\n                                true,\n                            )\n                            props.setUss(newUss)\n                        }\n                    }}\n                />\n            )}\n        </div>\n    )\n    return (\n        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5em' }}>\n            {select}\n            {errorComponent}\n        </div>\n    )\n}\n\nfunction TextInput({ currentValue, blockIdent, setUss }: { currentValue: string, blockIdent: string, setUss: (u: UrbanStatsASTExpression) => void }): ReactNode {\n    return (\n        <textarea\n            value={currentValue}\n            onChange={(e) => {\n                const value = e.target.value\n                setUss({\n                    type: 'constant',\n                    value: {\n                        node: { type: 'string', value },\n                        location: emptyLocation(blockIdent),\n                    },\n                })\n            }}\n            style={{ width: '200px', fontSize: '14px', padding: '4px 8px', resize: 'vertical' }}\n            placeholder=\"Enter string\"\n        />\n    )\n}\n\nfunction NumberInput({ currentValue, blockIdent, setUss }: { currentValue: string, blockIdent: string, setUss: (u: UrbanStatsASTExpression) => void }): ReactNode {\n    return (\n        <input\n            type=\"text\"\n            value={currentValue}\n            onChange={(e) => {\n                const value = e.target.value\n                let node: (UrbanStatsASTExpression & { type: 'constant' })['value']['node']\n                let numberValue\n                if ((numberValue = parseNumber(value)) !== undefined) {\n                    node = { type: 'number', value: numberValue }\n                }\n                else {\n                    node = { type: 'string', value }\n                }\n                const newUss: UrbanStatsASTExpression = {\n                    type: 'constant',\n                    value: {\n                        node,\n                        location: emptyLocation(blockIdent),\n                    },\n                }\n                setUss(newUss)\n            }}\n            style={{ width: '200px', fontSize: '14px', padding: '4px 8px', resize: 'none' }}\n            placeholder=\"Enter number\"\n        />\n    )\n}\n\nexport function classifyExpr(uss: UrbanStatsASTExpression): Selection {\n    if (uss.type === 'customNode') {\n        return { type: 'custom' }\n    }\n    if (uss.type === 'constant') {\n        return { type: 'constant' }\n    }\n    if (uss.type === 'identifier') {\n        return { type: 'variable', name: uss.name.node }\n    }\n    if (uss.type === 'call') {\n        const classifiedFn = classifyExpr(uss.fn)\n        assert(classifiedFn.type === 'variable', 'Function must be a variable or another function')\n        return { type: 'function', name: classifiedFn.name }\n    }\n    if (uss.type === 'vectorLiteral') {\n        return { type: 'vector' }\n    }\n    if (uss.type === 'objectLiteral') {\n        return { type: 'object' }\n    }\n    throw new Error(`Unsupported USS expression type: ${uss.type}`)\n}\n\nexport function renderSelection(typeEnvironment: TypeEnvironment, selection: Selection): SelectorRenderResult {\n    if (selection.type === 'custom') {\n        return { text: 'Custom Expression' }\n    }\n    if (selection.type === 'constant') {\n        return { text: 'Constant' }\n    }\n    if (selection.type === 'vector') {\n        return { text: 'Manual List' }\n    }\n    if (selection.type === 'object') {\n        return { text: 'Properties' }\n    }\n    const doc = typeEnvironment.get(selection.name)?.documentation\n    if (doc?.selectorRendering?.kind === 'subtitleLongDescription') {\n        return {\n            text: doc.humanReadableName,\n            node: highlighted => <LongDescriptionSubtitle doc={doc} highlighted={highlighted} />,\n        }\n    }\n    if (doc?.selectorRendering?.kind === 'gradientBackground') {\n        const ramp = doc.selectorRendering.ramp\n        return {\n            text: doc.humanReadableName,\n            node: highlighted => <RampSelectorOption name={doc.humanReadableName} ramp={ramp} highlighted={highlighted} />,\n        }\n    }\n    else {\n        return { text: doc?.humanReadableName ?? selection.name }\n    }\n}\n\nexport const colorSchema = l.transformExpr(l.customNodeExpr(l.deconstruct(l.call({\n    fn: l.union([l.identifier('rgb'), l.identifier('hsv')]),\n    unnamedArgs: [l.number(), l.number(), l.number()],\n    namedArgs: { a: l.optional(l.number()) },\n}))), (call) => {\n    let color: Color | undefined\n    switch (call.fn) {\n        case 'rgb':\n            color = rgbToColor(call.unnamedArgs[0], call.unnamedArgs[1], call.unnamedArgs[2], call.namedArgs.a ?? 1, true)\n            break\n        case 'hsv':\n            color = hsvToColor(call.unnamedArgs[0], call.unnamedArgs[1], call.unnamedArgs[2], call.namedArgs.a ?? 1, true)\n            break\n    }\n    if (color === undefined) {\n        return undefined\n    }\n    return { color, kind: call.fn }\n})\n\nexport function getColor(expr: UrbanStatsASTExpression, typeEnvironment: TypeEnvironment): { color: Color, kind: 'rgb' | 'hsv' } | undefined {\n    try {\n        return colorSchema.parse(expr, typeEnvironment)\n    }\n    catch {\n        return\n    }\n}\n\nfunction LongDescriptionSubtitle(props: { doc: Documentation, highlighted: boolean }): ReactNode {\n    const colors = useColors()\n    return (\n        <div style={{\n            padding: '8px 12px',\n            background: props.highlighted ? colors.slightlyDifferentBackgroundFocused : colors.slightlyDifferentBackground,\n        }}\n        >\n            <div>{props.doc.humanReadableName}</div>\n            <div style={{ fontSize: 'smaller', color: colors.ordinalTextColor }}>\n                {props.doc.longDescription}\n            </div>\n        </div>\n    )\n}\n\nfunction RampSelectorOption(props: { name: string, ramp: RampT, highlighted: boolean }): ReactNode {\n    const colors = useColors()\n    const firstRampColor = ColorLib(props.ramp[0][1])\n    const highlightedColor = `rgb(from ${colors.slightlyDifferentBackgroundFocused} r g b / 1)`\n    return (\n        <div style={{\n            padding: '8px 12px',\n            color: colorThemes[firstRampColor.isLight() ? 'Light Mode' : 'Dark Mode'].textMain,\n            background: props.highlighted ? `${selectionGradient(highlightedColor, 'bottom')}, ${selectionGradient(highlightedColor, 'right')}, ${toCssGradient(props.ramp)}` : toCssGradient(props.ramp),\n        }}\n        >\n            {props.name}\n        </div>\n    )\n}\n\nfunction toCssGradient(ramp: RampT): string {\n    return `linear-gradient(to right, ${ramp.map(([pos, color]) => `${color} ${Math.round(pos * 100)}%`).join(', ')})`\n}\n\nfunction selectionGradient(selectionColor: string, direction: string): string {\n    const border = `5px`\n    return `linear-gradient(to ${direction}, ${selectionColor} ${border}, transparent ${border}, transparent calc(100% - ${border}), ${selectionColor} calc(100% - ${border}))`\n}\n","import React, { ReactNode, useContext, useMemo } from 'react'\n\nimport { Editor } from '../../urban-stats-script/Editor'\nimport { UrbanStatsASTExpression } from '../../urban-stats-script/ast'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { ParseError, parseNoErrorAsCustomNode } from '../../urban-stats-script/parser'\nimport { TypeEnvironment } from '../../urban-stats-script/types-values'\n\nimport { SelectionContext } from './SelectionContext'\n\nexport function CustomEditor({\n    uss,\n    setUss,\n    typeEnvironment,\n    errors,\n    blockIdent,\n    placeholder,\n}: {\n    uss: UrbanStatsASTExpression & { type: 'customNode' }\n    setUss: (u: UrbanStatsASTExpression & { type: 'customNode' }) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n    blockIdent: string\n    placeholder?: string\n}): ReactNode {\n    const ourErrors = useMemo(() => errors.filter((e: ParseError) => e.location.start.block.type === 'single' && e.location.start.block.ident === blockIdent), [errors, blockIdent])\n\n    const selectionContext = useContext(SelectionContext)\n    const selection = selectionContext.use()\n\n    return (\n        <Editor\n            uss={uss.originalCode}\n            setUss={(u: string) => {\n                const parsed = parseNoErrorAsCustomNode(u, blockIdent, uss.expectedType)\n                setUss(parsed)\n            }}\n            typeEnvironment={typeEnvironment}\n            results={ourErrors}\n            placeholder={placeholder}\n            selection={selection?.blockIdent === blockIdent ? selection.range : null}\n            setSelection={(range) => {\n                if (range !== null) {\n                    selectionContext.value = { blockIdent, range }\n                }\n                else if (selectionContext.value?.blockIdent === blockIdent) {\n                    selectionContext.value = undefined\n                }\n            }}\n        />\n    )\n}\n","import stableStringify from 'json-stable-stringify'\nimport React, { ReactNode } from 'react'\n\nimport { CheckboxSettingCustom } from '../../components/sidebar'\nimport { UrbanStatsASTExpression, UrbanStatsASTArg, locationOf } from '../../urban-stats-script/ast'\nimport { hsvColorExpression, rgbColorExpression } from '../../urban-stats-script/constants/color-utils'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { emptyLocation } from '../../urban-stats-script/lexer'\nimport { extendBlockIdKwarg, extendBlockIdObjectProperty, extendBlockIdPositionalArg, extendBlockIdVectorElement } from '../../urban-stats-script/location'\nimport { parseNoErrorAsCustomNode, parseNoErrorAsExpression, unparse } from '../../urban-stats-script/parser'\nimport { USSType, USSFunctionArgType, renderType, USSFunctionType, TypeEnvironment } from '../../urban-stats-script/types-values'\nimport { DefaultMap } from '../../utils/DefaultMap'\nimport { assert } from '../../utils/defensive'\nimport { useMobileLayout } from '../../utils/responsive'\n\nimport { CustomEditor } from './CustomEditor'\nimport { Selector, classifyExpr, getColor, labelPadding } from './Selector'\nimport { maybeParseExpr, parseExpr, Selection, possibilities } from './parseExpr'\n\nfunction createDefaultExpression(type: USSType, blockIdent: string, typeEnvironment: TypeEnvironment): UrbanStatsASTExpression {\n    if (type.type === 'number') {\n        return { type: 'constant', value: { node: { type: 'number', value: 0 }, location: emptyLocation(blockIdent) } }\n    }\n    if (type.type === 'string') {\n        return { type: 'constant', value: { node: { type: 'string', value: '' }, location: emptyLocation(blockIdent) } }\n    }\n    for (const [name, tdoc] of typeEnvironment) {\n        if (!tdoc.documentation?.isDefault) {\n            continue\n        }\n        if (renderType(tdoc.type) === renderType(type)) {\n            return getDefaultVariable({ type: 'variable', name }, typeEnvironment, blockIdent)\n        }\n        if (tdoc.type.type === 'function' && tdoc.type.returnType.type !== 'inferFromPrimitive' && renderType(tdoc.type.returnType.value) === renderType(type)) {\n            return getDefaultFunction({ type: 'function', name }, typeEnvironment, blockIdent)\n        }\n    }\n    if (type.type === 'vector') {\n        return {\n            type: 'vectorLiteral',\n            entireLoc: emptyLocation(blockIdent),\n            elements: [],\n        }\n    }\n    return parseNoErrorAsCustomNode('', blockIdent, [type])\n}\n\nfunction ArgumentEditor(props: {\n    name: string\n    argWDefault: { type: USSFunctionArgType, defaultValue?: UrbanStatsASTExpression }\n    uss: UrbanStatsASTExpression & { type: 'call', fn: UrbanStatsASTExpression & { type: 'identifier' } }\n    setUss: (u: UrbanStatsASTExpression) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n    blockIdent: string\n}): ReactNode {\n    const arg = props.argWDefault.type\n    assert(arg.type === 'concrete', `Named argument ${props.name} must be concrete`)\n\n    const functionUss = props.uss\n    const argValue = functionUss.args.find(a => a.type === 'named' && a.name.node === props.name)\n    const hasDefault = props.argWDefault.defaultValue !== undefined\n    const isEnabled = argValue !== undefined\n    const subident = extendBlockIdKwarg(props.blockIdent, props.name)\n\n    // Get the function's documentation to find human-readable argument names\n    const tdoc = props.typeEnvironment.get(functionUss.fn.name.node)\n    const humanReadableName = tdoc?.documentation?.namedArgs?.[props.name] ?? props.name\n\n    return (\n        <div style={{ display: 'flex', alignItems: 'flex-start', gap: '0.25em', width: '100%', margin: '0.25em 0' }}>\n            <div style={{ flex: 1 }}>\n                <div>\n                    {hasDefault\n                        ? (\n                                <CheckboxSettingCustom\n                                    name={humanReadableName}\n                                    checked={isEnabled}\n                                    onChange={(checked) => {\n                                        if (checked) {\n                                            const defaultExpr = props.argWDefault.defaultValue\n                                            let exprToUse = defaultExpr === undefined || (defaultExpr.type === 'identifier' && defaultExpr.name.node === 'null')\n                                                ? createDefaultExpression(arg.value, subident, props.typeEnvironment)\n                                                : defaultExpr\n                                            exprToUse = deconstruct(exprToUse, props.typeEnvironment, subident, arg.value) ?? parseExpr(exprToUse, subident, [arg.value], props.typeEnvironment, () => {\n                                                throw new Error('Should not happen')\n                                            }, true)\n                                            // Add the argument with default value\n                                            const newArg = {\n                                                type: 'named' as const,\n                                                name: { node: props.name, location: emptyLocation(subident) },\n                                                value: exprToUse,\n                                            }\n                                            const newArgs = [...functionUss.args, newArg]\n                                            props.setUss({ ...functionUss, args: newArgs })\n                                        }\n                                        else {\n                                            // Remove the argument\n                                            const newArgs = functionUss.args.filter(a => !(a.type === 'named' && a.name.node === props.name))\n                                            props.setUss({ ...functionUss, args: newArgs })\n                                        }\n                                    }}\n                                />\n                            )\n                        : <span>{humanReadableName}</span>}\n\n                </div>\n                {isEnabled\n                && (\n                    <AutoUXEditor\n                        uss={argValue.value}\n                        setUss={(newUss) => {\n                            const newArgs = functionUss.args.map(a => a.type === 'named' && a.name.node === props.name ? { ...a, value: newUss } : a)\n                            props.setUss({ ...functionUss, args: newArgs })\n                        }}\n                        typeEnvironment={props.typeEnvironment}\n                        errors={props.errors}\n                        blockIdent={subident}\n                        type={[arg.value]}\n                    />\n                )}\n            </div>\n        </div>\n    )\n}\n\nexport function AutoUXEditor(props: {\n    uss: UrbanStatsASTExpression\n    setUss: (u: UrbanStatsASTExpression) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n    blockIdent: string\n    type: USSType[]\n    label?: string\n    labelWidth?: string\n}): ReactNode {\n    const ussLoc = locationOf(props.uss).start\n    if (ussLoc.block.type !== 'single' || ussLoc.block.ident !== props.blockIdent) {\n        console.warn('USS: ', props.uss)\n        console.warn('USS Location: ', ussLoc)\n        console.warn('Editor blockIdent: ', props.blockIdent)\n        console.error('[failtest] USS expression location does not match block identifier', props.uss, ussLoc.block.type === 'single' ? ussLoc.block.ident : '(multi)', props.blockIdent)\n    }\n    const labelWidth = props.labelWidth ?? '5%'\n    const subcomponent = (): [ReactNode | undefined, 'consumes-errors' | 'does-not-consume-errors'] => {\n        if (props.uss.type === 'constant') {\n            return [undefined, 'does-not-consume-errors']\n        }\n        const uss = props.uss\n        if (uss.type === 'customNode') {\n            const editor = (\n                <CustomEditor\n                    key=\"custom\"\n                    uss={uss}\n                    setUss={props.setUss}\n                    typeEnvironment={props.typeEnvironment}\n                    errors={props.errors}\n                    blockIdent={props.blockIdent}\n                />\n            )\n            return [editor, 'consumes-errors']\n        }\n        if (uss.type === 'identifier') {\n            return [undefined, 'does-not-consume-errors']\n        }\n        if (uss.type === 'call') {\n            assert(uss.fn.type === 'identifier', 'Function must be an identifier')\n            const tdoc = props.typeEnvironment.get(uss.fn.name.node)\n            assert(tdoc !== undefined, `Function ${uss.fn.name.node} not found in type environment`)\n            const type = tdoc.type\n            assert(type.type === 'function', `Function ${uss.fn.name.node} must be a function type`)\n            const subselectors: ReactNode[] = []\n            type.posArgs.forEach((arg, i) => {\n                assert(arg.type === 'concrete', `Positional argument must be concrete`)\n                subselectors.push(\n                    <AutoUXEditor\n                        key={`pos-${i}`}\n                        uss={uss.args[i].value}\n                        setUss={(newUss) => {\n                            const newArgs = [...uss.args]\n                            newArgs[i] = { ...newArgs[i], value: newUss }\n                            props.setUss({ ...uss, args: newArgs })\n                        }}\n                        typeEnvironment={props.typeEnvironment}\n                        errors={props.errors}\n                        blockIdent={extendBlockIdPositionalArg(props.blockIdent, i)}\n                        type={[arg.value]}\n                    />,\n                )\n            })\n            Object.entries(type.namedArgs).forEach(([name, argWDefault]) => {\n                if (argWDefault.documentation?.hide !== true) {\n                    subselectors.push(\n                        <ArgumentEditor\n                            key={`named-${name}`}\n                            name={name}\n                            argWDefault={argWDefault}\n                            // cast is valid because we checked type above\n                            uss={uss as UrbanStatsASTExpression & { type: 'function', fn: UrbanStatsASTExpression & { type: 'identifier' } }}\n                            setUss={props.setUss}\n                            typeEnvironment={props.typeEnvironment}\n                            errors={props.errors}\n                            blockIdent={props.blockIdent}\n                        />,\n                    )\n                }\n            })\n            const element = <div key=\"subselectors\">{...subselectors}</div>\n            return [element, 'does-not-consume-errors']\n        }\n        if (uss.type === 'vectorLiteral') {\n            // Determine the element type\n            let elementType: USSType = { type: 'number' } // fallback\n            if (props.type[0].type === 'vector') {\n                // something of a hack, but this really shouldn't be an issue because we don't support multiple types for vectors\n                elementType = props.type[0].elementType as USSType\n            }\n            const element = (\n                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5em', width: '100%' }}>\n                    {uss.elements.map((el, i) => (\n                        <div key={i} style={{ display: 'flex', alignItems: 'center', gap: '0.5em', width: '100%' }}>\n                            <AutoUXEditor\n                                uss={el}\n                                setUss={(newEl) => {\n                                    const newElements = [...uss.elements]\n                                    newElements[i] = newEl\n                                    props.setUss({ ...uss, elements: newElements })\n                                }}\n                                typeEnvironment={props.typeEnvironment}\n                                errors={props.errors}\n                                blockIdent={extendBlockIdVectorElement(props.blockIdent, i)}\n                                type={[elementType]}\n                                label={`${i + 1}`}\n                            />\n                            <button\n                                style={{ flexShrink: 0 }}\n                                onClick={() => {\n                                    const newElements = uss.elements.filter((_, j) => j !== i)\n                                    props.setUss({ ...uss, elements: newElements })\n                                }}\n                                title=\"Remove element\"\n                            >\n                                â€“\n                            </button>\n                        </div>\n                    ))}\n                    <button\n                        style={{ alignSelf: 'flex-start', marginTop: 4 }}\n                        onClick={() => {\n                            const newElements = [\n                                ...uss.elements,\n                                // Copy the last element if there is one\n                                uss.elements.length > 0\n                                    ? uss.elements[uss.elements.length - 1]\n                                    : createDefaultExpression(elementType, extendBlockIdVectorElement(props.blockIdent, uss.elements.length), props.typeEnvironment),\n                            ]\n                            props.setUss({ ...uss, elements: newElements })\n                        }}\n                    >\n                        + Add element\n                    </button>\n                </div>\n            )\n            return [element, 'does-not-consume-errors']\n        }\n        if (uss.type === 'objectLiteral') {\n            // Determine the element type\n            let propertiesTypes: Map<string, USSType> = new DefaultMap(() => ({ type: 'number' })) // fallback\n            if (props.type[0].type === 'object') {\n                // something of a hack, but this really shouldn't be an issue because we don't support multiple types for objects\n                propertiesTypes = props.type[0].properties\n            }\n            const element = (\n                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5em', width: '100%' }}>\n                    {Array.from(propertiesTypes.keys()).sort().map((key) => {\n                        const propertyType = propertiesTypes.get(key)!\n                        return (\n                            <AutoUXEditor\n                                key={key}\n                                uss={uss.properties.find(([k]) => k === key)?.[1] ?? createDefaultExpression(propertyType, extendBlockIdObjectProperty(props.blockIdent, key), props.typeEnvironment)}\n                                setUss={(newVal) => {\n                                    props.setUss({ ...uss, properties: uss.properties.map(([k, v]) => [k, k === key ? newVal : v]) })\n                                }}\n                                typeEnvironment={props.typeEnvironment}\n                                errors={props.errors}\n                                blockIdent={extendBlockIdObjectProperty(props.blockIdent, key)}\n                                type={[propertyType]}\n                                label={key}\n                            />\n                        )\n                    })}\n                </div>\n            )\n            return [element, 'does-not-consume-errors']\n        }\n        throw new Error(`Unsupported USS expression type: ${props.uss.type}`) // TODO handle other types\n    }\n\n    const wrappedSubcomponent = (): [ReactNode | undefined, 'consumes-errors' | 'does-not-consume-errors'] => {\n        const [subc, doesConsume] = subcomponent()\n        if (subc === undefined) {\n            return [undefined, doesConsume]\n        }\n        const element = (\n            <div style={{ width: '100%', flex: 1 }}>\n                <div style={{ display: 'flex', gap: '1em', marginLeft: labelWidth }}>\n                    {props.label && <span style={{ minWidth: 'fit-content' }}></span>}\n                    <div style={{ flex: 1 }}>\n                        {subc}\n                    </div>\n                </div>\n            </div>\n        )\n        return [element, doesConsume]\n    }\n\n    const [wrapped, doesConsume] = wrappedSubcomponent()\n\n    const leftSegment = props.label === undefined\n        ? undefined\n        : (\n                <div style={{ padding: `${labelPadding} 0px`, display: 'flex', justifyContent: 'flex-end' }}>\n                    <span style={{ minWidth: 'fit-content', marginRight: '5px' }}>{props.label}</span>\n                </div>\n            )\n    const rightSegment = possibilities(props.type, props.typeEnvironment).length < 2\n        ? undefined\n        : (\n                <div style={{ width: `calc(100% - ${labelWidth})` }}>\n                    <Selector\n                        uss={props.uss}\n                        setSelection={(selection: Selection) => {\n                            props.setUss(defaultForSelection(selection, props.uss, props.typeEnvironment, props.blockIdent, props.type[0]))\n                        }}\n                        setUss={props.setUss}\n                        typeEnvironment={props.typeEnvironment}\n                        type={props.type}\n                        blockIdent={props.blockIdent}\n                        errors={doesConsume === 'consumes-errors' ? [] : props.errors}\n                    />\n                </div>\n\n            )\n\n    const twoLines = useMobileLayout() || (props.label?.length ?? 0) > 5\n\n    const component = (): ReactNode => {\n        if (twoLines) {\n            return (\n                <>\n                    <div style={{ display: 'flex', alignItems: 'top' }}>\n                        {leftSegment}\n                    </div>\n                    <div style={{ display: 'flex', alignItems: 'top' }}>\n                        <div style={{ width: labelWidth }} />\n                        {rightSegment}\n                    </div>\n                </>\n            )\n        }\n        else {\n            return (\n                <div style={{ display: 'flex', alignItems: 'top' }}>\n                    <div style={{ width: labelWidth }}>\n                        {leftSegment}\n                    </div>\n                    {rightSegment}\n                </div>\n            )\n        }\n    }\n\n    return (\n        <div style={{ display: 'flex', flexDirection: 'column', width: '100%', flex: 1, margin: '0.25em 0', gap: '0.25em' }} id={`auto-ux-editor-${props.blockIdent}`}>\n            {leftSegment !== undefined || rightSegment !== undefined ? <div style={{ width: '100%', flex: 1 }}>{component()}</div> : undefined}\n            {wrapped}\n        </div>\n    )\n}\n\nfunction getDefaultVariable(selection: Selection & { type: 'variable' }, typeEnvironment: TypeEnvironment, blockIdent: string): UrbanStatsASTExpression {\n    const varType = typeEnvironment.get(selection.name)?.type\n    assert(varType !== undefined, `Variable ${selection.name} not found in type environment`)\n    return { type: 'identifier', name: { node: selection.name, location: emptyLocation(blockIdent) } }\n}\n\n// Returns a function that pulls named or unnamed arguments of the same type and position out of the passed `expr`\n// Returns undefined if incompatible\n// We're assuming the result will have the correct idnet, since we're using the same position, and it's hard to check\nfunction extractCompatiblePreviousArgs(expr: UrbanStatsASTExpression, typeEnvironment: TypeEnvironment): (arg: number | string, type: USSType) => UrbanStatsASTExpression | undefined {\n    let type\n    if (expr.type === 'call' && expr.fn.type === 'identifier' && (type = typeEnvironment.get(expr.fn.name.node)) && type.type.type === 'function') {\n        const foundType: USSFunctionType = type.type\n        return (arg, targetType) => {\n            if (typeof arg === 'number' && arg < foundType.posArgs.length && foundType.posArgs[arg].type === 'concrete' && renderType(targetType) === renderType(foundType.posArgs[arg].value)) {\n                return expr.args.filter(a => a.type === 'unnamed')[arg]?.value\n            }\n            if (typeof arg === 'string' && arg in foundType.namedArgs && foundType.namedArgs[arg].type.type === 'concrete' && renderType(targetType) === renderType(foundType.namedArgs[arg].type.value)) {\n                return expr.args.find(a => a.type === 'named' && a.name.node === arg)?.value\n            }\n            return undefined\n        }\n    }\n    return () => undefined\n}\n\nfunction getDefaultFunction(selection: Selection & { type: 'function' }, typeEnvironment: TypeEnvironment, blockIdent: string, previous?: UrbanStatsASTExpression): UrbanStatsASTExpression {\n    const fn = typeEnvironment.get(selection.name)\n    assert(fn !== undefined && fn.type.type === 'function', `Function ${selection.name} not found or not a function`)\n    const compatiblePreviousArg = previous ? extractCompatiblePreviousArgs(previous, typeEnvironment) : undefined\n    const args: UrbanStatsASTArg[] = []\n    // Only include positional arguments by default, not named arguments with defaults, unless there's an existing value for the named argument\n    for (let i = 0; i < fn.type.posArgs.length; i++) {\n        const arg = fn.type.posArgs[i]\n        assert(arg.type === 'concrete', `Positional argument must be concrete`)\n        args.push({\n            type: 'unnamed',\n            value: compatiblePreviousArg?.(i, arg.value) ?? createDefaultExpression(arg.value, extendBlockIdPositionalArg(blockIdent, i), typeEnvironment),\n        })\n    }\n    for (const [name, argWDefault] of Object.entries(fn.type.namedArgs)) {\n        const arg = argWDefault.type\n        assert(arg.type === 'concrete', `Named argument ${name} must be concrete`)\n        const prev = compatiblePreviousArg?.(name, arg.value)\n        if (prev || argWDefault.defaultValue === undefined) {\n            args.push({\n                type: 'named',\n                name: { node: name, location: emptyLocation(blockIdent) },\n                value: prev ?? createDefaultExpression(arg.value, extendBlockIdKwarg(blockIdent, name), typeEnvironment),\n            })\n        }\n    }\n    return {\n        type: 'call',\n        fn: { type: 'identifier', name: { node: selection.name, location: emptyLocation(blockIdent) } },\n        args,\n        entireLoc: emptyLocation(blockIdent),\n    }\n}\n\nfunction deconstruct(expr: UrbanStatsASTExpression, typeEnvironment: TypeEnvironment, blockIdent: string, type: USSType, selection?: Selection): UrbanStatsASTExpression | undefined {\n    switch (expr.type) {\n        case 'identifier': {\n            const reference = typeEnvironment.get(expr.name.node)\n\n            if (reference === undefined) {\n                return\n            }\n\n            if (reference.documentation?.equivalentExpressions === undefined) {\n                return\n            }\n\n            for (const equiv of reference.documentation.equivalentExpressions) {\n                const valid = maybeParseExpr(equiv, blockIdent, type, typeEnvironment)\n                if (valid !== undefined && (selection === undefined || stableStringify(classifyExpr(valid)) === stableStringify(selection))) {\n                    return valid\n                }\n            }\n\n            return\n        }\n        case 'customNode':\n            if (expr.expr.type === 'expression') {\n                return deconstruct(expr.expr.value, typeEnvironment, blockIdent, type, selection)\n            }\n            return\n        case 'call': {\n            if (type.type === 'opaque' && type.name === 'color' && selection?.type === 'function') {\n                // Conversion between RGB and HSV functions\n                const color = getColor(expr, typeEnvironment)\n                switch (true) {\n                    case color?.kind === 'rgb' && selection.name === 'hsv':\n                        // rgb to hsv\n                        return parseNoErrorAsExpression(hsvColorExpression(color.color), blockIdent)\n                    case color?.kind === 'hsv' && selection.name === 'rgb':\n                        // hsv to rgb\n                        return parseNoErrorAsExpression(rgbColorExpression(color.color), blockIdent)\n                }\n            }\n            return\n        }\n        default:\n            return\n    }\n}\n\nfunction defaultForSelection(\n    selection: Selection,\n    current: UrbanStatsASTExpression,\n    typeEnvironment: TypeEnvironment,\n    blockIdent: string,\n    type: USSType,\n): UrbanStatsASTExpression {\n    const deconstructed = deconstruct(current, typeEnvironment, blockIdent, type, selection)\n    if (deconstructed !== undefined) {\n        return deconstructed\n    }\n\n    const parsed = maybeParseExpr(current, blockIdent, type, typeEnvironment)\n    if (parsed !== undefined && stableStringify(classifyExpr(parsed)) === stableStringify(selection)) {\n        return parsed\n    }\n\n    switch (selection.type) {\n        case 'custom':\n            return parseNoErrorAsCustomNode(unparse(current), blockIdent, [type])\n        case 'constant':\n            return createDefaultExpression(type, blockIdent, typeEnvironment)\n        case 'variable':\n            return getDefaultVariable(selection as Selection & { type: 'variable' }, typeEnvironment, blockIdent)\n        case 'function':\n            return getDefaultFunction(selection as Selection & { type: 'function' }, typeEnvironment, blockIdent, current)\n        case 'vector': {\n            // Create an empty vectorLiteral of the right type\n            return {\n                type: 'vectorLiteral',\n                entireLoc: emptyLocation(blockIdent),\n                elements: [],\n            }\n        }\n        case 'object':\n            return {\n                type: 'objectLiteral',\n                entireLoc: emptyLocation(blockIdent),\n                properties: [],\n            }\n    }\n}\n","import React, { ReactNode } from 'react'\n\nimport { CheckboxSettingCustom } from '../../components/sidebar'\nimport { UrbanStatsASTExpression } from '../../urban-stats-script/ast'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { emptyLocation } from '../../urban-stats-script/lexer'\nimport { unparse, parseNoErrorAsCustomNode } from '../../urban-stats-script/parser'\nimport { TypeEnvironment } from '../../urban-stats-script/types-values'\n\nimport { CustomEditor } from './CustomEditor'\n\nexport function ConditionEditor({\n    condition,\n    setCondition,\n    typeEnvironment,\n    errors,\n    blockIdent,\n}: {\n    condition: UrbanStatsASTExpression\n    setCondition: (conditionExpr: UrbanStatsASTExpression) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n    blockIdent: string\n}): ReactNode {\n    const conditionIsCustom = condition.type === 'customNode'\n\n    return (\n        <div style={{ margin: '0.5em 0' }}>\n            <CheckboxSettingCustom\n                name=\"Filter?\"\n                checked={conditionIsCustom}\n                onChange={(checked) => {\n                    if (checked) {\n                        // Enable condition - keep current condition or set to 'true'\n                        const currentCondition = unparse(condition) || 'true'\n                        const conditionExpr = parseNoErrorAsCustomNode(currentCondition, blockIdent, [{ type: 'vector', elementType: { type: 'boolean' } }])\n                        setCondition(conditionExpr)\n                    }\n                    else {\n                        // Disable condition - set to constant true\n                        const conditionExpr = { type: 'identifier', name: { node: 'true', location: emptyLocation(blockIdent) } } satisfies UrbanStatsASTExpression\n                        setCondition(conditionExpr)\n                    }\n                }}\n            />\n            {conditionIsCustom && (\n                <CustomEditor\n                    uss={condition as UrbanStatsASTExpression & { type: 'customNode' }}\n                    setUss={setCondition}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={blockIdent}\n                />\n            )}\n        </div>\n    )\n}\n","import React, { ReactNode, useEffect, useState } from 'react'\n\nimport { CheckboxSettingCustom } from '../../components/sidebar'\nimport { UrbanStatsASTExpression } from '../../urban-stats-script/ast'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { parseNoErrorAsCustomNode } from '../../urban-stats-script/parser'\nimport { TypeEnvironment } from '../../urban-stats-script/types-values'\n\nimport { CustomEditor } from './CustomEditor'\n\nexport function PreambleEditor({\n    preamble,\n    setPreamble,\n    typeEnvironment,\n    errors,\n    blockIdent,\n}: {\n    preamble: UrbanStatsASTExpression & { type: 'customNode' }\n    setPreamble: (conditionExpr: UrbanStatsASTExpression & { type: 'customNode' }) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n    blockIdent: string\n}): ReactNode {\n    const [showPreamble, setShowPreamble] = useState(preamble.originalCode.trim() !== '')\n\n    useEffect(() => {\n        setShowPreamble(preamble.originalCode.trim() !== '')\n    }, [preamble.originalCode])\n\n    return (\n        <div style={{ margin: '0.5em 0' }}>\n            <CheckboxSettingCustom\n                name=\"Preamble\"\n                checked={showPreamble}\n                onChange={(checked) => {\n                    // Enable/disable preamble\n                    const preambleExpr = parseNoErrorAsCustomNode('', blockIdent)\n                    setPreamble(preambleExpr)\n                    setShowPreamble(checked)\n                }}\n            />\n            {showPreamble && (\n                <CustomEditor\n                    uss={preamble as UrbanStatsASTExpression & { type: 'customNode' }}\n                    setUss={setPreamble}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={blockIdent}\n                    placeholder=\"Variables here can be used by all custom expressions.\"\n                />\n            )}\n        </div>\n    )\n}\n","import assert from 'assert'\n\nimport React, { ReactNode } from 'react'\n\nimport { CheckboxSettingCustom } from '../../components/sidebar'\nimport { DisplayResults } from '../../urban-stats-script/Editor'\nimport { locationOf, UrbanStatsASTExpression, UrbanStatsASTStatement } from '../../urban-stats-script/ast'\nimport { EditorError } from '../../urban-stats-script/editor-utils'\nimport { emptyLocation } from '../../urban-stats-script/lexer'\nimport { unparse, parseNoErrorAsCustomNode } from '../../urban-stats-script/parser'\nimport { TypeEnvironment, USSType } from '../../urban-stats-script/types-values'\n\nimport { AutoUXEditor } from './AutoUXEditor'\nimport { ConditionEditor } from './ConditionEditor'\nimport { CustomEditor } from './CustomEditor'\nimport { PreambleEditor } from './PreambleEditor'\nimport { parseExpr } from './parseExpr'\nimport { makeStatements } from './utils'\n\nconst cMap = { type: 'opaque', name: 'cMap', allowCustomExpression: false } satisfies USSType\nconst cMapRGB = { type: 'opaque', name: 'cMapRGB', allowCustomExpression: false } satisfies USSType\nconst pMap = { type: 'opaque', name: 'pMap', allowCustomExpression: false } satisfies USSType\n\nexport const validMapperOutputs = [cMap, cMapRGB, pMap] satisfies USSType[]\n\nexport const rootBlockIdent = 'r'\nconst idPreamble = `${rootBlockIdent}p`\nconst idCondition = `${rootBlockIdent}c`\nexport const idOutput = `${rootBlockIdent}o`\n\nexport type MapUSS = UrbanStatsASTExpression & { type: 'customNode' } |\n    (UrbanStatsASTStatement &\n    {\n        type: 'statements'\n        result: [\n                UrbanStatsASTStatement & { type: 'expression', value: UrbanStatsASTExpression & { type: 'customNode' } },\n                UrbanStatsASTStatement & { type: 'condition', rest: [UrbanStatsASTStatement & { type: 'expression' }] },\n        ]\n    })\n\nexport function TopLevelEditor({\n    uss,\n    setUss,\n    typeEnvironment,\n    errors,\n}: {\n    uss: MapUSS\n    setUss: (u: MapUSS) => void\n    typeEnvironment: TypeEnvironment\n    errors: EditorError[]\n}): ReactNode {\n    const subcomponent = (): ReactNode => {\n        if (uss.type === 'customNode') {\n            return (\n                <CustomEditor\n                    uss={uss}\n                    setUss={setUss}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={rootBlockIdent}\n                />\n            )\n        }\n\n        return (\n            <div>\n                {/* Preamble */}\n                <PreambleEditor\n                    preamble={uss.result[0].value}\n                    setPreamble={(u: UrbanStatsASTExpression & { type: 'customNode' }) => {\n                        const preamble = {\n                            type: 'expression',\n                            value: u,\n                        } satisfies UrbanStatsASTStatement\n                        setUss(makeStatements([preamble, uss.result[1]]))\n                    }}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={idPreamble}\n                />\n                {/* Condition */}\n                <ConditionEditor\n                    condition={uss.result[1].condition}\n                    setCondition={(newConditionExpr) => {\n                        const conditionStatement = {\n                            type: 'condition',\n                            entireLoc: locationOf(newConditionExpr),\n                            condition: newConditionExpr,\n                            rest: uss.result[1].rest,\n                        } satisfies UrbanStatsASTStatement\n                        setUss(makeStatements([uss.result[0], conditionStatement]))\n                    }}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={idCondition}\n                />\n                {/* Output */}\n                <AutoUXEditor\n                    uss={uss.result[1].rest[0].value}\n                    setUss={(u: UrbanStatsASTExpression) => {\n                        const condition = {\n                            type: 'condition',\n                            entireLoc: uss.result[1].entireLoc,\n                            condition: uss.result[1].condition,\n                            rest: [{ type: 'expression', value: u }] as const,\n                        } satisfies UrbanStatsASTStatement\n                        setUss(makeStatements([uss.result[0], condition]))\n                    }}\n                    typeEnvironment={typeEnvironment}\n                    errors={errors}\n                    blockIdent={idOutput}\n                    type={validMapperOutputs}\n                    labelWidth=\"0px\"\n                />\n            </div>\n        )\n    }\n    return (\n        <div>\n            <div style={{ margin: '0.5em 0px' }} />\n            <CheckboxSettingCustom\n                name=\"Enable custom script\"\n                checked={uss.type === 'customNode'}\n                onChange={(checked) => {\n                    if (checked) {\n                        assert(uss.type === 'statements', 'USS should be statements when enabling custom script')\n                        setUss(parseNoErrorAsCustomNode(unparse(uss, { simplify: true }), rootBlockIdent))\n                    }\n                    else {\n                        assert(uss.type === 'customNode', 'USS should not be a custom node when disabled')\n                        setUss(attemptParseAsTopLevel(uss.expr, typeEnvironment, false))\n                    }\n                }}\n            />\n            { subcomponent() }\n            <DisplayResults\n                editor={false}\n                results={errors.filter(e => e.location.start.block.type === 'multi')}\n            />\n        </div>\n    )\n}\n\nexport function attemptParseAsTopLevel(stmt: MapUSS | UrbanStatsASTStatement, typeEnvironment: TypeEnvironment, preserveCustomNodes: boolean): MapUSS {\n    /**\n     * Splits up the statements into a preamble and a condition statement. Make the body of the condition a custom node.\n     */\n    if (stmt.type === 'customNode') {\n        return stmt\n    }\n    const stmts = stmt.type === 'statements' ? stmt.result : [stmt]\n    const preamble = {\n        type: 'statements',\n        result: stmts.slice(0, -1),\n        entireLoc: locationOf(stmt),\n    } satisfies UrbanStatsASTStatement\n    const conditionStmt = stmts.length > 0 ? stmts[stmts.length - 1] : undefined\n    const { conditionRest, conditionExpr } = attemptParseCondition(conditionStmt)\n    const body = parseExpr(makeStatements(conditionRest, idOutput), idOutput, validMapperOutputs, typeEnvironment, parseNoErrorAsCustomNode, preserveCustomNodes)\n    const condition = {\n        type: 'condition',\n        entireLoc: locationOf(conditionExpr),\n        condition: conditionExpr,\n        rest: [{ type: 'expression', value: body }] as const,\n    } satisfies UrbanStatsASTStatement\n    return {\n        type: 'statements',\n        result: [\n            { type: 'expression', value: parseNoErrorAsCustomNode(unparse(preamble, { simplify: true }), idPreamble) },\n            condition,\n        ] as const,\n        entireLoc: locationOf(stmt),\n    } satisfies UrbanStatsASTStatement\n}\n\nfunction attemptParseCondition(conditionStmt: UrbanStatsASTStatement | undefined): { conditionRest: UrbanStatsASTStatement[], conditionExpr: UrbanStatsASTExpression } {\n    let stmts = conditionStmt !== undefined ? [conditionStmt] : []\n    if (conditionStmt?.type === 'condition') {\n        const conditionText = unparse(conditionStmt.condition, { simplify: true })\n        if (conditionText.trim() !== 'true') {\n            return {\n                conditionExpr: parseNoErrorAsCustomNode(conditionText, idCondition, [{ type: 'vector', elementType: { type: 'boolean' } }]),\n                conditionRest: conditionStmt.rest,\n            }\n        }\n        stmts = conditionStmt.rest\n    }\n    return {\n        conditionExpr: { type: 'identifier', name: { node: 'true', location: emptyLocation(idCondition) } } satisfies UrbanStatsASTExpression,\n        conditionRest: stmts,\n    }\n}\n\nexport function defaultTopLevelEditor(): UrbanStatsASTStatement {\n    const expr = parseNoErrorAsCustomNode('cMap(data=density_pw_1km, scale=linearScale(), ramp=rampUridis)', rootBlockIdent, validMapperOutputs)\n    return expr.expr\n}\n","import { UrbanStatsASTArg, UrbanStatsASTExpression, UrbanStatsASTStatement } from '../../urban-stats-script/ast'\nimport { emptyLocation } from '../../urban-stats-script/lexer'\nimport { extendBlockIdKwarg, extendBlockIdObjectProperty, extendBlockIdPositionalArg, extendBlockIdVectorElement } from '../../urban-stats-script/location'\nimport { parseNoErrorAsCustomNode, unparse } from '../../urban-stats-script/parser'\nimport { renderType, TypeEnvironment, USSObjectType, USSType } from '../../urban-stats-script/types-values'\n\nexport function maybeParseExpr(\n    expr: UrbanStatsASTExpression | UrbanStatsASTStatement,\n    blockIdent: string,\n    type: USSType,\n    typeEnvironment: TypeEnvironment,\n): UrbanStatsASTExpression | undefined {\n    try {\n        return parseExpr(expr, blockIdent, [type], typeEnvironment, () => {\n            throw new Error('parsing failed')\n        }, false)\n    }\n    catch {}\n    return\n}\n\ntype Fallback = (uss: string, i: string, t: USSType[]) => UrbanStatsASTExpression\n\nexport function parseExpr(\n    expr: UrbanStatsASTExpression | UrbanStatsASTStatement,\n    blockIdent: string,\n    types: USSType[],\n    typeEnvironment: TypeEnvironment,\n    fallback: Fallback,\n    preserveCustomNodes: boolean,\n): UrbanStatsASTExpression {\n    const parsed = attemptParseExpr(expr, blockIdent, types, typeEnvironment, fallback, preserveCustomNodes)\n    return parsed ?? fallback(unparse(expr), blockIdent, types)\n}\n\nfunction attemptParseExpr(\n    expr: UrbanStatsASTExpression | UrbanStatsASTStatement,\n    blockIdent: string,\n    types: USSType[],\n    typeEnvironment: TypeEnvironment,\n    fallback: Fallback,\n    preserveCustomNodes: boolean,\n): UrbanStatsASTExpression | undefined {\n    switch (expr.type) {\n        case 'condition':\n        case 'binaryOperator':\n        case 'if':\n        case 'assignment':\n        case 'parseError':\n        case 'attribute':\n            return undefined\n        case 'vectorLiteral':\n            const elementTypes = types\n                .filter(t => t.type === 'vector')\n                .map(t => t.elementType)\n                .filter(t => t.type !== 'elementOfEmptyVector') satisfies USSType[]\n            if (elementTypes.length === 0) {\n                return undefined\n            }\n            return {\n                type: 'vectorLiteral',\n                entireLoc: emptyLocation(blockIdent),\n                elements: expr.elements.map((elem, idx) => parseExpr(elem, extendBlockIdVectorElement(blockIdent, idx), elementTypes, typeEnvironment, fallback, preserveCustomNodes)),\n            }\n        case 'objectLiteral':\n            const exprProps = new Set(expr.properties.map(([key]) => key))\n            const compatibleTypes = types.filter(\n                (t) => {\n                    if (t.type !== 'object') {\n                        return false\n                    }\n                    if (t.properties.size !== expr.properties.length) {\n                        return false\n                    }\n                    if (Array.from(t.properties.keys()).some(key => !exprProps.has(key))) {\n                        return false\n                    }\n                    return true\n                },\n            ) as USSObjectType[]\n            if (compatibleTypes.length === 0) {\n                return undefined\n            }\n            return {\n                type: 'objectLiteral',\n                entireLoc: emptyLocation(blockIdent),\n                properties: expr.properties.map(([key, value]) => [\n                    key,\n                    parseExpr(value, extendBlockIdObjectProperty(blockIdent, key), compatibleTypes.map(t => t.properties.get(key)!) satisfies USSType[], typeEnvironment, fallback, preserveCustomNodes),\n                ]),\n            }\n        case 'do':\n            const stmts = { type: 'statements', result: expr.statements, entireLoc: expr.entireLoc } satisfies UrbanStatsASTStatement\n            return attemptParseExpr(stmts, blockIdent, types, typeEnvironment, fallback, preserveCustomNodes) ?? fallback(unparse(stmts), blockIdent, types)\n        case 'customNode':\n            if (preserveCustomNodes) {\n                return parseNoErrorAsCustomNode(unparse(expr, { simplify: true }), blockIdent, types)\n            }\n            else {\n                return parseExpr(expr.expr, blockIdent, types, typeEnvironment, fallback, preserveCustomNodes)\n            }\n        case 'statements':\n            if (expr.result.length === 1) {\n                return parseExpr(expr.result[0], blockIdent, types, typeEnvironment, fallback, preserveCustomNodes)\n            }\n            return undefined\n        case 'expression':\n            return parseExpr(expr.value, blockIdent, types, typeEnvironment, fallback, preserveCustomNodes)\n        case 'identifier':\n            const validVariableSelections = possibilities(types, typeEnvironment).filter(s => s.type === 'variable') as { type: 'variable', name: string }[]\n            if (validVariableSelections.some(s => s.name === expr.name.node)) {\n                return { type: 'identifier', name: { node: expr.name.node, location: emptyLocation(blockIdent) } }\n            }\n            return undefined\n        case 'constant':\n            if (types.some(type => type.type === expr.value.node.type)) {\n                return { type: 'constant', value: { node: expr.value.node, location: emptyLocation(blockIdent) } }\n            }\n            return undefined\n        case 'unaryOperator':\n            if (expr.operator.node === '-' && expr.expr.type === 'constant' && expr.expr.value.node.type === 'number' && types.some(type => type.type === 'number')) {\n                return {\n                    type: 'constant',\n                    value: { location: emptyLocation(blockIdent), node: { type: 'number', value: -(expr.expr.value.node.value) } },\n                }\n            }\n            return undefined\n        case 'call':\n            const fn = expr.fn\n            if (fn.type !== 'identifier') {\n                return undefined\n            }\n            const validFunctionSelections = possibilities(types, typeEnvironment).filter(s => s.type === 'function') as { type: 'function', name: string }[]\n            if (!validFunctionSelections.some(s => s.name === fn.name.node)) {\n                return undefined\n            }\n            const tdoc = typeEnvironment.get(fn.name.node)\n            if (!tdoc || tdoc.type.type !== 'function') {\n                return undefined\n            }\n            const fnType = tdoc.type\n            let positionals = expr.args.filter(a => a.type === 'unnamed') satisfies (UrbanStatsASTArg & { type: 'unnamed' })[]\n            if (positionals.length !== fnType.posArgs.length) {\n                return undefined\n            }\n            let nameds = expr.args.filter(a => a.type === 'named') satisfies (UrbanStatsASTArg & { type: 'named' })[]\n            const names = new Set(nameds.map(a => a.name.node))\n            const needed = Object.entries(fnType.namedArgs).filter(([, a]) => a.defaultValue === undefined)\n            if (needed.some(([name]) => !names.has(name))) {\n                return undefined\n            }\n            if (fnType.posArgs.some(a => a.type !== 'concrete')) {\n                return undefined\n            }\n            positionals = positionals.map((a, i) => ({\n                type: 'unnamed',\n                value: parseExpr(a.value, extendBlockIdPositionalArg(blockIdent, i), [(fnType.posArgs[i] as { type: 'concrete', value: USSType }).value], typeEnvironment, fallback, preserveCustomNodes),\n            }))\n            if (Object.values(fnType.namedArgs).some(a => a.type.type !== 'concrete')) {\n                return undefined\n            }\n            nameds = nameds.map(a => ({\n                type: 'named',\n                name: a.name,\n                value: parseExpr(a.value, extendBlockIdKwarg(blockIdent, a.name.node), [(fnType.namedArgs[a.name.node].type as { type: 'concrete', value: USSType }).value], typeEnvironment, fallback, preserveCustomNodes),\n            }))\n            return {\n                type: 'call',\n                fn: { type: 'identifier', name: { node: fn.name.node, location: emptyLocation(blockIdent) } },\n                args: [...positionals, ...nameds],\n                entireLoc: emptyLocation(blockIdent),\n            }\n    }\n}\n\nexport type Selection = { type: 'variable' | 'function', name: string } | { type: 'custom' } | { type: 'constant' } | { type: 'vector' } | { type: 'object' }\n\nfunction shouldShowConstant(type: USSType): boolean {\n    return type.type === 'number' || type.type === 'string'\n}\n\nexport function possibilities(target: USSType[], env: TypeEnvironment): Selection[] {\n    const results: Selection[] = []\n    // Add vector option if the type is a vector\n    if (target.some(t => t.type === 'vector')) {\n        results.push({ type: 'vector' })\n    }\n    // Add properties option if the type is an object\n    if (target.some(t => t.type === 'object')) {\n        results.push({ type: 'object' })\n    }\n    // Add custom option for non-opaque or custom-allowed types\n    if (target.some(t => t.type !== 'opaque' || t.allowCustomExpression !== false)) {\n        results.push({ type: 'custom' })\n    }\n    // Add constant option for numbers and strings\n    if (target.some(shouldShowConstant)) {\n        results.push({ type: 'constant' })\n    }\n    else {\n        const renderedTypes = target.map(renderType)\n        // Only add variables and functions if constants are not shown\n        const variables: Selection[] = []\n        const functions: Selection[] = []\n        for (const [name, type] of env) {\n            const t: USSType = type.type\n            // if (renderType(t) === renderType(target)) {\n            if (renderedTypes.includes(renderType(t))) {\n                variables.push({ type: 'variable', name })\n            }\n            else if (t.type === 'function' && t.returnType.type === 'concrete' && renderedTypes.includes(renderType(t.returnType.value))) {\n                functions.push({ type: 'function', name })\n            }\n        }\n        // Sort variables by priority (lower numbers first)\n        variables.sort((a, b) => {\n            const aPriority = a.type === 'variable' ? (env.get(a.name)?.documentation?.priority ?? 1) : 1\n            const bPriority = b.type === 'variable' ? (env.get(b.name)?.documentation?.priority ?? 1) : 1\n            return aPriority - bPriority\n        })\n        // Sort functions by priority (functions get priority 0 by default)\n        functions.sort((a, b) => {\n            const aPriority = a.type === 'function' ? (env.get(a.name)?.documentation?.priority ?? 0) : 0\n            const bPriority = b.type === 'function' ? (env.get(b.name)?.documentation?.priority ?? 0) : 0\n            return aPriority - bPriority\n        })\n        // Functions first, then variables\n        results.push(...functions)\n        results.push(...variables)\n    }\n    return results\n}\n","import { gunzipSync } from 'zlib'\n\nimport { z } from 'zod'\n\nimport valid_geographies from '../../data/mapper/used_geographies'\nimport universes_ordered from '../../data/universes_ordered'\nimport { Universe } from '../../universe'\nimport { locationOf, toStatement, unify, UrbanStatsASTStatement } from '../../urban-stats-script/ast'\nimport { longMessage } from '../../urban-stats-script/editor-utils'\nimport { emptyLocation } from '../../urban-stats-script/lexer'\nimport { parse, parseNoErrorAsCustomNode, unparse } from '../../urban-stats-script/parser'\nimport { defaultTypeEnvironment } from '../context'\n\nimport { attemptParseAsTopLevel, defaultTopLevelEditor, MapUSS, rootBlockIdent } from './TopLevelEditor'\n\nexport type StatisticsForGeography = { stats: number[] }[]\n\n/* eslint-disable no-restricted-syntax -- This represents persitent links */\nexport interface RegressionDescriptor {\n    var_coefficients: string[]\n    var_intercept: string\n    independent: ColorStatDescriptor | undefined | null\n    residual_name?: string\n    var_residue: string\n    weight_by_population: boolean\n    dependents: (ColorStatDescriptor | undefined | null)[]\n}\n/* eslint-enable no-restricted-syntax */\n\nexport type ColorStatDescriptor = (\n    { type: 'single', value: string, name?: string, uss: string }\n    |\n    { type: 'function', value: 'Function', name?: string, uss?: string }\n)\n\nexport interface LineStyle {\n    color: string\n    weight: number\n}\n\nexport type Basemap = {\n    type: 'osm'\n    noLabels?: boolean\n    subnationalOutlines?: LineStyle\n} | { type: 'none', backgroundColor: string, textColor: string }\n\nexport interface FilterSettings {\n    enabled: boolean\n    function: ColorStatDescriptor\n}\n\nexport interface MapperScriptSettings {\n    uss: MapUSS\n}\n\nexport interface MapSettings {\n    geographyKind: typeof valid_geographies[number] | undefined\n    universe: Universe | undefined\n    script: MapperScriptSettings\n}\n\nexport function computeUSS(mapSettings: MapperScriptSettings): UrbanStatsASTStatement {\n    return toStatement(mapSettings.uss)\n}\n\nexport function defaultSettings(addTo: Partial<MapSettings>): MapSettings {\n    const uss = attemptParseAsTopLevel(addTo.script?.uss ?? defaultTopLevelEditor(), defaultTypeEnvironment(addTo.universe ?? 'USA'), true)\n    return {\n        geographyKind: addTo.geographyKind ?? 'Subnational Region',\n        universe: addTo.universe ?? 'USA',\n        script: {\n            uss,\n        },\n    }\n}\n\nexport function makeStatements<const T extends UrbanStatsASTStatement[]>(elements: T, identFallback?: string): UrbanStatsASTStatement & { type: 'statements', result: T } {\n    const locations = [...elements.map(locationOf)]\n    if (identFallback !== undefined) {\n        locations.push(emptyLocation(identFallback))\n    }\n    return {\n        type: 'statements',\n        result: elements,\n        entireLoc: unify(...locations),\n    }\n}\n\nexport const mapperMetaFields = z.object({\n    // Catch statements so we can remove universes/geos in the future and maps will still partially load\n    geographyKind: z.optional(z.enum(valid_geographies)).catch(undefined),\n    universe: z.optional(z.enum(universes_ordered)).catch(undefined),\n})\n\nexport function mapSettingsFromURLParam(encodedSettings: string | undefined): MapSettings {\n    let settings: Partial<MapSettings> = {}\n    if (encodedSettings !== undefined) {\n        const jsonedSettings = gunzipSync(Buffer.from(encodedSettings, 'base64')).toString()\n        const rawSettings = z.object({\n            ...mapperMetaFields.shape,\n            script: z.object({\n                uss: z.string(),\n            }) }).parse(JSON.parse(jsonedSettings))\n        const uss = parse(rawSettings.script.uss)\n        if (uss.type === 'error') {\n            throw new Error(uss.errors.map(error => longMessage({ kind: 'error', ...error }, true)).join(', '))\n        }\n        settings = {\n            ...rawSettings,\n            script: { uss: convertToMapUss(uss) },\n        }\n    }\n    return defaultSettings(settings)\n}\n\nexport function convertToMapUss(uss: UrbanStatsASTStatement): MapUSS {\n    if (uss.type === 'expression' && uss.value.type === 'customNode') {\n        return uss.value\n    }\n    if (\n        uss.type === 'statements'\n        && uss.result.length === 2\n        && uss.result[0].type === 'expression'\n        && uss.result[0].value.type === 'customNode'\n        && uss.result[1].type === 'condition'\n        && uss.result[1].rest.length === 1\n        && uss.result[1].rest[0].type === 'expression'\n    ) {\n        return {\n            ...uss,\n            result: [\n                {\n                    ...uss.result[0],\n                    value: uss.result[0].value,\n                },\n                {\n                    ...uss.result[1],\n                    rest: [uss.result[1].rest[0]],\n                },\n            ],\n        }\n    }\n    // Support arbitrary scripts\n    return parseNoErrorAsCustomNode(unparse(uss), rootBlockIdent)\n}\n","/**\n * A zod-like parser to extract static values from and edit USS ASTs\n */\n\nimport { parseExpr } from '../mapper/settings/parseExpr'\nimport { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTExpression, UrbanStatsASTStatement } from './ast'\nimport { noLocation } from './location'\nimport { unparse } from './parser'\nimport { TypeEnvironment, USSType } from './types-values'\n\nfunction error(message: string, expr: UrbanStatsASTExpression | UrbanStatsASTStatement | undefined | UrbanStatsASTStatement[], childErrors?: Error[]): never {\n    throw new Error(`${message}: ${JSON.stringify(expr)}${childErrors && `\\n${childErrors.map(e => `  ${e.message}`).join('\\n')}`}`)\n}\n\ninterface LiteralExprParser<T> {\n    // Undefined is a non-existent expression, used for optionals\n    parse: (\n        expr: UrbanStatsASTExpression | undefined,\n        typeEnvironment: TypeEnvironment,\n        doEdit?: (newExpr: UrbanStatsASTExpression | undefined) => UrbanStatsASTExpression | UrbanStatsASTStatement | undefined\n    ) => T\n}\n\nexport function string(): LiteralExprParser<string> {\n    return {\n        parse(expr) {\n            if (expr?.type === 'constant' && expr.value.node.type === 'string') {\n                return expr.value.node.value\n            }\n            error(`not a string constant`, expr)\n        },\n    }\n}\n\nexport function boolean(): LiteralExprParser<boolean> {\n    return transformExpr(union([identifier('true'), identifier('false')]), i => i === 'true')\n}\n\nexport function identifier<T extends string>(name: T): LiteralExprParser<T> {\n    return {\n        parse(expr) {\n            if (expr?.type === 'identifier' && expr.name.node === name) {\n                return name\n            }\n            error(`not an identifier with the name ${name}`, expr)\n        },\n    }\n}\n\nexport function union<T>(schemas: LiteralExprParser<T>[]): LiteralExprParser<T> {\n    return {\n        parse(expr, env, doEdit) {\n            const errors: Error[] = []\n            for (const schema of schemas) {\n                try {\n                    return schema.parse(expr, env, doEdit)\n                }\n                catch (e) {\n                    errors.push(e as Error)\n                }\n            }\n            error(`No union schema could be parsed`, expr, errors)\n        },\n    }\n}\n\nexport function number(): LiteralExprParser<number> {\n    return {\n        parse(expr, env) {\n            if (expr?.type === 'unaryOperator' && expr.operator.node === '-') {\n                return -this.parse(expr.expr, env)\n            }\n            if (expr?.type === 'constant' && expr.value.node.type === 'number') {\n                return expr.value.node.value\n            }\n            error('not a number', expr)\n        },\n    }\n}\n\nexport function object<T extends Record<string, unknown>>(schema: { [K in keyof T]: LiteralExprParser<T[K]> }): LiteralExprParser<T> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr?.type === 'objectLiteral') {\n                const result = {} as T\n                for (const key of Object.keys(schema)) {\n                    const match = expr.properties.find(([k]) => k === key)\n                    result[key] = schema[key].parse(\n                        match?.[1], env,\n                        newExpr => doEdit({ ...expr, properties: newExpr === undefined\n                            ? expr.properties.filter(prop => prop[0] !== key)\n                            : match\n                                ? expr.properties.map(prop => prop === match ? [prop[0], newExpr] : prop)\n                                : [...expr.properties, [key as string, newExpr]] }))\n                }\n                return result\n            }\n            error('not an object literal', expr)\n        },\n    }\n}\n\nexport function optional<T>(schema: LiteralExprParser<T>): LiteralExprParser<T | undefined> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr === undefined) {\n                return undefined\n            }\n            return schema.parse(expr, env, doEdit)\n        },\n    }\n}\n\nexport function call<N extends Record<string, unknown>, U extends unknown[], F>(schema: {\n    namedArgs: { [K in keyof N]: LiteralExprParser<N[K]> }\n    unnamedArgs: { [I in keyof U]: LiteralExprParser<U[I]> }\n    fn: LiteralExprParser<F>\n}): LiteralExprParser<{ namedArgs: N, unnamedArgs: U, fn: F }> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr?.type === 'call') {\n                const fn = schema.fn.parse(expr.fn, env,\n                    (newExpr) => {\n                        assert(newExpr !== undefined, 'cannot remove just the callee')\n                        return doEdit({ ...expr, fn: newExpr })\n                    },\n                )\n                const namedResult = {} as N\n                for (const key of Object.keys(schema.namedArgs)) {\n                    const match = expr.args.find(arg => arg.type === 'named' && arg.name.node === key)\n                    namedResult[key] = schema.namedArgs[key].parse(match?.value, env,\n                        newExpr => doEdit({ ...expr, args: match\n                            ? newExpr === undefined ? expr.args.filter(prop => prop !== match) : expr.args.map(prop => prop === match ? { ...prop, value: newExpr } : prop)\n                            : newExpr === undefined ? expr.args : [...expr.args, { type: 'named', name: { node: key as string, location: noLocation }, value: newExpr }] }),\n                    )\n                }\n\n                const unnamedResult = [] as unknown as U\n                argSchemas: for (const [i, argSchema] of schema.unnamedArgs.entries()) {\n                    let j = 0\n                    for (const arg of expr.args) {\n                        if (arg.type === 'named') {\n                            continue\n                        }\n                        if (j === i) {\n                            unnamedResult[i] = argSchema.parse(arg.value, env,\n                                newExpr => doEdit({ ...expr, args: newExpr === undefined ? expr.args.filter(a => a !== arg) : expr.args.map(a => a === arg ? { ...a, value: newExpr } : a) }),\n                            )\n                            continue argSchemas\n                        }\n                        j++\n                    }\n                    error('not enough named args', expr)\n                }\n\n                return { namedArgs: namedResult, unnamedArgs: unnamedResult, fn }\n            }\n            error('not a call expression', expr)\n        },\n    }\n}\n\nexport function vector<T>(schema: LiteralExprParser<T>): LiteralExprParser<T[]> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            return editableVector(schema).parse(expr, env, doEdit).currentValue\n        },\n    }\n}\n\nexport function editableVector<T>(schema: LiteralExprParser<T>): LiteralExprParser<{\n    currentValue: T[]\n    edit: (edits: (oldAst: UrbanStatsASTExpression[]) => UrbanStatsASTExpression[]) => UrbanStatsASTExpression | UrbanStatsASTStatement\n}> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr?.type === 'vectorLiteral') {\n                return {\n                    currentValue: expr.elements.map(elem => schema.parse(elem, env,\n                        newExpr => doEdit({ ...expr, elements: newExpr === undefined ? expr.elements.filter(e => e !== elem) : expr.elements.map(e => e === elem ? newExpr : e) }),\n                    )),\n                    edit(edits) {\n                        return doEdit({\n                            ...expr,\n                            elements: edits(expr.elements),\n                        })!\n                    },\n                }\n            }\n            error('not a vector literal', expr)\n        },\n    }\n}\n\nexport function deconstruct<T>(schema: LiteralExprParser<T>): LiteralExprParser<T> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr?.type === 'identifier') {\n                const type = env.get(expr.name.node)\n                if (type?.documentation?.equivalentExpressions !== undefined && type.documentation.equivalentExpressions.length > 0) {\n                    for (const equivalentExpression of type.documentation.equivalentExpressions) {\n                        try {\n                            return schema.parse(equivalentExpression, env, doEdit)\n                        }\n                        catch {}\n                    }\n                }\n            }\n            return schema.parse(expr, env, doEdit)\n        },\n    }\n}\n\n/**\n * Enables selectively editing an AST (does a shallow copy)\n */\nexport function edit<T>(\n    schema: LiteralExprParser<T>,\n): LiteralExprParser<{\n        currentValue: T\n        edit: (newExpr: UrbanStatsASTExpression | undefined) => UrbanStatsASTExpression | UrbanStatsASTStatement | undefined\n        expr: UrbanStatsASTExpression | undefined\n    }> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            return {\n                currentValue: schema.parse(expr, env, doEdit),\n                edit: doEdit,\n                expr,\n            }\n        },\n    }\n}\n\n/**\n * Reparse the expr when editing\n */\nexport function reparse<T>(blockIdent: string, types: USSType[], schema: LiteralExprParser<T>): LiteralExprParser<T> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            return schema.parse(expr, env,\n                newExpr => doEdit(newExpr === undefined ? undefined : parseExpr(newExpr, blockIdent, types, env, () => { throw new Error('should not happen') }, true)),\n            )\n        },\n    }\n}\n\ninterface LiteralStmtParser<T> {\n    // Undefined is a non-existent expression, used for optionals\n    parse: (\n        stmt: UrbanStatsASTStatement | undefined,\n        typeEnvironment: TypeEnvironment,\n        doEdit?: (newStmt: UrbanStatsASTStatement) => UrbanStatsASTStatement\n    ) => T\n}\n\nexport function expression<T>(schema: LiteralExprParser<T>): LiteralStmtParser<T> {\n    return {\n        parse(stmt, env, doEdit = e => e) {\n            if (stmt?.type === 'expression') {\n                return schema.parse(stmt.value, env,\n                    newExpr => newExpr === undefined ? undefined : doEdit({ ...stmt, value: newExpr }),\n                )\n            }\n            error('not an expression', stmt)\n        },\n    }\n}\n\nfunction parseStatements<T extends unknown[]>(\n    schema: { [I in keyof T]: LiteralStmtParser<T[I]> },\n    stmts: UrbanStatsASTStatement[],\n    env: TypeEnvironment,\n    doEdit: (newStmt: UrbanStatsASTStatement[]) => UrbanStatsASTStatement,\n): T {\n    const result = [] as unknown as T\n    for (const [i, s] of schema.entries()) {\n        if (i >= stmts.length) {\n            error('not enough statements', stmts)\n        }\n        result[i] = s.parse(stmts[i], env,\n            newStmt => doEdit([...stmts.slice(0, i), newStmt, ...stmts.slice(i + 1)]),\n        )\n    }\n    return result\n}\n\nexport function statements<T extends unknown[]>(schema: { [I in keyof T]: LiteralStmtParser<T[I]> }): LiteralStmtParser<T> {\n    return {\n        parse(stmt, env, doEdit = e => e) {\n            if (stmt?.type === 'statements') {\n                return parseStatements(schema, stmt.result, env,\n                    newStmts => doEdit({ ...stmt, result: newStmts }),\n                )\n            }\n            error('not a statements list', stmt)\n        },\n    }\n}\n\nexport function ignore(): LiteralStmtParser<undefined> & LiteralExprParser<undefined> {\n    return {\n        parse() {\n            return undefined\n        },\n    }\n}\n\nexport function condition<C, R extends unknown[]>(schema: { condition: LiteralExprParser<C>, rest: { [I in keyof R]: LiteralStmtParser<R[I]> } }): LiteralStmtParser<{ condition: C, rest: R }> {\n    return {\n        parse(stmt, env, doEdit = e => e) {\n            if (stmt?.type === 'condition') {\n                return {\n                    condition: schema.condition.parse(stmt.condition, env,\n                        (newExpr) => {\n                            assert(newExpr !== undefined, 'cannot remove just the condition from a condition statement')\n                            return doEdit({ ...stmt, condition: newExpr })\n                        },\n                    ),\n                    rest: parseStatements(schema.rest, stmt.rest, env,\n                        newStmts => doEdit({ ...stmt, rest: newStmts }),\n                    ),\n                }\n            }\n            error('not a condition', stmt)\n        },\n    }\n}\nexport function transformExpr<T, U>(schema: LiteralExprParser<T>, map: (t: T) => U): LiteralExprParser<U> {\n    return {\n        parse(ast, env, doEdit = e => e) {\n            return map(schema.parse(ast, env, doEdit))\n        },\n    }\n}\n\nexport function transformStmt<T, U>(schema: LiteralStmtParser<T>, map: (t: T) => U): LiteralStmtParser<U> {\n    return {\n        parse(ast, env, doEdit = e => e) {\n            return map(schema.parse(ast, env, doEdit))\n        },\n    }\n}\n\nexport function customNodeExpr<T>(schema: LiteralExprParser<T>): LiteralExprParser<T> {\n    return {\n        parse(expr, env, doEdit = e => e) {\n            if (expr?.type === 'customNode' && expr.expr.type === 'expression') {\n                const expressionStatement = expr.expr\n                return schema.parse(expr.expr.value, env, newExpr => newExpr === undefined\n                    ? undefined\n                    : doEdit({\n                        ...expr,\n                        expr: {\n                            ...expressionStatement,\n                            value: newExpr,\n                        },\n                        originalCode: unparse(newExpr),\n                    }))\n            }\n            return schema.parse(expr, env, doEdit)\n        },\n    }\n}\n"],"names":["SelectionContext","createContext","Property","undefined","labelPadding","isCustomConstructor","possibility","typeEnvironment","_typeEnvironment_get_documentation","Selector","props","setSelection","selected","classifyExpr","selectionPossibilities","useMemo","allPossibilities","Set","type","typePossibilities","possibilities","Array","stableStringify","hasCustomConstructor","renderPossibility","useCallback","selection","renderSelection","_typeEnvironment_get","_doc_selectorRendering","_doc_selectorRendering1","_doc_humanReadableName","doc","highlighted","LongDescriptionSubtitle","ramp","RampSelectorOption","onEdit","customConstructorOption","isNumber","isString","showConstantInput","currentValue","errors","e","errorComponent","DisplayResults","colorValue","getColor","select","BetterSelector","NumberInput","TextInput","doRender","newUss","newColor","hexToColor","newColorUss","hsvColorExpression","rgbColorExpression","parseNoErrorAsCustomNode","parseNoErrorAsExpression","parseExpr","Error","param","blockIdent","setUss","value","emptyLocation","node","numberValue","parseNumber","uss","classifiedFn","assert","colorSchema","l","call","color","_call_namedArgs_a","_call_namedArgs_a1","rgbToColor","hsvToColor","expr","colors","useColors","firstRampColor","ColorLib","highlightedColor","colorThemes","selectionGradient","toCssGradient","pos","Math","selectionColor","direction","border","CustomEditor","placeholder","ourErrors","selectionContext","useContext","Editor","u","range","_selectionContext_value","createDefaultExpression","_iteratorError","_tdoc_documentation","name","tdoc","renderType","getDefaultVariable","getDefaultFunction","ArgumentEditor","_tdoc_documentation_namedArgs_props_name","arg","functionUss","argValue","a","hasDefault","isEnabled","subident","extendBlockIdKwarg","humanReadableName","CheckboxSettingCustom","checked","_deconstruct","defaultExpr","exprToUse","newArg","newArgs","newArgs1","AutoUXEditor","_subcomponent","subc","doesConsume","_props_label_length","_props_labelWidth","ussLoc","locationOf","console","labelWidth","_wrappedSubcomponent","subselectors","i","extendBlockIdPositionalArg","Object","_argWDefault_documentation","argWDefault","elementType","el","newEl","newElements","extendBlockIdVectorElement","_","j","propertiesTypes","DefaultMap","key","_uss_properties_find_","propertyType","k","extendBlockIdObjectProperty","newVal","v","wrapped","leftSegment","rightSegment","defaultForSelection","current","deconstructed","deconstruct","parsed","maybeParseExpr","unparse","twoLines","useMobileLayout","varType","previous","fn","compatiblePreviousArg","extractCompatiblePreviousArgs","foundType","targetType","_expr_args_filter_arg","_expr_args_find","args","_compatiblePreviousArg","arg1","prev","reference","_reference_documentation","equiv","valid","ConditionEditor","condition","setCondition","conditionIsCustom","currentCondition","PreambleEditor","preamble","setPreamble","_useState","showPreamble","setShowPreamble","useEffect","validMapperOutputs","rootBlockIdent","idPreamble","idCondition","idOutput","TopLevelEditor","attemptParseAsTopLevel","makeStatements","newConditionExpr","conditionStatement","stmt","preserveCustomNodes","stmts","_attemptParseCondition","conditionStmt","conditionText","conditionRest","conditionExpr","body","defaultTopLevelEditor","types","fallback","attemptParseExpr","elementTypes","t","elem","idx","exprProps","compatibleTypes","_attemptParseExpr","validVariableSelections","s","validFunctionSelections","fnType","positionals","nameds","names","needed","shouldShowConstant","target","env","results","renderedTypes","variables","functions","b","_env_get_documentation_priority","_env_get_documentation_priority1","aPriority","_results","_results1","computeUSS","mapSettings","toStatement","defaultSettings","addTo","_addTo_script_uss","_addTo_universe","_addTo_geographyKind","_addTo_universe1","defaultTypeEnvironment","elements","identFallback","locations","unify","mapperMetaFields","z","valid_geographies","universes_ordered","mapSettingsFromURLParam","encodedSettings","settings","jsonedSettings","gunzipSync","Buffer","rawSettings","JSON","parse","error","longMessage","convertToMapUss","message","childErrors","string","boolean","transformExpr","union","identifier","schemas","doEdit","schema","number","object","result","match","newExpr","prop","optional","namedResult","noLocation","unnamedResult","_iteratorError1","argSchemas","argSchema","_iteratorError2","vector","editableVector","edit","edits","_type_documentation","equivalentExpression","reparse","expression","parseStatements","newStmt","statements","newStmts","ignore","map","ast","transformStmt","customNodeExpr","expressionStatement"],"mappings":"mJAWaA,EAAmBC,AAAAA,GAAAA,EAAAA,aAAAA,AAAAA,EAAc,IAAIC,EAAAA,CAAQA,CAAwBC,Q,4vBCU3E,IAAMC,EAAe,MAE5B,SAASC,EAAoBC,CAAsB,CAAEC,CAAgC,E,IACvCC,EAAAA,EAA1C,MAAOF,AAAqB,aAArBA,EAAY,IAAI,EAAmBE,OAAAA,CAAAA,EAAAA,EAAgB,GAAG,CAACF,EAAY,IAAI,IAApCE,MAAAA,CAAAA,EAAAA,EAAuC,aAAa,AAAD,EAAnDA,KAAAA,EAAAA,EAAsD,iBAAiB,IAAK,EAC1H,CAEO,SAASC,EAASC,CAQxB,EACG,IAAQC,EAAkCD,EAAlCC,YAAY,CAAEJ,EAAoBG,EAApBH,eAAe,CAC/BK,EAAWC,EAAaH,EAAM,GAAG,EAEjCI,EAAyBC,AAAAA,GAAAA,EAAAA,OAAAA,AAAAA,EAAQ,WAEnC,IAAMC,EAAmB,IAAIC,IAM7B,OALAP,EAAM,IAAI,CAAC,OAAO,CAAC,SAACQ,CAAI,EAEpBC,AAD0BC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAc,CAACF,EAAK,CAAER,EAAM,eAAe,EACnD,OAAO,CAACJ,SAAAA,CAAW,E,OAAIU,EAAiB,GAAG,CAACV,E,EAClE,GAEOe,MAAM,IAAI,CAACL,EAEtB,EAAG,CAACM,IAAgBZ,EAAM,IAAI,EAAGA,EAAM,eAAe,CAAC,EAEjDa,EAAuBR,AAAAA,GAAAA,EAAAA,OAAAA,AAAAA,EAAQ,WACjC,OAAOD,EAAuB,IAAI,CAACR,SAAAA,CAAW,E,OAAID,EAAoBC,EAAaI,EAAM,eAAe,C,IAAM,CAACL,EAAoBO,EAAUF,EAAM,eAAe,CACtK,EAAG,CAACI,EAAwBJ,EAAM,eAAe,CAAEE,EAAS,EAEtDY,EAAoBC,AAAAA,GAAAA,EAAAA,WAAAA,AAAAA,EAAY,SAACC,CAAS,E,OAAgBC,AA4J7D,SAAyBpB,CAAgC,CAAEmB,CAAoB,EAClF,GAAIA,AAAmB,WAAnBA,EAAU,IAAI,CACd,MAAO,CAAE,KAAM,mBAAoB,EAEvC,GAAIA,AAAmB,aAAnBA,EAAU,IAAI,CACd,MAAO,CAAE,KAAM,UAAW,EAE9B,GAAIA,AAAmB,WAAnBA,EAAU,IAAI,CACd,MAAO,CAAE,KAAM,aAAc,EAEjC,GAAIA,AAAmB,WAAnBA,EAAU,IAAI,CACd,MAAO,CAAE,KAAM,YAAa,EAEhC,IAAYE,EACRC,EAMAC,EAQeC,EAfbC,EAAM,MAAAJ,CAAAA,EAAAA,EAAgB,GAAG,CAACF,EAAU,IAAI,GAAlCE,KAAAA,EAAAA,EAAqC,aAAa,CAC9D,GAAIC,OAAAA,GAAAA,MAAAA,CAAAA,EAAAA,EAAK,iBAAiB,AAAD,EAArBA,KAAAA,EAAAA,EAAwB,IAAI,IAAK,0BACjC,MAAO,CACH,KAAMG,EAAI,iBAAiB,CAC3B,KAAMC,SAAAA,CAAW,E,OAAI,gBAACC,EAAAA,CAAwB,IAAKF,EAAK,YAAaC,C,GACzE,EAEJ,GAAIH,OAAAA,GAAAA,MAAAA,CAAAA,EAAAA,EAAK,iBAAiB,AAAD,EAArBA,KAAAA,EAAAA,EAAwB,IAAI,IAAK,qBAQjC,MAAO,CAAE,KAAMC,MAAAA,CAAAA,EAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAK,iBAAiB,AAAD,EAArBA,EAA0BL,EAAU,IAAI,AAAC,EAPxD,IAAMS,EAAOH,EAAI,iBAAiB,CAAC,IAAI,CACvC,MAAO,CACH,KAAMA,EAAI,iBAAiB,CAC3B,KAAMC,SAAAA,CAAW,E,OAAI,gBAACG,EAAAA,CAAmB,KAAMJ,EAAI,iBAAiB,CAAE,KAAMG,EAAM,YAAaF,C,GACnG,CAKR,EA1LoFvB,EAAM,eAAe,CAAEgB,E,EAAY,CAAChB,EAAM,eAAe,CAAC,EAEpI2B,EAASZ,AAAAA,GAAAA,EAAAA,WAAAA,AAAAA,EAAY,WACvB,IAAMa,EAA0BxB,EAAuB,IAAI,CAACR,SAAAA,CAAW,E,OAAID,EAAoBC,EAAaC,E,EACxG+B,CAAAA,GACA3B,EAAa2B,EAErB,EAAG,CAACxB,EAAwBP,EAAiBI,EAAa,EAE1D,IAAIG,CAAAA,EAAuB,MAAM,CAAG,IAIpC,IAAMyB,EAAW7B,EAAM,IAAI,CAAC,IAAI,CAACQ,SAAAA,CAAI,E,MAAIA,AAAc,WAAdA,EAAK,IAAI,A,GAC5CsB,EAAW9B,EAAM,IAAI,CAAC,IAAI,CAACQ,SAAAA,CAAI,E,MAAIA,AAAc,WAAdA,EAAK,IAAI,A,GAC5CuB,EAAoB7B,AAAkB,aAAlBA,EAAS,IAAI,EAAoB2B,CAAAA,GAAYC,CAAO,EACxEE,EAAehC,AAAmB,aAAnBA,EAAM,GAAG,CAAC,IAAI,CAAkBA,EAAM,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAK,GACvFiC,EAASjC,EAAM,MAAM,CAAC,MAAM,CAACkC,SAAAA,CAAC,E,MAAIA,AAAgC,WAAhCA,EAAE,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAiBA,EAAE,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,GAAKlC,EAAM,UAAU,A,GAC/HmC,EAAiB,gBAACC,EAAAA,EAAcA,CAAAA,CAAC,QAASH,EAAQ,OAAQ,E,GAE1DI,EAAarC,EAAM,IAAI,CAAC,IAAI,CAACQ,SAAAA,CAAI,E,MAAIA,AAAc,WAAdA,EAAK,IAAI,EAAiBA,AAAc,UAAdA,EAAK,IAAI,A,GAAgB8B,EAAStC,EAAM,GAAG,CAAEA,EAAM,eAAe,EAAIP,OAErI8C,EACF,gBAAC,OAAI,MAAO,CAAE,SAAU,WAAY,QAAS,OAAQ,WAAY,SAAU,IAAK,OAAQ,C,EACpF,gBAACC,EAAAA,CAAcA,CAAAA,CACX,MAAOtC,EACP,eAAgBE,EAChB,YAAaU,EACb,SAAUd,EAAM,YAAY,CAC5B,OAAQa,EAAuBc,EAASlC,M,GAE3CsC,GACGF,CAAAA,EAAW,gBAACY,EAAAA,EAAAA,CAAY,aAAcT,C,EAAkBhC,IAAY,gBAAC0C,EAAAA,EAAAA,CAAU,aAAcV,C,EAAkBhC,GAAAA,EAElHqC,AAAe5C,SAAf4C,GACG,gBAAC,SACG,KAAK,QACL,MAAOM,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAASN,EAAW,KAAK,CAAE,IAClC,MAAO,CAAE,MAAO,QAAS,OAAQ,QAAS,EAC1C,SAAU,SAACH,CAAC,EACR,IAEIU,EAFEC,EAAWC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWZ,EAAE,MAAM,CAAC,KAAK,EACpCa,EAAcV,AAAoB,QAApBA,EAAW,IAAI,CAAaW,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAmBH,EAAU,CAAE,WAAYR,EAAW,KAAK,CAAC,CAAC,AAAC,GAAKY,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAmBJ,EAAU,CAAE,WAAYR,EAAW,KAAK,CAAC,CAAC,AAAC,GAEjL,OAAQrC,EAAM,GAAG,CAAC,IAAI,EAClB,IAAK,aACD4C,EAASM,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EACLH,EACA/C,EAAM,UAAU,CAChBA,EAAM,IAAI,EAEd,KACJ,KAAK,aACL,IAAK,OACD4C,EAASO,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EACLJ,EACA/C,EAAM,UAAU,CAE5B,CACeP,SAAXmD,IACAA,EAASQ,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EACLR,EACA5C,EAAM,UAAU,CAChBA,EAAM,IAAI,CACVA,EAAM,eAAe,CACrB,WAAQ,MAAM,AAAIqD,MAAM,oBAAqB,EAC7C,IAEJrD,EAAM,MAAM,CAAC4C,GAErB,C,IAKhB,OACI,gBAAC,OAAI,MAAO,CAAE,QAAS,OAAQ,cAAe,SAAU,IAAK,OAAQ,C,EAChEL,EACAJ,GAGb,CAEA,SAASO,EAAUY,CAAgI,E,IAA9HtB,EAAFsB,EAAEtB,YAAY,CAAEuB,EAAhBD,EAAgBC,UAAU,CAAEC,EAA5BF,EAA4BE,MAAM,CACjD,OACI,gBAAC,YACG,MAAOxB,EACP,SAAU,SAACE,CAAC,EAERsB,EAAO,CACH,KAAM,WACN,MAAO,CACH,KAAM,CAAE,KAAM,SAAUC,MAJlBvB,EAAE,MAAM,CAAC,KAAK,AAIU,EAC9B,SAAUwB,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAC5B,CACJ,EACJ,EACA,MAAO,CAAE,MAAO,QAAS,SAAU,OAAQ,QAAS,UAAW,OAAQ,UAAW,EAClF,YAAY,c,EAGxB,CAEA,SAASd,EAAYa,CAAgI,E,IAA9HtB,EAAFsB,EAAEtB,YAAY,CAAEuB,EAAhBD,EAAgBC,UAAU,CAAEC,EAA5BF,EAA4BE,MAAM,CACnD,OACI,gBAAC,SACG,KAAK,OACL,MAAOxB,EACP,SAAU,SAACE,CAAC,EACR,IACIyB,EACAC,EAFEH,EAAQvB,EAAE,MAAM,CAAC,KAAK,CAgB5BsB,EAPwC,CACpC,KAAM,WACN,MAAO,CACHG,IAAI,CATPC,AAAsCnE,SAAtCmE,CAAAA,EAAcC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAYJ,EAAK,EACzB,CAAE,KAAM,SAAU,MAAOG,CAAY,EAGrC,CAAE,KAAM,SAAUH,MAAAA,CAAM,EAM3B,SAAUC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAC5B,CACJ,EAEJ,EACA,MAAO,CAAE,MAAO,QAAS,SAAU,OAAQ,QAAS,UAAW,OAAQ,MAAO,EAC9E,YAAY,c,EAGxB,CAEO,SAASpD,EAAa2D,CAA4B,EACrD,GAAIA,AAAa,eAAbA,EAAI,IAAI,CACR,MAAO,CAAE,KAAM,QAAS,EAE5B,GAAIA,AAAa,aAAbA,EAAI,IAAI,CACR,MAAO,CAAE,KAAM,UAAW,EAE9B,GAAIA,AAAa,eAAbA,EAAI,IAAI,CACR,MAAO,CAAE,KAAM,WAAY,KAAMA,EAAI,IAAI,CAAC,IAAI,AAAC,EAEnD,GAAIA,AAAa,SAAbA,EAAI,IAAI,CAAa,CACrB,IAAMC,EAAe5D,EAAa2D,EAAI,EAAE,EAExC,MADAE,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAOD,AAAsB,aAAtBA,EAAa,IAAI,CAAiB,mDAClC,CAAE,KAAM,WAAY,KAAMA,EAAa,IAAI,AAAC,CACvD,CACA,GAAID,AAAa,kBAAbA,EAAI,IAAI,CACR,MAAO,CAAE,KAAM,QAAS,EAE5B,GAAIA,AAAa,kBAAbA,EAAI,IAAI,CACR,MAAO,CAAE,KAAM,QAAS,CAE5B,OAAM,AAAIT,MAAO,oCAA4C,OAATS,EAAI,IAAI,EAChE,CAkCO,IAAMG,EAAcC,EAAAA,EAAe,CAACA,EAAAA,EAAgB,CAACA,EAAAA,EAAa,CAACA,EAAAA,EAAM,CAAC,CAC7E,GAAIA,EAAAA,EAAO,CAAC,CAACA,EAAAA,EAAY,CAAC,OAAQA,EAAAA,EAAY,CAAC,OAAO,EACtD,YAAa,CAACA,EAAAA,EAAQ,GAAIA,EAAAA,EAAQ,GAAIA,EAAAA,EAAQ,GAAG,CACjD,UAAW,CAAE,EAAGA,EAAAA,EAAU,CAACA,EAAAA,EAAQ,GAAI,CAC3C,KAAM,SAACC,CAAI,MACHC,EAGsFC,EAGAC,EAL1F,OAAQH,EAAK,EAAE,EACX,IAAK,MACDC,EAAQG,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWJ,EAAK,WAAW,CAAC,EAAE,CAAEA,EAAK,WAAW,CAAC,EAAE,CAAEA,EAAK,WAAW,CAAC,EAAE,CAAEE,MAAAA,CAAAA,EAAAA,EAAK,SAAS,CAAC,CAAC,AAAD,EAAfA,EAAoB,EAAG,IACzG,KACJ,KAAK,MACDD,EAAQI,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWL,EAAK,WAAW,CAAC,EAAE,CAAEA,EAAK,WAAW,CAAC,EAAE,CAAEA,EAAK,WAAW,CAAC,EAAE,CAAEG,MAAAA,CAAAA,EAAAA,EAAK,SAAS,CAAC,CAAC,AAAD,EAAfA,EAAoB,EAAG,GAEjH,CACA,GAAIF,AAAU3E,SAAV2E,EAGJ,MAAO,CAAEA,MAAAA,EAAO,KAAMD,EAAK,EAAE,AAAC,CAClC,GAEO,SAAS7B,EAASmC,CAA6B,CAAE5E,CAAgC,EACpF,GAAI,CACA,OAAOoE,EAAY,KAAK,CAACQ,EAAM5E,EACnC,CACA,QAAM,CACF,MACJ,CACJ,CAEA,SAAS2B,EAAwBxB,CAAmD,EAChF,IAAM0E,EAASC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,IACf,OACI,gBAAC,OAAI,MAAO,CACR,QAAS,WACT,WAAY3E,EAAM,WAAW,CAAG0E,EAAO,kCAAkC,CAAGA,EAAO,2BAA2B,AAClH,C,EAEI,gBAAC,WAAK1E,EAAM,GAAG,CAAC,iBAAiB,EACjC,gBAAC,OAAI,MAAO,CAAE,SAAU,UAAW,MAAO0E,EAAO,gBAAgB,AAAC,C,EAC7D1E,EAAM,GAAG,CAAC,eAAe,EAI1C,CAEA,SAAS0B,EAAmB1B,CAA0D,EAClF,IAAM0E,EAASC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,IACTC,EAAiBC,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAS7E,EAAM,IAAI,CAAC,EAAE,CAAC,EAAE,EAC1C8E,EAAoB,YAAqD,OAA1CJ,EAAO,kCAAkC,CAAC,eAC/E,OACI,gBAAC,OAAI,MAAO,CACR,QAAS,WACT,MAAOK,EAAAA,CAAW,CAACH,EAAe,OAAO,GAAK,aAAe,YAAY,CAAC,QAAQ,CAClF,WAAY5E,EAAM,WAAW,CAAI,GAAoDgF,MAAAA,CAAlDA,EAAkBF,EAAkB,UAAU,MAAqDG,MAAAA,CAAjDD,EAAkBF,EAAkB,SAAS,MAA8B,OAA1BG,EAAcjF,EAAM,IAAI,GAAMiF,EAAcjF,EAAM,IAAI,CAChM,C,EAEKA,EAAM,IAAI,CAGvB,CAEA,SAASiF,EAAcxD,CAAW,EAC9B,MAAQ,6BAAwG,OAA5EA,EAAK,GAAG,CAAC,Y,m0BAAEyD,EAAAA,CAAAA,CAAAA,EAAAA,CAAKd,EAAAA,CAAAA,CAAAA,EAAAA,C,MAAY,GAAWe,MAAAA,CAATf,EAAM,KAAyB,OAAtBe,KAAK,KAAK,CAACD,AAAM,IAANA,GAAW,I,GAAI,IAAI,CAAC,MAAM,IACpH,CAEA,SAASF,EAAkBI,CAAsB,CAAEC,CAAiB,EAEhE,MAAQ,sBAAmCD,MAAAA,CAAdC,EAAU,MAAsBC,MAAAA,CAAlBF,EAAe,KAA0BE,MAAAA,CADpE,MACoD,kBAAmDA,MAAAA,CADvG,MAC2E,8BAAwCF,MAAAA,CADnH,MAC8G,OAAmCE,MAAAA,CAA9BF,EAAe,iBAAsB,OADxJ,MACwJ,KAC5K,C,gRC7SO,SAASG,EAAajC,CAc5B,E,IAbGQ,EADyBR,EACzBQ,GAAG,CACHN,EAFyBF,EAEzBE,MAAM,CACN3D,EAHyByD,EAGzBzD,eAAe,CACfoC,EAJyBqB,EAIzBrB,MAAM,CACNsB,EALyBD,EAKzBC,UAAU,CACViC,EANyBlC,EAMzBkC,WAAW,CASLC,EAAYpF,AAAAA,GAAAA,EAAAA,OAAAA,AAAAA,EAAQ,W,OAAM4B,EAAO,MAAM,CAAC,SAACC,CAAC,E,MAAiBA,AAAgC,WAAhCA,EAAE,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAiBA,EAAE,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,GAAKqB,C,IAAa,CAACtB,EAAQsB,EAAW,EAEzKmC,EAAmBC,AAAAA,GAAAA,EAAAA,UAAAA,AAAAA,EAAWrG,EAAAA,CAAgBA,EAC9C0B,EAAY0E,EAAiB,GAAG,GAEtC,OACI,gBAACE,EAAAA,EAAMA,CAAAA,CACH,IAAK9B,EAAI,YAAY,CACrB,OAAQ,SAAC+B,CAAC,EAENrC,EADeN,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyB2C,EAAGtC,EAAYO,EAAI,YAAY,EAE3E,EACA,gBAAiBjE,EACjB,QAAS4F,EACT,YAAaD,EACb,UAAWxE,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAW,UAAU,AAAD,IAAMuC,EAAavC,EAAU,KAAK,CAAG,KACpE,aAAc,SAAC8E,CAAK,E,IAIPC,CAHLD,AAAU,QAAVA,EACAJ,EAAiB,KAAK,CAAG,CAAEnC,WAAAA,EAAYuC,MAAAA,CAAM,EAExCC,AAAAA,OAAAA,CAAAA,EAAAA,EAAiB,KAAK,AAAD,EAArBA,KAAAA,EAAAA,EAAwB,UAAU,AAAD,IAAMxC,GAC5CmC,CAAAA,EAAiB,KAAK,CAAGjG,MAAQ,CAEzC,C,EAGZ,C,imEChCA,SAASuG,EAAwBxF,CAAa,CAAE+C,CAAkB,CAAE1D,CAAgC,EAChG,GAAIW,AAAc,WAAdA,EAAK,IAAI,CACT,MAAO,CAAE,KAAM,WAAY,MAAO,CAAE,KAAM,CAAE,KAAM,SAAU,MAAO,CAAE,EAAG,SAAUkD,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAAY,CAAE,EAElH,GAAI/C,AAAc,WAAdA,EAAK,IAAI,CACT,MAAO,CAAE,KAAM,WAAY,MAAO,CAAE,KAAM,CAAE,KAAM,SAAU,MAAO,EAAG,EAAG,SAAUkD,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAAY,CAAE,E,IAE9G0C,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAL,QAAKA,EAAAA,EAAsBpG,CAAe,CAAfA,OAAAA,QAAAA,CAAAA,GAAtBoG,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,GAAuC,CAAvCA,IACIC,EADJD,EAAAA,EAAAA,EAAAA,KAAAA,CAAAA,GAAOE,EAAAA,CAAAA,CAAAA,EAAAA,CAAMC,EAAAA,CAAAA,CAAAA,EAAAA,CACd,GAAI,MAACF,CAAAA,EAAAA,EAAK,aAAa,AAAD,EAAjBA,KAAAA,EAAAA,EAAoB,SAAS,EAGlC,GAAIG,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWD,EAAK,IAAI,IAAMC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAW7F,GACrC,OAAO8F,EAAmB,CAAE,KAAM,WAAYH,KAAAA,CAAK,EAAGtG,EAAiB0D,GAE3E,GAAI6C,AAAmB,aAAnBA,EAAK,IAAI,CAAC,IAAI,EAAmBA,AAA8B,uBAA9BA,EAAK,IAAI,CAAC,UAAU,CAAC,IAAI,EAA6BC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWD,EAAK,IAAI,CAAC,UAAU,CAAC,KAAK,IAAMC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAW7F,GAC7I,OAAO+F,EAAmB,CAAE,KAAM,WAAYJ,KAAAA,CAAK,EAAGtG,EAAiB0D,GAE/E,C,UAVK0C,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,QAWL,AAAIzF,AAAc,WAAdA,EAAK,IAAI,CACF,CACH,KAAM,gBACN,UAAWkD,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,GACzB,SAAU,EAAE,AAChB,EAEGL,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyB,GAAIK,EAAY,CAAC/C,EAAK,CAC1D,CAEA,SAASgG,EAAexG,CAQvB,EACG,IAW0ByG,EAAAA,EAAAA,EAXpBC,EAAM1G,EAAM,WAAW,CAAC,IAAI,CAClCgE,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAO0C,AAAa,aAAbA,EAAI,IAAI,CAAkB,kBAA4B,OAAX1G,EAAM,IAAI,CAAC,sBAE7D,IAAM2G,EAAc3G,EAAM,GAAG,CACvB4G,EAAWD,EAAY,IAAI,CAAC,IAAI,CAACE,SAAAA,CAAC,E,MAAIA,AAAW,UAAXA,EAAE,IAAI,EAAgBA,EAAE,IAAI,CAAC,IAAI,GAAK7G,EAAM,IAAI,A,GACtF8G,EAAa9G,AAAmCP,SAAnCO,EAAM,WAAW,CAAC,YAAY,CAC3C+G,EAAYH,AAAanH,SAAbmH,EACZI,EAAWC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAmBjH,EAAM,UAAU,CAAEA,EAAM,IAAI,EAG1DoG,EAAOpG,EAAM,eAAe,CAAC,GAAG,CAAC2G,EAAY,EAAE,CAAC,IAAI,CAAC,IAAI,EACzDO,EAAoBT,MAAAA,CAAAA,QAAAA,GAAAA,MAAAA,CAAAA,EAAAA,EAAM,aAAa,AAAD,GAAlBA,MAAAA,CAAAA,EAAAA,EAAqB,SAAS,AAAD,EAA7BA,KAAAA,EAAAA,CAAgC,CAACzG,EAAM,IAAI,CAAC,AAAD,EAA3CyG,EAAgDzG,EAAM,IAAI,CAEpF,OACI,gBAAC,OAAI,MAAO,CAAE,QAAS,OAAQ,WAAY,aAAc,IAAK,SAAU,MAAO,OAAQ,OAAQ,UAAW,C,EACtG,gBAAC,OAAI,MAAO,CAAE,KAAM,CAAE,C,EAClB,gBAAC,WACI8G,EAEW,gBAACK,EAAAA,EAAqBA,CAAAA,CAClB,KAAMD,EACN,QAASH,EACT,SAAU,SAACK,CAAO,EACd,GAAIA,EAAS,CACT,IAIYC,EAJNC,EAActH,EAAM,WAAW,CAAC,YAAY,CAC9CuH,EAAYD,AAAgB7H,SAAhB6H,GAA8BA,AAAqB,eAArBA,EAAY,IAAI,EAAqBA,AAA0B,SAA1BA,EAAY,IAAI,CAAC,IAAI,CAClGtB,EAAwBU,EAAI,KAAK,CAAEM,EAAUhH,EAAM,eAAe,EAClEsH,EACNC,EAAYF,MAAAA,CAAAA,EAAAA,EAAYE,EAAWvH,EAAM,eAAe,CAAEgH,EAAUN,EAAI,KAAK,GAAjEW,EAAsEjE,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAUmE,EAAWP,EAAU,CAACN,EAAI,KAAK,CAAC,CAAE1G,EAAM,eAAe,CAAE,WACjJ,MAAM,AAAIqD,MAAM,oBACpB,EAAG,IAEH,IAAMmE,EAAS,CACX,KAAM,QACN,KAAM,CAAE,KAAMxH,EAAM,IAAI,CAAE,SAAU0D,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcsD,EAAU,EAC5D,MAAOO,CACX,EACME,EAAW,EAAGd,EAAY,IAAI,SAApB,CAAsBa,EAAO,EAC7CxH,EAAM,MAAM,CAAC,OAAK2G,GAAAA,CAAa,KAAMc,C,GACzC,KACK,CAED,IAAMC,EAAUf,EAAY,IAAI,CAAC,MAAM,CAACE,SAAAA,CAAC,E,MAAMA,AAAW,UAAXA,EAAE,IAAI,EAAgBA,EAAE,IAAI,CAAC,IAAI,GAAK7G,EAAM,IAAG,A,GAC9FA,EAAM,MAAM,CAAC,OAAK2G,GAAAA,CAAa,KAAMe,C,GACzC,CACJ,C,GAGV,gBAAC,YAAMR,IAGhBH,GAEG,gBAACY,EAAAA,CACG,IAAKf,EAAS,KAAK,CACnB,OAAQ,SAAChE,CAAM,EACX,IAAM6E,EAAUd,EAAY,IAAI,CAAC,GAAG,CAACE,SAAAA,CAAC,E,MAAIA,AAAW,UAAXA,EAAE,IAAI,EAAgBA,EAAE,IAAI,CAAC,IAAI,GAAK7G,EAAM,IAAI,CAAG,OAAK6G,GAAAA,CAAG,MAAOjE,C,GAAWiE,C,GACvH7G,EAAM,MAAM,CAAC,OAAK2G,GAAAA,CAAa,KAAMc,C,GACzC,EACA,gBAAiBzH,EAAM,eAAe,CACtC,OAAQA,EAAM,MAAM,CACpB,WAAYgH,EACZ,KAAM,CAACN,EAAI,KAAK,CAAC,A,IAMzC,CAEO,SAASiB,EAAa3H,CAS5B,EACG,IAmKgC4H,EAArBC,EAAMC,EA6CsBC,EAzMpBC,EAyMoBD,EAhNjCE,EAASC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWlI,EAAM,GAAG,EAAE,KAAK,CACtCiI,CAAAA,AAAsB,WAAtBA,EAAO,KAAK,CAAC,IAAI,EAAiBA,EAAO,KAAK,CAAC,KAAK,GAAKjI,EAAM,UAAU,AAAD,IACxEmI,EAAQ,IAAI,CAAC,QAASnI,EAAM,GAAG,EAC/BmI,EAAQ,IAAI,CAAC,iBAAkBF,GAC/BE,EAAQ,IAAI,CAAC,sBAAuBnI,EAAM,UAAU,EACpDmI,EAAQ,KAAK,CAAC,qEAAsEnI,EAAM,GAAG,CAAEiI,AAAsB,WAAtBA,EAAO,KAAK,CAAC,IAAI,CAAgBA,EAAO,KAAK,CAAC,KAAK,CAAG,UAAWjI,EAAM,UAAU,GAEpL,IAAMoI,EAAaJ,MAAAA,CAAAA,EAAAA,EAAM,UAAU,AAAD,EAAfA,EAAoB,KA6KRK,EAAAA,GAjBpBR,EAAqBD,CAAAA,EAAAA,EAAAA,AA3JX,WACjB,GAAI5H,AAAmB,aAAnBA,EAAM,GAAG,CAAC,IAAI,CACd,MAAO,CAACP,OAAW,0BAA0B,CAEjD,IAAMqE,EAAM9D,EAAM,GAAG,CACrB,GAAI8D,AAAa,eAAbA,EAAI,IAAI,CAWR,MAAO,CATH,gBAACyB,EAAYA,CACT,IAAI,SACJ,IAAKzB,EACL,OAAQ9D,EAAM,MAAM,CACpB,gBAAiBA,EAAM,eAAe,CACtC,OAAQA,EAAM,MAAM,CACpB,WAAYA,EAAM,UAAU,A,GAGpB,kBAAkB,CAEtC,GAAI8D,AAAa,eAAbA,EAAI,IAAI,CACR,MAAO,CAACrE,OAAW,0BAA0B,CAEjD,GAAIqE,AAAa,SAAbA,EAAI,IAAI,CAAa,CACrBE,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAOF,AAAgB,eAAhBA,EAAI,EAAE,CAAC,IAAI,CAAmB,kCACrC,IAAMsC,EAAOpG,EAAM,eAAe,CAAC,GAAG,CAAC8D,EAAI,EAAE,CAAC,IAAI,CAAC,IAAI,EACvDE,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAOoC,AAAS3G,SAAT2G,EAAqB,YAA4B,OAAjBtC,EAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,mCACxD,IAAMtD,EAAO4F,EAAK,IAAI,CACtBpC,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAOxD,AAAc,aAAdA,EAAK,IAAI,CAAkB,YAA4B,OAAjBsD,EAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,6BAC9D,IAAMwE,EAA4B,EAAE,CAqCpC,OApCA9H,EAAK,OAAO,CAAC,OAAO,CAAC,SAACkG,CAAG,CAAE6B,CAAC,EACxBvE,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAO0C,AAAa,aAAbA,EAAI,IAAI,CAAkB,wCACjC4B,EAAa,IAAI,CACb,gBAACX,EAAAA,CACG,IAAM,OAAQ,OAAFY,GACZ,IAAKzE,EAAI,IAAI,CAACyE,EAAE,CAAC,KAAK,CACtB,OAAQ,SAAC3F,CAAM,EACX,IAAM6E,EAAW,EAAG3D,EAAI,IAAI,CAC5B2D,CAAAA,CAAO,CAACc,EAAE,CAAG,OAAKd,CAAO,CAACc,EAAE,GAAE,MAAO3F,C,GACrC5C,EAAM,MAAM,CAAC,OAAK8D,GAAAA,CAAK,KAAM2D,C,GACjC,EACA,gBAAiBzH,EAAM,eAAe,CACtC,OAAQA,EAAM,MAAM,CACpB,WAAYwI,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAA2BxI,EAAM,UAAU,CAAEuI,GACzD,KAAM,CAAC7B,EAAI,KAAK,CAAC,A,GAG7B,GACA+B,OAAO,OAAO,CAACjI,EAAK,SAAS,EAAE,OAAO,CAAC,Y,IAC/BkI,E,SADiCvC,EAAAA,CAAAA,CAAAA,EAAAA,CAAMwC,EAAAA,CAAAA,CAAAA,EAAAA,AACvCD,CAAAA,OAAAA,CAAAA,EAAAA,EAAY,aAAa,AAAD,EAAxBA,KAAAA,EAAAA,EAA2B,IAAI,AAAD,IAAM,IACpCJ,EAAa,IAAI,CACb,gBAAC9B,EAAAA,CACG,IAAM,SAAa,OAALL,GACd,KAAMA,EACN,YAAawC,EAEb,IAAK7E,EACL,OAAQ9D,EAAM,MAAM,CACpB,gBAAiBA,EAAM,eAAe,CACtC,OAAQA,EAAM,MAAM,CACpB,WAAYA,EAAM,UAAU,A,GAI5C,GAEO,CADS,yBAAC,M,CAAI,IAAI,c,EAAsC,CAA/C,OAAwB,EAAIsI,KAC3B,0BAA0B,AAC/C,CACA,GAAIxE,AAAa,kBAAbA,EAAI,IAAI,CAAsB,CAE9B,IAAI8E,EAAuB,CAAE,KAAM,QAAS,EAmD5C,MAlDI5I,AAAuB,WAAvBA,EAAM,IAAI,CAAC,EAAE,CAAC,IAAI,EAElB4I,CAAAA,EAAc5I,EAAM,IAAI,CAAC,EAAE,CAAC,WAAW,AAAD,EAgDnC,CA7CH,gBAAC,OAAI,MAAO,CAAE,QAAS,OAAQ,cAAe,SAAU,IAAK,QAAS,MAAO,MAAO,C,EAC/E8D,EAAI,QAAQ,CAAC,GAAG,CAAC,SAAC+E,CAAE,CAAEN,CAAC,E,OACpB,gBAAC,OAAI,IAAKA,EAAG,MAAO,CAAE,QAAS,OAAQ,WAAY,SAAU,IAAK,QAAS,MAAO,MAAO,C,EACrF,gBAACZ,EAAAA,CACG,IAAKkB,EACL,OAAQ,SAACC,CAAK,EACV,IAAMC,EAAe,EAAGjF,EAAI,QAAQ,CACpCiF,CAAAA,CAAW,CAACR,EAAE,CAAGO,EACjB9I,EAAM,MAAM,CAAC,OAAK8D,GAAAA,CAAK,SAAUiF,C,GACrC,EACA,gBAAiB/I,EAAM,eAAe,CACtC,OAAQA,EAAM,MAAM,CACpB,WAAYgJ,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAA2BhJ,EAAM,UAAU,CAAEuI,GACzD,KAAM,CAACK,EAAY,CACnB,MAAQ,GAAQ,OAANL,EAAI,E,GAElB,gBAAC,UACG,MAAO,CAAE,WAAY,CAAE,EACvB,QAAS,WACL,IAAMQ,EAAcjF,EAAI,QAAQ,CAAC,MAAM,CAAC,SAACmF,CAAC,CAAEC,CAAC,E,OAAKA,IAAMX,C,GACxDvI,EAAM,MAAM,CAAC,OAAK8D,GAAAA,CAAK,SAAUiF,C,GACrC,EACA,MAAM,gB,EACT,K,GAKT,gBAAC,UACG,MAAO,CAAE,UAAW,aAAc,UAAW,CAAE,EAC/C,QAAS,WACL,IAAMA,EACF,EAAGjF,EAAI,QAAQ,SADC,CAGhBA,EAAI,QAAQ,CAAC,MAAM,CAAG,EAChBA,EAAI,QAAQ,CAACA,EAAI,QAAQ,CAAC,MAAM,CAAG,EAAE,CACrCkC,EAAwB4C,EAAaI,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAA2BhJ,EAAM,UAAU,CAAE8D,EAAI,QAAQ,CAAC,MAAM,EAAG9D,EAAM,eAAe,EACtI,EACDA,EAAM,MAAM,CAAC,OAAK8D,GAAAA,CAAK,SAAUiF,C,GACrC,C,EACH,kBAKQ,0BAA0B,AAC/C,CACA,GAAIjF,AAAa,kBAAbA,EAAI,IAAI,CAAsB,CAE9B,IAAIqF,EAAwC,IAAIC,EAAAA,CAAUA,CAAC,W,MAAO,CAAE,KAAM,QAAS,C,GA0BnF,MAzBIpJ,AAAuB,WAAvBA,EAAM,IAAI,CAAC,EAAE,CAAC,IAAI,EAElBmJ,CAAAA,EAAkBnJ,EAAM,IAAI,CAAC,EAAE,CAAC,UAAU,AAAD,EAuBtC,CApBH,gBAAC,OAAI,MAAO,CAAE,QAAS,OAAQ,cAAe,SAAU,IAAK,QAAS,MAAO,MAAO,C,EAC/EW,MAAM,IAAI,CAACwI,EAAgB,IAAI,IAAI,IAAI,GAAG,GAAG,CAAC,SAACE,CAAG,EAC/C,IAIaC,EAAAA,EAJPC,EAAeJ,EAAgB,GAAG,CAACE,GACzC,OACI,gBAAC1B,EAAAA,CACG,IAAK0B,EACL,IAAKC,MAAAA,CAAAA,EAAAA,MAAAA,CAAAA,EAAAA,EAAI,UAAU,CAAC,IAAI,CAAC,Y,OAASE,AAAPA,A,MAAAA,CAAAA,EAAAA,GAAaH,C,IAAnCC,KAAAA,EAAAA,CAAyC,CAAC,EAAE,AAAD,EAA3CA,EAAgDtD,EAAwBuD,EAAcE,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAA4BzJ,EAAM,UAAU,CAAEqJ,GAAMrJ,EAAM,eAAe,EACpK,OAAQ,SAAC0J,CAAM,EACX1J,EAAM,MAAM,CAAC,OAAK8D,GAAAA,CAAK,WAAYA,EAAI,UAAU,CAAC,GAAG,CAAC,Y,aAAE0F,EAAAA,CAAAA,CAAAA,EAAAA,CAAGG,EAAAA,CAAAA,CAAAA,EAAAA,C,MAAO,CAACH,EAAGA,IAAMH,EAAMK,EAASC,EAAE,A,KACjG,EACA,gBAAiB3J,EAAM,eAAe,CACtC,OAAQA,EAAM,MAAM,CACpB,WAAYyJ,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAA4BzJ,EAAM,UAAU,CAAEqJ,GAC1D,KAAM,CAACE,EAAa,CACpB,MAAOF,C,EAGnB,IAGS,0BAA0B,AAC/C,CACA,MAAM,AAAIhG,MAAO,oCAAkD,OAAfrD,EAAM,GAAG,CAAC,IAAI,EACtE,IAGgC4H,GAAAA,CAAAA,EAAAA,CAAfE,EAAeF,CAAAA,CAAAA,EAAAA,CAC5B,AAAIC,AAASpI,SAAToI,EACO,CAACpI,OAAWqI,EAAY,CAY5B,CATH,gBAAC,OAAI,MAAO,CAAE,MAAO,OAAQ,KAAM,CAAE,C,EACjC,gBAAC,OAAI,MAAO,CAAE,QAAS,OAAQ,IAAK,MAAO,WAAYM,CAAW,C,EAC7DpI,EAAM,KAAK,EAAI,gBAAC,QAAK,MAAO,CAAE,SAAU,aAAc,C,GACvD,gBAAC,OAAI,MAAO,CAAE,KAAM,CAAE,C,EACjB6H,KAKAC,EAAY,EAGFO,GAAxBuB,EAAwBvB,CAAAA,CAAAA,EAAAA,CAAfP,EAAeO,CAAAA,CAAAA,EAAAA,CAEzBwB,EAAc7J,AAAgBP,SAAhBO,EAAM,KAAK,CACzBP,OAEM,gBAAC,OAAI,MAAO,CAAE,QAAU,GAAe,OAAbC,EAAAA,EAAYA,CAAC,QAAO,QAAS,OAAQ,eAAgB,UAAW,C,EACtF,gBAAC,QAAK,MAAO,CAAE,SAAU,cAAe,YAAa,KAAM,C,EAAIM,EAAM,KAAK,GAGpF8J,EAAepJ,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcV,EAAM,IAAI,CAAEA,EAAM,eAAe,EAAE,MAAM,CAAG,EACzEP,OAEM,gBAAC,OAAI,MAAO,CAAE,MAAQ,eAAyB,OAAX2I,EAAW,IAAG,C,EAC9C,gBAACrI,EAAAA,EAAQA,CAAAA,CACL,IAAKC,EAAM,GAAG,CACd,aAAc,SAACgB,CAAS,EACpBhB,EAAM,MAAM,CAAC+J,AA2JzC,SACI/I,CAAoB,CACpBgJ,CAAgC,CAChCnK,CAAgC,CAChC0D,CAAkB,CAClB/C,CAAa,EAEb,IAAMyJ,EAAgBC,EAAYF,EAASnK,EAAiB0D,EAAY/C,EAAMQ,GAC9E,GAAIiJ,AAAkBxK,SAAlBwK,EACA,OAAOA,EAGX,IAAME,EAASC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAeJ,EAASzG,EAAY/C,EAAMX,GACzD,GAAIsK,AAAW1K,SAAX0K,GAAwBvJ,IAAgBT,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAagK,MAAavJ,IAAgBI,GAClF,OAAOmJ,EAGX,OAAQnJ,EAAU,IAAI,EAClB,IAAK,SACD,MAAOkC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyBmH,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAQL,GAAUzG,EAAY,CAAC/C,EAAK,CACxE,KAAK,WACD,OAAOwF,EAAwBxF,EAAM+C,EAAY1D,EACrD,KAAK,WACD,OAAOyG,EAAmBtF,EAA+CnB,EAAiB0D,EAC9F,KAAK,WACD,OAAOgD,EAAmBvF,EAA+CnB,EAAiB0D,EAAYyG,EAC1G,KAAK,SAED,MAAO,CACH,KAAM,gBACN,UAAWtG,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,GACzB,SAAU,EAAE,AAChB,CAEJ,KAAK,SACD,MAAO,CACH,KAAM,gBACN,UAAWG,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,GACzB,WAAY,EAAE,AAClB,CACR,CACJ,EApM6DvC,EAAWhB,EAAM,GAAG,CAAEA,EAAM,eAAe,CAAEA,EAAM,UAAU,CAAEA,EAAM,IAAI,CAAC,EAAE,EACjH,EACA,OAAQA,EAAM,MAAM,CACpB,gBAAiBA,EAAM,eAAe,CACtC,KAAMA,EAAM,IAAI,CAChB,WAAYA,EAAM,UAAU,CAC5B,OAAQ8H,AAAgB,oBAAhBA,EAAoC,EAAE,CAAG9H,EAAM,MAAM,A,IAM3EsK,EAAWC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,KAAsBxC,AAAAA,OAAAA,CAAAA,EAAAA,MAAAA,CAAAA,EAAAA,EAAM,KAAK,AAAD,EAAVA,KAAAA,EAAAA,EAAa,MAAM,AAAD,EAAlBA,EAAuB,GAAK,EA4BnE,OACI,gBAAC,OAAI,MAAO,CAAE,QAAS,OAAQ,cAAe,SAAU,MAAO,OAAQ,KAAM,EAAG,OAAQ,WAAY,IAAK,QAAS,EAAG,GAAK,kBAAkC,OAAjB/H,EAAM,UAAU,C,EACtJ6J,AAAgBpK,SAAhBoK,GAA6BC,AAAiBrK,SAAjBqK,EAA6B,gBAAC,OAAI,MAAO,CAAE,MAAO,OAAQ,KAAM,CAAE,C,EA3BpG,AAAIQ,EAEI,gCACI,gBAAC,OAAI,MAAO,CAAE,QAAS,OAAQ,WAAY,KAAM,C,EAC5CT,GAEL,gBAAC,OAAI,MAAO,CAAE,QAAS,OAAQ,WAAY,KAAM,C,EAC7C,gBAAC,OAAI,MAAO,CAAE,MAAOzB,CAAW,C,GAC/B0B,IAOT,gBAAC,OAAI,MAAO,CAAE,QAAS,OAAQ,WAAY,KAAM,C,EAC7C,gBAAC,OAAI,MAAO,CAAE,MAAO1B,CAAW,C,EAC3ByB,GAEJC,IAQgHrK,OACxHmK,EAGb,CAEA,SAAStD,EAAmBtF,CAA2C,CAAEnB,CAAgC,CAAE0D,CAAkB,EACzH,IAAgBrC,EAAVsJ,EAAU,MAAAtJ,CAAAA,EAAAA,EAAgB,GAAG,CAACF,EAAU,IAAI,GAAlCE,KAAAA,EAAAA,EAAqC,IAAI,CAEzD,MADA8C,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAOwG,AAAY/K,SAAZ+K,EAAwB,YAA0B,OAAfxJ,EAAU,IAAI,CAAC,mCAClD,CAAE,KAAM,aAAc,KAAM,CAAE,KAAMA,EAAU,IAAI,CAAE,SAAU0C,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAAY,CAAE,CACrG,CAsBA,SAASgD,EAAmBvF,CAA2C,CAAEnB,CAAgC,CAAE0D,CAAkB,CAAEkH,CAAkC,EAC7J,IAAMC,EAAK7K,EAAgB,GAAG,CAACmB,EAAU,IAAI,EAC7CgD,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAO0G,AAAOjL,SAAPiL,GAAoBA,AAAiB,aAAjBA,EAAG,IAAI,CAAC,IAAI,CAAkB,YAA0B,OAAf1J,EAAU,IAAI,CAAC,iCAInF,IAAK,IAHC2J,EAAwBF,EAAWG,AApB7C,SAAuCnG,CAA6B,CAAE5E,CAAgC,EAClG,IAAIW,EACJ,GAAIiE,AAAc,SAAdA,EAAK,IAAI,EAAeA,AAAiB,eAAjBA,EAAK,EAAE,CAAC,IAAI,EAAsBjE,CAAAA,EAAOX,EAAgB,GAAG,CAAC4E,EAAK,EAAE,CAAC,IAAI,CAAC,IAAI,IAAMjE,AAAmB,aAAnBA,EAAK,IAAI,CAAC,IAAI,CAAiB,CAC3I,IAAMqK,EAA6BrK,EAAK,IAAI,CAC5C,OAAO,SAACkG,CAAG,CAAEoE,CAAU,MAERC,EAGAC,QAJX,AAAI,AAAe,UAAf,OAAOtE,GAAoBA,EAAMmE,EAAU,OAAO,CAAC,MAAM,EAAIA,AAAgC,aAAhCA,EAAU,OAAO,CAACnE,EAAI,CAAC,IAAI,EAAmBL,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWyE,KAAgBzE,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWwE,EAAU,OAAO,CAACnE,EAAI,CAAC,KAAK,EACtK,MAAAqE,CAAAA,EAAAA,EAAK,IAAI,CAAC,MAAM,CAAClE,SAAAA,CAAC,E,MAAIA,AAAW,YAAXA,EAAE,IAAI,A,EAAe,CAACH,EAAI,AAAD,EAA/CqE,KAAAA,EAAAA,EAAkD,KAAK,CAE9D,AAAe,UAAf,OAAOrE,GAAoBA,KAAOmE,EAAU,SAAS,EAAIA,AAAuC,aAAvCA,EAAU,SAAS,CAACnE,EAAI,CAAC,IAAI,CAAC,IAAI,EAAmBL,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWyE,KAAgBzE,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWwE,EAAU,SAAS,CAACnE,EAAI,CAAC,IAAI,CAAC,KAAK,EAChL,MAAAsE,CAAAA,EAAAA,EAAK,IAAI,CAAC,IAAI,CAACnE,SAAAA,CAAC,E,MAAIA,AAAW,UAAXA,EAAE,IAAI,EAAgBA,EAAE,IAAI,CAAC,IAAI,GAAKH,C,IAA1DsE,KAAAA,EAAAA,EAAgE,KAAK,OAGpF,CACJ,CACA,OAAO,W,CACX,EAK2EP,EAAU5K,GAAmBJ,OAC9FwL,EAA2B,EAAE,CAE1B1C,EAAI,EAAGA,EAAImC,EAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAEnC,IAAK,CAC7C,IAIW2C,EAJLxE,EAAMgE,EAAG,IAAI,CAAC,OAAO,CAACnC,EAAE,CAC9BvE,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAO0C,AAAa,aAAbA,EAAI,IAAI,CAAkB,wCACjCuE,EAAK,IAAI,CAAC,CACN,KAAM,UACN,MAAOC,MAAAA,CAAAA,EAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAwB3C,EAAG7B,EAAI,KAAK,GAApCwE,EAAyClF,EAAwBU,EAAI,KAAK,CAAE8B,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAA2BjF,EAAYgF,GAAI1I,EAClI,EACJ,CAVA,IAWKoG,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAL,QAAKA,EAAAA,EAA6BwC,OAAO,OAAO,CAACiC,EAAG,IAAI,CAAC,SAAS,CAAC,CAAD,mBAA7DzE,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,GAAgE,CAAhEA,IAAAA,EAAAA,EAAAA,EAAAA,KAAAA,CAAAA,GAAOE,EAAAA,CAAAA,CAAAA,EAAAA,CAAMwC,EAAAA,CAAAA,CAAAA,EAAAA,CACRwC,EAAMxC,EAAY,IAAI,CAC5B3E,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAOmH,AAAa,aAAbA,EAAI,IAAI,CAAkB,kBAAsB,OAALhF,EAAK,sBACvD,IAAMiF,EAAOT,MAAAA,EAAAA,KAAAA,EAAAA,EAAwBxE,EAAMgF,EAAI,KAAK,CAChDC,CAAAA,CAAAA,GAAQzC,AAA6BlJ,SAA7BkJ,EAAY,YAAY,AAAa,GAC7CsC,EAAK,IAAI,CAAC,CACN,KAAM,QACN,KAAM,CAAE,KAAM9E,EAAM,SAAUzC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAAY,EACxD,MAAO6H,MAAAA,EAAAA,EAAQpF,EAAwBmF,EAAI,KAAK,CAAElE,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAmB1D,EAAY4C,GAAOtG,EAC5F,EAER,C,UAXKoG,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EAYL,MAAO,CACH,KAAM,OACN,GAAI,CAAE,KAAM,aAAc,KAAM,CAAE,KAAMjF,EAAU,IAAI,CAAE,SAAU0C,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAAY,CAAE,EAC9F0H,KAAAA,EACA,UAAWvH,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAC7B,CACJ,CAEA,SAAS2G,EAAYzF,CAA6B,CAAE5E,CAAgC,CAAE0D,CAAkB,CAAE/C,CAAa,CAAEQ,CAAqB,EAC1I,OAAQyD,EAAK,IAAI,EACb,IAAK,aACD,IAAM4G,EAAYxL,EAAgB,GAAG,CAAC4E,EAAK,IAAI,CAAC,IAAI,EAEpD,GAAkBhF,SAAd4L,GAIAC,AAAAA,OAAAA,CAAAA,EAAAA,EAAU,aAAa,AAAD,EAAtBA,KAAAA,EAAAA,EAAyB,qBAAqB,AAAD,IAAM7L,OAHnD,O,IAOCwG,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAL,QAJIqF,EAICrF,EAAAA,EAAeoF,EAAU,aAAa,CAAC,qBAAqB,oBAA5DpF,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,GAA8D,CAA9DA,IAAMsF,EAANtF,EAAAA,KAAAA,CACKuF,EAAQpB,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAemB,EAAOhI,EAAY/C,EAAMX,GACtD,GAAI2L,AAAU/L,SAAV+L,GAAwBxK,CAAAA,AAAcvB,SAAduB,GAA2BJ,IAAgBT,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAaqL,MAAY5K,IAAgBI,EAAS,EACrH,OAAOwK,CAEf,C,UALKvF,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EAOL,MAEJ,KAAK,aACD,GAAIxB,AAAmB,eAAnBA,EAAK,IAAI,CAAC,IAAI,CACd,OAAOyF,EAAYzF,EAAK,IAAI,CAAC,KAAK,CAAE5E,EAAiB0D,EAAY/C,EAAMQ,GAE3E,MACJ,KAAK,OACD,GAAIR,AAAc,WAAdA,EAAK,IAAI,EAAiBA,AAAc,UAAdA,EAAK,IAAI,EAAgBQ,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAW,IAAI,AAAD,IAAM,WAAY,CAEnF,IAAMoD,EAAQ9B,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAASmC,EAAM5E,GAC7B,OAAQ,IACJ,IAAKuE,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAO,IAAI,AAAD,IAAM,OAASpD,AAAmB,QAAnBA,EAAU,IAAI,CAExC,MAAOmC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyBH,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAmBoB,EAAM,KAAK,EAAGb,EACrE,KAAKa,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAO,IAAI,AAAD,IAAM,OAASpD,AAAmB,QAAnBA,EAAU,IAAI,CAExC,MAAOmC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyBF,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAmBmB,EAAM,KAAK,EAAGb,EACzE,CACJ,CACA,MAEJ,SACI,MACR,CACJ,CC1dO,SAASkI,EAAgBnI,CAY/B,E,IAXGoI,EAD4BpI,EAC5BoI,SAAS,CACTC,EAF4BrI,EAE5BqI,YAAY,CACZ9L,EAH4ByD,EAG5BzD,eAAe,CACfoC,EAJ4BqB,EAI5BrB,MAAM,CACNsB,EAL4BD,EAK5BC,UAAU,CAQJqI,EAAoBF,AAAmB,eAAnBA,EAAU,IAAI,CAExC,OACI,gBAAC,OAAI,MAAO,CAAE,OAAQ,SAAU,C,EAC5B,gBAACvE,EAAAA,EAAqBA,CAAAA,CAClB,KAAK,UACL,QAASyE,EACT,SAAU,SAACxE,CAAO,EACd,GAAIA,EAAS,CAET,IAAMyE,EAAmBxB,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAQqB,IAAc,OAE/CC,EADsBzI,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyB2I,EAAkBtI,EAAY,CAAC,CAAE,KAAM,SAAU,YAAa,CAAE,KAAM,SAAU,CAAE,EAAE,EAEvI,MAIIoI,EADsB,CAAE,KAAM,aAAc,KAAM,CAAE,KAAM,OAAQ,SAAUjI,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAAY,CAAE,EAGhH,C,GAEHqI,GACG,gBAACrG,EAAYA,CACT,IAAKmG,EACL,OAAQC,EACR,gBAAiB9L,EACjB,OAAQoC,EACR,WAAYsB,C,GAKhC,C,sGC9CO,SAASuI,EAAexI,CAY9B,E,MAXGyI,EAD2BzI,EAC3ByI,QAAQ,CACRC,EAF2B1I,EAE3B0I,WAAW,CACXnM,EAH2ByD,EAG3BzD,eAAe,CACfoC,EAJ2BqB,EAI3BrB,MAAM,CACNsB,EAL2BD,EAK3BC,UAAU,CAQ8B0I,G,EAAAA,AAAAA,GAAAA,EAAAA,QAAAA,AAAAA,EAASF,AAAiC,KAAjCA,EAAS,YAAY,CAAC,IAAI,I,mWAAO,I,qDAAA,G,8OAAA,I,6KAA3EG,EAAiCD,CAAAA,CAAAA,EAAAA,CAAnBE,EAAmBF,CAAAA,CAAAA,EAAAA,CAMxC,MAJAG,AAAAA,GAAAA,EAAAA,SAAAA,AAAAA,EAAU,WACND,EAAgBJ,AAAiC,KAAjCA,EAAS,YAAY,CAAC,IAAI,GAC9C,EAAG,CAACA,EAAS,YAAY,CAAC,EAGtB,gBAAC,OAAI,MAAO,CAAE,OAAQ,SAAU,C,EAC5B,gBAAC5E,EAAAA,EAAqBA,CAAAA,CAClB,KAAK,WACL,QAAS+E,EACT,SAAU,SAAC9E,CAAO,EAGd4E,EADqB9I,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyB,GAAIK,IAElD4I,EAAgB/E,EACpB,C,GAEH8E,GACG,gBAAC3G,EAAYA,CACT,IAAKwG,EACL,OAAQC,EACR,gBAAiBnM,EACjB,OAAQoC,EACR,WAAYsB,EACZ,YAAY,uD,GAKhC,C,eC9Ba8I,EAAqB,CAJrB,CAAE,KAAM,SAAU,KAAM,OAAQ,sBAAuB,EAAM,EAC1D,CAAE,KAAM,SAAU,KAAM,UAAW,sBAAuB,EAAM,EACnE,CAAE,KAAM,SAAU,KAAM,OAAQ,sBAAuB,EAAM,EAEnB,CAE1CC,EAAiB,IACxBC,EAAc,GAAiB,OAAfD,EAAe,KAC/BE,EAAe,GAAiB,OAAfF,EAAe,KACzBG,EAAY,GAAiB,OAAfH,EAAe,KAYnC,SAASI,EAAepJ,CAU9B,E,IATGQ,EAD2BR,EAC3BQ,GAAG,CACHN,EAF2BF,EAE3BE,MAAM,CACN3D,EAH2ByD,EAG3BzD,eAAe,CACfoC,EAJ2BqB,EAI3BrB,MAAM,CAyEN,OACI,gBAAC,WACG,gBAAC,OAAI,MAAO,CAAE,OAAQ,WAAY,C,GAClC,gBAACkF,EAAAA,EAAqBA,CAAAA,CAClB,KAAK,uBACL,QAASrD,AAAa,eAAbA,EAAI,IAAI,CACjB,SAAU,SAACsD,CAAO,EACVA,GACApD,IAAOF,AAAa,eAAbA,EAAI,IAAI,CAAmB,wDAClCN,EAAON,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyBmH,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAQvG,EAAK,CAAE,SAAU,EAAK,GAAIwI,MAGlEtI,IAAOF,AAAa,eAAbA,EAAI,IAAI,CAAmB,iDAClCN,EAAOmJ,EAAuB7I,EAAI,IAAI,CAAEjE,EAAiB,KAEjE,C,GAhFR,AAAIiE,AAAa,eAAbA,EAAI,IAAI,CAEJ,gBAACyB,EAAYA,CACT,IAAKzB,EACL,OAAQN,EACR,gBAAiB3D,EACjB,OAAQoC,EACR,WAAYqK,C,GAMpB,gBAAC,WAEG,gBAACR,EAAcA,CACX,SAAUhI,EAAI,MAAM,CAAC,EAAE,CAAC,KAAK,CAC7B,YAAa,SAAC+B,CAAC,EAKXrC,EAAOoJ,AAAAA,GAAAA,EAAAA,cAAAA,AAAAA,EAAe,CAJL,CACb,KAAM,aACN,MAAO/G,CACX,EACiC/B,EAAI,MAAM,CAAC,EAAE,CAAC,EACnD,EACA,gBAAiBjE,EACjB,OAAQoC,EACR,WAAYsK,C,GAGhB,gBAACd,EAAeA,CACZ,UAAW3H,EAAI,MAAM,CAAC,EAAE,CAAC,SAAS,CAClC,aAAc,SAAC+I,CAAgB,EAC3B,IAAMC,EAAqB,CACvB,KAAM,YACN,UAAW5E,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAW2E,GACtB,UAAWA,EACX,KAAM/I,EAAI,MAAM,CAAC,EAAE,CAAC,IAAI,AAC5B,EACAN,EAAOoJ,AAAAA,GAAAA,EAAAA,cAAAA,AAAAA,EAAe,CAAC9I,EAAI,MAAM,CAAC,EAAE,CAAEgJ,EAAmB,EAC7D,EACA,gBAAiBjN,EACjB,OAAQoC,EACR,WAAYuK,C,GAGhB,gBAAC7E,EAAYA,CACT,IAAK7D,EAAI,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAChC,OAAQ,SAAC+B,CAAC,EACN,IAAM6F,EAAY,CACd,KAAM,YACN,UAAW5H,EAAI,MAAM,CAAC,EAAE,CAAC,SAAS,CAClC,UAAWA,EAAI,MAAM,CAAC,EAAE,CAAC,SAAS,CAClC,KAAM,CAAC,CAAE,KAAM,aAAc,MAAO+B,CAAE,EAAE,AAC5C,EACArC,EAAOoJ,AAAAA,GAAAA,EAAAA,cAAAA,AAAAA,EAAe,CAAC9I,EAAI,MAAM,CAAC,EAAE,CAAE4H,EAAU,EACpD,EACA,gBAAiB7L,EACjB,OAAQoC,EACR,WAAYwK,EACZ,KAAMJ,EACN,WAAW,K,IAuBnB,gBAACjK,EAAAA,EAAcA,CAAAA,CACX,OAAQ,GACR,QAASH,EAAO,MAAM,CAACC,SAAAA,CAAC,E,MAAIA,AAAgC,UAAhCA,EAAE,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,A,KAIvE,CAEO,SAASyK,EAAuBI,CAAqC,CAAElN,CAAgC,CAAEmN,CAA4B,EAIxI,GAAID,AAAc,eAAdA,EAAK,IAAI,CACT,OAAOA,EAEX,IAAME,EAAQF,AAAc,eAAdA,EAAK,IAAI,CAAoBA,EAAK,MAAM,CAAG,CAACA,EAAK,CACzDhB,EAAW,CACb,KAAM,aACN,OAAQkB,EAAM,KAAK,CAAC,EAAG,IACvB,UAAW/E,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAW6E,EAC1B,EAEyCG,EAAAA,AAkB7C,SAA+BC,CAAiD,EAC5E,IAAIF,EAAQE,AAAkB1N,SAAlB0N,EAA8B,CAACA,EAAc,CAAG,EAAE,CAC9D,GAAIA,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAe,IAAI,AAAD,IAAM,YAAa,CACrC,IAAMC,EAAgB/C,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAQ8C,EAAc,SAAS,CAAE,CAAE,SAAU,EAAK,GACxE,GAAIC,AAAyB,SAAzBA,EAAc,IAAI,GAClB,MAAO,CACH,cAAelK,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyBkK,EAAeZ,EAAa,CAAC,CAAE,KAAM,SAAU,YAAa,CAAE,KAAM,SAAU,CAAE,EAAE,EAC1H,cAAeW,EAAc,IAAI,AACrC,EAEJF,EAAQE,EAAc,IAAI,AAC9B,CACA,MAAO,CACH,cAAe,CAAE,KAAM,aAAc,KAAM,CAAE,KAAM,OAAQ,SAAUzJ,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAc8I,EAAa,CAAE,EAClG,cAAeS,CACnB,CACJ,EAnC0BA,EAAM,MAAM,CAAG,EAAIA,CAAK,CAACA,EAAM,MAAM,CAAG,EAAE,CAAGxN,QAC3D4N,EAAiCH,EAAjCG,aAAa,CAAEC,EAAkBJ,EAAlBI,aAAa,CAC9BC,EAAOnK,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAUwJ,AAAAA,GAAAA,EAAAA,cAAAA,AAAAA,EAAeS,EAAeZ,GAAWA,EAAUJ,EAAoBxM,EAAiBqD,EAAAA,EAAwBA,CAAE8J,GACnItB,EAAY,CACd,KAAM,YACN,UAAWxD,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWoF,GACtB,UAAWA,EACX,KAAM,CAAC,CAAE,KAAM,aAAc,MAAOC,CAAK,EAAE,AAC/C,EACA,MAAO,CACH,KAAM,aACN,OAAQ,CACJ,CAAE,KAAM,aAAc,MAAOrK,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyBmH,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAQ0B,EAAU,CAAE,SAAU,EAAK,GAAIQ,EAAY,EACzGb,EACH,CACD,UAAWxD,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAW6E,EAC1B,CACJ,CAoBO,SAASS,IAEZ,MAAO/I,AADMvB,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyB,kEAAmEoJ,EAAgBD,GAC7G,IAAI,AACpB,C,o5CC9LO,SAASjC,EACZ3F,CAAsD,CACtDlB,CAAkB,CAClB/C,CAAa,CACbX,CAAgC,EAEhC,GAAI,CACA,OAAOuD,EAAUqB,EAAMlB,EAAY,CAAC/C,EAAK,CAAEX,EAAiB,WACxD,MAAM,AAAIwD,MAAM,iBACpB,EAAG,GACP,CACA,QAAM,CAAC,CAEX,CAIO,SAASD,EACZqB,CAAsD,CACtDlB,CAAkB,CAClBkK,CAAgB,CAChB5N,CAAgC,CAChC6N,CAAkB,CAClBV,CAA4B,EAE5B,IAAM7C,EAASwD,AAInB,SAASA,EACLlJ,CAAsD,CACtDlB,CAAkB,CAClBkK,CAAgB,CAChB5N,CAAgC,CAChC6N,CAAkB,CAClBV,CAA4B,EAE5B,OAAQvI,EAAK,IAAI,EACb,IAAK,YACL,IAAK,iBACL,IAAK,KACL,IAAK,aACL,IAAK,aACL,IAAK,YACD,MACJ,KAAK,gBACD,IAAMmJ,EAAeH,EAChB,MAAM,CAACI,SAAAA,CAAC,E,MAAIA,AAAW,WAAXA,EAAE,IAAI,A,GAClB,GAAG,CAACA,SAAAA,CAAC,E,OAAIA,EAAE,WAAW,A,GACtB,MAAM,CAACA,SAAAA,CAAC,E,MAAIA,AAAW,yBAAXA,EAAE,IAAI,A,GACvB,GAAID,AAAwB,IAAxBA,EAAa,MAAM,CACnB,OAEJ,MAAO,CACH,KAAM,gBACN,UAAWlK,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,GACzB,SAAUkB,EAAK,QAAQ,CAAC,GAAG,CAAC,SAACqJ,CAAI,CAAEC,CAAG,E,OAAK3K,EAAU0K,EAAM9E,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAA2BzF,EAAYwK,GAAMH,EAAc/N,EAAiB6N,EAAUV,E,EACrJ,CACJ,KAAK,gBACD,IAAMgB,EAAY,IAAIzN,IAAIkE,EAAK,UAAU,CAAC,GAAG,CAAC,Y,OAAE4E,A,MAAAA,CAAAA,EAAAA,A,IAC1C4E,EAAkBR,EAAM,MAAM,CAChC,SAACI,CAAC,UACiB,WAAXA,EAAE,IAAI,EAGNA,EAAE,UAAU,CAAC,IAAI,GAAKpJ,EAAK,UAAU,CAAC,MAAM,EAG5C9D,MAAM,IAAI,CAACkN,EAAE,UAAU,CAAC,IAAI,IAAI,IAAI,CAACxE,SAAAA,CAAG,E,MAAI,CAAC2E,EAAU,GAAG,CAAC3E,E,GAInE,GAEJ,GAAI4E,AAA2B,IAA3BA,EAAgB,MAAM,CACtB,OAEJ,MAAO,CACH,KAAM,gBACN,UAAWvK,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,GACzB,WAAYkB,EAAK,UAAU,CAAC,GAAG,CAAC,Y,aAAE4E,EAAAA,CAAAA,CAAAA,EAAAA,C,MAAgB,CAC9CA,EACAjG,EAFmCK,CAAAA,CAAAA,EAAAA,CAElBgG,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAA4BlG,EAAY8F,GAAM4E,EAAgB,GAAG,CAACJ,SAAAA,CAAC,E,OAAIA,EAAE,UAAU,CAAC,GAAG,CAACxE,E,GAA4BxJ,EAAiB6N,EAAUV,GACnK,A,EACL,CACJ,KAAK,KACD,IACOkB,EADDjB,EAAQ,CAAE,KAAM,aAAc,OAAQxI,EAAK,UAAU,CAAE,UAAWA,EAAK,SAAS,AAAC,EACvF,OAAOyJ,MAAAA,CAAAA,EAAAA,EAAiBjB,EAAO1J,EAAYkK,EAAO5N,EAAiB6N,EAAUV,EAAmB,EAAzFkB,EAA8FR,EAASrD,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAQ4C,GAAQ1J,EAAYkK,EAC9I,KAAK,aACD,GAAIT,EACA,MAAO9J,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyBmH,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAQ5F,EAAM,CAAE,SAAU,EAAK,GAAIlB,EAAYkK,GAG/E,OAAOrK,EAAUqB,EAAK,IAAI,CAAElB,EAAYkK,EAAO5N,EAAiB6N,EAAUV,EAElF,KAAK,aACD,GAAIvI,AAAuB,IAAvBA,EAAK,MAAM,CAAC,MAAM,CAClB,OAAOrB,EAAUqB,EAAK,MAAM,CAAC,EAAE,CAAElB,EAAYkK,EAAO5N,EAAiB6N,EAAUV,GAEnF,MACJ,KAAK,aACD,OAAO5J,EAAUqB,EAAK,KAAK,CAAElB,EAAYkK,EAAO5N,EAAiB6N,EAAUV,EAC/E,KAAK,aAED,GAAImB,AAD4BzN,EAAc+M,EAAO5N,GAAiB,MAAM,CAACuO,SAAAA,CAAC,E,MAAIA,AAAW,aAAXA,EAAE,IAAI,A,GAC5D,IAAI,CAACA,SAAAA,CAAC,E,OAAIA,EAAE,IAAI,GAAK3J,EAAK,IAAI,CAAC,IAAI,A,GAC3D,MAAO,CAAE,KAAM,aAAc,KAAM,CAAE,KAAMA,EAAK,IAAI,CAAC,IAAI,CAAE,SAAUf,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAAY,CAAE,EAErG,MACJ,KAAK,WACD,GAAIkK,EAAM,IAAI,CAACjN,SAAAA,CAAI,E,OAAIA,EAAK,IAAI,GAAKiE,EAAK,KAAK,CAAC,IAAI,CAAC,IAAI,A,GACrD,MAAO,CAAE,KAAM,WAAY,MAAO,CAAE,KAAMA,EAAK,KAAK,CAAC,IAAI,CAAE,SAAUf,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAAY,CAAE,EAErG,MACJ,KAAK,gBACD,GAAIkB,AAAuB,MAAvBA,EAAK,QAAQ,CAAC,IAAI,EAAYA,AAAmB,aAAnBA,EAAK,IAAI,CAAC,IAAI,EAAmBA,AAA8B,WAA9BA,EAAK,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAiBgJ,EAAM,IAAI,CAACjN,SAAAA,CAAI,E,MAAIA,AAAc,WAAdA,EAAK,IAAI,A,GACrI,MAAO,CACH,KAAM,WACN,MAAO,CAAE,SAAUkD,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,GAAa,KAAM,CAAE,KAAM,SAAU,MAAO,CAAEkB,EAAK,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,AAAE,CAAE,CACjH,EAEJ,MACJ,KAAK,OACD,IAAMiG,EAAKjG,EAAK,EAAE,CAClB,GAAgB,eAAZiG,EAAG,IAAI,EAIP,CAAC2D,AAD2B3N,EAAc+M,EAAO5N,GAAiB,MAAM,CAACuO,SAAAA,CAAC,E,MAAIA,AAAW,aAAXA,EAAE,IAAI,A,GAC3D,IAAI,CAACA,SAAAA,CAAC,E,OAAIA,EAAE,IAAI,GAAK1D,EAAG,IAAI,CAAC,IAAI,A,GAH1D,OAMJ,IAAMtE,EAAOvG,EAAgB,GAAG,CAAC6K,EAAG,IAAI,CAAC,IAAI,EAC7C,GAAI,CAACtE,GAAQA,AAAmB,aAAnBA,EAAK,IAAI,CAAC,IAAI,CACvB,OAEJ,IAAMkI,EAASlI,EAAK,IAAI,CACpBmI,EAAc9J,EAAK,IAAI,CAAC,MAAM,CAACoC,SAAAA,CAAC,E,MAAIA,AAAW,YAAXA,EAAE,IAAI,A,GAC9C,GAAI0H,EAAY,MAAM,GAAKD,EAAO,OAAO,CAAC,MAAM,CAC5C,OAEJ,IAAIE,EAAS/J,EAAK,IAAI,CAAC,MAAM,CAACoC,SAAAA,CAAC,E,MAAIA,AAAW,UAAXA,EAAE,IAAI,A,GACnC4H,EAAQ,IAAIlO,IAAIiO,EAAO,GAAG,CAAC3H,SAAAA,CAAC,E,OAAIA,EAAE,IAAI,CAAC,IAAI,A,IAEjD,GAAI6H,AADWjG,OAAO,OAAO,CAAC6F,EAAO,SAAS,EAAE,MAAM,CAAC,Y,OAAWzH,AAAmBpH,SAAnBoH,AAAPA,A,MAAAA,CAAAA,EAAAA,CAAS,YAAY,A,GACrE,IAAI,CAAC,Y,IAAEV,EAAAA,A,MAAAA,CAAAA,EAAAA,C,MAAU,CAACsI,EAAM,GAAG,CAACtI,E,IAGnCmI,EAAO,OAAO,CAAC,IAAI,CAACzH,SAAAA,CAAC,E,MAAIA,AAAW,aAAXA,EAAE,IAAI,A,KAGnC0H,EAAcA,EAAY,GAAG,CAAC,SAAC1H,CAAC,CAAE0B,CAAC,E,MAAM,CACrC,KAAM,UACN,MAAOnF,EAAUyD,EAAE,KAAK,CAAE2B,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAA2BjF,EAAYgF,GAAI,CAAE+F,EAAO,OAAO,CAAC/F,EAAE,CAA0C,KAAK,CAAC,CAAE1I,EAAiB6N,EAAUV,EACzK,C,GACIvE,OAAO,MAAM,CAAC6F,EAAO,SAAS,EAAE,IAAI,CAACzH,SAAAA,CAAC,E,MAAIA,AAAgB,aAAhBA,EAAE,IAAI,CAAC,IAAI,A,IATrD,OAiBJ,OALA2H,EAASA,EAAO,GAAG,CAAC3H,SAAAA,CAAC,E,MAAK,CACtB,KAAM,QACN,KAAMA,EAAE,IAAI,CACZ,MAAOzD,EAAUyD,EAAE,KAAK,CAAEI,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAmB1D,EAAYsD,EAAE,IAAI,CAAC,IAAI,EAAG,CAAEyH,EAAO,SAAS,CAACzH,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAA0C,KAAK,CAAC,CAAEhH,EAAiB6N,EAAUV,EAC5L,C,GACO,CACH,KAAM,OACN,GAAI,CAAE,KAAM,aAAc,KAAM,CAAE,KAAMtC,EAAG,IAAI,CAAC,IAAI,CAAE,SAAUhH,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAAY,CAAE,EAC5F,KAAO,EAAGgL,GAAAA,MAAAA,CAAa,EAAGC,IAC1B,UAAW9K,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcH,EAC7B,CACR,CACJ,EA9IoCkB,EAAMlB,EAAYkK,EAAO5N,EAAiB6N,EAAUV,GACpF,OAAO7C,MAAAA,EAAAA,EAAUuD,EAASrD,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAQ5F,GAAOlB,EAAYkK,EACzD,CAgJA,SAASkB,EAAmBnO,CAAa,EACrC,MAAOA,AAAc,WAAdA,EAAK,IAAI,EAAiBA,AAAc,WAAdA,EAAK,IAAI,AAC9C,CAEO,SAASE,EAAckO,CAAiB,CAAEC,CAAoB,EACjE,IAAMC,EAAuB,EAAE,CAc/B,GAZIF,EAAO,IAAI,CAACf,SAAAA,CAAC,E,MAAIA,AAAW,WAAXA,EAAE,IAAI,A,IACvBiB,EAAQ,IAAI,CAAC,CAAE,KAAM,QAAS,GAG9BF,EAAO,IAAI,CAACf,SAAAA,CAAC,E,MAAIA,AAAW,WAAXA,EAAE,IAAI,A,IACvBiB,EAAQ,IAAI,CAAC,CAAE,KAAM,QAAS,GAG9BF,EAAO,IAAI,CAACf,SAAAA,CAAC,E,MAAIA,AAAW,WAAXA,EAAE,IAAI,EAAiBA,AAA4B,KAA5BA,EAAE,qBAAqB,A,IAC/DiB,EAAQ,IAAI,CAAC,CAAE,KAAM,QAAS,GAG9BF,EAAO,IAAI,CAACD,GACZG,EAAQ,IAAI,CAAC,CAAE,KAAM,UAAW,OAE/B,CACD,IAAMC,EAAgBH,EAAO,GAAG,CAACvI,EAAAA,EAAUA,EAErC2I,EAAyB,EAAE,CAC3BC,EAAyB,EAAE,CAC5BhJ,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAL,QAAKA,EAAAA,EAAsB4I,CAAG,CAAHA,OAAAA,QAAAA,CAAAA,GAAtB5I,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,GAA2B,CAA3BA,IAAAA,EAAAA,EAAAA,EAAAA,KAAAA,CAAAA,GAAOE,EAAAA,CAAAA,CAAAA,EAAAA,CACF0H,EAAarN,AADLA,CAAAA,CAAAA,EAAAA,CACU,IAAI,CAExBuO,EAAc,QAAQ,CAAC1I,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWwH,IAClCmB,EAAU,IAAI,CAAC,CAAE,KAAM,WAAY7I,KAAAA,CAAK,GAEnC0H,AAAW,aAAXA,EAAE,IAAI,EAAmBA,AAAsB,aAAtBA,EAAE,UAAU,CAAC,IAAI,EAAmBkB,EAAc,QAAQ,CAAC1I,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWwH,EAAE,UAAU,CAAC,KAAK,IACtHoB,EAAU,IAAI,CAAC,CAAE,KAAM,WAAY9I,KAAAA,CAAK,EAEhD,C,UATKF,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EAWL+I,EAAU,IAAI,CAAC,SAACnI,CAAC,CAAEqI,CAAC,EAChB,IAA2CC,EAAAA,EACAC,EAAAA,EADAD,EACAC,EAC3C,MAAOC,CAFsB,aAAXxI,EAAE,IAAI,EAAmBsI,MAAAA,CAAAA,QAAAA,CAAAA,EAAAA,EAAI,GAAG,CAACtI,EAAE,IAAI,IAAdsI,MAAAA,CAAAA,EAAAA,EAAiB,aAAa,AAAD,EAA7BA,KAAAA,EAAAA,EAAgC,QAAQ,AAAD,EAAvCA,EAA4C,IAC1D,aAAXD,EAAE,IAAI,EAAmBE,MAAAA,CAAAA,QAAAA,CAAAA,EAAAA,EAAI,GAAG,CAACF,EAAE,IAAI,IAAdE,MAAAA,CAAAA,EAAAA,EAAiB,aAAa,AAAD,EAA7BA,KAAAA,EAAAA,EAAgC,QAAQ,AAAD,EAAvCA,EAA4C,EAE3F,GAEAH,EAAU,IAAI,CAAC,SAACpI,CAAC,CAAEqI,CAAC,EAChB,IAA2CC,EAAAA,EACAC,EAAAA,EADAD,EACAC,EAC3C,MAAOC,CAFsB,aAAXxI,EAAE,IAAI,EAAmBsI,MAAAA,CAAAA,QAAAA,CAAAA,EAAAA,EAAI,GAAG,CAACtI,EAAE,IAAI,IAAdsI,MAAAA,CAAAA,EAAAA,EAAiB,aAAa,AAAD,EAA7BA,KAAAA,EAAAA,EAAgC,QAAQ,AAAD,EAAvCA,EAA4C,IAC1D,aAAXD,EAAE,IAAI,EAAmBE,MAAAA,CAAAA,QAAAA,CAAAA,EAAAA,EAAI,GAAG,CAACF,EAAE,IAAI,IAAdE,MAAAA,CAAAA,EAAAA,EAAiB,aAAa,AAAD,EAA7BA,KAAAA,EAAAA,EAAgC,QAAQ,AAAD,EAAvCA,EAA4C,EAE3F,GAEAE,AAAAA,EAAQ,IAAI,OAAZA,EAAa,EAAGL,IAChBM,AAAAA,EAAQ,IAAI,OAAZA,EAAa,EAAGP,GACpB,CACA,OAAOF,CACX,C,wzDC1KO,SAASU,EAAWC,CAAiC,EACxD,MAAOC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAYD,EAAY,GAAG,CACtC,CAEO,SAASE,EAAgBC,CAA2B,EACvD,IAAmCC,EAAAA,EAAqEC,EAErFC,EACLC,EAHRlM,EAAM6I,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAuBkD,MAAAA,CAAAA,EAAAA,MAAAA,CAAAA,EAAAA,EAAM,MAAM,AAAD,EAAXA,KAAAA,EAAAA,EAAc,GAAG,AAAD,EAAhBA,EAAqBrC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,IAAyByC,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAuBH,MAAAA,CAAAA,EAAAA,EAAM,QAAQ,AAAD,EAAbA,EAAkB,OAAQ,IAClI,MAAO,CACH,cAAeC,MAAAA,CAAAA,EAAAA,EAAM,aAAa,AAAD,EAAlBA,EAAuB,qBACtC,SAAUC,MAAAA,CAAAA,EAAAA,EAAM,QAAQ,AAAD,EAAbA,EAAkB,MAC5B,OAAQ,CACJlM,IAAAA,CACJ,CACJ,CACJ,CAEO,SAAS8I,EAAyDsD,CAAW,CAAEC,CAAsB,EACxG,IAAMC,EAAa,EAAGF,EAAS,GAAG,CAAChI,EAAAA,EAAUA,GAI7C,OAHIiI,AAAkB1Q,SAAlB0Q,GACAC,EAAU,IAAI,CAAC1M,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAcyM,IAE1B,CACH,KAAM,aACN,OAAQD,EACR,UAAWG,EAAAA,EAAAA,CAAAA,KAAAA,CAAAA,KAAAA,EAAM,EAAGD,GACxB,CACJ,CAEO,IAAME,EAAmBC,EAAAA,CAAAA,CAAAA,MAAQ,CAAC,CAErC,cAAeA,EAAAA,CAAAA,CAAAA,QAAU,CAACA,EAAAA,CAAAA,CAAAA,IAAM,CAACC,EAAAA,CAAiBA,GAAG,KAAK,CAAC/Q,QAC3D,SAAU8Q,EAAAA,CAAAA,CAAAA,QAAU,CAACA,EAAAA,CAAAA,CAAAA,IAAM,CAACE,EAAAA,CAAiBA,GAAG,KAAK,CAAChR,OAC1D,GAEO,SAASiR,EAAwBC,CAAmC,EACvE,IAAIC,EAAiC,CAAC,EACtC,GAAID,AAAoBlR,SAApBkR,EAA+B,CAC/B,IAAME,EAAiBC,AAAAA,GAAAA,EAAAA,UAAAA,AAAAA,EAAWC,EAAO,IAAI,CAACJ,EAAiB,WAAW,QAAQ,GAC5EK,EAAcT,EAAAA,CAAAA,CAAAA,MAAQ,CAAC,OACtBD,EAAiB,KAAK,GACzB,OAAQC,EAAAA,CAAAA,CAAAA,MAAQ,CAAC,CACb,IAAKA,EAAAA,CAAAA,CAAAA,MAAQ,EACjB,E,IAAM,KAAK,CAACU,KAAK,KAAK,CAACJ,IACrB/M,EAAMoN,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAMF,EAAY,MAAM,CAAC,GAAG,EACxC,GAAIlN,AAAa,UAAbA,EAAI,IAAI,CACR,MAAM,AAAIT,MAAMS,EAAI,MAAM,CAAC,GAAG,CAACqN,SAAAA,CAAK,E,MAAIC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAY,GAAE,KAAM,O,EAAYD,GAAS,G,GAAO,IAAI,CAAC,OAEjGP,EAAW,OACJI,GAAAA,CACH,OAAQ,CAAE,IAAKK,EAAgBvN,EAAK,C,EAE5C,CACA,OAAO6L,EAAgBiB,EAC3B,CAEO,SAASS,EAAgBvN,CAA2B,QACvD,AAAIA,AAAa,eAAbA,EAAI,IAAI,EAAqBA,AAAmB,eAAnBA,EAAI,KAAK,CAAC,IAAI,CACpCA,EAAI,KAAK,CAGhBA,AAAa,eAAbA,EAAI,IAAI,EACLA,AAAsB,IAAtBA,EAAI,MAAM,CAAC,MAAM,EACjBA,AAAuB,eAAvBA,EAAI,MAAM,CAAC,EAAE,CAAC,IAAI,EAClBA,AAA6B,eAA7BA,EAAI,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,EACxBA,AAAuB,cAAvBA,EAAI,MAAM,CAAC,EAAE,CAAC,IAAI,EAClBA,AAA8B,IAA9BA,EAAI,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,EACzBA,AAA+B,eAA/BA,EAAI,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAEtB,OACAA,GAAAA,CACH,OAAQ,CACJ,OACOA,EAAI,MAAM,CAAC,EAAE,GAChB,MAAOA,EAAI,MAAM,CAAC,EAAE,CAAC,KAAK,A,GAE9B,OACOA,EAAI,MAAM,CAAC,EAAE,GAChB,KAAM,CAACA,EAAI,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,A,GAEpC,A,GAIFZ,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAyBmH,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAQvG,GAAMwI,EAAAA,EAAcA,CAChE,C,qQC9IC,gB,4iEAUD,SAAS6E,EAAMG,CAAe,CAAE7M,CAA6F,CAAE8M,CAAqB,EAChJ,MAAM,AAAIlO,MAAO,GAAc4N,MAAAA,CAAZK,EAAQ,MAA2BC,MAAAA,CAAvBN,KAAK,SAAS,CAACxM,IAAgF,OAAxE8M,GAAgB,KAAsD,OAAlDA,EAAY,GAAG,CAACrP,SAAAA,CAAC,E,MAAK,KAAc,OAAVA,EAAE,OAAO,C,GAAI,IAAI,CAAC,QAC1H,CAWO,SAASsP,IACZ,MAAO,CACHN,MAAAA,SAAMzM,CAAI,EACN,GAAIA,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,YAAcA,AAAyB,WAAzBA,EAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CACjD,OAAOA,EAAK,KAAK,CAAC,IAAI,CAAC,KAAK,CAEhC0M,EAAO,wBAAwB1M,EACnC,CACJ,CACJ,CAEO,SAASgN,IACZ,OAAOC,EAAcC,EAAM,CAACC,EAAW,QAASA,EAAW,SAAS,EAAGrJ,SAAAA,CAAC,E,MAAIA,AAAM,SAANA,C,EAChF,CAEO,SAASqJ,EAA6BzL,CAAO,EAChD,MAAO,CACH+K,MAAAA,SAAMzM,CAAI,EACN,GAAIA,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,cAAgBA,EAAK,IAAI,CAAC,IAAI,GAAK0B,EAClD,OAAOA,EAEXgL,EAAO,mCAAuC,OAALhL,GAAQ1B,EACrD,CACJ,CACJ,CAEO,SAASkN,EAASE,CAA+B,EACpD,MAAO,CACHX,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,CAAEiD,CAAM,EACnB,IAAM7P,EAAkB,EAAE,CACrBgE,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAL,QAAKA,EAAAA,EAAgB4L,CAAO,CAAPA,OAAAA,QAAAA,CAAAA,GAAhB5L,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,GAAyB,CAAzBA,IAAM8L,EAAN9L,EAAAA,KAAAA,CACD,GAAI,CACA,OAAO8L,EAAO,KAAK,CAACtN,EAAMoK,EAAKiD,EACnC,CACA,MAAO5P,EAAG,CACND,EAAO,IAAI,CAACC,EAChB,CACJ,C,UAPK+D,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EAQLkL,EAAO,kCAAkC1M,EAAMxC,EACnD,CACJ,CACJ,CAEO,SAAS+P,IACZ,MAAO,CACHd,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,QACX,AAAIpK,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,iBAAmBA,AAAuB,MAAvBA,EAAK,QAAQ,CAAC,IAAI,CAC7C,CAAC,IAAI,CAAC,KAAK,CAACA,EAAK,IAAI,CAAEoK,GAE9BpK,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,YAAcA,AAAyB,WAAzBA,EAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAC1CA,EAAK,KAAK,CAAC,IAAI,CAAC,KAAK,MAEhC0M,EAAM,eAAgB1M,EAC1B,CACJ,CACJ,CAEO,SAASwN,EAA0CF,CAAmD,EACzG,MAAO,CACHb,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,GAAIuC,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,gBAAiB,CAChC,IAAMyN,EAAS,CAAC,EACXjM,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAL,QAAKA,EAAAA,EAAawC,OAAO,IAAI,CAACsJ,EAAO,CAAPA,OAAAA,QAAAA,CAAAA,GAAzB9L,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,IAAAA,A,WAAAA,IAAMoD,EAANpD,EAAAA,KAAAA,CACKkM,EAAQ1N,EAAK,UAAU,CAAC,IAAI,CAAC,Y,OAAS+E,AAAPA,A,MAAAA,CAAAA,EAAAA,GAAaH,C,EAClD6I,CAAAA,CAAM,CAAC7I,EAAI,CAAG0I,CAAM,CAAC1I,EAAI,CAAC,KAAK,CAC3B8I,MAAAA,EAAAA,KAAAA,EAAAA,CAAO,CAAC,EAAE,CAAEtD,EACZuD,SAAAA,CAAO,E,OAAIN,EAAO,OAAKrN,GAAAA,CAAM,WAAY2N,AAAY3S,SAAZ2S,EACnC3N,EAAK,UAAU,CAAC,MAAM,CAAC4N,SAAAA,CAAI,E,OAAIA,CAAI,CAAC,EAAE,GAAKhJ,C,GAC3C8I,EACI1N,EAAK,UAAU,CAAC,GAAG,CAAC4N,SAAAA,CAAI,E,OAAIA,IAASF,EAAQ,CAACE,CAAI,CAAC,EAAE,CAAED,EAAQ,CAAGC,C,GACjE,EAAG5N,EAAK,UAAU,SAAnB,CAAqB,CAAC4E,EAAe+I,EAAQ,CAAC,C,KAChE,G,UATKnM,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EAUL,OAAOiM,CACX,CACAf,EAAM,wBAAyB1M,EACnC,CACJ,CACJ,CAEO,SAAS6N,EAAYP,CAA4B,EACpD,MAAO,CACHb,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,GAAIuC,AAAShF,SAATgF,EAGJ,OAAOsN,EAAO,KAAK,CAACtN,EAAMoK,EAAKiD,EACnC,CACJ,CACJ,CAEO,SAAS3N,EAAgE4N,CAI/E,EACG,MAAO,CACHb,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,GAAIuC,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,OAAQ,CACvB,IAAMiG,EAAKqH,EAAO,EAAE,CAAC,KAAK,CAACtN,EAAK,EAAE,CAAEoK,EAChC,SAACuD,CAAO,EAEJ,MADApO,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAOoO,AAAY3S,SAAZ2S,EAAuB,iCACvBN,EAAO,OAAKrN,GAAAA,CAAM,GAAI2N,C,GACjC,GAEEG,EAAc,CAAC,EAChBtM,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAL,QAAKA,EAAAA,EAAawC,OAAO,IAAI,CAACsJ,EAAO,SAAS,CAAC,CAAD,mBAAzC9L,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,IAAAA,A,WAAAA,IAAMoD,EAANpD,EAAAA,KAAAA,CACKkM,EAAQ1N,EAAK,IAAI,CAAC,IAAI,CAACiC,SAAAA,CAAG,E,MAAIA,AAAa,UAAbA,EAAI,IAAI,EAAgBA,EAAI,IAAI,CAAC,IAAI,GAAK2C,C,EAC9EkJ,CAAAA,CAAW,CAAClJ,EAAI,CAAG0I,EAAO,SAAS,CAAC1I,EAAI,CAAC,KAAK,CAAC8I,MAAAA,EAAAA,KAAAA,EAAAA,EAAO,KAAK,CAAEtD,EACzDuD,SAAAA,CAAO,E,OAAIN,EAAO,OAAKrN,GAAAA,CAAM,KAAM0N,EAC7BC,AAAY3S,SAAZ2S,EAAwB3N,EAAK,IAAI,CAAC,MAAM,CAAC4N,SAAAA,CAAI,E,OAAIA,IAASF,C,GAAS1N,EAAK,IAAI,CAAC,GAAG,CAAC4N,SAAAA,CAAI,E,OAAIA,IAASF,EAAQ,OAAKE,GAAAA,CAAM,MAAOD,C,GAAYC,C,GACxID,AAAY3S,SAAZ2S,EAAwB3N,EAAK,IAAI,CAAI,EAAGA,EAAK,IAAI,SAAb,CAAe,CAAE,KAAM,QAAS,KAAM,CAAE,KAAM4E,EAAe,SAAUmJ,EAAAA,EAAUA,AAAC,EAAG,MAAOJ,CAAQ,EAAE,C,KAExJ,G,UAPKnM,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EASL,IAAMwM,EAAgB,EAAE,CACPC,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAjBC,EAAY,QAAKD,EAAAA,EAAwBX,EAAO,WAAW,CAAC,OAAO,EAAE,CAAF,mBAAlDW,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,GAAsD,CAAtDA,IAAAA,EAAAA,EAAAA,EAAAA,KAAAA,CAAAA,GAAOnK,EAAAA,CAAAA,CAAAA,EAAAA,CAAGqK,EAAAA,CAAAA,CAAAA,EAAAA,CACnB1J,EAAI,EACH2J,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAL,QAAKA,EAAAA,EAAapO,EAAK,IAAI,oBAAtBoO,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,G,sCAAAA,IAAMnM,EAANmM,EAAAA,KAAAA,OACD,AAAInM,AAAa,UAAbA,EAAI,IAAI,CACR,WAEAwC,IAAMX,GACNkK,CAAa,CAAClK,EAAE,CAAGqK,EAAU,KAAK,CAAClM,EAAI,KAAK,CAAEmI,EAC1CuD,SAAAA,CAAO,E,OAAIN,EAAO,OAAKrN,GAAAA,CAAM,KAAM2N,AAAY3S,SAAZ2S,EAAwB3N,EAAK,IAAI,CAAC,MAAM,CAACoC,SAAAA,CAAC,E,OAAIA,IAAMH,C,GAAOjC,EAAK,IAAI,CAAC,GAAG,CAACoC,SAAAA,CAAC,E,OAAIA,IAAMH,EAAM,OAAKG,GAAAA,CAAG,MAAOuL,C,GAAYvL,C,QAE5J,4BAEJqC,GACJ,I,SAHiByJ,C,UARZE,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EAYL1B,EAAM,wBAAyB1M,EACnC,C,UAfiBiO,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EAiBjB,MAAO,CAAE,UAAWH,EAAa,YAAaE,EAAe/H,GAAAA,CAAG,CACpE,CACAyG,EAAM,wBAAyB1M,EACnC,CACJ,CACJ,CAEO,SAASqO,EAAUf,CAA4B,EAClD,MAAO,CACHb,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,OAAO6Q,EAAehB,GAAQ,KAAK,CAACtN,EAAMoK,EAAKiD,GAAQ,YAAY,AACvE,CACJ,CACJ,CAEO,SAASiB,EAAkBhB,CAA4B,EAI1D,MAAO,CACHb,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,GAAIuC,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,gBACf,MAAO,CACH,aAAcA,EAAK,QAAQ,CAAC,GAAG,CAACqJ,SAAAA,CAAI,E,OAAIiE,EAAO,KAAK,CAACjE,EAAMe,EACvDuD,SAAAA,CAAO,E,OAAIN,EAAO,OAAKrN,GAAAA,CAAM,SAAU2N,AAAY3S,SAAZ2S,EAAwB3N,EAAK,QAAQ,CAAC,MAAM,CAACvC,SAAAA,CAAC,E,OAAIA,IAAM4L,C,GAAQrJ,EAAK,QAAQ,CAAC,GAAG,CAACvC,SAAAA,CAAC,E,OAAIA,IAAM4L,EAAOsE,EAAUlQ,C,UAEzJ8Q,KAAAA,SAAKC,CAAK,EACN,OAAOnB,EAAO,OACPrN,GAAAA,CACH,SAAUwO,EAAMxO,EAAK,QAAQ,C,GAErC,CACJ,EAEJ0M,EAAM,uBAAwB1M,EAClC,CACJ,CACJ,CAEO,SAASyF,EAAe6H,CAA4B,EACvD,MAAO,CACHb,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,GAAIuC,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,aAAc,CAC7B,IAAMjE,EAAOqO,EAAI,GAAG,CAACpK,EAAK,IAAI,CAAC,IAAI,EACnC,GAAIyO,OAAAA,GAAAA,MAAAA,CAAAA,EAAAA,EAAM,aAAa,AAAD,EAAlBA,KAAAA,EAAAA,EAAqB,qBAAqB,IAAKzT,QAAae,EAAK,aAAa,CAAC,qBAAqB,CAAC,MAAM,CAAG,EAAG,C,IAC5GyF,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAL,QADAiN,EACKjN,EAAAA,EAA8BzF,EAAK,aAAa,CAAC,qBAAqB,oBAAtEyF,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,GAAwE,CAAxEA,IAAMkN,EAANlN,EAAAA,KAAAA,CACD,GAAI,CACA,OAAO8L,EAAO,KAAK,CAACoB,EAAsBtE,EAAKiD,EACnD,CACA,QAAM,CAAC,CACX,C,UALK7L,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EAMT,CACJ,CACA,OAAO8L,EAAO,KAAK,CAACtN,EAAMoK,EAAKiD,EACnC,CACJ,CACJ,CAKO,SAASkB,EACZjB,CAA4B,EAM5B,MAAO,CACHb,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,MAAO,CACH,aAAc6P,EAAO,KAAK,CAACtN,EAAMoK,EAAKiD,GACtC,KAAMA,EACNrN,KAAAA,CACJ,CACJ,CACJ,CACJ,CAKO,SAAS2O,EAAW7P,CAAkB,CAAEkK,CAAgB,CAAEsE,CAA4B,EACzF,MAAO,CACHb,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,OAAO6P,EAAO,KAAK,CAACtN,EAAMoK,EACtBuD,SAAAA,CAAO,E,OAAIN,EAAOM,AAAY3S,SAAZ2S,EAAwB3S,OAAY2D,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAUgP,EAAS7O,EAAYkK,EAAOoB,EAAK,WAAQ,MAAM,AAAIxL,MAAM,oBAAqB,EAAG,I,EAEzJ,CACJ,CACJ,CAWO,SAASgQ,EAActB,CAA4B,EACtD,MAAO,CACHb,MAAAA,SAAMnE,CAAI,CAAE8B,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,GAAI6K,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,aACf,OAAOgF,EAAO,KAAK,CAAChF,EAAK,KAAK,CAAE8B,EAC5BuD,SAAAA,CAAO,E,OAAIA,AAAY3S,SAAZ2S,EAAwB3S,OAAYqS,EAAO,OAAK/E,GAAAA,CAAM,MAAOqF,C,MAGhFjB,EAAM,oBAAqBpE,EAC/B,CACJ,CACJ,CAEA,SAASuG,EACLvB,CAAmD,CACnD9E,CAA+B,CAC/B4B,CAAoB,CACpBiD,CAAqE,EAErE,IAAMI,EAAS,EAAE,CACZjM,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,IAAL,QAAKA,EAAAA,EAAgB8L,EAAO,OAAO,EAAE,CAAF,mBAA9B9L,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,IAAAA,A,WAAAA,IAAAA,EAAAA,EAAAA,EAAAA,KAAAA,CAAAA,GAAOsC,EAAAA,CAAAA,CAAAA,EAAAA,CAAG6F,EAAAA,CAAAA,CAAAA,EAAAA,AACP7F,CAAAA,GAAK0E,EAAM,MAAM,EACjBkE,EAAM,wBAAyBlE,GAEnCiF,CAAM,CAAC3J,EAAE,CAAG6F,EAAE,KAAK,CAACnB,CAAK,CAAC1E,EAAE,CAAEsG,EAC1B0E,SAAAA,CAAO,E,OAAIzB,EAAQ,EAAG7E,EAAM,KAAK,CAAC,EAAG1E,IAAAA,MAAAA,CAAnB,CAAuBgL,EAA+B,CAAtB,EAAGtG,EAAM,KAAK,CAAC1E,EAAI,K,EAE7E,G,UAPKtC,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EAQL,OAAOiM,CACX,CAEO,SAASsB,EAAgCzB,CAAmD,EAC/F,MAAO,CACHb,MAAAA,SAAMnE,CAAI,CAAE8B,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,GAAI6K,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,aACf,OAAOuG,EAAgBvB,EAAQhF,EAAK,MAAM,CAAE8B,EACxC4E,SAAAA,CAAQ,E,OAAI3B,EAAO,OAAK/E,GAAAA,CAAM,OAAQ0G,C,MAG9CtC,EAAM,wBAAyBpE,EACnC,CACJ,CACJ,CAEO,SAAS2G,IACZ,MAAO,CACHxC,MAAAA,WAEA,CACJ,CACJ,CAEO,SAASxF,EAAkCqG,CAA8F,EAC5I,MAAO,CACHb,MAAAA,SAAMnE,CAAI,CAAE8B,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,GAAI6K,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,YACf,MAAO,CACH,UAAWgF,EAAO,SAAS,CAAC,KAAK,CAAChF,EAAK,SAAS,CAAE8B,EAC9C,SAACuD,CAAO,EAEJ,MADApO,AAAAA,GAAAA,EAAAA,CAAAA,AAAAA,EAAOoO,AAAY3S,SAAZ2S,EAAuB,+DACvBN,EAAO,OAAK/E,GAAAA,CAAM,UAAWqF,C,GACxC,GAEJ,KAAMkB,EAAgBvB,EAAO,IAAI,CAAEhF,EAAK,IAAI,CAAE8B,EAC1C4E,SAAAA,CAAQ,E,OAAI3B,EAAO,OAAK/E,GAAAA,CAAM,KAAM0G,C,KAE5C,EAEJtC,EAAM,kBAAmBpE,EAC7B,CACJ,CACJ,CACO,SAAS2E,EAAoBK,CAA4B,CAAE4B,CAAgB,EAC9E,MAAO,CACHzC,MAAAA,SAAM0C,CAAG,CAAE/E,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC1B,OAAOyR,EAAI5B,EAAO,KAAK,CAAC6B,EAAK/E,EAAKiD,GACtC,CACJ,CACJ,CAEO,SAAS+B,EAAoB9B,CAA4B,CAAE4B,CAAgB,EAC9E,MAAO,CACHzC,MAAAA,SAAM0C,CAAG,CAAE/E,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC1B,OAAOyR,EAAI5B,EAAO,KAAK,CAAC6B,EAAK/E,EAAKiD,GACtC,CACJ,CACJ,CAEO,SAASgC,EAAkB/B,CAA4B,EAC1D,MAAO,CACHb,MAAAA,SAAMzM,CAAI,CAAEoK,CAAG,E,IAAEiD,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAS5P,SAAAA,CAAC,E,OAAIA,C,EAC3B,GAAIuC,AAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAM,IAAI,AAAD,IAAM,cAAgBA,AAAmB,eAAnBA,EAAK,IAAI,CAAC,IAAI,CAAmB,CAChE,IAAMsP,EAAsBtP,EAAK,IAAI,CACrC,OAAOsN,EAAO,KAAK,CAACtN,EAAK,IAAI,CAAC,KAAK,CAAEoK,EAAKuD,SAAAA,CAAO,E,OAAIA,AAAY3S,SAAZ2S,EAC/C3S,OACAqS,EAAO,OACFrN,GAAAA,CACH,KAAM,OACCsP,GAAAA,CACH,MAAO3B,C,GAEX,aAAc/H,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAQ+H,E,KAElC,CACA,OAAOL,EAAO,KAAK,CAACtN,EAAMoK,EAAKiD,EACnC,CACJ,CACJ,C"}