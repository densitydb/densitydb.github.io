{"version":3,"file":"427.js","sources":["webpack://assets/./src/data/type_ordering_idx.ts","webpack://assets/./src/utils/defensive.ts","webpack://assets/./src/utils/protos.js"],"sourcesContent":["const value: Record<string, number> = {\n    \"Continent\": 0,\n    \"Country\": 1,\n    \"Subnational Region\": 2,\n    \"County\": 3,\n    \"Urban Center\": 4,\n    \"Metropolitan Cluster\": 5,\n    \"CA Census Division\": 6,\n    \"CA Population Center\": 7,\n    \"City\": 8,\n    \"CSA\": 9,\n    \"MSA\": 10,\n    \"Urban Area\": 11,\n    \"CA CMA\": 12,\n    \"CCD\": 13,\n    \"CA Census Subdivision\": 14,\n    \"Neighborhood\": 15,\n    \"ZIP\": 16,\n    \"Congressional District (1780s)\": 17,\n    \"Congressional District (1790s)\": 18,\n    \"Congressional District (1800s)\": 19,\n    \"Congressional District (1810s)\": 20,\n    \"Congressional District (1820s)\": 21,\n    \"Congressional District (1830s)\": 22,\n    \"Congressional District (1840s)\": 23,\n    \"Congressional District (1850s)\": 24,\n    \"Congressional District (1860s)\": 25,\n    \"Congressional District (1870s)\": 26,\n    \"Congressional District (1880s)\": 27,\n    \"Congressional District (1890s)\": 28,\n    \"Congressional District (1900s)\": 29,\n    \"Congressional District (1910s)\": 30,\n    \"Congressional District (1920s)\": 31,\n    \"Congressional District (1930s)\": 32,\n    \"Congressional District (1940s)\": 33,\n    \"Congressional District (1950s)\": 34,\n    \"Congressional District (1960s)\": 35,\n    \"Congressional District (1970s)\": 36,\n    \"Congressional District (1980s)\": 37,\n    \"Congressional District (1990s)\": 38,\n    \"Congressional District (2000s)\": 39,\n    \"Congressional District (2010s)\": 40,\n    \"Congressional District (2020s)\": 41,\n    \"State House District\": 42,\n    \"State Senate District\": 43,\n    \"Congressional District\": 44,\n    \"County Cross CD\": 45,\n    \"CA Riding\": 46,\n    \"Native Area\": 47,\n    \"Native Statistical Area\": 48,\n    \"Native Subdivision\": 49,\n    \"School District\": 50,\n    \"Judicial Circuit\": 51,\n    \"Media Market\": 52,\n    \"USDA County Type\": 53,\n    \"Hospital Referral Region\": 54,\n    \"Judicial District\": 55,\n    \"Hospital Service Area\": 56,\n    \"1B Person Circle\": 57,\n    \"500M Person Circle\": 58,\n    \"200M Person Circle\": 59,\n    \"100M Person Circle\": 60,\n    \"50M Person Circle\": 61,\n    \"20M Person Circle\": 62,\n    \"10M Person Circle\": 63,\n    \"5M Person Circle\": 64\n}\nexport default value","/* c8 ignore start */\nexport function assert(condition: boolean, message: string): asserts condition {\n    if (!condition) {\n        throw new Error(message)\n    }\n}\n/* c8 ignore end */\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\nimport $protobuf from \"protobufjs/minimal\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\nexport const StatisticRow = $root.StatisticRow = (() => {\n\n    /**\n     * Properties of a StatisticRow.\n     * @exports IStatisticRow\n     * @interface IStatisticRow\n     * @property {number|null} [statval] StatisticRow statval\n     * @property {Array.<number>|null} [ordinalByUniverse] StatisticRow ordinalByUniverse\n     * @property {Array.<number>|null} [percentileByPopulationByUniverse] StatisticRow percentileByPopulationByUniverse\n     */\n\n    /**\n     * Constructs a new StatisticRow.\n     * @exports StatisticRow\n     * @classdesc Represents a StatisticRow.\n     * @implements IStatisticRow\n     * @constructor\n     * @param {IStatisticRow=} [properties] Properties to set\n     */\n    function StatisticRow(properties) {\n        this.ordinalByUniverse = [];\n        this.percentileByPopulationByUniverse = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * StatisticRow statval.\n     * @member {number} statval\n     * @memberof StatisticRow\n     * @instance\n     */\n    StatisticRow.prototype.statval = 0;\n\n    /**\n     * StatisticRow ordinalByUniverse.\n     * @member {Array.<number>} ordinalByUniverse\n     * @memberof StatisticRow\n     * @instance\n     */\n    StatisticRow.prototype.ordinalByUniverse = $util.emptyArray;\n\n    /**\n     * StatisticRow percentileByPopulationByUniverse.\n     * @member {Array.<number>} percentileByPopulationByUniverse\n     * @memberof StatisticRow\n     * @instance\n     */\n    StatisticRow.prototype.percentileByPopulationByUniverse = $util.emptyArray;\n\n    /**\n     * Creates a new StatisticRow instance using the specified properties.\n     * @function create\n     * @memberof StatisticRow\n     * @static\n     * @param {IStatisticRow=} [properties] Properties to set\n     * @returns {StatisticRow} StatisticRow instance\n     */\n    StatisticRow.create = function create(properties) {\n        return new StatisticRow(properties);\n    };\n\n    /**\n     * Encodes the specified StatisticRow message. Does not implicitly {@link StatisticRow.verify|verify} messages.\n     * @function encode\n     * @memberof StatisticRow\n     * @static\n     * @param {IStatisticRow} message StatisticRow message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StatisticRow.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.statval != null && Object.hasOwnProperty.call(message, \"statval\"))\n            writer.uint32(/* id 1, wireType 5 =*/13).float(message.statval);\n        if (message.ordinalByUniverse != null && message.ordinalByUniverse.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.ordinalByUniverse.length; ++i)\n                writer.int32(message.ordinalByUniverse[i]);\n            writer.ldelim();\n        }\n        if (message.percentileByPopulationByUniverse != null && message.percentileByPopulationByUniverse.length) {\n            writer.uint32(/* id 4, wireType 2 =*/34).fork();\n            for (let i = 0; i < message.percentileByPopulationByUniverse.length; ++i)\n                writer.int32(message.percentileByPopulationByUniverse[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified StatisticRow message, length delimited. Does not implicitly {@link StatisticRow.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof StatisticRow\n     * @static\n     * @param {IStatisticRow} message StatisticRow message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StatisticRow.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a StatisticRow message from the specified reader or buffer.\n     * @function decode\n     * @memberof StatisticRow\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {StatisticRow} StatisticRow\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StatisticRow.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StatisticRow();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.statval = reader.float();\n                    break;\n                }\n            case 2: {\n                    if (!(message.ordinalByUniverse && message.ordinalByUniverse.length))\n                        message.ordinalByUniverse = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.ordinalByUniverse.push(reader.int32());\n                    } else\n                        message.ordinalByUniverse.push(reader.int32());\n                    break;\n                }\n            case 4: {\n                    if (!(message.percentileByPopulationByUniverse && message.percentileByPopulationByUniverse.length))\n                        message.percentileByPopulationByUniverse = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.percentileByPopulationByUniverse.push(reader.int32());\n                    } else\n                        message.percentileByPopulationByUniverse.push(reader.int32());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a StatisticRow message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof StatisticRow\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {StatisticRow} StatisticRow\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StatisticRow.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a StatisticRow message.\n     * @function verify\n     * @memberof StatisticRow\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    StatisticRow.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.statval != null && message.hasOwnProperty(\"statval\"))\n            if (typeof message.statval !== \"number\")\n                return \"statval: number expected\";\n        if (message.ordinalByUniverse != null && message.hasOwnProperty(\"ordinalByUniverse\")) {\n            if (!Array.isArray(message.ordinalByUniverse))\n                return \"ordinalByUniverse: array expected\";\n            for (let i = 0; i < message.ordinalByUniverse.length; ++i)\n                if (!$util.isInteger(message.ordinalByUniverse[i]))\n                    return \"ordinalByUniverse: integer[] expected\";\n        }\n        if (message.percentileByPopulationByUniverse != null && message.hasOwnProperty(\"percentileByPopulationByUniverse\")) {\n            if (!Array.isArray(message.percentileByPopulationByUniverse))\n                return \"percentileByPopulationByUniverse: array expected\";\n            for (let i = 0; i < message.percentileByPopulationByUniverse.length; ++i)\n                if (!$util.isInteger(message.percentileByPopulationByUniverse[i]))\n                    return \"percentileByPopulationByUniverse: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a StatisticRow message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof StatisticRow\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {StatisticRow} StatisticRow\n     */\n    StatisticRow.fromObject = function fromObject(object) {\n        if (object instanceof $root.StatisticRow)\n            return object;\n        let message = new $root.StatisticRow();\n        if (object.statval != null)\n            message.statval = Number(object.statval);\n        if (object.ordinalByUniverse) {\n            if (!Array.isArray(object.ordinalByUniverse))\n                throw TypeError(\".StatisticRow.ordinalByUniverse: array expected\");\n            message.ordinalByUniverse = [];\n            for (let i = 0; i < object.ordinalByUniverse.length; ++i)\n                message.ordinalByUniverse[i] = object.ordinalByUniverse[i] | 0;\n        }\n        if (object.percentileByPopulationByUniverse) {\n            if (!Array.isArray(object.percentileByPopulationByUniverse))\n                throw TypeError(\".StatisticRow.percentileByPopulationByUniverse: array expected\");\n            message.percentileByPopulationByUniverse = [];\n            for (let i = 0; i < object.percentileByPopulationByUniverse.length; ++i)\n                message.percentileByPopulationByUniverse[i] = object.percentileByPopulationByUniverse[i] | 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a StatisticRow message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof StatisticRow\n     * @static\n     * @param {StatisticRow} message StatisticRow\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    StatisticRow.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.ordinalByUniverse = [];\n            object.percentileByPopulationByUniverse = [];\n        }\n        if (options.defaults)\n            object.statval = 0;\n        if (message.statval != null && message.hasOwnProperty(\"statval\"))\n            object.statval = options.json && !isFinite(message.statval) ? String(message.statval) : message.statval;\n        if (message.ordinalByUniverse && message.ordinalByUniverse.length) {\n            object.ordinalByUniverse = [];\n            for (let j = 0; j < message.ordinalByUniverse.length; ++j)\n                object.ordinalByUniverse[j] = message.ordinalByUniverse[j];\n        }\n        if (message.percentileByPopulationByUniverse && message.percentileByPopulationByUniverse.length) {\n            object.percentileByPopulationByUniverse = [];\n            for (let j = 0; j < message.percentileByPopulationByUniverse.length; ++j)\n                object.percentileByPopulationByUniverse[j] = message.percentileByPopulationByUniverse[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this StatisticRow to JSON.\n     * @function toJSON\n     * @memberof StatisticRow\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    StatisticRow.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for StatisticRow\n     * @function getTypeUrl\n     * @memberof StatisticRow\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    StatisticRow.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/StatisticRow\";\n    };\n\n    return StatisticRow;\n})();\n\nexport const FirstOrLast = $root.FirstOrLast = (() => {\n\n    /**\n     * Properties of a FirstOrLast.\n     * @exports IFirstOrLast\n     * @interface IFirstOrLast\n     * @property {number|null} [articleRowIdx] FirstOrLast articleRowIdx\n     * @property {number|null} [articleUniversesIdx] FirstOrLast articleUniversesIdx\n     * @property {boolean|null} [isFirst] FirstOrLast isFirst\n     */\n\n    /**\n     * Constructs a new FirstOrLast.\n     * @exports FirstOrLast\n     * @classdesc Represents a FirstOrLast.\n     * @implements IFirstOrLast\n     * @constructor\n     * @param {IFirstOrLast=} [properties] Properties to set\n     */\n    function FirstOrLast(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * FirstOrLast articleRowIdx.\n     * @member {number} articleRowIdx\n     * @memberof FirstOrLast\n     * @instance\n     */\n    FirstOrLast.prototype.articleRowIdx = 0;\n\n    /**\n     * FirstOrLast articleUniversesIdx.\n     * @member {number} articleUniversesIdx\n     * @memberof FirstOrLast\n     * @instance\n     */\n    FirstOrLast.prototype.articleUniversesIdx = 0;\n\n    /**\n     * FirstOrLast isFirst.\n     * @member {boolean} isFirst\n     * @memberof FirstOrLast\n     * @instance\n     */\n    FirstOrLast.prototype.isFirst = false;\n\n    /**\n     * Creates a new FirstOrLast instance using the specified properties.\n     * @function create\n     * @memberof FirstOrLast\n     * @static\n     * @param {IFirstOrLast=} [properties] Properties to set\n     * @returns {FirstOrLast} FirstOrLast instance\n     */\n    FirstOrLast.create = function create(properties) {\n        return new FirstOrLast(properties);\n    };\n\n    /**\n     * Encodes the specified FirstOrLast message. Does not implicitly {@link FirstOrLast.verify|verify} messages.\n     * @function encode\n     * @memberof FirstOrLast\n     * @static\n     * @param {IFirstOrLast} message FirstOrLast message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FirstOrLast.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.articleRowIdx != null && Object.hasOwnProperty.call(message, \"articleRowIdx\"))\n            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.articleRowIdx);\n        if (message.articleUniversesIdx != null && Object.hasOwnProperty.call(message, \"articleUniversesIdx\"))\n            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.articleUniversesIdx);\n        if (message.isFirst != null && Object.hasOwnProperty.call(message, \"isFirst\"))\n            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isFirst);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified FirstOrLast message, length delimited. Does not implicitly {@link FirstOrLast.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof FirstOrLast\n     * @static\n     * @param {IFirstOrLast} message FirstOrLast message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FirstOrLast.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a FirstOrLast message from the specified reader or buffer.\n     * @function decode\n     * @memberof FirstOrLast\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {FirstOrLast} FirstOrLast\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FirstOrLast.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FirstOrLast();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.articleRowIdx = reader.int32();\n                    break;\n                }\n            case 2: {\n                    message.articleUniversesIdx = reader.int32();\n                    break;\n                }\n            case 3: {\n                    message.isFirst = reader.bool();\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a FirstOrLast message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof FirstOrLast\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {FirstOrLast} FirstOrLast\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FirstOrLast.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a FirstOrLast message.\n     * @function verify\n     * @memberof FirstOrLast\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    FirstOrLast.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.articleRowIdx != null && message.hasOwnProperty(\"articleRowIdx\"))\n            if (!$util.isInteger(message.articleRowIdx))\n                return \"articleRowIdx: integer expected\";\n        if (message.articleUniversesIdx != null && message.hasOwnProperty(\"articleUniversesIdx\"))\n            if (!$util.isInteger(message.articleUniversesIdx))\n                return \"articleUniversesIdx: integer expected\";\n        if (message.isFirst != null && message.hasOwnProperty(\"isFirst\"))\n            if (typeof message.isFirst !== \"boolean\")\n                return \"isFirst: boolean expected\";\n        return null;\n    };\n\n    /**\n     * Creates a FirstOrLast message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof FirstOrLast\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {FirstOrLast} FirstOrLast\n     */\n    FirstOrLast.fromObject = function fromObject(object) {\n        if (object instanceof $root.FirstOrLast)\n            return object;\n        let message = new $root.FirstOrLast();\n        if (object.articleRowIdx != null)\n            message.articleRowIdx = object.articleRowIdx | 0;\n        if (object.articleUniversesIdx != null)\n            message.articleUniversesIdx = object.articleUniversesIdx | 0;\n        if (object.isFirst != null)\n            message.isFirst = Boolean(object.isFirst);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a FirstOrLast message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof FirstOrLast\n     * @static\n     * @param {FirstOrLast} message FirstOrLast\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    FirstOrLast.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.articleRowIdx = 0;\n            object.articleUniversesIdx = 0;\n            object.isFirst = false;\n        }\n        if (message.articleRowIdx != null && message.hasOwnProperty(\"articleRowIdx\"))\n            object.articleRowIdx = message.articleRowIdx;\n        if (message.articleUniversesIdx != null && message.hasOwnProperty(\"articleUniversesIdx\"))\n            object.articleUniversesIdx = message.articleUniversesIdx;\n        if (message.isFirst != null && message.hasOwnProperty(\"isFirst\"))\n            object.isFirst = message.isFirst;\n        return object;\n    };\n\n    /**\n     * Converts this FirstOrLast to JSON.\n     * @function toJSON\n     * @memberof FirstOrLast\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    FirstOrLast.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for FirstOrLast\n     * @function getTypeUrl\n     * @memberof FirstOrLast\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    FirstOrLast.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/FirstOrLast\";\n    };\n\n    return FirstOrLast;\n})();\n\nexport const RelatedButton = $root.RelatedButton = (() => {\n\n    /**\n     * Properties of a RelatedButton.\n     * @exports IRelatedButton\n     * @interface IRelatedButton\n     * @property {string|null} [longname] RelatedButton longname\n     * @property {string|null} [shortname] RelatedButton shortname\n     * @property {string|null} [rowType] RelatedButton rowType\n     */\n\n    /**\n     * Constructs a new RelatedButton.\n     * @exports RelatedButton\n     * @classdesc Represents a RelatedButton.\n     * @implements IRelatedButton\n     * @constructor\n     * @param {IRelatedButton=} [properties] Properties to set\n     */\n    function RelatedButton(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * RelatedButton longname.\n     * @member {string} longname\n     * @memberof RelatedButton\n     * @instance\n     */\n    RelatedButton.prototype.longname = \"\";\n\n    /**\n     * RelatedButton shortname.\n     * @member {string} shortname\n     * @memberof RelatedButton\n     * @instance\n     */\n    RelatedButton.prototype.shortname = \"\";\n\n    /**\n     * RelatedButton rowType.\n     * @member {string} rowType\n     * @memberof RelatedButton\n     * @instance\n     */\n    RelatedButton.prototype.rowType = \"\";\n\n    /**\n     * Creates a new RelatedButton instance using the specified properties.\n     * @function create\n     * @memberof RelatedButton\n     * @static\n     * @param {IRelatedButton=} [properties] Properties to set\n     * @returns {RelatedButton} RelatedButton instance\n     */\n    RelatedButton.create = function create(properties) {\n        return new RelatedButton(properties);\n    };\n\n    /**\n     * Encodes the specified RelatedButton message. Does not implicitly {@link RelatedButton.verify|verify} messages.\n     * @function encode\n     * @memberof RelatedButton\n     * @static\n     * @param {IRelatedButton} message RelatedButton message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    RelatedButton.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.longname != null && Object.hasOwnProperty.call(message, \"longname\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).string(message.longname);\n        if (message.shortname != null && Object.hasOwnProperty.call(message, \"shortname\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).string(message.shortname);\n        if (message.rowType != null && Object.hasOwnProperty.call(message, \"rowType\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.rowType);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified RelatedButton message, length delimited. Does not implicitly {@link RelatedButton.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof RelatedButton\n     * @static\n     * @param {IRelatedButton} message RelatedButton message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    RelatedButton.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a RelatedButton message from the specified reader or buffer.\n     * @function decode\n     * @memberof RelatedButton\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {RelatedButton} RelatedButton\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    RelatedButton.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RelatedButton();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.longname = reader.string();\n                    break;\n                }\n            case 2: {\n                    message.shortname = reader.string();\n                    break;\n                }\n            case 3: {\n                    message.rowType = reader.string();\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a RelatedButton message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof RelatedButton\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {RelatedButton} RelatedButton\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    RelatedButton.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a RelatedButton message.\n     * @function verify\n     * @memberof RelatedButton\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    RelatedButton.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.longname != null && message.hasOwnProperty(\"longname\"))\n            if (!$util.isString(message.longname))\n                return \"longname: string expected\";\n        if (message.shortname != null && message.hasOwnProperty(\"shortname\"))\n            if (!$util.isString(message.shortname))\n                return \"shortname: string expected\";\n        if (message.rowType != null && message.hasOwnProperty(\"rowType\"))\n            if (!$util.isString(message.rowType))\n                return \"rowType: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a RelatedButton message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof RelatedButton\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {RelatedButton} RelatedButton\n     */\n    RelatedButton.fromObject = function fromObject(object) {\n        if (object instanceof $root.RelatedButton)\n            return object;\n        let message = new $root.RelatedButton();\n        if (object.longname != null)\n            message.longname = String(object.longname);\n        if (object.shortname != null)\n            message.shortname = String(object.shortname);\n        if (object.rowType != null)\n            message.rowType = String(object.rowType);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a RelatedButton message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof RelatedButton\n     * @static\n     * @param {RelatedButton} message RelatedButton\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    RelatedButton.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.longname = \"\";\n            object.shortname = \"\";\n            object.rowType = \"\";\n        }\n        if (message.longname != null && message.hasOwnProperty(\"longname\"))\n            object.longname = message.longname;\n        if (message.shortname != null && message.hasOwnProperty(\"shortname\"))\n            object.shortname = message.shortname;\n        if (message.rowType != null && message.hasOwnProperty(\"rowType\"))\n            object.rowType = message.rowType;\n        return object;\n    };\n\n    /**\n     * Converts this RelatedButton to JSON.\n     * @function toJSON\n     * @memberof RelatedButton\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    RelatedButton.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for RelatedButton\n     * @function getTypeUrl\n     * @memberof RelatedButton\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    RelatedButton.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/RelatedButton\";\n    };\n\n    return RelatedButton;\n})();\n\nexport const RelatedButtons = $root.RelatedButtons = (() => {\n\n    /**\n     * Properties of a RelatedButtons.\n     * @exports IRelatedButtons\n     * @interface IRelatedButtons\n     * @property {string|null} [relationshipType] RelatedButtons relationshipType\n     * @property {Array.<IRelatedButton>|null} [buttons] RelatedButtons buttons\n     */\n\n    /**\n     * Constructs a new RelatedButtons.\n     * @exports RelatedButtons\n     * @classdesc Represents a RelatedButtons.\n     * @implements IRelatedButtons\n     * @constructor\n     * @param {IRelatedButtons=} [properties] Properties to set\n     */\n    function RelatedButtons(properties) {\n        this.buttons = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * RelatedButtons relationshipType.\n     * @member {string} relationshipType\n     * @memberof RelatedButtons\n     * @instance\n     */\n    RelatedButtons.prototype.relationshipType = \"\";\n\n    /**\n     * RelatedButtons buttons.\n     * @member {Array.<IRelatedButton>} buttons\n     * @memberof RelatedButtons\n     * @instance\n     */\n    RelatedButtons.prototype.buttons = $util.emptyArray;\n\n    /**\n     * Creates a new RelatedButtons instance using the specified properties.\n     * @function create\n     * @memberof RelatedButtons\n     * @static\n     * @param {IRelatedButtons=} [properties] Properties to set\n     * @returns {RelatedButtons} RelatedButtons instance\n     */\n    RelatedButtons.create = function create(properties) {\n        return new RelatedButtons(properties);\n    };\n\n    /**\n     * Encodes the specified RelatedButtons message. Does not implicitly {@link RelatedButtons.verify|verify} messages.\n     * @function encode\n     * @memberof RelatedButtons\n     * @static\n     * @param {IRelatedButtons} message RelatedButtons message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    RelatedButtons.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.relationshipType != null && Object.hasOwnProperty.call(message, \"relationshipType\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).string(message.relationshipType);\n        if (message.buttons != null && message.buttons.length)\n            for (let i = 0; i < message.buttons.length; ++i)\n                $root.RelatedButton.encode(message.buttons[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified RelatedButtons message, length delimited. Does not implicitly {@link RelatedButtons.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof RelatedButtons\n     * @static\n     * @param {IRelatedButtons} message RelatedButtons message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    RelatedButtons.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a RelatedButtons message from the specified reader or buffer.\n     * @function decode\n     * @memberof RelatedButtons\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {RelatedButtons} RelatedButtons\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    RelatedButtons.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RelatedButtons();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.relationshipType = reader.string();\n                    break;\n                }\n            case 2: {\n                    if (!(message.buttons && message.buttons.length))\n                        message.buttons = [];\n                    message.buttons.push($root.RelatedButton.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a RelatedButtons message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof RelatedButtons\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {RelatedButtons} RelatedButtons\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    RelatedButtons.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a RelatedButtons message.\n     * @function verify\n     * @memberof RelatedButtons\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    RelatedButtons.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.relationshipType != null && message.hasOwnProperty(\"relationshipType\"))\n            if (!$util.isString(message.relationshipType))\n                return \"relationshipType: string expected\";\n        if (message.buttons != null && message.hasOwnProperty(\"buttons\")) {\n            if (!Array.isArray(message.buttons))\n                return \"buttons: array expected\";\n            for (let i = 0; i < message.buttons.length; ++i) {\n                let error = $root.RelatedButton.verify(message.buttons[i]);\n                if (error)\n                    return \"buttons.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a RelatedButtons message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof RelatedButtons\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {RelatedButtons} RelatedButtons\n     */\n    RelatedButtons.fromObject = function fromObject(object) {\n        if (object instanceof $root.RelatedButtons)\n            return object;\n        let message = new $root.RelatedButtons();\n        if (object.relationshipType != null)\n            message.relationshipType = String(object.relationshipType);\n        if (object.buttons) {\n            if (!Array.isArray(object.buttons))\n                throw TypeError(\".RelatedButtons.buttons: array expected\");\n            message.buttons = [];\n            for (let i = 0; i < object.buttons.length; ++i) {\n                if (typeof object.buttons[i] !== \"object\")\n                    throw TypeError(\".RelatedButtons.buttons: object expected\");\n                message.buttons[i] = $root.RelatedButton.fromObject(object.buttons[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a RelatedButtons message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof RelatedButtons\n     * @static\n     * @param {RelatedButtons} message RelatedButtons\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    RelatedButtons.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.buttons = [];\n        if (options.defaults)\n            object.relationshipType = \"\";\n        if (message.relationshipType != null && message.hasOwnProperty(\"relationshipType\"))\n            object.relationshipType = message.relationshipType;\n        if (message.buttons && message.buttons.length) {\n            object.buttons = [];\n            for (let j = 0; j < message.buttons.length; ++j)\n                object.buttons[j] = $root.RelatedButton.toObject(message.buttons[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this RelatedButtons to JSON.\n     * @function toJSON\n     * @memberof RelatedButtons\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    RelatedButtons.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for RelatedButtons\n     * @function getTypeUrl\n     * @memberof RelatedButtons\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    RelatedButtons.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/RelatedButtons\";\n    };\n\n    return RelatedButtons;\n})();\n\nexport const Histogram = $root.Histogram = (() => {\n\n    /**\n     * Properties of a Histogram.\n     * @exports IHistogram\n     * @interface IHistogram\n     * @property {number|null} [binMin] Histogram binMin\n     * @property {number|null} [binSize] Histogram binSize\n     * @property {Array.<number>|null} [counts] Histogram counts\n     */\n\n    /**\n     * Constructs a new Histogram.\n     * @exports Histogram\n     * @classdesc Represents a Histogram.\n     * @implements IHistogram\n     * @constructor\n     * @param {IHistogram=} [properties] Properties to set\n     */\n    function Histogram(properties) {\n        this.counts = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Histogram binMin.\n     * @member {number} binMin\n     * @memberof Histogram\n     * @instance\n     */\n    Histogram.prototype.binMin = 0;\n\n    /**\n     * Histogram binSize.\n     * @member {number} binSize\n     * @memberof Histogram\n     * @instance\n     */\n    Histogram.prototype.binSize = 0;\n\n    /**\n     * Histogram counts.\n     * @member {Array.<number>} counts\n     * @memberof Histogram\n     * @instance\n     */\n    Histogram.prototype.counts = $util.emptyArray;\n\n    /**\n     * Creates a new Histogram instance using the specified properties.\n     * @function create\n     * @memberof Histogram\n     * @static\n     * @param {IHistogram=} [properties] Properties to set\n     * @returns {Histogram} Histogram instance\n     */\n    Histogram.create = function create(properties) {\n        return new Histogram(properties);\n    };\n\n    /**\n     * Encodes the specified Histogram message. Does not implicitly {@link Histogram.verify|verify} messages.\n     * @function encode\n     * @memberof Histogram\n     * @static\n     * @param {IHistogram} message Histogram message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Histogram.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.binMin != null && Object.hasOwnProperty.call(message, \"binMin\"))\n            writer.uint32(/* id 1, wireType 5 =*/13).float(message.binMin);\n        if (message.binSize != null && Object.hasOwnProperty.call(message, \"binSize\"))\n            writer.uint32(/* id 2, wireType 5 =*/21).float(message.binSize);\n        if (message.counts != null && message.counts.length) {\n            writer.uint32(/* id 3, wireType 2 =*/26).fork();\n            for (let i = 0; i < message.counts.length; ++i)\n                writer.int32(message.counts[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Histogram message, length delimited. Does not implicitly {@link Histogram.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Histogram\n     * @static\n     * @param {IHistogram} message Histogram message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Histogram.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Histogram message from the specified reader or buffer.\n     * @function decode\n     * @memberof Histogram\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Histogram} Histogram\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Histogram.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Histogram();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.binMin = reader.float();\n                    break;\n                }\n            case 2: {\n                    message.binSize = reader.float();\n                    break;\n                }\n            case 3: {\n                    if (!(message.counts && message.counts.length))\n                        message.counts = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.counts.push(reader.int32());\n                    } else\n                        message.counts.push(reader.int32());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Histogram message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Histogram\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Histogram} Histogram\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Histogram.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Histogram message.\n     * @function verify\n     * @memberof Histogram\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Histogram.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.binMin != null && message.hasOwnProperty(\"binMin\"))\n            if (typeof message.binMin !== \"number\")\n                return \"binMin: number expected\";\n        if (message.binSize != null && message.hasOwnProperty(\"binSize\"))\n            if (typeof message.binSize !== \"number\")\n                return \"binSize: number expected\";\n        if (message.counts != null && message.hasOwnProperty(\"counts\")) {\n            if (!Array.isArray(message.counts))\n                return \"counts: array expected\";\n            for (let i = 0; i < message.counts.length; ++i)\n                if (!$util.isInteger(message.counts[i]))\n                    return \"counts: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a Histogram message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Histogram\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Histogram} Histogram\n     */\n    Histogram.fromObject = function fromObject(object) {\n        if (object instanceof $root.Histogram)\n            return object;\n        let message = new $root.Histogram();\n        if (object.binMin != null)\n            message.binMin = Number(object.binMin);\n        if (object.binSize != null)\n            message.binSize = Number(object.binSize);\n        if (object.counts) {\n            if (!Array.isArray(object.counts))\n                throw TypeError(\".Histogram.counts: array expected\");\n            message.counts = [];\n            for (let i = 0; i < object.counts.length; ++i)\n                message.counts[i] = object.counts[i] | 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Histogram message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Histogram\n     * @static\n     * @param {Histogram} message Histogram\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Histogram.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.counts = [];\n        if (options.defaults) {\n            object.binMin = 0;\n            object.binSize = 0;\n        }\n        if (message.binMin != null && message.hasOwnProperty(\"binMin\"))\n            object.binMin = options.json && !isFinite(message.binMin) ? String(message.binMin) : message.binMin;\n        if (message.binSize != null && message.hasOwnProperty(\"binSize\"))\n            object.binSize = options.json && !isFinite(message.binSize) ? String(message.binSize) : message.binSize;\n        if (message.counts && message.counts.length) {\n            object.counts = [];\n            for (let j = 0; j < message.counts.length; ++j)\n                object.counts[j] = message.counts[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Histogram to JSON.\n     * @function toJSON\n     * @memberof Histogram\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Histogram.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for Histogram\n     * @function getTypeUrl\n     * @memberof Histogram\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    Histogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/Histogram\";\n    };\n\n    return Histogram;\n})();\n\nexport const TimeSeries = $root.TimeSeries = (() => {\n\n    /**\n     * Properties of a TimeSeries.\n     * @exports ITimeSeries\n     * @interface ITimeSeries\n     * @property {Array.<number>|null} [values] TimeSeries values\n     */\n\n    /**\n     * Constructs a new TimeSeries.\n     * @exports TimeSeries\n     * @classdesc Represents a TimeSeries.\n     * @implements ITimeSeries\n     * @constructor\n     * @param {ITimeSeries=} [properties] Properties to set\n     */\n    function TimeSeries(properties) {\n        this.values = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TimeSeries values.\n     * @member {Array.<number>} values\n     * @memberof TimeSeries\n     * @instance\n     */\n    TimeSeries.prototype.values = $util.emptyArray;\n\n    /**\n     * Creates a new TimeSeries instance using the specified properties.\n     * @function create\n     * @memberof TimeSeries\n     * @static\n     * @param {ITimeSeries=} [properties] Properties to set\n     * @returns {TimeSeries} TimeSeries instance\n     */\n    TimeSeries.create = function create(properties) {\n        return new TimeSeries(properties);\n    };\n\n    /**\n     * Encodes the specified TimeSeries message. Does not implicitly {@link TimeSeries.verify|verify} messages.\n     * @function encode\n     * @memberof TimeSeries\n     * @static\n     * @param {ITimeSeries} message TimeSeries message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TimeSeries.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.values != null && message.values.length) {\n            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n            for (let i = 0; i < message.values.length; ++i)\n                writer.float(message.values[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TimeSeries message, length delimited. Does not implicitly {@link TimeSeries.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TimeSeries\n     * @static\n     * @param {ITimeSeries} message TimeSeries message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TimeSeries.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TimeSeries message from the specified reader or buffer.\n     * @function decode\n     * @memberof TimeSeries\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TimeSeries} TimeSeries\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TimeSeries.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TimeSeries();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.values && message.values.length))\n                        message.values = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.values.push(reader.float());\n                    } else\n                        message.values.push(reader.float());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a TimeSeries message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TimeSeries\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TimeSeries} TimeSeries\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TimeSeries.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TimeSeries message.\n     * @function verify\n     * @memberof TimeSeries\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TimeSeries.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.values != null && message.hasOwnProperty(\"values\")) {\n            if (!Array.isArray(message.values))\n                return \"values: array expected\";\n            for (let i = 0; i < message.values.length; ++i)\n                if (typeof message.values[i] !== \"number\")\n                    return \"values: number[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a TimeSeries message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof TimeSeries\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {TimeSeries} TimeSeries\n     */\n    TimeSeries.fromObject = function fromObject(object) {\n        if (object instanceof $root.TimeSeries)\n            return object;\n        let message = new $root.TimeSeries();\n        if (object.values) {\n            if (!Array.isArray(object.values))\n                throw TypeError(\".TimeSeries.values: array expected\");\n            message.values = [];\n            for (let i = 0; i < object.values.length; ++i)\n                message.values[i] = Number(object.values[i]);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a TimeSeries message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TimeSeries\n     * @static\n     * @param {TimeSeries} message TimeSeries\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TimeSeries.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.values = [];\n        if (message.values && message.values.length) {\n            object.values = [];\n            for (let j = 0; j < message.values.length; ++j)\n                object.values[j] = options.json && !isFinite(message.values[j]) ? String(message.values[j]) : message.values[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this TimeSeries to JSON.\n     * @function toJSON\n     * @memberof TimeSeries\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TimeSeries.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TimeSeries\n     * @function getTypeUrl\n     * @memberof TimeSeries\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TimeSeries.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/TimeSeries\";\n    };\n\n    return TimeSeries;\n})();\n\nexport const TemperatureHistogram = $root.TemperatureHistogram = (() => {\n\n    /**\n     * Properties of a TemperatureHistogram.\n     * @exports ITemperatureHistogram\n     * @interface ITemperatureHistogram\n     * @property {Array.<number>|null} [counts] TemperatureHistogram counts\n     */\n\n    /**\n     * Constructs a new TemperatureHistogram.\n     * @exports TemperatureHistogram\n     * @classdesc Represents a TemperatureHistogram.\n     * @implements ITemperatureHistogram\n     * @constructor\n     * @param {ITemperatureHistogram=} [properties] Properties to set\n     */\n    function TemperatureHistogram(properties) {\n        this.counts = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TemperatureHistogram counts.\n     * @member {Array.<number>} counts\n     * @memberof TemperatureHistogram\n     * @instance\n     */\n    TemperatureHistogram.prototype.counts = $util.emptyArray;\n\n    /**\n     * Creates a new TemperatureHistogram instance using the specified properties.\n     * @function create\n     * @memberof TemperatureHistogram\n     * @static\n     * @param {ITemperatureHistogram=} [properties] Properties to set\n     * @returns {TemperatureHistogram} TemperatureHistogram instance\n     */\n    TemperatureHistogram.create = function create(properties) {\n        return new TemperatureHistogram(properties);\n    };\n\n    /**\n     * Encodes the specified TemperatureHistogram message. Does not implicitly {@link TemperatureHistogram.verify|verify} messages.\n     * @function encode\n     * @memberof TemperatureHistogram\n     * @static\n     * @param {ITemperatureHistogram} message TemperatureHistogram message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TemperatureHistogram.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.counts != null && message.counts.length) {\n            writer.uint32(/* id 4, wireType 2 =*/34).fork();\n            for (let i = 0; i < message.counts.length; ++i)\n                writer.int32(message.counts[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TemperatureHistogram message, length delimited. Does not implicitly {@link TemperatureHistogram.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TemperatureHistogram\n     * @static\n     * @param {ITemperatureHistogram} message TemperatureHistogram message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TemperatureHistogram.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TemperatureHistogram message from the specified reader or buffer.\n     * @function decode\n     * @memberof TemperatureHistogram\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TemperatureHistogram} TemperatureHistogram\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TemperatureHistogram.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TemperatureHistogram();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 4: {\n                    if (!(message.counts && message.counts.length))\n                        message.counts = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.counts.push(reader.int32());\n                    } else\n                        message.counts.push(reader.int32());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a TemperatureHistogram message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TemperatureHistogram\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TemperatureHistogram} TemperatureHistogram\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TemperatureHistogram.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TemperatureHistogram message.\n     * @function verify\n     * @memberof TemperatureHistogram\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TemperatureHistogram.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.counts != null && message.hasOwnProperty(\"counts\")) {\n            if (!Array.isArray(message.counts))\n                return \"counts: array expected\";\n            for (let i = 0; i < message.counts.length; ++i)\n                if (!$util.isInteger(message.counts[i]))\n                    return \"counts: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a TemperatureHistogram message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof TemperatureHistogram\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {TemperatureHistogram} TemperatureHistogram\n     */\n    TemperatureHistogram.fromObject = function fromObject(object) {\n        if (object instanceof $root.TemperatureHistogram)\n            return object;\n        let message = new $root.TemperatureHistogram();\n        if (object.counts) {\n            if (!Array.isArray(object.counts))\n                throw TypeError(\".TemperatureHistogram.counts: array expected\");\n            message.counts = [];\n            for (let i = 0; i < object.counts.length; ++i)\n                message.counts[i] = object.counts[i] | 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a TemperatureHistogram message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TemperatureHistogram\n     * @static\n     * @param {TemperatureHistogram} message TemperatureHistogram\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TemperatureHistogram.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.counts = [];\n        if (message.counts && message.counts.length) {\n            object.counts = [];\n            for (let j = 0; j < message.counts.length; ++j)\n                object.counts[j] = message.counts[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this TemperatureHistogram to JSON.\n     * @function toJSON\n     * @memberof TemperatureHistogram\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TemperatureHistogram.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TemperatureHistogram\n     * @function getTypeUrl\n     * @memberof TemperatureHistogram\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TemperatureHistogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/TemperatureHistogram\";\n    };\n\n    return TemperatureHistogram;\n})();\n\nexport const ExtraStatistic = $root.ExtraStatistic = (() => {\n\n    /**\n     * Properties of an ExtraStatistic.\n     * @exports IExtraStatistic\n     * @interface IExtraStatistic\n     * @property {IHistogram|null} [histogram] ExtraStatistic histogram\n     * @property {ITimeSeries|null} [timeseries] ExtraStatistic timeseries\n     * @property {ITemperatureHistogram|null} [temperatureHistogram] ExtraStatistic temperatureHistogram\n     */\n\n    /**\n     * Constructs a new ExtraStatistic.\n     * @exports ExtraStatistic\n     * @classdesc Represents an ExtraStatistic.\n     * @implements IExtraStatistic\n     * @constructor\n     * @param {IExtraStatistic=} [properties] Properties to set\n     */\n    function ExtraStatistic(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ExtraStatistic histogram.\n     * @member {IHistogram|null|undefined} histogram\n     * @memberof ExtraStatistic\n     * @instance\n     */\n    ExtraStatistic.prototype.histogram = null;\n\n    /**\n     * ExtraStatistic timeseries.\n     * @member {ITimeSeries|null|undefined} timeseries\n     * @memberof ExtraStatistic\n     * @instance\n     */\n    ExtraStatistic.prototype.timeseries = null;\n\n    /**\n     * ExtraStatistic temperatureHistogram.\n     * @member {ITemperatureHistogram|null|undefined} temperatureHistogram\n     * @memberof ExtraStatistic\n     * @instance\n     */\n    ExtraStatistic.prototype.temperatureHistogram = null;\n\n    // OneOf field names bound to virtual getters and setters\n    let $oneOfFields;\n\n    /**\n     * ExtraStatistic _histogram.\n     * @member {\"histogram\"|undefined} _histogram\n     * @memberof ExtraStatistic\n     * @instance\n     */\n    Object.defineProperty(ExtraStatistic.prototype, \"_histogram\", {\n        get: $util.oneOfGetter($oneOfFields = [\"histogram\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * ExtraStatistic _timeseries.\n     * @member {\"timeseries\"|undefined} _timeseries\n     * @memberof ExtraStatistic\n     * @instance\n     */\n    Object.defineProperty(ExtraStatistic.prototype, \"_timeseries\", {\n        get: $util.oneOfGetter($oneOfFields = [\"timeseries\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * ExtraStatistic _temperatureHistogram.\n     * @member {\"temperatureHistogram\"|undefined} _temperatureHistogram\n     * @memberof ExtraStatistic\n     * @instance\n     */\n    Object.defineProperty(ExtraStatistic.prototype, \"_temperatureHistogram\", {\n        get: $util.oneOfGetter($oneOfFields = [\"temperatureHistogram\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * Creates a new ExtraStatistic instance using the specified properties.\n     * @function create\n     * @memberof ExtraStatistic\n     * @static\n     * @param {IExtraStatistic=} [properties] Properties to set\n     * @returns {ExtraStatistic} ExtraStatistic instance\n     */\n    ExtraStatistic.create = function create(properties) {\n        return new ExtraStatistic(properties);\n    };\n\n    /**\n     * Encodes the specified ExtraStatistic message. Does not implicitly {@link ExtraStatistic.verify|verify} messages.\n     * @function encode\n     * @memberof ExtraStatistic\n     * @static\n     * @param {IExtraStatistic} message ExtraStatistic message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ExtraStatistic.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.histogram != null && Object.hasOwnProperty.call(message, \"histogram\"))\n            $root.Histogram.encode(message.histogram, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.timeseries != null && Object.hasOwnProperty.call(message, \"timeseries\"))\n            $root.TimeSeries.encode(message.timeseries, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.temperatureHistogram != null && Object.hasOwnProperty.call(message, \"temperatureHistogram\"))\n            $root.TemperatureHistogram.encode(message.temperatureHistogram, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ExtraStatistic message, length delimited. Does not implicitly {@link ExtraStatistic.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ExtraStatistic\n     * @static\n     * @param {IExtraStatistic} message ExtraStatistic message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ExtraStatistic.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an ExtraStatistic message from the specified reader or buffer.\n     * @function decode\n     * @memberof ExtraStatistic\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ExtraStatistic} ExtraStatistic\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ExtraStatistic.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExtraStatistic();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.histogram = $root.Histogram.decode(reader, reader.uint32());\n                    break;\n                }\n            case 2: {\n                    message.timeseries = $root.TimeSeries.decode(reader, reader.uint32());\n                    break;\n                }\n            case 3: {\n                    message.temperatureHistogram = $root.TemperatureHistogram.decode(reader, reader.uint32());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes an ExtraStatistic message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ExtraStatistic\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ExtraStatistic} ExtraStatistic\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ExtraStatistic.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an ExtraStatistic message.\n     * @function verify\n     * @memberof ExtraStatistic\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ExtraStatistic.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        let properties = {};\n        if (message.histogram != null && message.hasOwnProperty(\"histogram\")) {\n            properties._histogram = 1;\n            {\n                let error = $root.Histogram.verify(message.histogram);\n                if (error)\n                    return \"histogram.\" + error;\n            }\n        }\n        if (message.timeseries != null && message.hasOwnProperty(\"timeseries\")) {\n            properties._timeseries = 1;\n            {\n                let error = $root.TimeSeries.verify(message.timeseries);\n                if (error)\n                    return \"timeseries.\" + error;\n            }\n        }\n        if (message.temperatureHistogram != null && message.hasOwnProperty(\"temperatureHistogram\")) {\n            properties._temperatureHistogram = 1;\n            {\n                let error = $root.TemperatureHistogram.verify(message.temperatureHistogram);\n                if (error)\n                    return \"temperatureHistogram.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates an ExtraStatistic message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ExtraStatistic\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ExtraStatistic} ExtraStatistic\n     */\n    ExtraStatistic.fromObject = function fromObject(object) {\n        if (object instanceof $root.ExtraStatistic)\n            return object;\n        let message = new $root.ExtraStatistic();\n        if (object.histogram != null) {\n            if (typeof object.histogram !== \"object\")\n                throw TypeError(\".ExtraStatistic.histogram: object expected\");\n            message.histogram = $root.Histogram.fromObject(object.histogram);\n        }\n        if (object.timeseries != null) {\n            if (typeof object.timeseries !== \"object\")\n                throw TypeError(\".ExtraStatistic.timeseries: object expected\");\n            message.timeseries = $root.TimeSeries.fromObject(object.timeseries);\n        }\n        if (object.temperatureHistogram != null) {\n            if (typeof object.temperatureHistogram !== \"object\")\n                throw TypeError(\".ExtraStatistic.temperatureHistogram: object expected\");\n            message.temperatureHistogram = $root.TemperatureHistogram.fromObject(object.temperatureHistogram);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an ExtraStatistic message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ExtraStatistic\n     * @static\n     * @param {ExtraStatistic} message ExtraStatistic\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ExtraStatistic.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (message.histogram != null && message.hasOwnProperty(\"histogram\")) {\n            object.histogram = $root.Histogram.toObject(message.histogram, options);\n            if (options.oneofs)\n                object._histogram = \"histogram\";\n        }\n        if (message.timeseries != null && message.hasOwnProperty(\"timeseries\")) {\n            object.timeseries = $root.TimeSeries.toObject(message.timeseries, options);\n            if (options.oneofs)\n                object._timeseries = \"timeseries\";\n        }\n        if (message.temperatureHistogram != null && message.hasOwnProperty(\"temperatureHistogram\")) {\n            object.temperatureHistogram = $root.TemperatureHistogram.toObject(message.temperatureHistogram, options);\n            if (options.oneofs)\n                object._temperatureHistogram = \"temperatureHistogram\";\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ExtraStatistic to JSON.\n     * @function toJSON\n     * @memberof ExtraStatistic\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ExtraStatistic.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for ExtraStatistic\n     * @function getTypeUrl\n     * @memberof ExtraStatistic\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    ExtraStatistic.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/ExtraStatistic\";\n    };\n\n    return ExtraStatistic;\n})();\n\nexport const Metadata = $root.Metadata = (() => {\n\n    /**\n     * Properties of a Metadata.\n     * @exports IMetadata\n     * @interface IMetadata\n     * @property {number|null} [metadataIndex] Metadata metadataIndex\n     * @property {string|null} [stringValue] Metadata stringValue\n     */\n\n    /**\n     * Constructs a new Metadata.\n     * @exports Metadata\n     * @classdesc Represents a Metadata.\n     * @implements IMetadata\n     * @constructor\n     * @param {IMetadata=} [properties] Properties to set\n     */\n    function Metadata(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Metadata metadataIndex.\n     * @member {number} metadataIndex\n     * @memberof Metadata\n     * @instance\n     */\n    Metadata.prototype.metadataIndex = 0;\n\n    /**\n     * Metadata stringValue.\n     * @member {string|null|undefined} stringValue\n     * @memberof Metadata\n     * @instance\n     */\n    Metadata.prototype.stringValue = null;\n\n    // OneOf field names bound to virtual getters and setters\n    let $oneOfFields;\n\n    /**\n     * Metadata _stringValue.\n     * @member {\"stringValue\"|undefined} _stringValue\n     * @memberof Metadata\n     * @instance\n     */\n    Object.defineProperty(Metadata.prototype, \"_stringValue\", {\n        get: $util.oneOfGetter($oneOfFields = [\"stringValue\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * Creates a new Metadata instance using the specified properties.\n     * @function create\n     * @memberof Metadata\n     * @static\n     * @param {IMetadata=} [properties] Properties to set\n     * @returns {Metadata} Metadata instance\n     */\n    Metadata.create = function create(properties) {\n        return new Metadata(properties);\n    };\n\n    /**\n     * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.\n     * @function encode\n     * @memberof Metadata\n     * @static\n     * @param {IMetadata} message Metadata message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Metadata.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.metadataIndex != null && Object.hasOwnProperty.call(message, \"metadataIndex\"))\n            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.metadataIndex);\n        if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).string(message.stringValue);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Metadata message, length delimited. Does not implicitly {@link Metadata.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Metadata\n     * @static\n     * @param {IMetadata} message Metadata message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Metadata.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Metadata message from the specified reader or buffer.\n     * @function decode\n     * @memberof Metadata\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Metadata} Metadata\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Metadata.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Metadata();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.metadataIndex = reader.int32();\n                    break;\n                }\n            case 2: {\n                    message.stringValue = reader.string();\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Metadata message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Metadata\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Metadata} Metadata\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Metadata.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Metadata message.\n     * @function verify\n     * @memberof Metadata\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Metadata.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        let properties = {};\n        if (message.metadataIndex != null && message.hasOwnProperty(\"metadataIndex\"))\n            if (!$util.isInteger(message.metadataIndex))\n                return \"metadataIndex: integer expected\";\n        if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            properties._stringValue = 1;\n            if (!$util.isString(message.stringValue))\n                return \"stringValue: string expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a Metadata message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Metadata\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Metadata} Metadata\n     */\n    Metadata.fromObject = function fromObject(object) {\n        if (object instanceof $root.Metadata)\n            return object;\n        let message = new $root.Metadata();\n        if (object.metadataIndex != null)\n            message.metadataIndex = object.metadataIndex | 0;\n        if (object.stringValue != null)\n            message.stringValue = String(object.stringValue);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Metadata message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Metadata\n     * @static\n     * @param {Metadata} message Metadata\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Metadata.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults)\n            object.metadataIndex = 0;\n        if (message.metadataIndex != null && message.hasOwnProperty(\"metadataIndex\"))\n            object.metadataIndex = message.metadataIndex;\n        if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            object.stringValue = message.stringValue;\n            if (options.oneofs)\n                object._stringValue = \"stringValue\";\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Metadata to JSON.\n     * @function toJSON\n     * @memberof Metadata\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Metadata.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for Metadata\n     * @function getTypeUrl\n     * @memberof Metadata\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    Metadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/Metadata\";\n    };\n\n    return Metadata;\n})();\n\nexport const Article = $root.Article = (() => {\n\n    /**\n     * Properties of an Article.\n     * @exports IArticle\n     * @interface IArticle\n     * @property {string|null} [shortname] Article shortname\n     * @property {string|null} [longname] Article longname\n     * @property {string|null} [source] Article source\n     * @property {string|null} [articleType] Article articleType\n     * @property {Uint8Array|null} [statisticIndicesPacked] Article statisticIndicesPacked\n     * @property {Array.<IStatisticRow>|null} [rows] Article rows\n     * @property {Array.<IFirstOrLast>|null} [overallFirstOrLast] Article overallFirstOrLast\n     * @property {Array.<IRelatedButtons>|null} [related] Article related\n     * @property {Array.<string>|null} [universes] Article universes\n     * @property {Array.<IExtraStatistic>|null} [extraStats] Article extraStats\n     * @property {Array.<IMetadata>|null} [metadata] Article metadata\n     */\n\n    /**\n     * Constructs a new Article.\n     * @exports Article\n     * @classdesc Represents an Article.\n     * @implements IArticle\n     * @constructor\n     * @param {IArticle=} [properties] Properties to set\n     */\n    function Article(properties) {\n        this.rows = [];\n        this.overallFirstOrLast = [];\n        this.related = [];\n        this.universes = [];\n        this.extraStats = [];\n        this.metadata = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Article shortname.\n     * @member {string} shortname\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.shortname = \"\";\n\n    /**\n     * Article longname.\n     * @member {string} longname\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.longname = \"\";\n\n    /**\n     * Article source.\n     * @member {string} source\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.source = \"\";\n\n    /**\n     * Article articleType.\n     * @member {string} articleType\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.articleType = \"\";\n\n    /**\n     * Article statisticIndicesPacked.\n     * @member {Uint8Array} statisticIndicesPacked\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.statisticIndicesPacked = $util.newBuffer([]);\n\n    /**\n     * Article rows.\n     * @member {Array.<IStatisticRow>} rows\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.rows = $util.emptyArray;\n\n    /**\n     * Article overallFirstOrLast.\n     * @member {Array.<IFirstOrLast>} overallFirstOrLast\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.overallFirstOrLast = $util.emptyArray;\n\n    /**\n     * Article related.\n     * @member {Array.<IRelatedButtons>} related\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.related = $util.emptyArray;\n\n    /**\n     * Article universes.\n     * @member {Array.<string>} universes\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.universes = $util.emptyArray;\n\n    /**\n     * Article extraStats.\n     * @member {Array.<IExtraStatistic>} extraStats\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.extraStats = $util.emptyArray;\n\n    /**\n     * Article metadata.\n     * @member {Array.<IMetadata>} metadata\n     * @memberof Article\n     * @instance\n     */\n    Article.prototype.metadata = $util.emptyArray;\n\n    /**\n     * Creates a new Article instance using the specified properties.\n     * @function create\n     * @memberof Article\n     * @static\n     * @param {IArticle=} [properties] Properties to set\n     * @returns {Article} Article instance\n     */\n    Article.create = function create(properties) {\n        return new Article(properties);\n    };\n\n    /**\n     * Encodes the specified Article message. Does not implicitly {@link Article.verify|verify} messages.\n     * @function encode\n     * @memberof Article\n     * @static\n     * @param {IArticle} message Article message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Article.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.shortname != null && Object.hasOwnProperty.call(message, \"shortname\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).string(message.shortname);\n        if (message.longname != null && Object.hasOwnProperty.call(message, \"longname\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).string(message.longname);\n        if (message.source != null && Object.hasOwnProperty.call(message, \"source\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.source);\n        if (message.articleType != null && Object.hasOwnProperty.call(message, \"articleType\"))\n            writer.uint32(/* id 4, wireType 2 =*/34).string(message.articleType);\n        if (message.rows != null && message.rows.length)\n            for (let i = 0; i < message.rows.length; ++i)\n                $root.StatisticRow.encode(message.rows[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n        if (message.related != null && message.related.length)\n            for (let i = 0; i < message.related.length; ++i)\n                $root.RelatedButtons.encode(message.related[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n        if (message.universes != null && message.universes.length)\n            for (let i = 0; i < message.universes.length; ++i)\n                writer.uint32(/* id 7, wireType 2 =*/58).string(message.universes[i]);\n        if (message.extraStats != null && message.extraStats.length)\n            for (let i = 0; i < message.extraStats.length; ++i)\n                $root.ExtraStatistic.encode(message.extraStats[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n        if (message.statisticIndicesPacked != null && Object.hasOwnProperty.call(message, \"statisticIndicesPacked\"))\n            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.statisticIndicesPacked);\n        if (message.overallFirstOrLast != null && message.overallFirstOrLast.length)\n            for (let i = 0; i < message.overallFirstOrLast.length; ++i)\n                $root.FirstOrLast.encode(message.overallFirstOrLast[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n        if (message.metadata != null && message.metadata.length)\n            for (let i = 0; i < message.metadata.length; ++i)\n                $root.Metadata.encode(message.metadata[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Article message, length delimited. Does not implicitly {@link Article.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Article\n     * @static\n     * @param {IArticle} message Article message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Article.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an Article message from the specified reader or buffer.\n     * @function decode\n     * @memberof Article\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Article} Article\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Article.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Article();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.shortname = reader.string();\n                    break;\n                }\n            case 2: {\n                    message.longname = reader.string();\n                    break;\n                }\n            case 3: {\n                    message.source = reader.string();\n                    break;\n                }\n            case 4: {\n                    message.articleType = reader.string();\n                    break;\n                }\n            case 9: {\n                    message.statisticIndicesPacked = reader.bytes();\n                    break;\n                }\n            case 5: {\n                    if (!(message.rows && message.rows.length))\n                        message.rows = [];\n                    message.rows.push($root.StatisticRow.decode(reader, reader.uint32()));\n                    break;\n                }\n            case 10: {\n                    if (!(message.overallFirstOrLast && message.overallFirstOrLast.length))\n                        message.overallFirstOrLast = [];\n                    message.overallFirstOrLast.push($root.FirstOrLast.decode(reader, reader.uint32()));\n                    break;\n                }\n            case 6: {\n                    if (!(message.related && message.related.length))\n                        message.related = [];\n                    message.related.push($root.RelatedButtons.decode(reader, reader.uint32()));\n                    break;\n                }\n            case 7: {\n                    if (!(message.universes && message.universes.length))\n                        message.universes = [];\n                    message.universes.push(reader.string());\n                    break;\n                }\n            case 8: {\n                    if (!(message.extraStats && message.extraStats.length))\n                        message.extraStats = [];\n                    message.extraStats.push($root.ExtraStatistic.decode(reader, reader.uint32()));\n                    break;\n                }\n            case 11: {\n                    if (!(message.metadata && message.metadata.length))\n                        message.metadata = [];\n                    message.metadata.push($root.Metadata.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes an Article message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Article\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Article} Article\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Article.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an Article message.\n     * @function verify\n     * @memberof Article\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Article.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.shortname != null && message.hasOwnProperty(\"shortname\"))\n            if (!$util.isString(message.shortname))\n                return \"shortname: string expected\";\n        if (message.longname != null && message.hasOwnProperty(\"longname\"))\n            if (!$util.isString(message.longname))\n                return \"longname: string expected\";\n        if (message.source != null && message.hasOwnProperty(\"source\"))\n            if (!$util.isString(message.source))\n                return \"source: string expected\";\n        if (message.articleType != null && message.hasOwnProperty(\"articleType\"))\n            if (!$util.isString(message.articleType))\n                return \"articleType: string expected\";\n        if (message.statisticIndicesPacked != null && message.hasOwnProperty(\"statisticIndicesPacked\"))\n            if (!(message.statisticIndicesPacked && typeof message.statisticIndicesPacked.length === \"number\" || $util.isString(message.statisticIndicesPacked)))\n                return \"statisticIndicesPacked: buffer expected\";\n        if (message.rows != null && message.hasOwnProperty(\"rows\")) {\n            if (!Array.isArray(message.rows))\n                return \"rows: array expected\";\n            for (let i = 0; i < message.rows.length; ++i) {\n                let error = $root.StatisticRow.verify(message.rows[i]);\n                if (error)\n                    return \"rows.\" + error;\n            }\n        }\n        if (message.overallFirstOrLast != null && message.hasOwnProperty(\"overallFirstOrLast\")) {\n            if (!Array.isArray(message.overallFirstOrLast))\n                return \"overallFirstOrLast: array expected\";\n            for (let i = 0; i < message.overallFirstOrLast.length; ++i) {\n                let error = $root.FirstOrLast.verify(message.overallFirstOrLast[i]);\n                if (error)\n                    return \"overallFirstOrLast.\" + error;\n            }\n        }\n        if (message.related != null && message.hasOwnProperty(\"related\")) {\n            if (!Array.isArray(message.related))\n                return \"related: array expected\";\n            for (let i = 0; i < message.related.length; ++i) {\n                let error = $root.RelatedButtons.verify(message.related[i]);\n                if (error)\n                    return \"related.\" + error;\n            }\n        }\n        if (message.universes != null && message.hasOwnProperty(\"universes\")) {\n            if (!Array.isArray(message.universes))\n                return \"universes: array expected\";\n            for (let i = 0; i < message.universes.length; ++i)\n                if (!$util.isString(message.universes[i]))\n                    return \"universes: string[] expected\";\n        }\n        if (message.extraStats != null && message.hasOwnProperty(\"extraStats\")) {\n            if (!Array.isArray(message.extraStats))\n                return \"extraStats: array expected\";\n            for (let i = 0; i < message.extraStats.length; ++i) {\n                let error = $root.ExtraStatistic.verify(message.extraStats[i]);\n                if (error)\n                    return \"extraStats.\" + error;\n            }\n        }\n        if (message.metadata != null && message.hasOwnProperty(\"metadata\")) {\n            if (!Array.isArray(message.metadata))\n                return \"metadata: array expected\";\n            for (let i = 0; i < message.metadata.length; ++i) {\n                let error = $root.Metadata.verify(message.metadata[i]);\n                if (error)\n                    return \"metadata.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates an Article message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Article\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Article} Article\n     */\n    Article.fromObject = function fromObject(object) {\n        if (object instanceof $root.Article)\n            return object;\n        let message = new $root.Article();\n        if (object.shortname != null)\n            message.shortname = String(object.shortname);\n        if (object.longname != null)\n            message.longname = String(object.longname);\n        if (object.source != null)\n            message.source = String(object.source);\n        if (object.articleType != null)\n            message.articleType = String(object.articleType);\n        if (object.statisticIndicesPacked != null)\n            if (typeof object.statisticIndicesPacked === \"string\")\n                $util.base64.decode(object.statisticIndicesPacked, message.statisticIndicesPacked = $util.newBuffer($util.base64.length(object.statisticIndicesPacked)), 0);\n            else if (object.statisticIndicesPacked.length >= 0)\n                message.statisticIndicesPacked = object.statisticIndicesPacked;\n        if (object.rows) {\n            if (!Array.isArray(object.rows))\n                throw TypeError(\".Article.rows: array expected\");\n            message.rows = [];\n            for (let i = 0; i < object.rows.length; ++i) {\n                if (typeof object.rows[i] !== \"object\")\n                    throw TypeError(\".Article.rows: object expected\");\n                message.rows[i] = $root.StatisticRow.fromObject(object.rows[i]);\n            }\n        }\n        if (object.overallFirstOrLast) {\n            if (!Array.isArray(object.overallFirstOrLast))\n                throw TypeError(\".Article.overallFirstOrLast: array expected\");\n            message.overallFirstOrLast = [];\n            for (let i = 0; i < object.overallFirstOrLast.length; ++i) {\n                if (typeof object.overallFirstOrLast[i] !== \"object\")\n                    throw TypeError(\".Article.overallFirstOrLast: object expected\");\n                message.overallFirstOrLast[i] = $root.FirstOrLast.fromObject(object.overallFirstOrLast[i]);\n            }\n        }\n        if (object.related) {\n            if (!Array.isArray(object.related))\n                throw TypeError(\".Article.related: array expected\");\n            message.related = [];\n            for (let i = 0; i < object.related.length; ++i) {\n                if (typeof object.related[i] !== \"object\")\n                    throw TypeError(\".Article.related: object expected\");\n                message.related[i] = $root.RelatedButtons.fromObject(object.related[i]);\n            }\n        }\n        if (object.universes) {\n            if (!Array.isArray(object.universes))\n                throw TypeError(\".Article.universes: array expected\");\n            message.universes = [];\n            for (let i = 0; i < object.universes.length; ++i)\n                message.universes[i] = String(object.universes[i]);\n        }\n        if (object.extraStats) {\n            if (!Array.isArray(object.extraStats))\n                throw TypeError(\".Article.extraStats: array expected\");\n            message.extraStats = [];\n            for (let i = 0; i < object.extraStats.length; ++i) {\n                if (typeof object.extraStats[i] !== \"object\")\n                    throw TypeError(\".Article.extraStats: object expected\");\n                message.extraStats[i] = $root.ExtraStatistic.fromObject(object.extraStats[i]);\n            }\n        }\n        if (object.metadata) {\n            if (!Array.isArray(object.metadata))\n                throw TypeError(\".Article.metadata: array expected\");\n            message.metadata = [];\n            for (let i = 0; i < object.metadata.length; ++i) {\n                if (typeof object.metadata[i] !== \"object\")\n                    throw TypeError(\".Article.metadata: object expected\");\n                message.metadata[i] = $root.Metadata.fromObject(object.metadata[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an Article message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Article\n     * @static\n     * @param {Article} message Article\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Article.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.rows = [];\n            object.related = [];\n            object.universes = [];\n            object.extraStats = [];\n            object.overallFirstOrLast = [];\n            object.metadata = [];\n        }\n        if (options.defaults) {\n            object.shortname = \"\";\n            object.longname = \"\";\n            object.source = \"\";\n            object.articleType = \"\";\n            if (options.bytes === String)\n                object.statisticIndicesPacked = \"\";\n            else {\n                object.statisticIndicesPacked = [];\n                if (options.bytes !== Array)\n                    object.statisticIndicesPacked = $util.newBuffer(object.statisticIndicesPacked);\n            }\n        }\n        if (message.shortname != null && message.hasOwnProperty(\"shortname\"))\n            object.shortname = message.shortname;\n        if (message.longname != null && message.hasOwnProperty(\"longname\"))\n            object.longname = message.longname;\n        if (message.source != null && message.hasOwnProperty(\"source\"))\n            object.source = message.source;\n        if (message.articleType != null && message.hasOwnProperty(\"articleType\"))\n            object.articleType = message.articleType;\n        if (message.rows && message.rows.length) {\n            object.rows = [];\n            for (let j = 0; j < message.rows.length; ++j)\n                object.rows[j] = $root.StatisticRow.toObject(message.rows[j], options);\n        }\n        if (message.related && message.related.length) {\n            object.related = [];\n            for (let j = 0; j < message.related.length; ++j)\n                object.related[j] = $root.RelatedButtons.toObject(message.related[j], options);\n        }\n        if (message.universes && message.universes.length) {\n            object.universes = [];\n            for (let j = 0; j < message.universes.length; ++j)\n                object.universes[j] = message.universes[j];\n        }\n        if (message.extraStats && message.extraStats.length) {\n            object.extraStats = [];\n            for (let j = 0; j < message.extraStats.length; ++j)\n                object.extraStats[j] = $root.ExtraStatistic.toObject(message.extraStats[j], options);\n        }\n        if (message.statisticIndicesPacked != null && message.hasOwnProperty(\"statisticIndicesPacked\"))\n            object.statisticIndicesPacked = options.bytes === String ? $util.base64.encode(message.statisticIndicesPacked, 0, message.statisticIndicesPacked.length) : options.bytes === Array ? Array.prototype.slice.call(message.statisticIndicesPacked) : message.statisticIndicesPacked;\n        if (message.overallFirstOrLast && message.overallFirstOrLast.length) {\n            object.overallFirstOrLast = [];\n            for (let j = 0; j < message.overallFirstOrLast.length; ++j)\n                object.overallFirstOrLast[j] = $root.FirstOrLast.toObject(message.overallFirstOrLast[j], options);\n        }\n        if (message.metadata && message.metadata.length) {\n            object.metadata = [];\n            for (let j = 0; j < message.metadata.length; ++j)\n                object.metadata[j] = $root.Metadata.toObject(message.metadata[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Article to JSON.\n     * @function toJSON\n     * @memberof Article\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Article.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for Article\n     * @function getTypeUrl\n     * @memberof Article\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    Article.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/Article\";\n    };\n\n    return Article;\n})();\n\nexport const Coordinate = $root.Coordinate = (() => {\n\n    /**\n     * Properties of a Coordinate.\n     * @exports ICoordinate\n     * @interface ICoordinate\n     * @property {number|null} [lon] Coordinate lon\n     * @property {number|null} [lat] Coordinate lat\n     */\n\n    /**\n     * Constructs a new Coordinate.\n     * @exports Coordinate\n     * @classdesc Represents a Coordinate.\n     * @implements ICoordinate\n     * @constructor\n     * @param {ICoordinate=} [properties] Properties to set\n     */\n    function Coordinate(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Coordinate lon.\n     * @member {number} lon\n     * @memberof Coordinate\n     * @instance\n     */\n    Coordinate.prototype.lon = 0;\n\n    /**\n     * Coordinate lat.\n     * @member {number} lat\n     * @memberof Coordinate\n     * @instance\n     */\n    Coordinate.prototype.lat = 0;\n\n    /**\n     * Creates a new Coordinate instance using the specified properties.\n     * @function create\n     * @memberof Coordinate\n     * @static\n     * @param {ICoordinate=} [properties] Properties to set\n     * @returns {Coordinate} Coordinate instance\n     */\n    Coordinate.create = function create(properties) {\n        return new Coordinate(properties);\n    };\n\n    /**\n     * Encodes the specified Coordinate message. Does not implicitly {@link Coordinate.verify|verify} messages.\n     * @function encode\n     * @memberof Coordinate\n     * @static\n     * @param {ICoordinate} message Coordinate message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Coordinate.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.lon != null && Object.hasOwnProperty.call(message, \"lon\"))\n            writer.uint32(/* id 1, wireType 5 =*/13).float(message.lon);\n        if (message.lat != null && Object.hasOwnProperty.call(message, \"lat\"))\n            writer.uint32(/* id 2, wireType 5 =*/21).float(message.lat);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Coordinate message, length delimited. Does not implicitly {@link Coordinate.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Coordinate\n     * @static\n     * @param {ICoordinate} message Coordinate message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Coordinate.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Coordinate message from the specified reader or buffer.\n     * @function decode\n     * @memberof Coordinate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Coordinate} Coordinate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Coordinate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Coordinate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.lon = reader.float();\n                    break;\n                }\n            case 2: {\n                    message.lat = reader.float();\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Coordinate message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Coordinate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Coordinate} Coordinate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Coordinate.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Coordinate message.\n     * @function verify\n     * @memberof Coordinate\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Coordinate.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.lon != null && message.hasOwnProperty(\"lon\"))\n            if (typeof message.lon !== \"number\")\n                return \"lon: number expected\";\n        if (message.lat != null && message.hasOwnProperty(\"lat\"))\n            if (typeof message.lat !== \"number\")\n                return \"lat: number expected\";\n        return null;\n    };\n\n    /**\n     * Creates a Coordinate message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Coordinate\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Coordinate} Coordinate\n     */\n    Coordinate.fromObject = function fromObject(object) {\n        if (object instanceof $root.Coordinate)\n            return object;\n        let message = new $root.Coordinate();\n        if (object.lon != null)\n            message.lon = Number(object.lon);\n        if (object.lat != null)\n            message.lat = Number(object.lat);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Coordinate message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Coordinate\n     * @static\n     * @param {Coordinate} message Coordinate\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Coordinate.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.lon = 0;\n            object.lat = 0;\n        }\n        if (message.lon != null && message.hasOwnProperty(\"lon\"))\n            object.lon = options.json && !isFinite(message.lon) ? String(message.lon) : message.lon;\n        if (message.lat != null && message.hasOwnProperty(\"lat\"))\n            object.lat = options.json && !isFinite(message.lat) ? String(message.lat) : message.lat;\n        return object;\n    };\n\n    /**\n     * Converts this Coordinate to JSON.\n     * @function toJSON\n     * @memberof Coordinate\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Coordinate.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for Coordinate\n     * @function getTypeUrl\n     * @memberof Coordinate\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    Coordinate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/Coordinate\";\n    };\n\n    return Coordinate;\n})();\n\nexport const Ring = $root.Ring = (() => {\n\n    /**\n     * Properties of a Ring.\n     * @exports IRing\n     * @interface IRing\n     * @property {Array.<ICoordinate>|null} [coords] Ring coords\n     */\n\n    /**\n     * Constructs a new Ring.\n     * @exports Ring\n     * @classdesc Represents a Ring.\n     * @implements IRing\n     * @constructor\n     * @param {IRing=} [properties] Properties to set\n     */\n    function Ring(properties) {\n        this.coords = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Ring coords.\n     * @member {Array.<ICoordinate>} coords\n     * @memberof Ring\n     * @instance\n     */\n    Ring.prototype.coords = $util.emptyArray;\n\n    /**\n     * Creates a new Ring instance using the specified properties.\n     * @function create\n     * @memberof Ring\n     * @static\n     * @param {IRing=} [properties] Properties to set\n     * @returns {Ring} Ring instance\n     */\n    Ring.create = function create(properties) {\n        return new Ring(properties);\n    };\n\n    /**\n     * Encodes the specified Ring message. Does not implicitly {@link Ring.verify|verify} messages.\n     * @function encode\n     * @memberof Ring\n     * @static\n     * @param {IRing} message Ring message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Ring.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.coords != null && message.coords.length)\n            for (let i = 0; i < message.coords.length; ++i)\n                $root.Coordinate.encode(message.coords[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Ring message, length delimited. Does not implicitly {@link Ring.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Ring\n     * @static\n     * @param {IRing} message Ring message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Ring.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Ring message from the specified reader or buffer.\n     * @function decode\n     * @memberof Ring\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Ring} Ring\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Ring.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ring();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.coords && message.coords.length))\n                        message.coords = [];\n                    message.coords.push($root.Coordinate.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Ring message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Ring\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Ring} Ring\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Ring.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Ring message.\n     * @function verify\n     * @memberof Ring\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Ring.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.coords != null && message.hasOwnProperty(\"coords\")) {\n            if (!Array.isArray(message.coords))\n                return \"coords: array expected\";\n            for (let i = 0; i < message.coords.length; ++i) {\n                let error = $root.Coordinate.verify(message.coords[i]);\n                if (error)\n                    return \"coords.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a Ring message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Ring\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Ring} Ring\n     */\n    Ring.fromObject = function fromObject(object) {\n        if (object instanceof $root.Ring)\n            return object;\n        let message = new $root.Ring();\n        if (object.coords) {\n            if (!Array.isArray(object.coords))\n                throw TypeError(\".Ring.coords: array expected\");\n            message.coords = [];\n            for (let i = 0; i < object.coords.length; ++i) {\n                if (typeof object.coords[i] !== \"object\")\n                    throw TypeError(\".Ring.coords: object expected\");\n                message.coords[i] = $root.Coordinate.fromObject(object.coords[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Ring message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Ring\n     * @static\n     * @param {Ring} message Ring\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Ring.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.coords = [];\n        if (message.coords && message.coords.length) {\n            object.coords = [];\n            for (let j = 0; j < message.coords.length; ++j)\n                object.coords[j] = $root.Coordinate.toObject(message.coords[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Ring to JSON.\n     * @function toJSON\n     * @memberof Ring\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Ring.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for Ring\n     * @function getTypeUrl\n     * @memberof Ring\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    Ring.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/Ring\";\n    };\n\n    return Ring;\n})();\n\nexport const Polygon = $root.Polygon = (() => {\n\n    /**\n     * Properties of a Polygon.\n     * @exports IPolygon\n     * @interface IPolygon\n     * @property {Array.<IRing>|null} [rings] Polygon rings\n     */\n\n    /**\n     * Constructs a new Polygon.\n     * @exports Polygon\n     * @classdesc Represents a Polygon.\n     * @implements IPolygon\n     * @constructor\n     * @param {IPolygon=} [properties] Properties to set\n     */\n    function Polygon(properties) {\n        this.rings = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Polygon rings.\n     * @member {Array.<IRing>} rings\n     * @memberof Polygon\n     * @instance\n     */\n    Polygon.prototype.rings = $util.emptyArray;\n\n    /**\n     * Creates a new Polygon instance using the specified properties.\n     * @function create\n     * @memberof Polygon\n     * @static\n     * @param {IPolygon=} [properties] Properties to set\n     * @returns {Polygon} Polygon instance\n     */\n    Polygon.create = function create(properties) {\n        return new Polygon(properties);\n    };\n\n    /**\n     * Encodes the specified Polygon message. Does not implicitly {@link Polygon.verify|verify} messages.\n     * @function encode\n     * @memberof Polygon\n     * @static\n     * @param {IPolygon} message Polygon message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Polygon.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.rings != null && message.rings.length)\n            for (let i = 0; i < message.rings.length; ++i)\n                $root.Ring.encode(message.rings[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Polygon message, length delimited. Does not implicitly {@link Polygon.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Polygon\n     * @static\n     * @param {IPolygon} message Polygon message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Polygon.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Polygon message from the specified reader or buffer.\n     * @function decode\n     * @memberof Polygon\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Polygon} Polygon\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Polygon.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Polygon();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.rings && message.rings.length))\n                        message.rings = [];\n                    message.rings.push($root.Ring.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Polygon message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Polygon\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Polygon} Polygon\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Polygon.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Polygon message.\n     * @function verify\n     * @memberof Polygon\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Polygon.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.rings != null && message.hasOwnProperty(\"rings\")) {\n            if (!Array.isArray(message.rings))\n                return \"rings: array expected\";\n            for (let i = 0; i < message.rings.length; ++i) {\n                let error = $root.Ring.verify(message.rings[i]);\n                if (error)\n                    return \"rings.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a Polygon message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Polygon\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Polygon} Polygon\n     */\n    Polygon.fromObject = function fromObject(object) {\n        if (object instanceof $root.Polygon)\n            return object;\n        let message = new $root.Polygon();\n        if (object.rings) {\n            if (!Array.isArray(object.rings))\n                throw TypeError(\".Polygon.rings: array expected\");\n            message.rings = [];\n            for (let i = 0; i < object.rings.length; ++i) {\n                if (typeof object.rings[i] !== \"object\")\n                    throw TypeError(\".Polygon.rings: object expected\");\n                message.rings[i] = $root.Ring.fromObject(object.rings[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Polygon message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Polygon\n     * @static\n     * @param {Polygon} message Polygon\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Polygon.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.rings = [];\n        if (message.rings && message.rings.length) {\n            object.rings = [];\n            for (let j = 0; j < message.rings.length; ++j)\n                object.rings[j] = $root.Ring.toObject(message.rings[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Polygon to JSON.\n     * @function toJSON\n     * @memberof Polygon\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Polygon.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for Polygon\n     * @function getTypeUrl\n     * @memberof Polygon\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    Polygon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/Polygon\";\n    };\n\n    return Polygon;\n})();\n\nexport const MultiPolygon = $root.MultiPolygon = (() => {\n\n    /**\n     * Properties of a MultiPolygon.\n     * @exports IMultiPolygon\n     * @interface IMultiPolygon\n     * @property {Array.<IPolygon>|null} [polygons] MultiPolygon polygons\n     */\n\n    /**\n     * Constructs a new MultiPolygon.\n     * @exports MultiPolygon\n     * @classdesc Represents a MultiPolygon.\n     * @implements IMultiPolygon\n     * @constructor\n     * @param {IMultiPolygon=} [properties] Properties to set\n     */\n    function MultiPolygon(properties) {\n        this.polygons = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * MultiPolygon polygons.\n     * @member {Array.<IPolygon>} polygons\n     * @memberof MultiPolygon\n     * @instance\n     */\n    MultiPolygon.prototype.polygons = $util.emptyArray;\n\n    /**\n     * Creates a new MultiPolygon instance using the specified properties.\n     * @function create\n     * @memberof MultiPolygon\n     * @static\n     * @param {IMultiPolygon=} [properties] Properties to set\n     * @returns {MultiPolygon} MultiPolygon instance\n     */\n    MultiPolygon.create = function create(properties) {\n        return new MultiPolygon(properties);\n    };\n\n    /**\n     * Encodes the specified MultiPolygon message. Does not implicitly {@link MultiPolygon.verify|verify} messages.\n     * @function encode\n     * @memberof MultiPolygon\n     * @static\n     * @param {IMultiPolygon} message MultiPolygon message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MultiPolygon.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.polygons != null && message.polygons.length)\n            for (let i = 0; i < message.polygons.length; ++i)\n                $root.Polygon.encode(message.polygons[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified MultiPolygon message, length delimited. Does not implicitly {@link MultiPolygon.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof MultiPolygon\n     * @static\n     * @param {IMultiPolygon} message MultiPolygon message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MultiPolygon.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a MultiPolygon message from the specified reader or buffer.\n     * @function decode\n     * @memberof MultiPolygon\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {MultiPolygon} MultiPolygon\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MultiPolygon.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MultiPolygon();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.polygons && message.polygons.length))\n                        message.polygons = [];\n                    message.polygons.push($root.Polygon.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a MultiPolygon message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof MultiPolygon\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {MultiPolygon} MultiPolygon\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MultiPolygon.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a MultiPolygon message.\n     * @function verify\n     * @memberof MultiPolygon\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    MultiPolygon.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.polygons != null && message.hasOwnProperty(\"polygons\")) {\n            if (!Array.isArray(message.polygons))\n                return \"polygons: array expected\";\n            for (let i = 0; i < message.polygons.length; ++i) {\n                let error = $root.Polygon.verify(message.polygons[i]);\n                if (error)\n                    return \"polygons.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a MultiPolygon message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof MultiPolygon\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {MultiPolygon} MultiPolygon\n     */\n    MultiPolygon.fromObject = function fromObject(object) {\n        if (object instanceof $root.MultiPolygon)\n            return object;\n        let message = new $root.MultiPolygon();\n        if (object.polygons) {\n            if (!Array.isArray(object.polygons))\n                throw TypeError(\".MultiPolygon.polygons: array expected\");\n            message.polygons = [];\n            for (let i = 0; i < object.polygons.length; ++i) {\n                if (typeof object.polygons[i] !== \"object\")\n                    throw TypeError(\".MultiPolygon.polygons: object expected\");\n                message.polygons[i] = $root.Polygon.fromObject(object.polygons[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a MultiPolygon message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof MultiPolygon\n     * @static\n     * @param {MultiPolygon} message MultiPolygon\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    MultiPolygon.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.polygons = [];\n        if (message.polygons && message.polygons.length) {\n            object.polygons = [];\n            for (let j = 0; j < message.polygons.length; ++j)\n                object.polygons[j] = $root.Polygon.toObject(message.polygons[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this MultiPolygon to JSON.\n     * @function toJSON\n     * @memberof MultiPolygon\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    MultiPolygon.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for MultiPolygon\n     * @function getTypeUrl\n     * @memberof MultiPolygon\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    MultiPolygon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/MultiPolygon\";\n    };\n\n    return MultiPolygon;\n})();\n\nexport const Feature = $root.Feature = (() => {\n\n    /**\n     * Properties of a Feature.\n     * @exports IFeature\n     * @interface IFeature\n     * @property {IPolygon|null} [polygon] Feature polygon\n     * @property {IMultiPolygon|null} [multipolygon] Feature multipolygon\n     * @property {Array.<number>|null} [zones] Feature zones\n     * @property {number|null} [centerLon] Feature centerLon\n     */\n\n    /**\n     * Constructs a new Feature.\n     * @exports Feature\n     * @classdesc Represents a Feature.\n     * @implements IFeature\n     * @constructor\n     * @param {IFeature=} [properties] Properties to set\n     */\n    function Feature(properties) {\n        this.zones = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Feature polygon.\n     * @member {IPolygon|null|undefined} polygon\n     * @memberof Feature\n     * @instance\n     */\n    Feature.prototype.polygon = null;\n\n    /**\n     * Feature multipolygon.\n     * @member {IMultiPolygon|null|undefined} multipolygon\n     * @memberof Feature\n     * @instance\n     */\n    Feature.prototype.multipolygon = null;\n\n    /**\n     * Feature zones.\n     * @member {Array.<number>} zones\n     * @memberof Feature\n     * @instance\n     */\n    Feature.prototype.zones = $util.emptyArray;\n\n    /**\n     * Feature centerLon.\n     * @member {number} centerLon\n     * @memberof Feature\n     * @instance\n     */\n    Feature.prototype.centerLon = 0;\n\n    // OneOf field names bound to virtual getters and setters\n    let $oneOfFields;\n\n    /**\n     * Feature geometry.\n     * @member {\"polygon\"|\"multipolygon\"|undefined} geometry\n     * @memberof Feature\n     * @instance\n     */\n    Object.defineProperty(Feature.prototype, \"geometry\", {\n        get: $util.oneOfGetter($oneOfFields = [\"polygon\", \"multipolygon\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * Creates a new Feature instance using the specified properties.\n     * @function create\n     * @memberof Feature\n     * @static\n     * @param {IFeature=} [properties] Properties to set\n     * @returns {Feature} Feature instance\n     */\n    Feature.create = function create(properties) {\n        return new Feature(properties);\n    };\n\n    /**\n     * Encodes the specified Feature message. Does not implicitly {@link Feature.verify|verify} messages.\n     * @function encode\n     * @memberof Feature\n     * @static\n     * @param {IFeature} message Feature message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Feature.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.polygon != null && Object.hasOwnProperty.call(message, \"polygon\"))\n            $root.Polygon.encode(message.polygon, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.multipolygon != null && Object.hasOwnProperty.call(message, \"multipolygon\"))\n            $root.MultiPolygon.encode(message.multipolygon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.zones != null && message.zones.length) {\n            writer.uint32(/* id 3, wireType 2 =*/26).fork();\n            for (let i = 0; i < message.zones.length; ++i)\n                writer.int32(message.zones[i]);\n            writer.ldelim();\n        }\n        if (message.centerLon != null && Object.hasOwnProperty.call(message, \"centerLon\"))\n            writer.uint32(/* id 4, wireType 5 =*/37).float(message.centerLon);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Feature message, length delimited. Does not implicitly {@link Feature.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Feature\n     * @static\n     * @param {IFeature} message Feature message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Feature.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Feature message from the specified reader or buffer.\n     * @function decode\n     * @memberof Feature\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Feature} Feature\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Feature.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Feature();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.polygon = $root.Polygon.decode(reader, reader.uint32());\n                    break;\n                }\n            case 2: {\n                    message.multipolygon = $root.MultiPolygon.decode(reader, reader.uint32());\n                    break;\n                }\n            case 3: {\n                    if (!(message.zones && message.zones.length))\n                        message.zones = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.zones.push(reader.int32());\n                    } else\n                        message.zones.push(reader.int32());\n                    break;\n                }\n            case 4: {\n                    message.centerLon = reader.float();\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Feature message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Feature\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Feature} Feature\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Feature.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Feature message.\n     * @function verify\n     * @memberof Feature\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Feature.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        let properties = {};\n        if (message.polygon != null && message.hasOwnProperty(\"polygon\")) {\n            properties.geometry = 1;\n            {\n                let error = $root.Polygon.verify(message.polygon);\n                if (error)\n                    return \"polygon.\" + error;\n            }\n        }\n        if (message.multipolygon != null && message.hasOwnProperty(\"multipolygon\")) {\n            if (properties.geometry === 1)\n                return \"geometry: multiple values\";\n            properties.geometry = 1;\n            {\n                let error = $root.MultiPolygon.verify(message.multipolygon);\n                if (error)\n                    return \"multipolygon.\" + error;\n            }\n        }\n        if (message.zones != null && message.hasOwnProperty(\"zones\")) {\n            if (!Array.isArray(message.zones))\n                return \"zones: array expected\";\n            for (let i = 0; i < message.zones.length; ++i)\n                if (!$util.isInteger(message.zones[i]))\n                    return \"zones: integer[] expected\";\n        }\n        if (message.centerLon != null && message.hasOwnProperty(\"centerLon\"))\n            if (typeof message.centerLon !== \"number\")\n                return \"centerLon: number expected\";\n        return null;\n    };\n\n    /**\n     * Creates a Feature message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Feature\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Feature} Feature\n     */\n    Feature.fromObject = function fromObject(object) {\n        if (object instanceof $root.Feature)\n            return object;\n        let message = new $root.Feature();\n        if (object.polygon != null) {\n            if (typeof object.polygon !== \"object\")\n                throw TypeError(\".Feature.polygon: object expected\");\n            message.polygon = $root.Polygon.fromObject(object.polygon);\n        }\n        if (object.multipolygon != null) {\n            if (typeof object.multipolygon !== \"object\")\n                throw TypeError(\".Feature.multipolygon: object expected\");\n            message.multipolygon = $root.MultiPolygon.fromObject(object.multipolygon);\n        }\n        if (object.zones) {\n            if (!Array.isArray(object.zones))\n                throw TypeError(\".Feature.zones: array expected\");\n            message.zones = [];\n            for (let i = 0; i < object.zones.length; ++i)\n                message.zones[i] = object.zones[i] | 0;\n        }\n        if (object.centerLon != null)\n            message.centerLon = Number(object.centerLon);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Feature message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Feature\n     * @static\n     * @param {Feature} message Feature\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Feature.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.zones = [];\n        if (options.defaults)\n            object.centerLon = 0;\n        if (message.polygon != null && message.hasOwnProperty(\"polygon\")) {\n            object.polygon = $root.Polygon.toObject(message.polygon, options);\n            if (options.oneofs)\n                object.geometry = \"polygon\";\n        }\n        if (message.multipolygon != null && message.hasOwnProperty(\"multipolygon\")) {\n            object.multipolygon = $root.MultiPolygon.toObject(message.multipolygon, options);\n            if (options.oneofs)\n                object.geometry = \"multipolygon\";\n        }\n        if (message.zones && message.zones.length) {\n            object.zones = [];\n            for (let j = 0; j < message.zones.length; ++j)\n                object.zones[j] = message.zones[j];\n        }\n        if (message.centerLon != null && message.hasOwnProperty(\"centerLon\"))\n            object.centerLon = options.json && !isFinite(message.centerLon) ? String(message.centerLon) : message.centerLon;\n        return object;\n    };\n\n    /**\n     * Converts this Feature to JSON.\n     * @function toJSON\n     * @memberof Feature\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Feature.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for Feature\n     * @function getTypeUrl\n     * @memberof Feature\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    Feature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/Feature\";\n    };\n\n    return Feature;\n})();\n\nexport const PointSeries = $root.PointSeries = (() => {\n\n    /**\n     * Properties of a PointSeries.\n     * @exports IPointSeries\n     * @interface IPointSeries\n     * @property {Array.<ICoordinate>|null} [coords] PointSeries coords\n     */\n\n    /**\n     * Constructs a new PointSeries.\n     * @exports PointSeries\n     * @classdesc Represents a PointSeries.\n     * @implements IPointSeries\n     * @constructor\n     * @param {IPointSeries=} [properties] Properties to set\n     */\n    function PointSeries(properties) {\n        this.coords = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PointSeries coords.\n     * @member {Array.<ICoordinate>} coords\n     * @memberof PointSeries\n     * @instance\n     */\n    PointSeries.prototype.coords = $util.emptyArray;\n\n    /**\n     * Creates a new PointSeries instance using the specified properties.\n     * @function create\n     * @memberof PointSeries\n     * @static\n     * @param {IPointSeries=} [properties] Properties to set\n     * @returns {PointSeries} PointSeries instance\n     */\n    PointSeries.create = function create(properties) {\n        return new PointSeries(properties);\n    };\n\n    /**\n     * Encodes the specified PointSeries message. Does not implicitly {@link PointSeries.verify|verify} messages.\n     * @function encode\n     * @memberof PointSeries\n     * @static\n     * @param {IPointSeries} message PointSeries message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PointSeries.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.coords != null && message.coords.length)\n            for (let i = 0; i < message.coords.length; ++i)\n                $root.Coordinate.encode(message.coords[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PointSeries message, length delimited. Does not implicitly {@link PointSeries.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PointSeries\n     * @static\n     * @param {IPointSeries} message PointSeries message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PointSeries.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PointSeries message from the specified reader or buffer.\n     * @function decode\n     * @memberof PointSeries\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PointSeries} PointSeries\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PointSeries.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PointSeries();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.coords && message.coords.length))\n                        message.coords = [];\n                    message.coords.push($root.Coordinate.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a PointSeries message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PointSeries\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PointSeries} PointSeries\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PointSeries.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PointSeries message.\n     * @function verify\n     * @memberof PointSeries\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PointSeries.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.coords != null && message.hasOwnProperty(\"coords\")) {\n            if (!Array.isArray(message.coords))\n                return \"coords: array expected\";\n            for (let i = 0; i < message.coords.length; ++i) {\n                let error = $root.Coordinate.verify(message.coords[i]);\n                if (error)\n                    return \"coords.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a PointSeries message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PointSeries\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PointSeries} PointSeries\n     */\n    PointSeries.fromObject = function fromObject(object) {\n        if (object instanceof $root.PointSeries)\n            return object;\n        let message = new $root.PointSeries();\n        if (object.coords) {\n            if (!Array.isArray(object.coords))\n                throw TypeError(\".PointSeries.coords: array expected\");\n            message.coords = [];\n            for (let i = 0; i < object.coords.length; ++i) {\n                if (typeof object.coords[i] !== \"object\")\n                    throw TypeError(\".PointSeries.coords: object expected\");\n                message.coords[i] = $root.Coordinate.fromObject(object.coords[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a PointSeries message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PointSeries\n     * @static\n     * @param {PointSeries} message PointSeries\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PointSeries.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.coords = [];\n        if (message.coords && message.coords.length) {\n            object.coords = [];\n            for (let j = 0; j < message.coords.length; ++j)\n                object.coords[j] = $root.Coordinate.toObject(message.coords[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this PointSeries to JSON.\n     * @function toJSON\n     * @memberof PointSeries\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PointSeries.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for PointSeries\n     * @function getTypeUrl\n     * @memberof PointSeries\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    PointSeries.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/PointSeries\";\n    };\n\n    return PointSeries;\n})();\n\nexport const ArticleOrderingList = $root.ArticleOrderingList = (() => {\n\n    /**\n     * Properties of an ArticleOrderingList.\n     * @exports IArticleOrderingList\n     * @interface IArticleOrderingList\n     * @property {Array.<string>|null} [longnames] ArticleOrderingList longnames\n     * @property {Array.<number>|null} [types] ArticleOrderingList types\n     */\n\n    /**\n     * Constructs a new ArticleOrderingList.\n     * @exports ArticleOrderingList\n     * @classdesc Represents an ArticleOrderingList.\n     * @implements IArticleOrderingList\n     * @constructor\n     * @param {IArticleOrderingList=} [properties] Properties to set\n     */\n    function ArticleOrderingList(properties) {\n        this.longnames = [];\n        this.types = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ArticleOrderingList longnames.\n     * @member {Array.<string>} longnames\n     * @memberof ArticleOrderingList\n     * @instance\n     */\n    ArticleOrderingList.prototype.longnames = $util.emptyArray;\n\n    /**\n     * ArticleOrderingList types.\n     * @member {Array.<number>} types\n     * @memberof ArticleOrderingList\n     * @instance\n     */\n    ArticleOrderingList.prototype.types = $util.emptyArray;\n\n    /**\n     * Creates a new ArticleOrderingList instance using the specified properties.\n     * @function create\n     * @memberof ArticleOrderingList\n     * @static\n     * @param {IArticleOrderingList=} [properties] Properties to set\n     * @returns {ArticleOrderingList} ArticleOrderingList instance\n     */\n    ArticleOrderingList.create = function create(properties) {\n        return new ArticleOrderingList(properties);\n    };\n\n    /**\n     * Encodes the specified ArticleOrderingList message. Does not implicitly {@link ArticleOrderingList.verify|verify} messages.\n     * @function encode\n     * @memberof ArticleOrderingList\n     * @static\n     * @param {IArticleOrderingList} message ArticleOrderingList message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ArticleOrderingList.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.longnames != null && message.longnames.length)\n            for (let i = 0; i < message.longnames.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.longnames[i]);\n        if (message.types != null && message.types.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.types.length; ++i)\n                writer.int32(message.types[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ArticleOrderingList message, length delimited. Does not implicitly {@link ArticleOrderingList.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ArticleOrderingList\n     * @static\n     * @param {IArticleOrderingList} message ArticleOrderingList message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ArticleOrderingList.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an ArticleOrderingList message from the specified reader or buffer.\n     * @function decode\n     * @memberof ArticleOrderingList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ArticleOrderingList} ArticleOrderingList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ArticleOrderingList.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ArticleOrderingList();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.longnames && message.longnames.length))\n                        message.longnames = [];\n                    message.longnames.push(reader.string());\n                    break;\n                }\n            case 2: {\n                    if (!(message.types && message.types.length))\n                        message.types = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.types.push(reader.int32());\n                    } else\n                        message.types.push(reader.int32());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes an ArticleOrderingList message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ArticleOrderingList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ArticleOrderingList} ArticleOrderingList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ArticleOrderingList.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an ArticleOrderingList message.\n     * @function verify\n     * @memberof ArticleOrderingList\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ArticleOrderingList.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.longnames != null && message.hasOwnProperty(\"longnames\")) {\n            if (!Array.isArray(message.longnames))\n                return \"longnames: array expected\";\n            for (let i = 0; i < message.longnames.length; ++i)\n                if (!$util.isString(message.longnames[i]))\n                    return \"longnames: string[] expected\";\n        }\n        if (message.types != null && message.hasOwnProperty(\"types\")) {\n            if (!Array.isArray(message.types))\n                return \"types: array expected\";\n            for (let i = 0; i < message.types.length; ++i)\n                if (!$util.isInteger(message.types[i]))\n                    return \"types: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates an ArticleOrderingList message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ArticleOrderingList\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ArticleOrderingList} ArticleOrderingList\n     */\n    ArticleOrderingList.fromObject = function fromObject(object) {\n        if (object instanceof $root.ArticleOrderingList)\n            return object;\n        let message = new $root.ArticleOrderingList();\n        if (object.longnames) {\n            if (!Array.isArray(object.longnames))\n                throw TypeError(\".ArticleOrderingList.longnames: array expected\");\n            message.longnames = [];\n            for (let i = 0; i < object.longnames.length; ++i)\n                message.longnames[i] = String(object.longnames[i]);\n        }\n        if (object.types) {\n            if (!Array.isArray(object.types))\n                throw TypeError(\".ArticleOrderingList.types: array expected\");\n            message.types = [];\n            for (let i = 0; i < object.types.length; ++i)\n                message.types[i] = object.types[i] | 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an ArticleOrderingList message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ArticleOrderingList\n     * @static\n     * @param {ArticleOrderingList} message ArticleOrderingList\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ArticleOrderingList.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.longnames = [];\n            object.types = [];\n        }\n        if (message.longnames && message.longnames.length) {\n            object.longnames = [];\n            for (let j = 0; j < message.longnames.length; ++j)\n                object.longnames[j] = message.longnames[j];\n        }\n        if (message.types && message.types.length) {\n            object.types = [];\n            for (let j = 0; j < message.types.length; ++j)\n                object.types[j] = message.types[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ArticleOrderingList to JSON.\n     * @function toJSON\n     * @memberof ArticleOrderingList\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ArticleOrderingList.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for ArticleOrderingList\n     * @function getTypeUrl\n     * @memberof ArticleOrderingList\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    ArticleOrderingList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/ArticleOrderingList\";\n    };\n\n    return ArticleOrderingList;\n})();\n\nexport const ArticleUniverseList = $root.ArticleUniverseList = (() => {\n\n    /**\n     * Properties of an ArticleUniverseList.\n     * @exports IArticleUniverseList\n     * @interface IArticleUniverseList\n     * @property {Array.<IUniverses>|null} [universes] ArticleUniverseList universes\n     */\n\n    /**\n     * Constructs a new ArticleUniverseList.\n     * @exports ArticleUniverseList\n     * @classdesc Represents an ArticleUniverseList.\n     * @implements IArticleUniverseList\n     * @constructor\n     * @param {IArticleUniverseList=} [properties] Properties to set\n     */\n    function ArticleUniverseList(properties) {\n        this.universes = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ArticleUniverseList universes.\n     * @member {Array.<IUniverses>} universes\n     * @memberof ArticleUniverseList\n     * @instance\n     */\n    ArticleUniverseList.prototype.universes = $util.emptyArray;\n\n    /**\n     * Creates a new ArticleUniverseList instance using the specified properties.\n     * @function create\n     * @memberof ArticleUniverseList\n     * @static\n     * @param {IArticleUniverseList=} [properties] Properties to set\n     * @returns {ArticleUniverseList} ArticleUniverseList instance\n     */\n    ArticleUniverseList.create = function create(properties) {\n        return new ArticleUniverseList(properties);\n    };\n\n    /**\n     * Encodes the specified ArticleUniverseList message. Does not implicitly {@link ArticleUniverseList.verify|verify} messages.\n     * @function encode\n     * @memberof ArticleUniverseList\n     * @static\n     * @param {IArticleUniverseList} message ArticleUniverseList message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ArticleUniverseList.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.universes != null && message.universes.length)\n            for (let i = 0; i < message.universes.length; ++i)\n                $root.Universes.encode(message.universes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ArticleUniverseList message, length delimited. Does not implicitly {@link ArticleUniverseList.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ArticleUniverseList\n     * @static\n     * @param {IArticleUniverseList} message ArticleUniverseList message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ArticleUniverseList.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an ArticleUniverseList message from the specified reader or buffer.\n     * @function decode\n     * @memberof ArticleUniverseList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ArticleUniverseList} ArticleUniverseList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ArticleUniverseList.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ArticleUniverseList();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 3: {\n                    if (!(message.universes && message.universes.length))\n                        message.universes = [];\n                    message.universes.push($root.Universes.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes an ArticleUniverseList message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ArticleUniverseList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ArticleUniverseList} ArticleUniverseList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ArticleUniverseList.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an ArticleUniverseList message.\n     * @function verify\n     * @memberof ArticleUniverseList\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ArticleUniverseList.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.universes != null && message.hasOwnProperty(\"universes\")) {\n            if (!Array.isArray(message.universes))\n                return \"universes: array expected\";\n            for (let i = 0; i < message.universes.length; ++i) {\n                let error = $root.Universes.verify(message.universes[i]);\n                if (error)\n                    return \"universes.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates an ArticleUniverseList message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ArticleUniverseList\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ArticleUniverseList} ArticleUniverseList\n     */\n    ArticleUniverseList.fromObject = function fromObject(object) {\n        if (object instanceof $root.ArticleUniverseList)\n            return object;\n        let message = new $root.ArticleUniverseList();\n        if (object.universes) {\n            if (!Array.isArray(object.universes))\n                throw TypeError(\".ArticleUniverseList.universes: array expected\");\n            message.universes = [];\n            for (let i = 0; i < object.universes.length; ++i) {\n                if (typeof object.universes[i] !== \"object\")\n                    throw TypeError(\".ArticleUniverseList.universes: object expected\");\n                message.universes[i] = $root.Universes.fromObject(object.universes[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an ArticleUniverseList message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ArticleUniverseList\n     * @static\n     * @param {ArticleUniverseList} message ArticleUniverseList\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ArticleUniverseList.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.universes = [];\n        if (message.universes && message.universes.length) {\n            object.universes = [];\n            for (let j = 0; j < message.universes.length; ++j)\n                object.universes[j] = $root.Universes.toObject(message.universes[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ArticleUniverseList to JSON.\n     * @function toJSON\n     * @memberof ArticleUniverseList\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ArticleUniverseList.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for ArticleUniverseList\n     * @function getTypeUrl\n     * @memberof ArticleUniverseList\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    ArticleUniverseList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/ArticleUniverseList\";\n    };\n\n    return ArticleUniverseList;\n})();\n\nexport const SearchIndexMetadata = $root.SearchIndexMetadata = (() => {\n\n    /**\n     * Properties of a SearchIndexMetadata.\n     * @exports ISearchIndexMetadata\n     * @interface ISearchIndexMetadata\n     * @property {number|null} [type] SearchIndexMetadata type\n     * @property {number|null} [isUsa] SearchIndexMetadata isUsa\n     * @property {number|null} [isSymlink] SearchIndexMetadata isSymlink\n     */\n\n    /**\n     * Constructs a new SearchIndexMetadata.\n     * @exports SearchIndexMetadata\n     * @classdesc Represents a SearchIndexMetadata.\n     * @implements ISearchIndexMetadata\n     * @constructor\n     * @param {ISearchIndexMetadata=} [properties] Properties to set\n     */\n    function SearchIndexMetadata(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SearchIndexMetadata type.\n     * @member {number} type\n     * @memberof SearchIndexMetadata\n     * @instance\n     */\n    SearchIndexMetadata.prototype.type = 0;\n\n    /**\n     * SearchIndexMetadata isUsa.\n     * @member {number} isUsa\n     * @memberof SearchIndexMetadata\n     * @instance\n     */\n    SearchIndexMetadata.prototype.isUsa = 0;\n\n    /**\n     * SearchIndexMetadata isSymlink.\n     * @member {number} isSymlink\n     * @memberof SearchIndexMetadata\n     * @instance\n     */\n    SearchIndexMetadata.prototype.isSymlink = 0;\n\n    /**\n     * Creates a new SearchIndexMetadata instance using the specified properties.\n     * @function create\n     * @memberof SearchIndexMetadata\n     * @static\n     * @param {ISearchIndexMetadata=} [properties] Properties to set\n     * @returns {SearchIndexMetadata} SearchIndexMetadata instance\n     */\n    SearchIndexMetadata.create = function create(properties) {\n        return new SearchIndexMetadata(properties);\n    };\n\n    /**\n     * Encodes the specified SearchIndexMetadata message. Does not implicitly {@link SearchIndexMetadata.verify|verify} messages.\n     * @function encode\n     * @memberof SearchIndexMetadata\n     * @static\n     * @param {ISearchIndexMetadata} message SearchIndexMetadata message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SearchIndexMetadata.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n        if (message.isUsa != null && Object.hasOwnProperty.call(message, \"isUsa\"))\n            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isUsa);\n        if (message.isSymlink != null && Object.hasOwnProperty.call(message, \"isSymlink\"))\n            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isSymlink);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified SearchIndexMetadata message, length delimited. Does not implicitly {@link SearchIndexMetadata.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof SearchIndexMetadata\n     * @static\n     * @param {ISearchIndexMetadata} message SearchIndexMetadata message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SearchIndexMetadata.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SearchIndexMetadata message from the specified reader or buffer.\n     * @function decode\n     * @memberof SearchIndexMetadata\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {SearchIndexMetadata} SearchIndexMetadata\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SearchIndexMetadata.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchIndexMetadata();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    message.type = reader.int32();\n                    break;\n                }\n            case 2: {\n                    message.isUsa = reader.int32();\n                    break;\n                }\n            case 3: {\n                    message.isSymlink = reader.int32();\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a SearchIndexMetadata message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof SearchIndexMetadata\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {SearchIndexMetadata} SearchIndexMetadata\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SearchIndexMetadata.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SearchIndexMetadata message.\n     * @function verify\n     * @memberof SearchIndexMetadata\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SearchIndexMetadata.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.type != null && message.hasOwnProperty(\"type\"))\n            if (!$util.isInteger(message.type))\n                return \"type: integer expected\";\n        if (message.isUsa != null && message.hasOwnProperty(\"isUsa\"))\n            if (!$util.isInteger(message.isUsa))\n                return \"isUsa: integer expected\";\n        if (message.isSymlink != null && message.hasOwnProperty(\"isSymlink\"))\n            if (!$util.isInteger(message.isSymlink))\n                return \"isSymlink: integer expected\";\n        return null;\n    };\n\n    /**\n     * Creates a SearchIndexMetadata message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof SearchIndexMetadata\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {SearchIndexMetadata} SearchIndexMetadata\n     */\n    SearchIndexMetadata.fromObject = function fromObject(object) {\n        if (object instanceof $root.SearchIndexMetadata)\n            return object;\n        let message = new $root.SearchIndexMetadata();\n        if (object.type != null)\n            message.type = object.type | 0;\n        if (object.isUsa != null)\n            message.isUsa = object.isUsa | 0;\n        if (object.isSymlink != null)\n            message.isSymlink = object.isSymlink | 0;\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a SearchIndexMetadata message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof SearchIndexMetadata\n     * @static\n     * @param {SearchIndexMetadata} message SearchIndexMetadata\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SearchIndexMetadata.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.type = 0;\n            object.isUsa = 0;\n            object.isSymlink = 0;\n        }\n        if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = message.type;\n        if (message.isUsa != null && message.hasOwnProperty(\"isUsa\"))\n            object.isUsa = message.isUsa;\n        if (message.isSymlink != null && message.hasOwnProperty(\"isSymlink\"))\n            object.isSymlink = message.isSymlink;\n        return object;\n    };\n\n    /**\n     * Converts this SearchIndexMetadata to JSON.\n     * @function toJSON\n     * @memberof SearchIndexMetadata\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SearchIndexMetadata.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for SearchIndexMetadata\n     * @function getTypeUrl\n     * @memberof SearchIndexMetadata\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    SearchIndexMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/SearchIndexMetadata\";\n    };\n\n    return SearchIndexMetadata;\n})();\n\nexport const SearchIndex = $root.SearchIndex = (() => {\n\n    /**\n     * Properties of a SearchIndex.\n     * @exports ISearchIndex\n     * @interface ISearchIndex\n     * @property {Array.<string>|null} [elements] SearchIndex elements\n     * @property {Array.<ISearchIndexMetadata>|null} [metadata] SearchIndex metadata\n     */\n\n    /**\n     * Constructs a new SearchIndex.\n     * @exports SearchIndex\n     * @classdesc Represents a SearchIndex.\n     * @implements ISearchIndex\n     * @constructor\n     * @param {ISearchIndex=} [properties] Properties to set\n     */\n    function SearchIndex(properties) {\n        this.elements = [];\n        this.metadata = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SearchIndex elements.\n     * @member {Array.<string>} elements\n     * @memberof SearchIndex\n     * @instance\n     */\n    SearchIndex.prototype.elements = $util.emptyArray;\n\n    /**\n     * SearchIndex metadata.\n     * @member {Array.<ISearchIndexMetadata>} metadata\n     * @memberof SearchIndex\n     * @instance\n     */\n    SearchIndex.prototype.metadata = $util.emptyArray;\n\n    /**\n     * Creates a new SearchIndex instance using the specified properties.\n     * @function create\n     * @memberof SearchIndex\n     * @static\n     * @param {ISearchIndex=} [properties] Properties to set\n     * @returns {SearchIndex} SearchIndex instance\n     */\n    SearchIndex.create = function create(properties) {\n        return new SearchIndex(properties);\n    };\n\n    /**\n     * Encodes the specified SearchIndex message. Does not implicitly {@link SearchIndex.verify|verify} messages.\n     * @function encode\n     * @memberof SearchIndex\n     * @static\n     * @param {ISearchIndex} message SearchIndex message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SearchIndex.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.elements != null && message.elements.length)\n            for (let i = 0; i < message.elements.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.elements[i]);\n        if (message.metadata != null && message.metadata.length)\n            for (let i = 0; i < message.metadata.length; ++i)\n                $root.SearchIndexMetadata.encode(message.metadata[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified SearchIndex message, length delimited. Does not implicitly {@link SearchIndex.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof SearchIndex\n     * @static\n     * @param {ISearchIndex} message SearchIndex message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SearchIndex.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SearchIndex message from the specified reader or buffer.\n     * @function decode\n     * @memberof SearchIndex\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {SearchIndex} SearchIndex\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SearchIndex.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchIndex();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.elements && message.elements.length))\n                        message.elements = [];\n                    message.elements.push(reader.string());\n                    break;\n                }\n            case 2: {\n                    if (!(message.metadata && message.metadata.length))\n                        message.metadata = [];\n                    message.metadata.push($root.SearchIndexMetadata.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a SearchIndex message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof SearchIndex\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {SearchIndex} SearchIndex\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SearchIndex.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SearchIndex message.\n     * @function verify\n     * @memberof SearchIndex\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SearchIndex.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.elements != null && message.hasOwnProperty(\"elements\")) {\n            if (!Array.isArray(message.elements))\n                return \"elements: array expected\";\n            for (let i = 0; i < message.elements.length; ++i)\n                if (!$util.isString(message.elements[i]))\n                    return \"elements: string[] expected\";\n        }\n        if (message.metadata != null && message.hasOwnProperty(\"metadata\")) {\n            if (!Array.isArray(message.metadata))\n                return \"metadata: array expected\";\n            for (let i = 0; i < message.metadata.length; ++i) {\n                let error = $root.SearchIndexMetadata.verify(message.metadata[i]);\n                if (error)\n                    return \"metadata.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a SearchIndex message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof SearchIndex\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {SearchIndex} SearchIndex\n     */\n    SearchIndex.fromObject = function fromObject(object) {\n        if (object instanceof $root.SearchIndex)\n            return object;\n        let message = new $root.SearchIndex();\n        if (object.elements) {\n            if (!Array.isArray(object.elements))\n                throw TypeError(\".SearchIndex.elements: array expected\");\n            message.elements = [];\n            for (let i = 0; i < object.elements.length; ++i)\n                message.elements[i] = String(object.elements[i]);\n        }\n        if (object.metadata) {\n            if (!Array.isArray(object.metadata))\n                throw TypeError(\".SearchIndex.metadata: array expected\");\n            message.metadata = [];\n            for (let i = 0; i < object.metadata.length; ++i) {\n                if (typeof object.metadata[i] !== \"object\")\n                    throw TypeError(\".SearchIndex.metadata: object expected\");\n                message.metadata[i] = $root.SearchIndexMetadata.fromObject(object.metadata[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a SearchIndex message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof SearchIndex\n     * @static\n     * @param {SearchIndex} message SearchIndex\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SearchIndex.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.elements = [];\n            object.metadata = [];\n        }\n        if (message.elements && message.elements.length) {\n            object.elements = [];\n            for (let j = 0; j < message.elements.length; ++j)\n                object.elements[j] = message.elements[j];\n        }\n        if (message.metadata && message.metadata.length) {\n            object.metadata = [];\n            for (let j = 0; j < message.metadata.length; ++j)\n                object.metadata[j] = $root.SearchIndexMetadata.toObject(message.metadata[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this SearchIndex to JSON.\n     * @function toJSON\n     * @memberof SearchIndex\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SearchIndex.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for SearchIndex\n     * @function getTypeUrl\n     * @memberof SearchIndex\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    SearchIndex.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/SearchIndex\";\n    };\n\n    return SearchIndex;\n})();\n\nexport const OrderList = $root.OrderList = (() => {\n\n    /**\n     * Properties of an OrderList.\n     * @exports IOrderList\n     * @interface IOrderList\n     * @property {Array.<number>|null} [orderIdxs] OrderList orderIdxs\n     */\n\n    /**\n     * Constructs a new OrderList.\n     * @exports OrderList\n     * @classdesc Represents an OrderList.\n     * @implements IOrderList\n     * @constructor\n     * @param {IOrderList=} [properties] Properties to set\n     */\n    function OrderList(properties) {\n        this.orderIdxs = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * OrderList orderIdxs.\n     * @member {Array.<number>} orderIdxs\n     * @memberof OrderList\n     * @instance\n     */\n    OrderList.prototype.orderIdxs = $util.emptyArray;\n\n    /**\n     * Creates a new OrderList instance using the specified properties.\n     * @function create\n     * @memberof OrderList\n     * @static\n     * @param {IOrderList=} [properties] Properties to set\n     * @returns {OrderList} OrderList instance\n     */\n    OrderList.create = function create(properties) {\n        return new OrderList(properties);\n    };\n\n    /**\n     * Encodes the specified OrderList message. Does not implicitly {@link OrderList.verify|verify} messages.\n     * @function encode\n     * @memberof OrderList\n     * @static\n     * @param {IOrderList} message OrderList message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    OrderList.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.orderIdxs != null && message.orderIdxs.length) {\n            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n            for (let i = 0; i < message.orderIdxs.length; ++i)\n                writer.int32(message.orderIdxs[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified OrderList message, length delimited. Does not implicitly {@link OrderList.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof OrderList\n     * @static\n     * @param {IOrderList} message OrderList message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    OrderList.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an OrderList message from the specified reader or buffer.\n     * @function decode\n     * @memberof OrderList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {OrderList} OrderList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OrderList.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderList();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.orderIdxs && message.orderIdxs.length))\n                        message.orderIdxs = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.orderIdxs.push(reader.int32());\n                    } else\n                        message.orderIdxs.push(reader.int32());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes an OrderList message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof OrderList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {OrderList} OrderList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OrderList.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an OrderList message.\n     * @function verify\n     * @memberof OrderList\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    OrderList.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.orderIdxs != null && message.hasOwnProperty(\"orderIdxs\")) {\n            if (!Array.isArray(message.orderIdxs))\n                return \"orderIdxs: array expected\";\n            for (let i = 0; i < message.orderIdxs.length; ++i)\n                if (!$util.isInteger(message.orderIdxs[i]))\n                    return \"orderIdxs: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates an OrderList message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof OrderList\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {OrderList} OrderList\n     */\n    OrderList.fromObject = function fromObject(object) {\n        if (object instanceof $root.OrderList)\n            return object;\n        let message = new $root.OrderList();\n        if (object.orderIdxs) {\n            if (!Array.isArray(object.orderIdxs))\n                throw TypeError(\".OrderList.orderIdxs: array expected\");\n            message.orderIdxs = [];\n            for (let i = 0; i < object.orderIdxs.length; ++i)\n                message.orderIdxs[i] = object.orderIdxs[i] | 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an OrderList message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof OrderList\n     * @static\n     * @param {OrderList} message OrderList\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    OrderList.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.orderIdxs = [];\n        if (message.orderIdxs && message.orderIdxs.length) {\n            object.orderIdxs = [];\n            for (let j = 0; j < message.orderIdxs.length; ++j)\n                object.orderIdxs[j] = message.orderIdxs[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this OrderList to JSON.\n     * @function toJSON\n     * @memberof OrderList\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    OrderList.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for OrderList\n     * @function getTypeUrl\n     * @memberof OrderList\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    OrderList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/OrderList\";\n    };\n\n    return OrderList;\n})();\n\nexport const PopulationPercentileByUniverse = $root.PopulationPercentileByUniverse = (() => {\n\n    /**\n     * Properties of a PopulationPercentileByUniverse.\n     * @exports IPopulationPercentileByUniverse\n     * @interface IPopulationPercentileByUniverse\n     * @property {Array.<number>|null} [populationPercentile] PopulationPercentileByUniverse populationPercentile\n     */\n\n    /**\n     * Constructs a new PopulationPercentileByUniverse.\n     * @exports PopulationPercentileByUniverse\n     * @classdesc Represents a PopulationPercentileByUniverse.\n     * @implements IPopulationPercentileByUniverse\n     * @constructor\n     * @param {IPopulationPercentileByUniverse=} [properties] Properties to set\n     */\n    function PopulationPercentileByUniverse(properties) {\n        this.populationPercentile = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PopulationPercentileByUniverse populationPercentile.\n     * @member {Array.<number>} populationPercentile\n     * @memberof PopulationPercentileByUniverse\n     * @instance\n     */\n    PopulationPercentileByUniverse.prototype.populationPercentile = $util.emptyArray;\n\n    /**\n     * Creates a new PopulationPercentileByUniverse instance using the specified properties.\n     * @function create\n     * @memberof PopulationPercentileByUniverse\n     * @static\n     * @param {IPopulationPercentileByUniverse=} [properties] Properties to set\n     * @returns {PopulationPercentileByUniverse} PopulationPercentileByUniverse instance\n     */\n    PopulationPercentileByUniverse.create = function create(properties) {\n        return new PopulationPercentileByUniverse(properties);\n    };\n\n    /**\n     * Encodes the specified PopulationPercentileByUniverse message. Does not implicitly {@link PopulationPercentileByUniverse.verify|verify} messages.\n     * @function encode\n     * @memberof PopulationPercentileByUniverse\n     * @static\n     * @param {IPopulationPercentileByUniverse} message PopulationPercentileByUniverse message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PopulationPercentileByUniverse.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.populationPercentile != null && message.populationPercentile.length) {\n            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n            for (let i = 0; i < message.populationPercentile.length; ++i)\n                writer.int32(message.populationPercentile[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PopulationPercentileByUniverse message, length delimited. Does not implicitly {@link PopulationPercentileByUniverse.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PopulationPercentileByUniverse\n     * @static\n     * @param {IPopulationPercentileByUniverse} message PopulationPercentileByUniverse message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PopulationPercentileByUniverse.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PopulationPercentileByUniverse message from the specified reader or buffer.\n     * @function decode\n     * @memberof PopulationPercentileByUniverse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PopulationPercentileByUniverse} PopulationPercentileByUniverse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PopulationPercentileByUniverse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PopulationPercentileByUniverse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.populationPercentile && message.populationPercentile.length))\n                        message.populationPercentile = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.populationPercentile.push(reader.int32());\n                    } else\n                        message.populationPercentile.push(reader.int32());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a PopulationPercentileByUniverse message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PopulationPercentileByUniverse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PopulationPercentileByUniverse} PopulationPercentileByUniverse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PopulationPercentileByUniverse.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PopulationPercentileByUniverse message.\n     * @function verify\n     * @memberof PopulationPercentileByUniverse\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PopulationPercentileByUniverse.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.populationPercentile != null && message.hasOwnProperty(\"populationPercentile\")) {\n            if (!Array.isArray(message.populationPercentile))\n                return \"populationPercentile: array expected\";\n            for (let i = 0; i < message.populationPercentile.length; ++i)\n                if (!$util.isInteger(message.populationPercentile[i]))\n                    return \"populationPercentile: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a PopulationPercentileByUniverse message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PopulationPercentileByUniverse\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PopulationPercentileByUniverse} PopulationPercentileByUniverse\n     */\n    PopulationPercentileByUniverse.fromObject = function fromObject(object) {\n        if (object instanceof $root.PopulationPercentileByUniverse)\n            return object;\n        let message = new $root.PopulationPercentileByUniverse();\n        if (object.populationPercentile) {\n            if (!Array.isArray(object.populationPercentile))\n                throw TypeError(\".PopulationPercentileByUniverse.populationPercentile: array expected\");\n            message.populationPercentile = [];\n            for (let i = 0; i < object.populationPercentile.length; ++i)\n                message.populationPercentile[i] = object.populationPercentile[i] | 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a PopulationPercentileByUniverse message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PopulationPercentileByUniverse\n     * @static\n     * @param {PopulationPercentileByUniverse} message PopulationPercentileByUniverse\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PopulationPercentileByUniverse.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.populationPercentile = [];\n        if (message.populationPercentile && message.populationPercentile.length) {\n            object.populationPercentile = [];\n            for (let j = 0; j < message.populationPercentile.length; ++j)\n                object.populationPercentile[j] = message.populationPercentile[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this PopulationPercentileByUniverse to JSON.\n     * @function toJSON\n     * @memberof PopulationPercentileByUniverse\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PopulationPercentileByUniverse.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for PopulationPercentileByUniverse\n     * @function getTypeUrl\n     * @memberof PopulationPercentileByUniverse\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    PopulationPercentileByUniverse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/PopulationPercentileByUniverse\";\n    };\n\n    return PopulationPercentileByUniverse;\n})();\n\nexport const DataList = $root.DataList = (() => {\n\n    /**\n     * Properties of a DataList.\n     * @exports IDataList\n     * @interface IDataList\n     * @property {Array.<number>|null} [value] DataList value\n     * @property {Array.<IPopulationPercentileByUniverse>|null} [populationPercentileByUniverse] DataList populationPercentileByUniverse\n     */\n\n    /**\n     * Constructs a new DataList.\n     * @exports DataList\n     * @classdesc Represents a DataList.\n     * @implements IDataList\n     * @constructor\n     * @param {IDataList=} [properties] Properties to set\n     */\n    function DataList(properties) {\n        this.value = [];\n        this.populationPercentileByUniverse = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * DataList value.\n     * @member {Array.<number>} value\n     * @memberof DataList\n     * @instance\n     */\n    DataList.prototype.value = $util.emptyArray;\n\n    /**\n     * DataList populationPercentileByUniverse.\n     * @member {Array.<IPopulationPercentileByUniverse>} populationPercentileByUniverse\n     * @memberof DataList\n     * @instance\n     */\n    DataList.prototype.populationPercentileByUniverse = $util.emptyArray;\n\n    /**\n     * Creates a new DataList instance using the specified properties.\n     * @function create\n     * @memberof DataList\n     * @static\n     * @param {IDataList=} [properties] Properties to set\n     * @returns {DataList} DataList instance\n     */\n    DataList.create = function create(properties) {\n        return new DataList(properties);\n    };\n\n    /**\n     * Encodes the specified DataList message. Does not implicitly {@link DataList.verify|verify} messages.\n     * @function encode\n     * @memberof DataList\n     * @static\n     * @param {IDataList} message DataList message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DataList.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.value != null && message.value.length) {\n            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n            for (let i = 0; i < message.value.length; ++i)\n                writer.float(message.value[i]);\n            writer.ldelim();\n        }\n        if (message.populationPercentileByUniverse != null && message.populationPercentileByUniverse.length)\n            for (let i = 0; i < message.populationPercentileByUniverse.length; ++i)\n                $root.PopulationPercentileByUniverse.encode(message.populationPercentileByUniverse[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified DataList message, length delimited. Does not implicitly {@link DataList.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof DataList\n     * @static\n     * @param {IDataList} message DataList message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DataList.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a DataList message from the specified reader or buffer.\n     * @function decode\n     * @memberof DataList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {DataList} DataList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DataList.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DataList();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.value && message.value.length))\n                        message.value = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.value.push(reader.float());\n                    } else\n                        message.value.push(reader.float());\n                    break;\n                }\n            case 2: {\n                    if (!(message.populationPercentileByUniverse && message.populationPercentileByUniverse.length))\n                        message.populationPercentileByUniverse = [];\n                    message.populationPercentileByUniverse.push($root.PopulationPercentileByUniverse.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a DataList message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof DataList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {DataList} DataList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DataList.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a DataList message.\n     * @function verify\n     * @memberof DataList\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    DataList.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.value != null && message.hasOwnProperty(\"value\")) {\n            if (!Array.isArray(message.value))\n                return \"value: array expected\";\n            for (let i = 0; i < message.value.length; ++i)\n                if (typeof message.value[i] !== \"number\")\n                    return \"value: number[] expected\";\n        }\n        if (message.populationPercentileByUniverse != null && message.hasOwnProperty(\"populationPercentileByUniverse\")) {\n            if (!Array.isArray(message.populationPercentileByUniverse))\n                return \"populationPercentileByUniverse: array expected\";\n            for (let i = 0; i < message.populationPercentileByUniverse.length; ++i) {\n                let error = $root.PopulationPercentileByUniverse.verify(message.populationPercentileByUniverse[i]);\n                if (error)\n                    return \"populationPercentileByUniverse.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a DataList message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof DataList\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {DataList} DataList\n     */\n    DataList.fromObject = function fromObject(object) {\n        if (object instanceof $root.DataList)\n            return object;\n        let message = new $root.DataList();\n        if (object.value) {\n            if (!Array.isArray(object.value))\n                throw TypeError(\".DataList.value: array expected\");\n            message.value = [];\n            for (let i = 0; i < object.value.length; ++i)\n                message.value[i] = Number(object.value[i]);\n        }\n        if (object.populationPercentileByUniverse) {\n            if (!Array.isArray(object.populationPercentileByUniverse))\n                throw TypeError(\".DataList.populationPercentileByUniverse: array expected\");\n            message.populationPercentileByUniverse = [];\n            for (let i = 0; i < object.populationPercentileByUniverse.length; ++i) {\n                if (typeof object.populationPercentileByUniverse[i] !== \"object\")\n                    throw TypeError(\".DataList.populationPercentileByUniverse: object expected\");\n                message.populationPercentileByUniverse[i] = $root.PopulationPercentileByUniverse.fromObject(object.populationPercentileByUniverse[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a DataList message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof DataList\n     * @static\n     * @param {DataList} message DataList\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    DataList.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.value = [];\n            object.populationPercentileByUniverse = [];\n        }\n        if (message.value && message.value.length) {\n            object.value = [];\n            for (let j = 0; j < message.value.length; ++j)\n                object.value[j] = options.json && !isFinite(message.value[j]) ? String(message.value[j]) : message.value[j];\n        }\n        if (message.populationPercentileByUniverse && message.populationPercentileByUniverse.length) {\n            object.populationPercentileByUniverse = [];\n            for (let j = 0; j < message.populationPercentileByUniverse.length; ++j)\n                object.populationPercentileByUniverse[j] = $root.PopulationPercentileByUniverse.toObject(message.populationPercentileByUniverse[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this DataList to JSON.\n     * @function toJSON\n     * @memberof DataList\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    DataList.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for DataList\n     * @function getTypeUrl\n     * @memberof DataList\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    DataList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/DataList\";\n    };\n\n    return DataList;\n})();\n\nexport const OrderLists = $root.OrderLists = (() => {\n\n    /**\n     * Properties of an OrderLists.\n     * @exports IOrderLists\n     * @interface IOrderLists\n     * @property {Array.<string>|null} [statnames] OrderLists statnames\n     * @property {Array.<IOrderList>|null} [orderLists] OrderLists orderLists\n     */\n\n    /**\n     * Constructs a new OrderLists.\n     * @exports OrderLists\n     * @classdesc Represents an OrderLists.\n     * @implements IOrderLists\n     * @constructor\n     * @param {IOrderLists=} [properties] Properties to set\n     */\n    function OrderLists(properties) {\n        this.statnames = [];\n        this.orderLists = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * OrderLists statnames.\n     * @member {Array.<string>} statnames\n     * @memberof OrderLists\n     * @instance\n     */\n    OrderLists.prototype.statnames = $util.emptyArray;\n\n    /**\n     * OrderLists orderLists.\n     * @member {Array.<IOrderList>} orderLists\n     * @memberof OrderLists\n     * @instance\n     */\n    OrderLists.prototype.orderLists = $util.emptyArray;\n\n    /**\n     * Creates a new OrderLists instance using the specified properties.\n     * @function create\n     * @memberof OrderLists\n     * @static\n     * @param {IOrderLists=} [properties] Properties to set\n     * @returns {OrderLists} OrderLists instance\n     */\n    OrderLists.create = function create(properties) {\n        return new OrderLists(properties);\n    };\n\n    /**\n     * Encodes the specified OrderLists message. Does not implicitly {@link OrderLists.verify|verify} messages.\n     * @function encode\n     * @memberof OrderLists\n     * @static\n     * @param {IOrderLists} message OrderLists message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    OrderLists.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.statnames != null && message.statnames.length)\n            for (let i = 0; i < message.statnames.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.statnames[i]);\n        if (message.orderLists != null && message.orderLists.length)\n            for (let i = 0; i < message.orderLists.length; ++i)\n                $root.OrderList.encode(message.orderLists[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified OrderLists message, length delimited. Does not implicitly {@link OrderLists.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof OrderLists\n     * @static\n     * @param {IOrderLists} message OrderLists message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    OrderLists.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an OrderLists message from the specified reader or buffer.\n     * @function decode\n     * @memberof OrderLists\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {OrderLists} OrderLists\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OrderLists.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderLists();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.statnames && message.statnames.length))\n                        message.statnames = [];\n                    message.statnames.push(reader.string());\n                    break;\n                }\n            case 2: {\n                    if (!(message.orderLists && message.orderLists.length))\n                        message.orderLists = [];\n                    message.orderLists.push($root.OrderList.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes an OrderLists message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof OrderLists\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {OrderLists} OrderLists\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OrderLists.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an OrderLists message.\n     * @function verify\n     * @memberof OrderLists\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    OrderLists.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.statnames != null && message.hasOwnProperty(\"statnames\")) {\n            if (!Array.isArray(message.statnames))\n                return \"statnames: array expected\";\n            for (let i = 0; i < message.statnames.length; ++i)\n                if (!$util.isString(message.statnames[i]))\n                    return \"statnames: string[] expected\";\n        }\n        if (message.orderLists != null && message.hasOwnProperty(\"orderLists\")) {\n            if (!Array.isArray(message.orderLists))\n                return \"orderLists: array expected\";\n            for (let i = 0; i < message.orderLists.length; ++i) {\n                let error = $root.OrderList.verify(message.orderLists[i]);\n                if (error)\n                    return \"orderLists.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates an OrderLists message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof OrderLists\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {OrderLists} OrderLists\n     */\n    OrderLists.fromObject = function fromObject(object) {\n        if (object instanceof $root.OrderLists)\n            return object;\n        let message = new $root.OrderLists();\n        if (object.statnames) {\n            if (!Array.isArray(object.statnames))\n                throw TypeError(\".OrderLists.statnames: array expected\");\n            message.statnames = [];\n            for (let i = 0; i < object.statnames.length; ++i)\n                message.statnames[i] = String(object.statnames[i]);\n        }\n        if (object.orderLists) {\n            if (!Array.isArray(object.orderLists))\n                throw TypeError(\".OrderLists.orderLists: array expected\");\n            message.orderLists = [];\n            for (let i = 0; i < object.orderLists.length; ++i) {\n                if (typeof object.orderLists[i] !== \"object\")\n                    throw TypeError(\".OrderLists.orderLists: object expected\");\n                message.orderLists[i] = $root.OrderList.fromObject(object.orderLists[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an OrderLists message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof OrderLists\n     * @static\n     * @param {OrderLists} message OrderLists\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    OrderLists.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.statnames = [];\n            object.orderLists = [];\n        }\n        if (message.statnames && message.statnames.length) {\n            object.statnames = [];\n            for (let j = 0; j < message.statnames.length; ++j)\n                object.statnames[j] = message.statnames[j];\n        }\n        if (message.orderLists && message.orderLists.length) {\n            object.orderLists = [];\n            for (let j = 0; j < message.orderLists.length; ++j)\n                object.orderLists[j] = $root.OrderList.toObject(message.orderLists[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this OrderLists to JSON.\n     * @function toJSON\n     * @memberof OrderLists\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    OrderLists.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for OrderLists\n     * @function getTypeUrl\n     * @memberof OrderLists\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    OrderLists.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/OrderLists\";\n    };\n\n    return OrderLists;\n})();\n\nexport const DataLists = $root.DataLists = (() => {\n\n    /**\n     * Properties of a DataLists.\n     * @exports IDataLists\n     * @interface IDataLists\n     * @property {Array.<string>|null} [statnames] DataLists statnames\n     * @property {Array.<IDataList>|null} [dataLists] DataLists dataLists\n     */\n\n    /**\n     * Constructs a new DataLists.\n     * @exports DataLists\n     * @classdesc Represents a DataLists.\n     * @implements IDataLists\n     * @constructor\n     * @param {IDataLists=} [properties] Properties to set\n     */\n    function DataLists(properties) {\n        this.statnames = [];\n        this.dataLists = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * DataLists statnames.\n     * @member {Array.<string>} statnames\n     * @memberof DataLists\n     * @instance\n     */\n    DataLists.prototype.statnames = $util.emptyArray;\n\n    /**\n     * DataLists dataLists.\n     * @member {Array.<IDataList>} dataLists\n     * @memberof DataLists\n     * @instance\n     */\n    DataLists.prototype.dataLists = $util.emptyArray;\n\n    /**\n     * Creates a new DataLists instance using the specified properties.\n     * @function create\n     * @memberof DataLists\n     * @static\n     * @param {IDataLists=} [properties] Properties to set\n     * @returns {DataLists} DataLists instance\n     */\n    DataLists.create = function create(properties) {\n        return new DataLists(properties);\n    };\n\n    /**\n     * Encodes the specified DataLists message. Does not implicitly {@link DataLists.verify|verify} messages.\n     * @function encode\n     * @memberof DataLists\n     * @static\n     * @param {IDataLists} message DataLists message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DataLists.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.statnames != null && message.statnames.length)\n            for (let i = 0; i < message.statnames.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.statnames[i]);\n        if (message.dataLists != null && message.dataLists.length)\n            for (let i = 0; i < message.dataLists.length; ++i)\n                $root.DataList.encode(message.dataLists[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified DataLists message, length delimited. Does not implicitly {@link DataLists.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof DataLists\n     * @static\n     * @param {IDataLists} message DataLists message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DataLists.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a DataLists message from the specified reader or buffer.\n     * @function decode\n     * @memberof DataLists\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {DataLists} DataLists\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DataLists.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DataLists();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.statnames && message.statnames.length))\n                        message.statnames = [];\n                    message.statnames.push(reader.string());\n                    break;\n                }\n            case 2: {\n                    if (!(message.dataLists && message.dataLists.length))\n                        message.dataLists = [];\n                    message.dataLists.push($root.DataList.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a DataLists message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof DataLists\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {DataLists} DataLists\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DataLists.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a DataLists message.\n     * @function verify\n     * @memberof DataLists\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    DataLists.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.statnames != null && message.hasOwnProperty(\"statnames\")) {\n            if (!Array.isArray(message.statnames))\n                return \"statnames: array expected\";\n            for (let i = 0; i < message.statnames.length; ++i)\n                if (!$util.isString(message.statnames[i]))\n                    return \"statnames: string[] expected\";\n        }\n        if (message.dataLists != null && message.hasOwnProperty(\"dataLists\")) {\n            if (!Array.isArray(message.dataLists))\n                return \"dataLists: array expected\";\n            for (let i = 0; i < message.dataLists.length; ++i) {\n                let error = $root.DataList.verify(message.dataLists[i]);\n                if (error)\n                    return \"dataLists.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a DataLists message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof DataLists\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {DataLists} DataLists\n     */\n    DataLists.fromObject = function fromObject(object) {\n        if (object instanceof $root.DataLists)\n            return object;\n        let message = new $root.DataLists();\n        if (object.statnames) {\n            if (!Array.isArray(object.statnames))\n                throw TypeError(\".DataLists.statnames: array expected\");\n            message.statnames = [];\n            for (let i = 0; i < object.statnames.length; ++i)\n                message.statnames[i] = String(object.statnames[i]);\n        }\n        if (object.dataLists) {\n            if (!Array.isArray(object.dataLists))\n                throw TypeError(\".DataLists.dataLists: array expected\");\n            message.dataLists = [];\n            for (let i = 0; i < object.dataLists.length; ++i) {\n                if (typeof object.dataLists[i] !== \"object\")\n                    throw TypeError(\".DataLists.dataLists: object expected\");\n                message.dataLists[i] = $root.DataList.fromObject(object.dataLists[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a DataLists message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof DataLists\n     * @static\n     * @param {DataLists} message DataLists\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    DataLists.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.statnames = [];\n            object.dataLists = [];\n        }\n        if (message.statnames && message.statnames.length) {\n            object.statnames = [];\n            for (let j = 0; j < message.statnames.length; ++j)\n                object.statnames[j] = message.statnames[j];\n        }\n        if (message.dataLists && message.dataLists.length) {\n            object.dataLists = [];\n            for (let j = 0; j < message.dataLists.length; ++j)\n                object.dataLists[j] = $root.DataList.toObject(message.dataLists[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this DataLists to JSON.\n     * @function toJSON\n     * @memberof DataLists\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    DataLists.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for DataLists\n     * @function getTypeUrl\n     * @memberof DataLists\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    DataLists.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/DataLists\";\n    };\n\n    return DataLists;\n})();\n\nexport const Universes = $root.Universes = (() => {\n\n    /**\n     * Properties of an Universes.\n     * @exports IUniverses\n     * @interface IUniverses\n     * @property {Array.<number>|null} [universeIdxs] Universes universeIdxs\n     */\n\n    /**\n     * Constructs a new Universes.\n     * @exports Universes\n     * @classdesc Represents an Universes.\n     * @implements IUniverses\n     * @constructor\n     * @param {IUniverses=} [properties] Properties to set\n     */\n    function Universes(properties) {\n        this.universeIdxs = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Universes universeIdxs.\n     * @member {Array.<number>} universeIdxs\n     * @memberof Universes\n     * @instance\n     */\n    Universes.prototype.universeIdxs = $util.emptyArray;\n\n    /**\n     * Creates a new Universes instance using the specified properties.\n     * @function create\n     * @memberof Universes\n     * @static\n     * @param {IUniverses=} [properties] Properties to set\n     * @returns {Universes} Universes instance\n     */\n    Universes.create = function create(properties) {\n        return new Universes(properties);\n    };\n\n    /**\n     * Encodes the specified Universes message. Does not implicitly {@link Universes.verify|verify} messages.\n     * @function encode\n     * @memberof Universes\n     * @static\n     * @param {IUniverses} message Universes message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Universes.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.universeIdxs != null && message.universeIdxs.length) {\n            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n            for (let i = 0; i < message.universeIdxs.length; ++i)\n                writer.int32(message.universeIdxs[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Universes message, length delimited. Does not implicitly {@link Universes.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Universes\n     * @static\n     * @param {IUniverses} message Universes message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Universes.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an Universes message from the specified reader or buffer.\n     * @function decode\n     * @memberof Universes\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Universes} Universes\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Universes.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Universes();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.universeIdxs && message.universeIdxs.length))\n                        message.universeIdxs = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.universeIdxs.push(reader.int32());\n                    } else\n                        message.universeIdxs.push(reader.int32());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes an Universes message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Universes\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Universes} Universes\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Universes.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an Universes message.\n     * @function verify\n     * @memberof Universes\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Universes.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.universeIdxs != null && message.hasOwnProperty(\"universeIdxs\")) {\n            if (!Array.isArray(message.universeIdxs))\n                return \"universeIdxs: array expected\";\n            for (let i = 0; i < message.universeIdxs.length; ++i)\n                if (!$util.isInteger(message.universeIdxs[i]))\n                    return \"universeIdxs: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates an Universes message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Universes\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Universes} Universes\n     */\n    Universes.fromObject = function fromObject(object) {\n        if (object instanceof $root.Universes)\n            return object;\n        let message = new $root.Universes();\n        if (object.universeIdxs) {\n            if (!Array.isArray(object.universeIdxs))\n                throw TypeError(\".Universes.universeIdxs: array expected\");\n            message.universeIdxs = [];\n            for (let i = 0; i < object.universeIdxs.length; ++i)\n                message.universeIdxs[i] = object.universeIdxs[i] | 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an Universes message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Universes\n     * @static\n     * @param {Universes} message Universes\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Universes.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.universeIdxs = [];\n        if (message.universeIdxs && message.universeIdxs.length) {\n            object.universeIdxs = [];\n            for (let j = 0; j < message.universeIdxs.length; ++j)\n                object.universeIdxs[j] = message.universeIdxs[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Universes to JSON.\n     * @function toJSON\n     * @memberof Universes\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Universes.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for Universes\n     * @function getTypeUrl\n     * @memberof Universes\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    Universes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/Universes\";\n    };\n\n    return Universes;\n})();\n\nexport const ConsolidatedShapes = $root.ConsolidatedShapes = (() => {\n\n    /**\n     * Properties of a ConsolidatedShapes.\n     * @exports IConsolidatedShapes\n     * @interface IConsolidatedShapes\n     * @property {Array.<string>|null} [longnames] ConsolidatedShapes longnames\n     * @property {Array.<IUniverses>|null} [universes] ConsolidatedShapes universes\n     * @property {Array.<IFeature>|null} [shapes] ConsolidatedShapes shapes\n     */\n\n    /**\n     * Constructs a new ConsolidatedShapes.\n     * @exports ConsolidatedShapes\n     * @classdesc Represents a ConsolidatedShapes.\n     * @implements IConsolidatedShapes\n     * @constructor\n     * @param {IConsolidatedShapes=} [properties] Properties to set\n     */\n    function ConsolidatedShapes(properties) {\n        this.longnames = [];\n        this.universes = [];\n        this.shapes = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ConsolidatedShapes longnames.\n     * @member {Array.<string>} longnames\n     * @memberof ConsolidatedShapes\n     * @instance\n     */\n    ConsolidatedShapes.prototype.longnames = $util.emptyArray;\n\n    /**\n     * ConsolidatedShapes universes.\n     * @member {Array.<IUniverses>} universes\n     * @memberof ConsolidatedShapes\n     * @instance\n     */\n    ConsolidatedShapes.prototype.universes = $util.emptyArray;\n\n    /**\n     * ConsolidatedShapes shapes.\n     * @member {Array.<IFeature>} shapes\n     * @memberof ConsolidatedShapes\n     * @instance\n     */\n    ConsolidatedShapes.prototype.shapes = $util.emptyArray;\n\n    /**\n     * Creates a new ConsolidatedShapes instance using the specified properties.\n     * @function create\n     * @memberof ConsolidatedShapes\n     * @static\n     * @param {IConsolidatedShapes=} [properties] Properties to set\n     * @returns {ConsolidatedShapes} ConsolidatedShapes instance\n     */\n    ConsolidatedShapes.create = function create(properties) {\n        return new ConsolidatedShapes(properties);\n    };\n\n    /**\n     * Encodes the specified ConsolidatedShapes message. Does not implicitly {@link ConsolidatedShapes.verify|verify} messages.\n     * @function encode\n     * @memberof ConsolidatedShapes\n     * @static\n     * @param {IConsolidatedShapes} message ConsolidatedShapes message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ConsolidatedShapes.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.longnames != null && message.longnames.length)\n            for (let i = 0; i < message.longnames.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.longnames[i]);\n        if (message.shapes != null && message.shapes.length)\n            for (let i = 0; i < message.shapes.length; ++i)\n                $root.Feature.encode(message.shapes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.universes != null && message.universes.length)\n            for (let i = 0; i < message.universes.length; ++i)\n                $root.Universes.encode(message.universes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ConsolidatedShapes message, length delimited. Does not implicitly {@link ConsolidatedShapes.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ConsolidatedShapes\n     * @static\n     * @param {IConsolidatedShapes} message ConsolidatedShapes message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ConsolidatedShapes.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ConsolidatedShapes message from the specified reader or buffer.\n     * @function decode\n     * @memberof ConsolidatedShapes\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ConsolidatedShapes} ConsolidatedShapes\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ConsolidatedShapes.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConsolidatedShapes();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.longnames && message.longnames.length))\n                        message.longnames = [];\n                    message.longnames.push(reader.string());\n                    break;\n                }\n            case 3: {\n                    if (!(message.universes && message.universes.length))\n                        message.universes = [];\n                    message.universes.push($root.Universes.decode(reader, reader.uint32()));\n                    break;\n                }\n            case 2: {\n                    if (!(message.shapes && message.shapes.length))\n                        message.shapes = [];\n                    message.shapes.push($root.Feature.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ConsolidatedShapes message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ConsolidatedShapes\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ConsolidatedShapes} ConsolidatedShapes\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ConsolidatedShapes.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ConsolidatedShapes message.\n     * @function verify\n     * @memberof ConsolidatedShapes\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ConsolidatedShapes.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.longnames != null && message.hasOwnProperty(\"longnames\")) {\n            if (!Array.isArray(message.longnames))\n                return \"longnames: array expected\";\n            for (let i = 0; i < message.longnames.length; ++i)\n                if (!$util.isString(message.longnames[i]))\n                    return \"longnames: string[] expected\";\n        }\n        if (message.universes != null && message.hasOwnProperty(\"universes\")) {\n            if (!Array.isArray(message.universes))\n                return \"universes: array expected\";\n            for (let i = 0; i < message.universes.length; ++i) {\n                let error = $root.Universes.verify(message.universes[i]);\n                if (error)\n                    return \"universes.\" + error;\n            }\n        }\n        if (message.shapes != null && message.hasOwnProperty(\"shapes\")) {\n            if (!Array.isArray(message.shapes))\n                return \"shapes: array expected\";\n            for (let i = 0; i < message.shapes.length; ++i) {\n                let error = $root.Feature.verify(message.shapes[i]);\n                if (error)\n                    return \"shapes.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a ConsolidatedShapes message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ConsolidatedShapes\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ConsolidatedShapes} ConsolidatedShapes\n     */\n    ConsolidatedShapes.fromObject = function fromObject(object) {\n        if (object instanceof $root.ConsolidatedShapes)\n            return object;\n        let message = new $root.ConsolidatedShapes();\n        if (object.longnames) {\n            if (!Array.isArray(object.longnames))\n                throw TypeError(\".ConsolidatedShapes.longnames: array expected\");\n            message.longnames = [];\n            for (let i = 0; i < object.longnames.length; ++i)\n                message.longnames[i] = String(object.longnames[i]);\n        }\n        if (object.universes) {\n            if (!Array.isArray(object.universes))\n                throw TypeError(\".ConsolidatedShapes.universes: array expected\");\n            message.universes = [];\n            for (let i = 0; i < object.universes.length; ++i) {\n                if (typeof object.universes[i] !== \"object\")\n                    throw TypeError(\".ConsolidatedShapes.universes: object expected\");\n                message.universes[i] = $root.Universes.fromObject(object.universes[i]);\n            }\n        }\n        if (object.shapes) {\n            if (!Array.isArray(object.shapes))\n                throw TypeError(\".ConsolidatedShapes.shapes: array expected\");\n            message.shapes = [];\n            for (let i = 0; i < object.shapes.length; ++i) {\n                if (typeof object.shapes[i] !== \"object\")\n                    throw TypeError(\".ConsolidatedShapes.shapes: object expected\");\n                message.shapes[i] = $root.Feature.fromObject(object.shapes[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a ConsolidatedShapes message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ConsolidatedShapes\n     * @static\n     * @param {ConsolidatedShapes} message ConsolidatedShapes\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ConsolidatedShapes.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.longnames = [];\n            object.shapes = [];\n            object.universes = [];\n        }\n        if (message.longnames && message.longnames.length) {\n            object.longnames = [];\n            for (let j = 0; j < message.longnames.length; ++j)\n                object.longnames[j] = message.longnames[j];\n        }\n        if (message.shapes && message.shapes.length) {\n            object.shapes = [];\n            for (let j = 0; j < message.shapes.length; ++j)\n                object.shapes[j] = $root.Feature.toObject(message.shapes[j], options);\n        }\n        if (message.universes && message.universes.length) {\n            object.universes = [];\n            for (let j = 0; j < message.universes.length; ++j)\n                object.universes[j] = $root.Universes.toObject(message.universes[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ConsolidatedShapes to JSON.\n     * @function toJSON\n     * @memberof ConsolidatedShapes\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ConsolidatedShapes.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for ConsolidatedShapes\n     * @function getTypeUrl\n     * @memberof ConsolidatedShapes\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    ConsolidatedShapes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/ConsolidatedShapes\";\n    };\n\n    return ConsolidatedShapes;\n})();\n\nexport const QuizDataForStat = $root.QuizDataForStat = (() => {\n\n    /**\n     * Properties of a QuizDataForStat.\n     * @exports IQuizDataForStat\n     * @interface IQuizDataForStat\n     * @property {Array.<number>|null} [stats] QuizDataForStat stats\n     */\n\n    /**\n     * Constructs a new QuizDataForStat.\n     * @exports QuizDataForStat\n     * @classdesc Represents a QuizDataForStat.\n     * @implements IQuizDataForStat\n     * @constructor\n     * @param {IQuizDataForStat=} [properties] Properties to set\n     */\n    function QuizDataForStat(properties) {\n        this.stats = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * QuizDataForStat stats.\n     * @member {Array.<number>} stats\n     * @memberof QuizDataForStat\n     * @instance\n     */\n    QuizDataForStat.prototype.stats = $util.emptyArray;\n\n    /**\n     * Creates a new QuizDataForStat instance using the specified properties.\n     * @function create\n     * @memberof QuizDataForStat\n     * @static\n     * @param {IQuizDataForStat=} [properties] Properties to set\n     * @returns {QuizDataForStat} QuizDataForStat instance\n     */\n    QuizDataForStat.create = function create(properties) {\n        return new QuizDataForStat(properties);\n    };\n\n    /**\n     * Encodes the specified QuizDataForStat message. Does not implicitly {@link QuizDataForStat.verify|verify} messages.\n     * @function encode\n     * @memberof QuizDataForStat\n     * @static\n     * @param {IQuizDataForStat} message QuizDataForStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QuizDataForStat.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.stats != null && message.stats.length) {\n            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n            for (let i = 0; i < message.stats.length; ++i)\n                writer.float(message.stats[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified QuizDataForStat message, length delimited. Does not implicitly {@link QuizDataForStat.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof QuizDataForStat\n     * @static\n     * @param {IQuizDataForStat} message QuizDataForStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QuizDataForStat.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a QuizDataForStat message from the specified reader or buffer.\n     * @function decode\n     * @memberof QuizDataForStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {QuizDataForStat} QuizDataForStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QuizDataForStat.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.QuizDataForStat();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.stats && message.stats.length))\n                        message.stats = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.stats.push(reader.float());\n                    } else\n                        message.stats.push(reader.float());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a QuizDataForStat message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof QuizDataForStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {QuizDataForStat} QuizDataForStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QuizDataForStat.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a QuizDataForStat message.\n     * @function verify\n     * @memberof QuizDataForStat\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    QuizDataForStat.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.stats != null && message.hasOwnProperty(\"stats\")) {\n            if (!Array.isArray(message.stats))\n                return \"stats: array expected\";\n            for (let i = 0; i < message.stats.length; ++i)\n                if (typeof message.stats[i] !== \"number\")\n                    return \"stats: number[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a QuizDataForStat message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof QuizDataForStat\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {QuizDataForStat} QuizDataForStat\n     */\n    QuizDataForStat.fromObject = function fromObject(object) {\n        if (object instanceof $root.QuizDataForStat)\n            return object;\n        let message = new $root.QuizDataForStat();\n        if (object.stats) {\n            if (!Array.isArray(object.stats))\n                throw TypeError(\".QuizDataForStat.stats: array expected\");\n            message.stats = [];\n            for (let i = 0; i < object.stats.length; ++i)\n                message.stats[i] = Number(object.stats[i]);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a QuizDataForStat message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof QuizDataForStat\n     * @static\n     * @param {QuizDataForStat} message QuizDataForStat\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    QuizDataForStat.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.stats = [];\n        if (message.stats && message.stats.length) {\n            object.stats = [];\n            for (let j = 0; j < message.stats.length; ++j)\n                object.stats[j] = options.json && !isFinite(message.stats[j]) ? String(message.stats[j]) : message.stats[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this QuizDataForStat to JSON.\n     * @function toJSON\n     * @memberof QuizDataForStat\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    QuizDataForStat.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for QuizDataForStat\n     * @function getTypeUrl\n     * @memberof QuizDataForStat\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    QuizDataForStat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/QuizDataForStat\";\n    };\n\n    return QuizDataForStat;\n})();\n\nexport const QuizFullData = $root.QuizFullData = (() => {\n\n    /**\n     * Properties of a QuizFullData.\n     * @exports IQuizFullData\n     * @interface IQuizFullData\n     * @property {Array.<IQuizDataForStat>|null} [stats] QuizFullData stats\n     */\n\n    /**\n     * Constructs a new QuizFullData.\n     * @exports QuizFullData\n     * @classdesc Represents a QuizFullData.\n     * @implements IQuizFullData\n     * @constructor\n     * @param {IQuizFullData=} [properties] Properties to set\n     */\n    function QuizFullData(properties) {\n        this.stats = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * QuizFullData stats.\n     * @member {Array.<IQuizDataForStat>} stats\n     * @memberof QuizFullData\n     * @instance\n     */\n    QuizFullData.prototype.stats = $util.emptyArray;\n\n    /**\n     * Creates a new QuizFullData instance using the specified properties.\n     * @function create\n     * @memberof QuizFullData\n     * @static\n     * @param {IQuizFullData=} [properties] Properties to set\n     * @returns {QuizFullData} QuizFullData instance\n     */\n    QuizFullData.create = function create(properties) {\n        return new QuizFullData(properties);\n    };\n\n    /**\n     * Encodes the specified QuizFullData message. Does not implicitly {@link QuizFullData.verify|verify} messages.\n     * @function encode\n     * @memberof QuizFullData\n     * @static\n     * @param {IQuizFullData} message QuizFullData message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QuizFullData.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.stats != null && message.stats.length)\n            for (let i = 0; i < message.stats.length; ++i)\n                $root.QuizDataForStat.encode(message.stats[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified QuizFullData message, length delimited. Does not implicitly {@link QuizFullData.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof QuizFullData\n     * @static\n     * @param {IQuizFullData} message QuizFullData message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QuizFullData.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a QuizFullData message from the specified reader or buffer.\n     * @function decode\n     * @memberof QuizFullData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {QuizFullData} QuizFullData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QuizFullData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.QuizFullData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.stats && message.stats.length))\n                        message.stats = [];\n                    message.stats.push($root.QuizDataForStat.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a QuizFullData message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof QuizFullData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {QuizFullData} QuizFullData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QuizFullData.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a QuizFullData message.\n     * @function verify\n     * @memberof QuizFullData\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    QuizFullData.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.stats != null && message.hasOwnProperty(\"stats\")) {\n            if (!Array.isArray(message.stats))\n                return \"stats: array expected\";\n            for (let i = 0; i < message.stats.length; ++i) {\n                let error = $root.QuizDataForStat.verify(message.stats[i]);\n                if (error)\n                    return \"stats.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a QuizFullData message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof QuizFullData\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {QuizFullData} QuizFullData\n     */\n    QuizFullData.fromObject = function fromObject(object) {\n        if (object instanceof $root.QuizFullData)\n            return object;\n        let message = new $root.QuizFullData();\n        if (object.stats) {\n            if (!Array.isArray(object.stats))\n                throw TypeError(\".QuizFullData.stats: array expected\");\n            message.stats = [];\n            for (let i = 0; i < object.stats.length; ++i) {\n                if (typeof object.stats[i] !== \"object\")\n                    throw TypeError(\".QuizFullData.stats: object expected\");\n                message.stats[i] = $root.QuizDataForStat.fromObject(object.stats[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a QuizFullData message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof QuizFullData\n     * @static\n     * @param {QuizFullData} message QuizFullData\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    QuizFullData.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.stats = [];\n        if (message.stats && message.stats.length) {\n            object.stats = [];\n            for (let j = 0; j < message.stats.length; ++j)\n                object.stats[j] = $root.QuizDataForStat.toObject(message.stats[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this QuizFullData to JSON.\n     * @function toJSON\n     * @memberof QuizFullData\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    QuizFullData.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for QuizFullData\n     * @function getTypeUrl\n     * @memberof QuizFullData\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    QuizFullData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/QuizFullData\";\n    };\n\n    return QuizFullData;\n})();\n\nexport const QuizQuestionTronche = $root.QuizQuestionTronche = (() => {\n\n    /**\n     * Properties of a QuizQuestionTronche.\n     * @exports IQuizQuestionTronche\n     * @interface IQuizQuestionTronche\n     * @property {Array.<number>|null} [geographyA] QuizQuestionTronche geographyA\n     * @property {Array.<number>|null} [geographyB] QuizQuestionTronche geographyB\n     * @property {Array.<number>|null} [stat] QuizQuestionTronche stat\n     * @property {number|null} [negLogProbX10Basis] QuizQuestionTronche negLogProbX10Basis\n     * @property {Array.<number>|null} [negLogProbX10MinusBasis] QuizQuestionTronche negLogProbX10MinusBasis\n     */\n\n    /**\n     * Constructs a new QuizQuestionTronche.\n     * @exports QuizQuestionTronche\n     * @classdesc Represents a QuizQuestionTronche.\n     * @implements IQuizQuestionTronche\n     * @constructor\n     * @param {IQuizQuestionTronche=} [properties] Properties to set\n     */\n    function QuizQuestionTronche(properties) {\n        this.geographyA = [];\n        this.geographyB = [];\n        this.stat = [];\n        this.negLogProbX10MinusBasis = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * QuizQuestionTronche geographyA.\n     * @member {Array.<number>} geographyA\n     * @memberof QuizQuestionTronche\n     * @instance\n     */\n    QuizQuestionTronche.prototype.geographyA = $util.emptyArray;\n\n    /**\n     * QuizQuestionTronche geographyB.\n     * @member {Array.<number>} geographyB\n     * @memberof QuizQuestionTronche\n     * @instance\n     */\n    QuizQuestionTronche.prototype.geographyB = $util.emptyArray;\n\n    /**\n     * QuizQuestionTronche stat.\n     * @member {Array.<number>} stat\n     * @memberof QuizQuestionTronche\n     * @instance\n     */\n    QuizQuestionTronche.prototype.stat = $util.emptyArray;\n\n    /**\n     * QuizQuestionTronche negLogProbX10Basis.\n     * @member {number} negLogProbX10Basis\n     * @memberof QuizQuestionTronche\n     * @instance\n     */\n    QuizQuestionTronche.prototype.negLogProbX10Basis = 0;\n\n    /**\n     * QuizQuestionTronche negLogProbX10MinusBasis.\n     * @member {Array.<number>} negLogProbX10MinusBasis\n     * @memberof QuizQuestionTronche\n     * @instance\n     */\n    QuizQuestionTronche.prototype.negLogProbX10MinusBasis = $util.emptyArray;\n\n    /**\n     * Creates a new QuizQuestionTronche instance using the specified properties.\n     * @function create\n     * @memberof QuizQuestionTronche\n     * @static\n     * @param {IQuizQuestionTronche=} [properties] Properties to set\n     * @returns {QuizQuestionTronche} QuizQuestionTronche instance\n     */\n    QuizQuestionTronche.create = function create(properties) {\n        return new QuizQuestionTronche(properties);\n    };\n\n    /**\n     * Encodes the specified QuizQuestionTronche message. Does not implicitly {@link QuizQuestionTronche.verify|verify} messages.\n     * @function encode\n     * @memberof QuizQuestionTronche\n     * @static\n     * @param {IQuizQuestionTronche} message QuizQuestionTronche message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QuizQuestionTronche.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.geographyA != null && message.geographyA.length) {\n            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n            for (let i = 0; i < message.geographyA.length; ++i)\n                writer.int32(message.geographyA[i]);\n            writer.ldelim();\n        }\n        if (message.geographyB != null && message.geographyB.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.geographyB.length; ++i)\n                writer.int32(message.geographyB[i]);\n            writer.ldelim();\n        }\n        if (message.stat != null && message.stat.length) {\n            writer.uint32(/* id 3, wireType 2 =*/26).fork();\n            for (let i = 0; i < message.stat.length; ++i)\n                writer.int32(message.stat[i]);\n            writer.ldelim();\n        }\n        if (message.negLogProbX10Basis != null && Object.hasOwnProperty.call(message, \"negLogProbX10Basis\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.negLogProbX10Basis);\n        if (message.negLogProbX10MinusBasis != null && message.negLogProbX10MinusBasis.length) {\n            writer.uint32(/* id 5, wireType 2 =*/42).fork();\n            for (let i = 0; i < message.negLogProbX10MinusBasis.length; ++i)\n                writer.int32(message.negLogProbX10MinusBasis[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified QuizQuestionTronche message, length delimited. Does not implicitly {@link QuizQuestionTronche.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof QuizQuestionTronche\n     * @static\n     * @param {IQuizQuestionTronche} message QuizQuestionTronche message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QuizQuestionTronche.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a QuizQuestionTronche message from the specified reader or buffer.\n     * @function decode\n     * @memberof QuizQuestionTronche\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {QuizQuestionTronche} QuizQuestionTronche\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QuizQuestionTronche.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.QuizQuestionTronche();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.geographyA && message.geographyA.length))\n                        message.geographyA = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.geographyA.push(reader.int32());\n                    } else\n                        message.geographyA.push(reader.int32());\n                    break;\n                }\n            case 2: {\n                    if (!(message.geographyB && message.geographyB.length))\n                        message.geographyB = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.geographyB.push(reader.int32());\n                    } else\n                        message.geographyB.push(reader.int32());\n                    break;\n                }\n            case 3: {\n                    if (!(message.stat && message.stat.length))\n                        message.stat = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.stat.push(reader.int32());\n                    } else\n                        message.stat.push(reader.int32());\n                    break;\n                }\n            case 4: {\n                    message.negLogProbX10Basis = reader.int32();\n                    break;\n                }\n            case 5: {\n                    if (!(message.negLogProbX10MinusBasis && message.negLogProbX10MinusBasis.length))\n                        message.negLogProbX10MinusBasis = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.negLogProbX10MinusBasis.push(reader.int32());\n                    } else\n                        message.negLogProbX10MinusBasis.push(reader.int32());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a QuizQuestionTronche message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof QuizQuestionTronche\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {QuizQuestionTronche} QuizQuestionTronche\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QuizQuestionTronche.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a QuizQuestionTronche message.\n     * @function verify\n     * @memberof QuizQuestionTronche\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    QuizQuestionTronche.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.geographyA != null && message.hasOwnProperty(\"geographyA\")) {\n            if (!Array.isArray(message.geographyA))\n                return \"geographyA: array expected\";\n            for (let i = 0; i < message.geographyA.length; ++i)\n                if (!$util.isInteger(message.geographyA[i]))\n                    return \"geographyA: integer[] expected\";\n        }\n        if (message.geographyB != null && message.hasOwnProperty(\"geographyB\")) {\n            if (!Array.isArray(message.geographyB))\n                return \"geographyB: array expected\";\n            for (let i = 0; i < message.geographyB.length; ++i)\n                if (!$util.isInteger(message.geographyB[i]))\n                    return \"geographyB: integer[] expected\";\n        }\n        if (message.stat != null && message.hasOwnProperty(\"stat\")) {\n            if (!Array.isArray(message.stat))\n                return \"stat: array expected\";\n            for (let i = 0; i < message.stat.length; ++i)\n                if (!$util.isInteger(message.stat[i]))\n                    return \"stat: integer[] expected\";\n        }\n        if (message.negLogProbX10Basis != null && message.hasOwnProperty(\"negLogProbX10Basis\"))\n            if (!$util.isInteger(message.negLogProbX10Basis))\n                return \"negLogProbX10Basis: integer expected\";\n        if (message.negLogProbX10MinusBasis != null && message.hasOwnProperty(\"negLogProbX10MinusBasis\")) {\n            if (!Array.isArray(message.negLogProbX10MinusBasis))\n                return \"negLogProbX10MinusBasis: array expected\";\n            for (let i = 0; i < message.negLogProbX10MinusBasis.length; ++i)\n                if (!$util.isInteger(message.negLogProbX10MinusBasis[i]))\n                    return \"negLogProbX10MinusBasis: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a QuizQuestionTronche message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof QuizQuestionTronche\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {QuizQuestionTronche} QuizQuestionTronche\n     */\n    QuizQuestionTronche.fromObject = function fromObject(object) {\n        if (object instanceof $root.QuizQuestionTronche)\n            return object;\n        let message = new $root.QuizQuestionTronche();\n        if (object.geographyA) {\n            if (!Array.isArray(object.geographyA))\n                throw TypeError(\".QuizQuestionTronche.geographyA: array expected\");\n            message.geographyA = [];\n            for (let i = 0; i < object.geographyA.length; ++i)\n                message.geographyA[i] = object.geographyA[i] | 0;\n        }\n        if (object.geographyB) {\n            if (!Array.isArray(object.geographyB))\n                throw TypeError(\".QuizQuestionTronche.geographyB: array expected\");\n            message.geographyB = [];\n            for (let i = 0; i < object.geographyB.length; ++i)\n                message.geographyB[i] = object.geographyB[i] | 0;\n        }\n        if (object.stat) {\n            if (!Array.isArray(object.stat))\n                throw TypeError(\".QuizQuestionTronche.stat: array expected\");\n            message.stat = [];\n            for (let i = 0; i < object.stat.length; ++i)\n                message.stat[i] = object.stat[i] | 0;\n        }\n        if (object.negLogProbX10Basis != null)\n            message.negLogProbX10Basis = object.negLogProbX10Basis | 0;\n        if (object.negLogProbX10MinusBasis) {\n            if (!Array.isArray(object.negLogProbX10MinusBasis))\n                throw TypeError(\".QuizQuestionTronche.negLogProbX10MinusBasis: array expected\");\n            message.negLogProbX10MinusBasis = [];\n            for (let i = 0; i < object.negLogProbX10MinusBasis.length; ++i)\n                message.negLogProbX10MinusBasis[i] = object.negLogProbX10MinusBasis[i] | 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a QuizQuestionTronche message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof QuizQuestionTronche\n     * @static\n     * @param {QuizQuestionTronche} message QuizQuestionTronche\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    QuizQuestionTronche.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.geographyA = [];\n            object.geographyB = [];\n            object.stat = [];\n            object.negLogProbX10MinusBasis = [];\n        }\n        if (options.defaults)\n            object.negLogProbX10Basis = 0;\n        if (message.geographyA && message.geographyA.length) {\n            object.geographyA = [];\n            for (let j = 0; j < message.geographyA.length; ++j)\n                object.geographyA[j] = message.geographyA[j];\n        }\n        if (message.geographyB && message.geographyB.length) {\n            object.geographyB = [];\n            for (let j = 0; j < message.geographyB.length; ++j)\n                object.geographyB[j] = message.geographyB[j];\n        }\n        if (message.stat && message.stat.length) {\n            object.stat = [];\n            for (let j = 0; j < message.stat.length; ++j)\n                object.stat[j] = message.stat[j];\n        }\n        if (message.negLogProbX10Basis != null && message.hasOwnProperty(\"negLogProbX10Basis\"))\n            object.negLogProbX10Basis = message.negLogProbX10Basis;\n        if (message.negLogProbX10MinusBasis && message.negLogProbX10MinusBasis.length) {\n            object.negLogProbX10MinusBasis = [];\n            for (let j = 0; j < message.negLogProbX10MinusBasis.length; ++j)\n                object.negLogProbX10MinusBasis[j] = message.negLogProbX10MinusBasis[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this QuizQuestionTronche to JSON.\n     * @function toJSON\n     * @memberof QuizQuestionTronche\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    QuizQuestionTronche.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for QuizQuestionTronche\n     * @function getTypeUrl\n     * @memberof QuizQuestionTronche\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    QuizQuestionTronche.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/QuizQuestionTronche\";\n    };\n\n    return QuizQuestionTronche;\n})();\n\nexport const CountsByColumnCompressed = $root.CountsByColumnCompressed = (() => {\n\n    /**\n     * Properties of a CountsByColumnCompressed.\n     * @exports ICountsByColumnCompressed\n     * @interface ICountsByColumnCompressed\n     * @property {Array.<number>|null} [count] CountsByColumnCompressed count\n     * @property {Array.<number>|null} [countRepeat] CountsByColumnCompressed countRepeat\n     */\n\n    /**\n     * Constructs a new CountsByColumnCompressed.\n     * @exports CountsByColumnCompressed\n     * @classdesc Represents a CountsByColumnCompressed.\n     * @implements ICountsByColumnCompressed\n     * @constructor\n     * @param {ICountsByColumnCompressed=} [properties] Properties to set\n     */\n    function CountsByColumnCompressed(properties) {\n        this.count = [];\n        this.countRepeat = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CountsByColumnCompressed count.\n     * @member {Array.<number>} count\n     * @memberof CountsByColumnCompressed\n     * @instance\n     */\n    CountsByColumnCompressed.prototype.count = $util.emptyArray;\n\n    /**\n     * CountsByColumnCompressed countRepeat.\n     * @member {Array.<number>} countRepeat\n     * @memberof CountsByColumnCompressed\n     * @instance\n     */\n    CountsByColumnCompressed.prototype.countRepeat = $util.emptyArray;\n\n    /**\n     * Creates a new CountsByColumnCompressed instance using the specified properties.\n     * @function create\n     * @memberof CountsByColumnCompressed\n     * @static\n     * @param {ICountsByColumnCompressed=} [properties] Properties to set\n     * @returns {CountsByColumnCompressed} CountsByColumnCompressed instance\n     */\n    CountsByColumnCompressed.create = function create(properties) {\n        return new CountsByColumnCompressed(properties);\n    };\n\n    /**\n     * Encodes the specified CountsByColumnCompressed message. Does not implicitly {@link CountsByColumnCompressed.verify|verify} messages.\n     * @function encode\n     * @memberof CountsByColumnCompressed\n     * @static\n     * @param {ICountsByColumnCompressed} message CountsByColumnCompressed message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CountsByColumnCompressed.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.count != null && message.count.length) {\n            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n            for (let i = 0; i < message.count.length; ++i)\n                writer.int32(message.count[i]);\n            writer.ldelim();\n        }\n        if (message.countRepeat != null && message.countRepeat.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.countRepeat.length; ++i)\n                writer.int32(message.countRepeat[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CountsByColumnCompressed message, length delimited. Does not implicitly {@link CountsByColumnCompressed.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CountsByColumnCompressed\n     * @static\n     * @param {ICountsByColumnCompressed} message CountsByColumnCompressed message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CountsByColumnCompressed.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CountsByColumnCompressed message from the specified reader or buffer.\n     * @function decode\n     * @memberof CountsByColumnCompressed\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CountsByColumnCompressed} CountsByColumnCompressed\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CountsByColumnCompressed.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CountsByColumnCompressed();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.count && message.count.length))\n                        message.count = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.count.push(reader.int32());\n                    } else\n                        message.count.push(reader.int32());\n                    break;\n                }\n            case 2: {\n                    if (!(message.countRepeat && message.countRepeat.length))\n                        message.countRepeat = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.countRepeat.push(reader.int32());\n                    } else\n                        message.countRepeat.push(reader.int32());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a CountsByColumnCompressed message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CountsByColumnCompressed\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CountsByColumnCompressed} CountsByColumnCompressed\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CountsByColumnCompressed.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CountsByColumnCompressed message.\n     * @function verify\n     * @memberof CountsByColumnCompressed\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CountsByColumnCompressed.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.count != null && message.hasOwnProperty(\"count\")) {\n            if (!Array.isArray(message.count))\n                return \"count: array expected\";\n            for (let i = 0; i < message.count.length; ++i)\n                if (!$util.isInteger(message.count[i]))\n                    return \"count: integer[] expected\";\n        }\n        if (message.countRepeat != null && message.hasOwnProperty(\"countRepeat\")) {\n            if (!Array.isArray(message.countRepeat))\n                return \"countRepeat: array expected\";\n            for (let i = 0; i < message.countRepeat.length; ++i)\n                if (!$util.isInteger(message.countRepeat[i]))\n                    return \"countRepeat: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a CountsByColumnCompressed message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CountsByColumnCompressed\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CountsByColumnCompressed} CountsByColumnCompressed\n     */\n    CountsByColumnCompressed.fromObject = function fromObject(object) {\n        if (object instanceof $root.CountsByColumnCompressed)\n            return object;\n        let message = new $root.CountsByColumnCompressed();\n        if (object.count) {\n            if (!Array.isArray(object.count))\n                throw TypeError(\".CountsByColumnCompressed.count: array expected\");\n            message.count = [];\n            for (let i = 0; i < object.count.length; ++i)\n                message.count[i] = object.count[i] | 0;\n        }\n        if (object.countRepeat) {\n            if (!Array.isArray(object.countRepeat))\n                throw TypeError(\".CountsByColumnCompressed.countRepeat: array expected\");\n            message.countRepeat = [];\n            for (let i = 0; i < object.countRepeat.length; ++i)\n                message.countRepeat[i] = object.countRepeat[i] | 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CountsByColumnCompressed message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CountsByColumnCompressed\n     * @static\n     * @param {CountsByColumnCompressed} message CountsByColumnCompressed\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CountsByColumnCompressed.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.count = [];\n            object.countRepeat = [];\n        }\n        if (message.count && message.count.length) {\n            object.count = [];\n            for (let j = 0; j < message.count.length; ++j)\n                object.count[j] = message.count[j];\n        }\n        if (message.countRepeat && message.countRepeat.length) {\n            object.countRepeat = [];\n            for (let j = 0; j < message.countRepeat.length; ++j)\n                object.countRepeat[j] = message.countRepeat[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this CountsByColumnCompressed to JSON.\n     * @function toJSON\n     * @memberof CountsByColumnCompressed\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CountsByColumnCompressed.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for CountsByColumnCompressed\n     * @function getTypeUrl\n     * @memberof CountsByColumnCompressed\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    CountsByColumnCompressed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/CountsByColumnCompressed\";\n    };\n\n    return CountsByColumnCompressed;\n})();\n\nexport const CountsByArticleType = $root.CountsByArticleType = (() => {\n\n    /**\n     * Properties of a CountsByArticleType.\n     * @exports ICountsByArticleType\n     * @interface ICountsByArticleType\n     * @property {Array.<string>|null} [articleType] CountsByArticleType articleType\n     * @property {Array.<ICountsByColumnCompressed>|null} [counts] CountsByArticleType counts\n     */\n\n    /**\n     * Constructs a new CountsByArticleType.\n     * @exports CountsByArticleType\n     * @classdesc Represents a CountsByArticleType.\n     * @implements ICountsByArticleType\n     * @constructor\n     * @param {ICountsByArticleType=} [properties] Properties to set\n     */\n    function CountsByArticleType(properties) {\n        this.articleType = [];\n        this.counts = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CountsByArticleType articleType.\n     * @member {Array.<string>} articleType\n     * @memberof CountsByArticleType\n     * @instance\n     */\n    CountsByArticleType.prototype.articleType = $util.emptyArray;\n\n    /**\n     * CountsByArticleType counts.\n     * @member {Array.<ICountsByColumnCompressed>} counts\n     * @memberof CountsByArticleType\n     * @instance\n     */\n    CountsByArticleType.prototype.counts = $util.emptyArray;\n\n    /**\n     * Creates a new CountsByArticleType instance using the specified properties.\n     * @function create\n     * @memberof CountsByArticleType\n     * @static\n     * @param {ICountsByArticleType=} [properties] Properties to set\n     * @returns {CountsByArticleType} CountsByArticleType instance\n     */\n    CountsByArticleType.create = function create(properties) {\n        return new CountsByArticleType(properties);\n    };\n\n    /**\n     * Encodes the specified CountsByArticleType message. Does not implicitly {@link CountsByArticleType.verify|verify} messages.\n     * @function encode\n     * @memberof CountsByArticleType\n     * @static\n     * @param {ICountsByArticleType} message CountsByArticleType message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CountsByArticleType.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.articleType != null && message.articleType.length)\n            for (let i = 0; i < message.articleType.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.articleType[i]);\n        if (message.counts != null && message.counts.length)\n            for (let i = 0; i < message.counts.length; ++i)\n                $root.CountsByColumnCompressed.encode(message.counts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CountsByArticleType message, length delimited. Does not implicitly {@link CountsByArticleType.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CountsByArticleType\n     * @static\n     * @param {ICountsByArticleType} message CountsByArticleType message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CountsByArticleType.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CountsByArticleType message from the specified reader or buffer.\n     * @function decode\n     * @memberof CountsByArticleType\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CountsByArticleType} CountsByArticleType\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CountsByArticleType.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CountsByArticleType();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.articleType && message.articleType.length))\n                        message.articleType = [];\n                    message.articleType.push(reader.string());\n                    break;\n                }\n            case 2: {\n                    if (!(message.counts && message.counts.length))\n                        message.counts = [];\n                    message.counts.push($root.CountsByColumnCompressed.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a CountsByArticleType message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CountsByArticleType\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CountsByArticleType} CountsByArticleType\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CountsByArticleType.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CountsByArticleType message.\n     * @function verify\n     * @memberof CountsByArticleType\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CountsByArticleType.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.articleType != null && message.hasOwnProperty(\"articleType\")) {\n            if (!Array.isArray(message.articleType))\n                return \"articleType: array expected\";\n            for (let i = 0; i < message.articleType.length; ++i)\n                if (!$util.isString(message.articleType[i]))\n                    return \"articleType: string[] expected\";\n        }\n        if (message.counts != null && message.hasOwnProperty(\"counts\")) {\n            if (!Array.isArray(message.counts))\n                return \"counts: array expected\";\n            for (let i = 0; i < message.counts.length; ++i) {\n                let error = $root.CountsByColumnCompressed.verify(message.counts[i]);\n                if (error)\n                    return \"counts.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a CountsByArticleType message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CountsByArticleType\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CountsByArticleType} CountsByArticleType\n     */\n    CountsByArticleType.fromObject = function fromObject(object) {\n        if (object instanceof $root.CountsByArticleType)\n            return object;\n        let message = new $root.CountsByArticleType();\n        if (object.articleType) {\n            if (!Array.isArray(object.articleType))\n                throw TypeError(\".CountsByArticleType.articleType: array expected\");\n            message.articleType = [];\n            for (let i = 0; i < object.articleType.length; ++i)\n                message.articleType[i] = String(object.articleType[i]);\n        }\n        if (object.counts) {\n            if (!Array.isArray(object.counts))\n                throw TypeError(\".CountsByArticleType.counts: array expected\");\n            message.counts = [];\n            for (let i = 0; i < object.counts.length; ++i) {\n                if (typeof object.counts[i] !== \"object\")\n                    throw TypeError(\".CountsByArticleType.counts: object expected\");\n                message.counts[i] = $root.CountsByColumnCompressed.fromObject(object.counts[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CountsByArticleType message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CountsByArticleType\n     * @static\n     * @param {CountsByArticleType} message CountsByArticleType\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CountsByArticleType.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.articleType = [];\n            object.counts = [];\n        }\n        if (message.articleType && message.articleType.length) {\n            object.articleType = [];\n            for (let j = 0; j < message.articleType.length; ++j)\n                object.articleType[j] = message.articleType[j];\n        }\n        if (message.counts && message.counts.length) {\n            object.counts = [];\n            for (let j = 0; j < message.counts.length; ++j)\n                object.counts[j] = $root.CountsByColumnCompressed.toObject(message.counts[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this CountsByArticleType to JSON.\n     * @function toJSON\n     * @memberof CountsByArticleType\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CountsByArticleType.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for CountsByArticleType\n     * @function getTypeUrl\n     * @memberof CountsByArticleType\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    CountsByArticleType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/CountsByArticleType\";\n    };\n\n    return CountsByArticleType;\n})();\n\nexport const CountsByArticleUniverseAndType = $root.CountsByArticleUniverseAndType = (() => {\n\n    /**\n     * Properties of a CountsByArticleUniverseAndType.\n     * @exports ICountsByArticleUniverseAndType\n     * @interface ICountsByArticleUniverseAndType\n     * @property {Array.<string>|null} [universe] CountsByArticleUniverseAndType universe\n     * @property {Array.<ICountsByArticleType>|null} [countsByType] CountsByArticleUniverseAndType countsByType\n     */\n\n    /**\n     * Constructs a new CountsByArticleUniverseAndType.\n     * @exports CountsByArticleUniverseAndType\n     * @classdesc Represents a CountsByArticleUniverseAndType.\n     * @implements ICountsByArticleUniverseAndType\n     * @constructor\n     * @param {ICountsByArticleUniverseAndType=} [properties] Properties to set\n     */\n    function CountsByArticleUniverseAndType(properties) {\n        this.universe = [];\n        this.countsByType = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CountsByArticleUniverseAndType universe.\n     * @member {Array.<string>} universe\n     * @memberof CountsByArticleUniverseAndType\n     * @instance\n     */\n    CountsByArticleUniverseAndType.prototype.universe = $util.emptyArray;\n\n    /**\n     * CountsByArticleUniverseAndType countsByType.\n     * @member {Array.<ICountsByArticleType>} countsByType\n     * @memberof CountsByArticleUniverseAndType\n     * @instance\n     */\n    CountsByArticleUniverseAndType.prototype.countsByType = $util.emptyArray;\n\n    /**\n     * Creates a new CountsByArticleUniverseAndType instance using the specified properties.\n     * @function create\n     * @memberof CountsByArticleUniverseAndType\n     * @static\n     * @param {ICountsByArticleUniverseAndType=} [properties] Properties to set\n     * @returns {CountsByArticleUniverseAndType} CountsByArticleUniverseAndType instance\n     */\n    CountsByArticleUniverseAndType.create = function create(properties) {\n        return new CountsByArticleUniverseAndType(properties);\n    };\n\n    /**\n     * Encodes the specified CountsByArticleUniverseAndType message. Does not implicitly {@link CountsByArticleUniverseAndType.verify|verify} messages.\n     * @function encode\n     * @memberof CountsByArticleUniverseAndType\n     * @static\n     * @param {ICountsByArticleUniverseAndType} message CountsByArticleUniverseAndType message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CountsByArticleUniverseAndType.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.universe != null && message.universe.length)\n            for (let i = 0; i < message.universe.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.universe[i]);\n        if (message.countsByType != null && message.countsByType.length)\n            for (let i = 0; i < message.countsByType.length; ++i)\n                $root.CountsByArticleType.encode(message.countsByType[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CountsByArticleUniverseAndType message, length delimited. Does not implicitly {@link CountsByArticleUniverseAndType.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CountsByArticleUniverseAndType\n     * @static\n     * @param {ICountsByArticleUniverseAndType} message CountsByArticleUniverseAndType message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CountsByArticleUniverseAndType.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CountsByArticleUniverseAndType message from the specified reader or buffer.\n     * @function decode\n     * @memberof CountsByArticleUniverseAndType\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CountsByArticleUniverseAndType} CountsByArticleUniverseAndType\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CountsByArticleUniverseAndType.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CountsByArticleUniverseAndType();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.universe && message.universe.length))\n                        message.universe = [];\n                    message.universe.push(reader.string());\n                    break;\n                }\n            case 2: {\n                    if (!(message.countsByType && message.countsByType.length))\n                        message.countsByType = [];\n                    message.countsByType.push($root.CountsByArticleType.decode(reader, reader.uint32()));\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a CountsByArticleUniverseAndType message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CountsByArticleUniverseAndType\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CountsByArticleUniverseAndType} CountsByArticleUniverseAndType\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CountsByArticleUniverseAndType.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CountsByArticleUniverseAndType message.\n     * @function verify\n     * @memberof CountsByArticleUniverseAndType\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CountsByArticleUniverseAndType.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.universe != null && message.hasOwnProperty(\"universe\")) {\n            if (!Array.isArray(message.universe))\n                return \"universe: array expected\";\n            for (let i = 0; i < message.universe.length; ++i)\n                if (!$util.isString(message.universe[i]))\n                    return \"universe: string[] expected\";\n        }\n        if (message.countsByType != null && message.hasOwnProperty(\"countsByType\")) {\n            if (!Array.isArray(message.countsByType))\n                return \"countsByType: array expected\";\n            for (let i = 0; i < message.countsByType.length; ++i) {\n                let error = $root.CountsByArticleType.verify(message.countsByType[i]);\n                if (error)\n                    return \"countsByType.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a CountsByArticleUniverseAndType message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CountsByArticleUniverseAndType\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CountsByArticleUniverseAndType} CountsByArticleUniverseAndType\n     */\n    CountsByArticleUniverseAndType.fromObject = function fromObject(object) {\n        if (object instanceof $root.CountsByArticleUniverseAndType)\n            return object;\n        let message = new $root.CountsByArticleUniverseAndType();\n        if (object.universe) {\n            if (!Array.isArray(object.universe))\n                throw TypeError(\".CountsByArticleUniverseAndType.universe: array expected\");\n            message.universe = [];\n            for (let i = 0; i < object.universe.length; ++i)\n                message.universe[i] = String(object.universe[i]);\n        }\n        if (object.countsByType) {\n            if (!Array.isArray(object.countsByType))\n                throw TypeError(\".CountsByArticleUniverseAndType.countsByType: array expected\");\n            message.countsByType = [];\n            for (let i = 0; i < object.countsByType.length; ++i) {\n                if (typeof object.countsByType[i] !== \"object\")\n                    throw TypeError(\".CountsByArticleUniverseAndType.countsByType: object expected\");\n                message.countsByType[i] = $root.CountsByArticleType.fromObject(object.countsByType[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CountsByArticleUniverseAndType message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CountsByArticleUniverseAndType\n     * @static\n     * @param {CountsByArticleUniverseAndType} message CountsByArticleUniverseAndType\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CountsByArticleUniverseAndType.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.universe = [];\n            object.countsByType = [];\n        }\n        if (message.universe && message.universe.length) {\n            object.universe = [];\n            for (let j = 0; j < message.universe.length; ++j)\n                object.universe[j] = message.universe[j];\n        }\n        if (message.countsByType && message.countsByType.length) {\n            object.countsByType = [];\n            for (let j = 0; j < message.countsByType.length; ++j)\n                object.countsByType[j] = $root.CountsByArticleType.toObject(message.countsByType[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this CountsByArticleUniverseAndType to JSON.\n     * @function toJSON\n     * @memberof CountsByArticleUniverseAndType\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CountsByArticleUniverseAndType.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for CountsByArticleUniverseAndType\n     * @function getTypeUrl\n     * @memberof CountsByArticleUniverseAndType\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    CountsByArticleUniverseAndType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/CountsByArticleUniverseAndType\";\n    };\n\n    return CountsByArticleUniverseAndType;\n})();\n\nexport const Symlinks = $root.Symlinks = (() => {\n\n    /**\n     * Properties of a Symlinks.\n     * @exports ISymlinks\n     * @interface ISymlinks\n     * @property {Array.<string>|null} [linkName] Symlinks linkName\n     * @property {Array.<string>|null} [targetName] Symlinks targetName\n     */\n\n    /**\n     * Constructs a new Symlinks.\n     * @exports Symlinks\n     * @classdesc Represents a Symlinks.\n     * @implements ISymlinks\n     * @constructor\n     * @param {ISymlinks=} [properties] Properties to set\n     */\n    function Symlinks(properties) {\n        this.linkName = [];\n        this.targetName = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Symlinks linkName.\n     * @member {Array.<string>} linkName\n     * @memberof Symlinks\n     * @instance\n     */\n    Symlinks.prototype.linkName = $util.emptyArray;\n\n    /**\n     * Symlinks targetName.\n     * @member {Array.<string>} targetName\n     * @memberof Symlinks\n     * @instance\n     */\n    Symlinks.prototype.targetName = $util.emptyArray;\n\n    /**\n     * Creates a new Symlinks instance using the specified properties.\n     * @function create\n     * @memberof Symlinks\n     * @static\n     * @param {ISymlinks=} [properties] Properties to set\n     * @returns {Symlinks} Symlinks instance\n     */\n    Symlinks.create = function create(properties) {\n        return new Symlinks(properties);\n    };\n\n    /**\n     * Encodes the specified Symlinks message. Does not implicitly {@link Symlinks.verify|verify} messages.\n     * @function encode\n     * @memberof Symlinks\n     * @static\n     * @param {ISymlinks} message Symlinks message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Symlinks.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.linkName != null && message.linkName.length)\n            for (let i = 0; i < message.linkName.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.linkName[i]);\n        if (message.targetName != null && message.targetName.length)\n            for (let i = 0; i < message.targetName.length; ++i)\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetName[i]);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Symlinks message, length delimited. Does not implicitly {@link Symlinks.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Symlinks\n     * @static\n     * @param {ISymlinks} message Symlinks message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Symlinks.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Symlinks message from the specified reader or buffer.\n     * @function decode\n     * @memberof Symlinks\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Symlinks} Symlinks\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Symlinks.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Symlinks();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1: {\n                    if (!(message.linkName && message.linkName.length))\n                        message.linkName = [];\n                    message.linkName.push(reader.string());\n                    break;\n                }\n            case 2: {\n                    if (!(message.targetName && message.targetName.length))\n                        message.targetName = [];\n                    message.targetName.push(reader.string());\n                    break;\n                }\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Symlinks message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Symlinks\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Symlinks} Symlinks\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Symlinks.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Symlinks message.\n     * @function verify\n     * @memberof Symlinks\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Symlinks.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.linkName != null && message.hasOwnProperty(\"linkName\")) {\n            if (!Array.isArray(message.linkName))\n                return \"linkName: array expected\";\n            for (let i = 0; i < message.linkName.length; ++i)\n                if (!$util.isString(message.linkName[i]))\n                    return \"linkName: string[] expected\";\n        }\n        if (message.targetName != null && message.hasOwnProperty(\"targetName\")) {\n            if (!Array.isArray(message.targetName))\n                return \"targetName: array expected\";\n            for (let i = 0; i < message.targetName.length; ++i)\n                if (!$util.isString(message.targetName[i]))\n                    return \"targetName: string[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a Symlinks message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Symlinks\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Symlinks} Symlinks\n     */\n    Symlinks.fromObject = function fromObject(object) {\n        if (object instanceof $root.Symlinks)\n            return object;\n        let message = new $root.Symlinks();\n        if (object.linkName) {\n            if (!Array.isArray(object.linkName))\n                throw TypeError(\".Symlinks.linkName: array expected\");\n            message.linkName = [];\n            for (let i = 0; i < object.linkName.length; ++i)\n                message.linkName[i] = String(object.linkName[i]);\n        }\n        if (object.targetName) {\n            if (!Array.isArray(object.targetName))\n                throw TypeError(\".Symlinks.targetName: array expected\");\n            message.targetName = [];\n            for (let i = 0; i < object.targetName.length; ++i)\n                message.targetName[i] = String(object.targetName[i]);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Symlinks message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Symlinks\n     * @static\n     * @param {Symlinks} message Symlinks\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Symlinks.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.linkName = [];\n            object.targetName = [];\n        }\n        if (message.linkName && message.linkName.length) {\n            object.linkName = [];\n            for (let j = 0; j < message.linkName.length; ++j)\n                object.linkName[j] = message.linkName[j];\n        }\n        if (message.targetName && message.targetName.length) {\n            object.targetName = [];\n            for (let j = 0; j < message.targetName.length; ++j)\n                object.targetName[j] = message.targetName[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Symlinks to JSON.\n     * @function toJSON\n     * @memberof Symlinks\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Symlinks.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for Symlinks\n     * @function getTypeUrl\n     * @memberof Symlinks\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    Symlinks.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n            typeUrlPrefix = \"type.googleapis.com\";\n        }\n        return typeUrlPrefix + \"/Symlinks\";\n    };\n\n    return Symlinks;\n})();\n\nexport { $root as default };\n"],"names":["assert","condition","message","Error","StatisticRow","FirstOrLast","RelatedButton","RelatedButtons","Histogram","TimeSeries","TemperatureHistogram","$oneOfFields","ExtraStatistic","Metadata","Article","Coordinate","Ring","Polygon","MultiPolygon","Feature","PointSeries","ArticleOrderingList","ArticleUniverseList","SearchIndexMetadata","SearchIndex","OrderList","PopulationPercentileByUniverse","DataList","OrderLists","DataLists","Universes","ConsolidatedShapes","QuizDataForStat","QuizFullData","QuizQuestionTronche","CountsByColumnCompressed","CountsByArticleType","CountsByArticleUniverseAndType","Symlinks","$Reader","$protobuf","$Writer","$util","$root","properties","keys","Object","i","writer","i1","reader","length","_instanceof","end","undefined","tag","end2","end21","_type_of","Array","object","Number","TypeError","options","isFinite","String","j","j1","typeUrlPrefix","Boolean","error","error1","error2","i2","i3","i4","i5","error3","error4","j2","j3","j4","j5","end22","end23"],"mappings":"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"}