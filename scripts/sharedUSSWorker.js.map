{"version":3,"file":"sharedUSSWorker.js","sources":["webpack://assets/./src/data/data_links.ts","webpack://assets/./src/data/hueColors.ts","webpack://assets/./src/data/statistic_path_list.ts","webpack://assets/./src/data/universes_ordered.ts","webpack://assets/./src/load_json.ts","webpack://assets/./src/navigation/links.ts","webpack://assets/./src/search.ts","webpack://assets/./src/urban-stats-script/ast.ts","webpack://assets/./src/urban-stats-script/constants/color.ts","webpack://assets/./src/urban-stats-script/constants/insets.ts","webpack://assets/./src/urban-stats-script/constants/scale.ts","webpack://assets/./src/urban-stats-script/context.ts","webpack://assets/./src/urban-stats-script/interpreter.ts","webpack://assets/./src/urban-stats-script/lexer.ts","webpack://assets/./src/urban-stats-script/location.ts","webpack://assets/./src/urban-stats-script/parser.ts","webpack://assets/./src/urban-stats-script/types-values.ts","webpack://assets/./src/urban-stats-script/worker.ts","webpack://assets/./src/utils/DefaultMap.ts","webpack://assets/./src/utils/is_historical.ts","webpack://assets/webpack/runtime/compat_get_default_export","webpack://assets/webpack/runtime/define_property_getters","webpack://assets/webpack/runtime/ensure_chunk","webpack://assets/webpack/runtime/get javascript chunk filename","webpack://assets/webpack/runtime/global","webpack://assets/webpack/runtime/has_own_property","webpack://assets/webpack/runtime/node_module_decorator","webpack://assets/webpack/runtime/on_chunk_loaded","webpack://assets/webpack/runtime/rspack_version","webpack://assets/webpack/runtime/startup_chunk_dependencies","webpack://assets/webpack/runtime/auto_public_path","webpack://assets/webpack/runtime/import_scripts_chunk_loading","webpack://assets/webpack/runtime/rspack_unique_id"],"sourcesContent":["const value: Record<string, number[]> = {\n    \"10M Person Circle\": [\n        105,\n        105,\n        105,\n        60\n    ],\n    \"20M Person Circle\": [\n        205,\n        170\n    ],\n    \"5M Person Circle\": [\n        54,\n        54,\n        54,\n        54,\n        54,\n        54,\n        51\n    ],\n    \"CA Census Division\": [\n        285,\n        90\n    ],\n    \"CA Census Subdivision\": [\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        15\n    ],\n    \"CA Population Center\": [\n        82,\n        82,\n        82,\n        82,\n        47\n    ],\n    \"CA Riding\": [\n        247,\n        128\n    ],\n    \"CCD\": [\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3\n    ],\n    \"City\": [\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3\n    ],\n    \"Congressional District\": [\n        192,\n        183\n    ],\n    \"Congressional District (1810s)\": [\n        328,\n        47\n    ],\n    \"Congressional District (1820s)\": [\n        344,\n        31\n    ],\n    \"Congressional District (1830s)\": [\n        288,\n        87\n    ],\n    \"Congressional District (1840s)\": [\n        230,\n        145\n    ],\n    \"Congressional District (1850s)\": [\n        241,\n        134\n    ],\n    \"Congressional District (1860s)\": [\n        295,\n        80\n    ],\n    \"Congressional District (1870s)\": [\n        153,\n        153,\n        69\n    ],\n    \"Congressional District (1880s)\": [\n        140,\n        140,\n        95\n    ],\n    \"Congressional District (1890s)\": [\n        169,\n        169,\n        37\n    ],\n    \"Congressional District (1900s)\": [\n        168,\n        168,\n        39\n    ],\n    \"Congressional District (1910s)\": [\n        124,\n        124,\n        124,\n        3\n    ],\n    \"Congressional District (1920s)\": [\n        169,\n        169,\n        37\n    ],\n    \"Congressional District (1930s)\": [\n        168,\n        168,\n        39\n    ],\n    \"Congressional District (1940s)\": [\n        149,\n        149,\n        77\n    ],\n    \"Congressional District (1950s)\": [\n        162,\n        162,\n        51\n    ],\n    \"Congressional District (1960s)\": [\n        82,\n        82,\n        82,\n        82,\n        47\n    ],\n    \"Congressional District (1970s)\": [\n        152,\n        152,\n        71\n    ],\n    \"Congressional District (1980s)\": [\n        139,\n        139,\n        97\n    ],\n    \"Congressional District (1990s)\": [\n        122,\n        122,\n        122,\n        9\n    ],\n    \"Congressional District (2000s)\": [\n        154,\n        154,\n        67\n    ],\n    \"Congressional District (2010s)\": [\n        161,\n        161,\n        53\n    ],\n    \"County\": [\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        11\n    ],\n    \"County Cross CD\": [\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        7\n    ],\n    \"Hospital Referral Region\": [\n        263,\n        112\n    ],\n    \"Hospital Service Area\": [\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25\n    ],\n    \"MSA\": [\n        88,\n        88,\n        88,\n        88,\n        23\n    ],\n    \"Metropolitan Cluster\": [\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3\n    ],\n    \"Native Area\": [\n        223,\n        152\n    ],\n    \"Native Statistical Area\": [\n        290,\n        85\n    ],\n    \"Native Subdivision\": [\n        181,\n        181,\n        13\n    ],\n    \"Neighborhood\": [\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        3\n    ],\n    \"School District\": [\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        4\n    ],\n    \"State House District\": [\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        15\n    ],\n    \"State Senate District\": [\n        43,\n        43,\n        43,\n        43,\n        43,\n        43,\n        43,\n        43,\n        31\n    ],\n    \"Subnational Region\": [\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25\n    ],\n    \"Urban Area\": [\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        23\n    ],\n    \"Urban Center\": [\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        6\n    ],\n    \"ZIP\": [\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3\n    ]\n}\nexport default value","export default {\n    \"blue\": \"#5a7dc3\",\n    \"orange\": \"#f7aa41\",\n    \"brown\": \"#af6707\",\n    \"purple\": \"#975ac3\",\n    \"red\": \"#f96d6d\",\n    \"grey\": \"#8e8e8e\",\n    \"darkGrey\": \"#4e525a\",\n    \"pink\": \"#c767b0\",\n    \"yellow\": \"#b8a32f\",\n    \"green\": \"#8ac35a\",\n    \"cyan\": \"#07a5af\"\n} as const","export default [\n    \"2008 Presidential Election-margin\",\n    \"2008-2012 Swing-margin\",\n    \"2012 Presidential Election-margin\",\n    \"2012-2016 Swing-margin\",\n    \"2016 Presidential Election-margin\",\n    \"2016-2020 Swing-margin\",\n    \"2020 Presidential Election-margin\",\n    \"2020-2024 Swing-margin\",\n    \"2024 Presidential Election-margin\",\n    \"ARTHRITIS_cdc_2\",\n    \"BINGE_cdc_2\",\n    \"BPHIGH_cdc_2\",\n    \"CANCER_cdc_2\",\n    \"CASTHMA_cdc_2\",\n    \"CHD_cdc_2\",\n    \"CHECKUP_cdc_2\",\n    \"CHOLSCREEN_cdc_2\",\n    \"COGNITION_cdc_2\",\n    \"COPD_cdc_2\",\n    \"CSMOKING_cdc_2\",\n    \"DENTAL_cdc_2\",\n    \"DIABETES_cdc_2\",\n    \"DISABILITY_cdc_2\",\n    \"GHLTH_cdc_2\",\n    \"HEARING_cdc_2\",\n    \"INDEPLIVE_cdc_2\",\n    \"KIDNEY_cdc_2\",\n    \"LPA_cdc_2\",\n    \"MOBILITY_cdc_2\",\n    \"OBESITY_cdc_2\",\n    \"PHLTH_cdc_2\",\n    \"SELFCARE_cdc_2\",\n    \"SLEEP_cdc_2\",\n    \"STROKE_cdc_2\",\n    \"VISION_cdc_2\",\n    \"ad_0.25\",\n    \"ad_0.25_2000\",\n    \"ad_0.25_2010\",\n    \"ad_0.25_change_2000\",\n    \"ad_0.25_change_2010\",\n    \"ad_0.5\",\n    \"ad_0.5_2000\",\n    \"ad_0.5_2010\",\n    \"ad_0.5_change_2000\",\n    \"ad_0.5_change_2010\",\n    \"ad_1\",\n    \"ad_1.609344\",\n    \"ad_1.609344_2000\",\n    \"ad_1.609344_2010\",\n    \"ad_1.609344_change_2000\",\n    \"ad_1.609344_change_2010\",\n    \"ad_16\",\n    \"ad_16_2000\",\n    \"ad_16_2010\",\n    \"ad_16_change_2000\",\n    \"ad_16_change_2010\",\n    \"ad_1_2000\",\n    \"ad_1_2010\",\n    \"ad_1_change_2000\",\n    \"ad_1_change_2010\",\n    \"ad_2\",\n    \"ad_2_2000\",\n    \"ad_2_2010\",\n    \"ad_2_change_2000\",\n    \"ad_2_change_2010\",\n    \"ad_32\",\n    \"ad_32_2000\",\n    \"ad_32_2010\",\n    \"ad_32_change_2000\",\n    \"ad_32_change_2010\",\n    \"ad_4\",\n    \"ad_4_2000\",\n    \"ad_4_2010\",\n    \"ad_4_change_2000\",\n    \"ad_4_change_2010\",\n    \"ad_64\",\n    \"ad_64_2000\",\n    \"ad_64_2010\",\n    \"ad_64_change_2000\",\n    \"ad_64_change_2010\",\n    \"ad_8\",\n    \"ad_8_2000\",\n    \"ad_8_2010\",\n    \"ad_8_change_2000\",\n    \"ad_8_change_2010\",\n    \"area\",\n    \"asian\",\n    \"asian_2000\",\n    \"asian_2010\",\n    \"birthplace_non_us\",\n    \"birthplace_us_not_state\",\n    \"birthplace_us_state\",\n    \"black\",\n    \"black_2000\",\n    \"black_2010\",\n    \"citizenship_citizen_by_birth\",\n    \"citizenship_citizen_by_naturalization\",\n    \"citizenship_not_citizen\",\n    \"compactness\",\n    \"days_above_90_4\",\n    \"days_below_40_4\",\n    \"days_between_40_and_90_4\",\n    \"days_dewpoint_-inf_50_4\",\n    \"days_dewpoint_50_70_4\",\n    \"days_dewpoint_70_inf_4\",\n    \"density_2021_pw_0.25_canada\",\n    \"density_2021_pw_0.5_canada\",\n    \"density_2021_pw_1.609344_canada\",\n    \"density_2021_pw_16_canada\",\n    \"density_2021_pw_1_canada\",\n    \"density_2021_pw_2_canada\",\n    \"density_2021_pw_32_canada\",\n    \"density_2021_pw_4_canada\",\n    \"density_2021_pw_64_canada\",\n    \"density_2021_pw_8_canada\",\n    \"education_field_business\",\n    \"education_field_humanities\",\n    \"education_field_stem\",\n    \"education_grad\",\n    \"education_grad_canada\",\n    \"education_high_school\",\n    \"education_high_school_canada\",\n    \"education_ugrad\",\n    \"education_ugrad_canada\",\n    \"female_grad_gap_4\",\n    \"female_hs_gap_4\",\n    \"female_ugrad_gap_4\",\n    \"generation_boomer\",\n    \"generation_boomer_canada\",\n    \"generation_genalpha\",\n    \"generation_genalpha_canada\",\n    \"generation_genx\",\n    \"generation_genx_canada\",\n    \"generation_genz\",\n    \"generation_genz_canada\",\n    \"generation_millenial\",\n    \"generation_millenial_canada\",\n    \"generation_silent\",\n    \"generation_silent_canada\",\n    \"gpw_aw_density\",\n    \"gpw_population\",\n    \"gpw_pw_density_1\",\n    \"gpw_pw_density_1.609344\",\n    \"gpw_pw_density_16\",\n    \"gpw_pw_density_2\",\n    \"gpw_pw_density_32\",\n    \"gpw_pw_density_4\",\n    \"gpw_pw_density_64\",\n    \"gpw_pw_density_8\",\n    \"gridded_elevation\",\n    \"gridded_hilliness\",\n    \"hawaiian_pi\",\n    \"hawaiian_pi_2000\",\n    \"hawaiian_pi_2010\",\n    \"heating_bottled_tank_lp_gas\",\n    \"heating_electricity\",\n    \"heating_feul_oil_kerosene\",\n    \"heating_no\",\n    \"heating_other\",\n    \"heating_utility_gas\",\n    \"hispanic\",\n    \"hispanic_2000\",\n    \"hispanic_2010\",\n    \"homogeneity_250_2000\",\n    \"homogeneity_250_2010\",\n    \"homogeneity_250_2020\",\n    \"homogeneity_250_diff_2000\",\n    \"homogeneity_250_diff_2010\",\n    \"hours_sunny_4\",\n    \"household_income_50_to_100cad\",\n    \"household_income_50k_to_100k\",\n    \"household_income_above_100_cad\",\n    \"household_income_over_100k\",\n    \"household_income_under_50cad\",\n    \"household_income_under_50k\",\n    \"housing_per_pop\",\n    \"housing_per_pop_2000\",\n    \"housing_per_pop_2010\",\n    \"individual_income_50_to_100cad\",\n    \"individual_income_50k_to_100k\",\n    \"individual_income_above_100_cad\",\n    \"individual_income_over_100k\",\n    \"individual_income_under_50cad\",\n    \"individual_income_under_50k\",\n    \"industry_accommodation_and_food_services\",\n    \"industry_accommodation_and_food_services_canada\",\n    \"industry_administrative_and_support_and_waste_management_services\",\n    \"industry_administrative_and_support_and_waste_management_services_canada\",\n    \"industry_agriculture,_forestry,_fishing_and_hunting\",\n    \"industry_agriculture,_forestry,_fishing_and_hunting_canada\",\n    \"industry_arts,_entertainment,_and_recreation\",\n    \"industry_arts,_entertainment,_and_recreation_canada\",\n    \"industry_construction\",\n    \"industry_construction_canada\",\n    \"industry_educational_services\",\n    \"industry_educational_services_canada\",\n    \"industry_finance_and_insurance\",\n    \"industry_finance_and_insurance_canada\",\n    \"industry_health_care_and_social_assistance\",\n    \"industry_health_care_and_social_assistance_canada\",\n    \"industry_information\",\n    \"industry_information_canada\",\n    \"industry_management_of_companies_and_enterprises\",\n    \"industry_management_of_companies_and_enterprises_canada\",\n    \"industry_manufacturing\",\n    \"industry_manufacturing_canada\",\n    \"industry_mining,_quarrying,_and_oil_and_gas_extraction\",\n    \"industry_mining,_quarrying,_and_oil_and_gas_extraction_canada\",\n    \"industry_other_services,_except_public_administration\",\n    \"industry_other_services,_except_public_administration_canada\",\n    \"industry_professional,_scientific,_and_technical_services\",\n    \"industry_professional,_scientific,_and_technical_services_canada\",\n    \"industry_public_administration\",\n    \"industry_public_administration_canada\",\n    \"industry_real_estate_and_rental_and_leasing\",\n    \"industry_real_estate_and_rental_and_leasing_canada\",\n    \"industry_retail_trade\",\n    \"industry_retail_trade_canada\",\n    \"industry_transportation_and_warehousing\",\n    \"industry_transportation_and_warehousing_canada\",\n    \"industry_utilities\",\n    \"industry_utilities_canada\",\n    \"industry_wholesale_trade\",\n    \"industry_wholesale_trade_canada\",\n    \"insurance_coverage_govt\",\n    \"insurance_coverage_none\",\n    \"insurance_coverage_private\",\n    \"internet_no_access\",\n    \"language_english_only\",\n    \"language_other\",\n    \"language_spanish\",\n    \"lapop10share_usda_fra_1\",\n    \"lapop1share_usda_fra_1\",\n    \"lapop20share_usda_fra_1\",\n    \"lapophalfshare_usda_fra_1\",\n    \"lico_at_canada\",\n    \"life_expectancy_2019\",\n    \"marriage_divorced\",\n    \"marriage_divorced_canada\",\n    \"marriage_married_not_divorced\",\n    \"marriage_married_not_divorced_canada\",\n    \"marriage_never_married\",\n    \"marriage_never_married_canada\",\n    \"mean_dist_Active Superfund Site_updated\",\n    \"mean_dist_Airport_updated\",\n    \"mean_dist_Hospital_updated\",\n    \"mean_dist_Public School_updated\",\n    \"mean_high_dewpoint_4\",\n    \"mean_high_heat_index_4\",\n    \"mean_high_temp_4\",\n    \"mean_high_temp_djf\",\n    \"mean_high_temp_fall_4\",\n    \"mean_high_temp_jja\",\n    \"mean_high_temp_mam\",\n    \"mean_high_temp_son\",\n    \"mean_high_temp_spring_4\",\n    \"mean_high_temp_summer_4\",\n    \"mean_high_temp_winter_4\",\n    \"mean_low_temp\",\n    \"mean_low_temp_djf\",\n    \"mean_low_temp_jja\",\n    \"mean_low_temp_mam\",\n    \"mean_low_temp_son\",\n    \"median_household_income\",\n    \"native\",\n    \"native_2000\",\n    \"native_2010\",\n    \"occupation_architecture_and_engineering_occupations\",\n    \"occupation_arts,_design,_entertainment,_sports,_and_media_occupations\",\n    \"occupation_building_and_grounds_cleaning_and_maintenance_occupations\",\n    \"occupation_business_and_financial_operations_occupations\",\n    \"occupation_community_and_social_service_occupations\",\n    \"occupation_computer_and_mathematical_occupations\",\n    \"occupation_construction_and_extraction_occupations\",\n    \"occupation_educational_instruction,_and_library_occupations\",\n    \"occupation_farming,_fishing,_and_forestry_occupations\",\n    \"occupation_firefighting_and_prevention,_and_other_protective_service_workers_including_supervisors\",\n    \"occupation_food_preparation_and_serving_related_occupations\",\n    \"occupation_health_diagnosing_and_treating_practitioners_and_other_technical_occupations\",\n    \"occupation_health_technologists_and_technicians\",\n    \"occupation_healthcare_support_occupations\",\n    \"occupation_installation,_maintenance,_and_repair_occupations\",\n    \"occupation_law_enforcement_workers_including_supervisors\",\n    \"occupation_legal_occupations\",\n    \"occupation_life,_physical,_and_social_science_occupations\",\n    \"occupation_management_occupations\",\n    \"occupation_material_moving_occupations\",\n    \"occupation_office_and_administrative_support_occupations\",\n    \"occupation_personal_care_and_service_occupations\",\n    \"occupation_production_occupations\",\n    \"occupation_sales_and_related_occupations\",\n    \"occupation_transportation_occupations\",\n    \"other  slash  mixed\",\n    \"other  slash  mixed_2000\",\n    \"other  slash  mixed_2010\",\n    \"park_percent_1km_v2\",\n    \"performance_score_adj_2019\",\n    \"pm_25_2018_2022\",\n    \"population\",\n    \"population_2000\",\n    \"population_2010\",\n    \"population_2021_canada\",\n    \"population_change_2000\",\n    \"population_change_2010\",\n    \"poverty_below_line\",\n    \"rainfall_4\",\n    \"rent_1br_750_to_1500\",\n    \"rent_1br_over_1500\",\n    \"rent_1br_under_750\",\n    \"rent_2br_750_to_1500\",\n    \"rent_2br_over_1500\",\n    \"rent_2br_under_750\",\n    \"rent_burden_20_to_40\",\n    \"rent_burden_over_40\",\n    \"rent_burden_under_20\",\n    \"rent_or_own_rent\",\n    \"sd\",\n    \"sd_2000\",\n    \"sd_2010\",\n    \"sd_2021_canada\",\n    \"segregation_250_10_2000\",\n    \"segregation_250_10_2010\",\n    \"segregation_250_10_2020\",\n    \"segregation_250_10_diff_2000\",\n    \"segregation_250_10_diff_2010\",\n    \"segregation_250_2000\",\n    \"segregation_250_2010\",\n    \"segregation_250_2020\",\n    \"segregation_250_diff_2000\",\n    \"segregation_250_diff_2010\",\n    \"snowfall_4\",\n    \"sors_child\",\n    \"sors_cohabiting_partnered_gay\",\n    \"sors_cohabiting_partnered_straight\",\n    \"sors_other\",\n    \"sors_unpartnered_householder\",\n    \"traffic_fatalities_last_decade\",\n    \"traffic_fatalities_last_decade_per_capita\",\n    \"traffic_fatalities_ped_last_decade\",\n    \"traffic_fatalities_ped_last_decade_per_capita\",\n    \"transportation_commute_time_15_to_29\",\n    \"transportation_commute_time_15_to_29_canada\",\n    \"transportation_commute_time_30_to_59\",\n    \"transportation_commute_time_30_to_59_canada\",\n    \"transportation_commute_time_median\",\n    \"transportation_commute_time_median_canada\",\n    \"transportation_commute_time_over_60\",\n    \"transportation_commute_time_over_60_canada\",\n    \"transportation_commute_time_under_15\",\n    \"transportation_commute_time_under_15_canada\",\n    \"transportation_means_bike\",\n    \"transportation_means_car\",\n    \"transportation_means_transit\",\n    \"transportation_means_walk\",\n    \"transportation_means_worked_at_home\",\n    \"vacancy\",\n    \"vacancy_2000\",\n    \"vacancy_2010\",\n    \"vehicle_ownership_at_least_1\",\n    \"vehicle_ownership_at_least_2\",\n    \"vehicle_ownership_none\",\n    \"white\",\n    \"white_2000\",\n    \"white_2010\",\n    \"wind_speed_over_10mph_4\",\n    \"within_Active Superfund Site_10\",\n    \"within_Airport_30\",\n    \"within_Hospital_10\",\n    \"within_Public School_2\",\n    \"year_built_1969_or_earlier\",\n    \"year_built_1970_to_1979\",\n    \"year_built_1980_to_1989\",\n    \"year_built_1990_to_1999\",\n    \"year_built_2000_to_2009\",\n    \"year_built_2010_or_later\"\n] as const","export default [\n    \"world\",\n    \"Africa\",\n    \"Asia\",\n    \"Europe\",\n    \"North America\",\n    \"Oceania\",\n    \"South America\",\n    \"Andorra\",\n    \"United Arab Emirates\",\n    \"Afghanistan\",\n    \"Antigua and Barbuda\",\n    \"Anguilla\",\n    \"Albania\",\n    \"Armenia\",\n    \"Angola\",\n    \"Argentina\",\n    \"Austria\",\n    \"Australia\",\n    \"Aruba\",\n    \"Azerbaijan\",\n    \"Bosnia and Herzegovina\",\n    \"Barbados\",\n    \"Bangladesh\",\n    \"Belgium\",\n    \"Burkina Faso\",\n    \"Bulgaria\",\n    \"Bahrain\",\n    \"Burundi\",\n    \"Benin\",\n    \"Bermuda\",\n    \"Brunei\",\n    \"Bolivia\",\n    \"Brazil\",\n    \"The Bahamas\",\n    \"Bhutan\",\n    \"Botswana\",\n    \"Belarus\",\n    \"Belize\",\n    \"Canada\",\n    \"Cocos (Keeling) Islands\",\n    \"Democratic Republic of the Congo\",\n    \"Central African Republic\",\n    \"Congo\",\n    \"Switzerland\",\n    \"Ivory Coast\",\n    \"Cook Islands\",\n    \"Chile\",\n    \"Cameroon\",\n    \"China\",\n    \"Colombia\",\n    \"Costa Rica\",\n    \"Cuba\",\n    \"Cape Verde\",\n    \"Christmas Island\",\n    \"Cyprus\",\n    \"Czech Republic\",\n    \"Germany\",\n    \"Djibouti\",\n    \"Denmark\",\n    \"Dominica\",\n    \"Dominican Republic\",\n    \"Algeria\",\n    \"Ecuador\",\n    \"Estonia\",\n    \"Egypt\",\n    \"Eritrea\",\n    \"Spain\",\n    \"Ethiopia\",\n    \"Finland\",\n    \"Fiji\",\n    \"Falkland Islands\",\n    \"Micronesia\",\n    \"Faroe Islands\",\n    \"France\",\n    \"Gabon\",\n    \"United Kingdom\",\n    \"Grenada\",\n    \"Georgia\",\n    \"Guernsey\",\n    \"Ghana\",\n    \"Gibraltar\",\n    \"Greenland\",\n    \"The Gambia\",\n    \"Guinea\",\n    \"Equatorial Guinea\",\n    \"Greece\",\n    \"Guatemala\",\n    \"Guinea-Bissau\",\n    \"Guyana\",\n    \"Honduras\",\n    \"Croatia\",\n    \"Haiti\",\n    \"Hungary\",\n    \"Indonesia\",\n    \"Ireland\",\n    \"Israel\",\n    \"Isle of Man\",\n    \"India\",\n    \"Iraq\",\n    \"Iran\",\n    \"Iceland\",\n    \"Italy\",\n    \"Jersey\",\n    \"Jamaica\",\n    \"Jordan\",\n    \"Japan\",\n    \"Kenya\",\n    \"Kyrgyzstan\",\n    \"Cambodia\",\n    \"Kiribati\",\n    \"Comoros\",\n    \"Saint Kitts and Nevis\",\n    \"North Korea\",\n    \"South Korea\",\n    \"Kuwait\",\n    \"Cayman Islands\",\n    \"Kazakhstan\",\n    \"Laos\",\n    \"Lebanon\",\n    \"Saint Lucia\",\n    \"Liechtenstein\",\n    \"Sri Lanka\",\n    \"Liberia\",\n    \"Lesotho\",\n    \"Lithuania\",\n    \"Luxembourg\",\n    \"Latvia\",\n    \"Libya\",\n    \"Morocco\",\n    \"Monaco\",\n    \"Moldova\",\n    \"Montenegro\",\n    \"Madagascar\",\n    \"Marshall Islands\",\n    \"North Macedonia\",\n    \"Mali\",\n    \"Myanmar\",\n    \"Mongolia\",\n    \"Mauritania\",\n    \"Montserrat\",\n    \"Malta\",\n    \"Mauritius\",\n    \"Maldives\",\n    \"Malawi\",\n    \"Mexico\",\n    \"Malaysia\",\n    \"Mozambique\",\n    \"Namibia\",\n    \"Niger\",\n    \"Norfolk Island\",\n    \"Nigeria\",\n    \"Nicaragua\",\n    \"Netherlands\",\n    \"Norway\",\n    \"Nepal\",\n    \"Nauru\",\n    \"Niue\",\n    \"New Zealand\",\n    \"Oman\",\n    \"Panama\",\n    \"Peru\",\n    \"Papua New Guinea\",\n    \"Philippines\",\n    \"Pakistan\",\n    \"Poland\",\n    \"Pitcairn Islands\",\n    \"State of Palestine\",\n    \"Portugal\",\n    \"Palau\",\n    \"Paraguay\",\n    \"Qatar\",\n    \"Romania\",\n    \"Serbia\",\n    \"Russia\",\n    \"Rwanda\",\n    \"Saudi Arabia\",\n    \"Solomon Islands\",\n    \"Seychelles\",\n    \"Sudan\",\n    \"Sweden\",\n    \"Singapore\",\n    \"Saint Helena, Ascension and Tristan da Cunha\",\n    \"Slovenia\",\n    \"Slovakia\",\n    \"Sierra Leone\",\n    \"San Marino\",\n    \"Senegal\",\n    \"Somalia\",\n    \"Suriname\",\n    \"South Sudan\",\n    \"S\\u00e3o Tom\\u00e9 and Pr\\u00edncipe\",\n    \"El Salvador\",\n    \"Syria\",\n    \"Eswatini\",\n    \"Turks and Caicos Islands\",\n    \"Chad\",\n    \"Togo\",\n    \"Thailand\",\n    \"Tajikistan\",\n    \"Tokelau\",\n    \"East Timor\",\n    \"Turkmenistan\",\n    \"Tunisia\",\n    \"Tonga\",\n    \"Turkey\",\n    \"Trinidad and Tobago\",\n    \"Tuvalu\",\n    \"Tanzania\",\n    \"Ukraine\",\n    \"Uganda\",\n    \"USA\",\n    \"Uruguay\",\n    \"Uzbekistan\",\n    \"Vatican City\",\n    \"Saint Vincent and the Grenadines\",\n    \"Venezuela\",\n    \"British Virgin Islands\",\n    \"Vietnam\",\n    \"Vanuatu\",\n    \"Samoa\",\n    \"Yemen\",\n    \"South Africa\",\n    \"Zambia\",\n    \"Zimbabwe\",\n    \"Alabama, USA\",\n    \"Alaska, USA\",\n    \"Arizona, USA\",\n    \"Arkansas, USA\",\n    \"California, USA\",\n    \"Colorado, USA\",\n    \"Connecticut, USA\",\n    \"Delaware, USA\",\n    \"Florida, USA\",\n    \"Georgia, USA\",\n    \"Hawaii, USA\",\n    \"Idaho, USA\",\n    \"Illinois, USA\",\n    \"Indiana, USA\",\n    \"Iowa, USA\",\n    \"Kansas, USA\",\n    \"Kentucky, USA\",\n    \"Louisiana, USA\",\n    \"Maine, USA\",\n    \"Maryland, USA\",\n    \"Massachusetts, USA\",\n    \"Michigan, USA\",\n    \"Minnesota, USA\",\n    \"Mississippi, USA\",\n    \"Missouri, USA\",\n    \"Montana, USA\",\n    \"Nebraska, USA\",\n    \"Nevada, USA\",\n    \"New Hampshire, USA\",\n    \"New Jersey, USA\",\n    \"New Mexico, USA\",\n    \"New York, USA\",\n    \"North Carolina, USA\",\n    \"North Dakota, USA\",\n    \"Ohio, USA\",\n    \"Oklahoma, USA\",\n    \"Oregon, USA\",\n    \"Pennsylvania, USA\",\n    \"Rhode Island, USA\",\n    \"South Carolina, USA\",\n    \"South Dakota, USA\",\n    \"Tennessee, USA\",\n    \"Texas, USA\",\n    \"Utah, USA\",\n    \"Vermont, USA\",\n    \"Virginia, USA\",\n    \"Washington, USA\",\n    \"West Virginia, USA\",\n    \"Wisconsin, USA\",\n    \"Wyoming, USA\",\n    \"American Samoa, USA\",\n    \"Guam, USA\",\n    \"Northern Mariana Islands, USA\",\n    \"Puerto Rico, USA\",\n    \"US Virgin Islands, USA\",\n    \"District of Columbia, USA\",\n    \"Alberta, Canada\",\n    \"British Columbia, Canada\",\n    \"Manitoba, Canada\",\n    \"New Brunswick, Canada\",\n    \"Newfoundland and Labrador, Canada\",\n    \"Northwest Territories, Canada\",\n    \"Nova Scotia, Canada\",\n    \"Nunavut, Canada\",\n    \"Ontario, Canada\",\n    \"Prince Edward Island, Canada\",\n    \"Quebec, Canada\",\n    \"Saskatchewan, Canada\",\n    \"Yukon, Canada\"\n] as const","import { gunzipSync } from 'zlib'\n\nimport data_links from './data/data_links'\nimport order_links from './data/order_links'\nimport statistic_path_list from './data/statistic_path_list'\nimport universes_ordered from './data/universes_ordered'\nimport { indexLink, orderingDataLink, orderingLink } from './navigation/links'\nimport { debugPerformance } from './search'\nimport { Universe } from './universe'\nimport { assert } from './utils/defensive'\nimport {\n    Article, ConsolidatedShapes, CountsByArticleUniverseAndType, DataLists,\n    Feature, IOrderList, OrderList,\n    OrderLists,\n    QuizFullData,\n    QuizQuestionTronche,\n    SearchIndex,\n    ArticleOrderingList,\n    Symlinks,\n    PointSeries,\n    ArticleUniverseList,\n} from './utils/protos'\nimport { NormalizeProto } from './utils/types'\n\n// from https://stackoverflow.com/a/4117299/1549476\n\n// Load JSON text from server hosted file and return JSON parsed object\nexport async function loadJSON(filePath: string): Promise<unknown> {\n    const response = await fetch(filePath, { headers: { 'Content-Type': 'application/json' } })\n    if (response.status < 200 || response.status > 299) {\n        throw new Error(`Expected response status 2xx for ${filePath}, got ${response.status}: ${response.statusText}`)\n    }\n    return response.json()\n}\n\n// Load a protobuf file from the server\nexport async function loadProtobuf(filePath: string, name: 'Article', errorOnMissing: boolean): Promise<Article | undefined>\nexport async function loadProtobuf(filePath: string, name: 'Feature', errorOnMissing: boolean): Promise<Feature>\nexport async function loadProtobuf(filePath: string, name: 'ArticleOrderingList'): Promise<ArticleOrderingList>\nexport async function loadProtobuf(filePath: string, name: 'OrderLists'): Promise<OrderLists>\nexport async function loadProtobuf(filePath: string, name: 'DataLists'): Promise<DataLists>\nexport async function loadProtobuf(filePath: string, name: 'ConsolidatedShapes'): Promise<ConsolidatedShapes>\nexport async function loadProtobuf(filePath: string, name: 'SearchIndex'): Promise<SearchIndex>\nexport async function loadProtobuf(filePath: string, name: 'QuizQuestionTronche'): Promise<QuizQuestionTronche>\nexport async function loadProtobuf(filePath: string, name: 'QuizFullData'): Promise<QuizFullData>\nexport async function loadProtobuf(filePath: string, name: 'CountsByArticleUniverseAndType'): Promise<CountsByArticleUniverseAndType>\nexport async function loadProtobuf(filePath: string, name: 'Symlinks'): Promise<Symlinks>\nexport async function loadProtobuf(filePath: string, name: 'PointSeries'): Promise<PointSeries>\nexport async function loadProtobuf(filePath: string, name: 'ArticleUniverseList'): Promise<ArticleUniverseList>\nexport async function loadProtobuf(filePath: string, name: string, errorOnMissing: boolean = true): Promise<Article | Feature | ArticleOrderingList | OrderLists | DataLists | ConsolidatedShapes | SearchIndex | QuizQuestionTronche | QuizFullData | CountsByArticleUniverseAndType | Symlinks | PointSeries | ArticleUniverseList | undefined> {\n    let perfCheckpoint = performance.now()\n\n    const response = await fetch(filePath)\n    if (response.status < 200 || response.status > 299) {\n        if (!errorOnMissing) {\n            return undefined\n        }\n        throw new Error(`Expected response status 2xx for ${filePath}, got ${response.status}: ${response.statusText}`)\n    }\n\n    const compressedBuffer = await response.arrayBuffer()\n\n    if (name === 'SearchIndex') {\n        debugPerformance(`Took ${performance.now() - perfCheckpoint}ms networking to load search index`)\n    }\n    perfCheckpoint = performance.now()\n\n    const buffer = gunzipSync(Buffer.from(compressedBuffer))\n    const arr = new Uint8Array(buffer)\n\n    if (name === 'SearchIndex') {\n        debugPerformance(`Took ${performance.now() - perfCheckpoint}ms to decompress search index`)\n    }\n    perfCheckpoint = performance.now()\n\n    if (name === 'Article') {\n        return Article.decode(arr)\n    }\n    else if (name === 'Feature') {\n        return Feature.decode(arr)\n    }\n    else if (name === 'ArticleOrderingList') {\n        return ArticleOrderingList.decode(arr)\n    }\n    else if (name === 'OrderLists') {\n        return OrderLists.decode(arr)\n    }\n    else if (name === 'DataLists') {\n        return DataLists.decode(arr)\n    }\n    else if (name === 'ConsolidatedShapes') {\n        return ConsolidatedShapes.decode(arr)\n    }\n    else if (name === 'SearchIndex') {\n        const result = SearchIndex.decode(arr)\n        debugPerformance(`Took ${performance.now() - perfCheckpoint}ms to decode search index`)\n        return result\n    }\n    else if (name === 'QuizQuestionTronche') {\n        return QuizQuestionTronche.decode(arr)\n    }\n    else if (name === 'QuizFullData') {\n        return QuizFullData.decode(arr)\n    }\n    else if (name === 'CountsByArticleUniverseAndType') {\n        return CountsByArticleUniverseAndType.decode(arr)\n    }\n    else if (name === 'Symlinks') {\n        return Symlinks.decode(arr)\n    }\n    else if (name === 'PointSeries') {\n        return PointSeries.decode(arr)\n    }\n    else if (name === 'ArticleUniverseList') {\n        return ArticleUniverseList.decode(arr)\n    }\n    else {\n        throw new Error('protobuf type not recognized (see load_json.ts)')\n    }\n}\n\nfunction pullKey(arr: number[], key: string): number {\n    const idx = statistic_path_list.indexOf(key as ElementOf<typeof statistic_path_list>)\n    if (idx === -1) {\n        throw new Error(`statistic path not found: ${key}`)\n    }\n    let current = 0\n    for (let i = 0; i < arr.length; i++) {\n        current += arr[i]\n        if (idx < current) {\n            return i\n        }\n    }\n    throw new Error('index not found')\n}\n\nexport async function loadUniverses(type: string): Promise<ArticleUniverseList> {\n    return loadProtobuf(`/universes/${type}.gz`, 'ArticleUniverseList')\n}\n\nasync function loadOrderingProtobuf(universe: string, statpath: string, type: string): Promise<IOrderList> {\n    const universeIdx = universes_ordered.indexOf(universe as Universe)\n    const links = order_links\n    const idx = type in links ? pullKey(links[type], statpath) : 0\n    const orderLink = orderingLink(type, idx)\n    const orderLists = await loadProtobuf(orderLink, 'OrderLists')\n    const index = orderLists.statnames.indexOf(statpath)\n    const res = orderLists.orderLists[index]\n    const universes = await loadUniverses(type)\n    const orderIndices = res.orderIdxs?.filter(i => universes.universes[i].universeIdxs?.includes(universeIdx))\n    return { orderIdxs: orderIndices }\n}\n\nexport async function loadOrderingDataProtobuf(universe: string, statpath: string, type: string): Promise<{\n    value: number[]\n    populationPercentile: number[]\n}> {\n    const links = data_links\n    const idx = type in links ? pullKey(links[type], statpath) : 0\n    const orderLink = orderingDataLink(type, idx)\n    const dataLists = await loadProtobuf(orderLink, 'DataLists')\n    const index = dataLists.statnames.indexOf(statpath)\n    const res = dataLists.dataLists[index]\n    const universeIdx = universes_ordered.indexOf(universe as Universe)\n    const universes = await loadUniverses(type)\n    return {\n        value: res.value!.filter((_, i) => universes.universes[i].universeIdxs?.includes(universeIdx)),\n        populationPercentile: res.populationPercentileByUniverse!.flatMap((_, i) => {\n            const universeIndex = universes.universes[i].universeIdxs!.indexOf(universeIdx)\n            if (universeIndex === -1) {\n                return []\n            }\n            return [res.populationPercentileByUniverse![i].populationPercentile![universeIndex]]\n        }),\n    }\n}\n\nexport async function loadDataInIndexOrder(\n    universe: string, statpath: string, type: string,\n): Promise<[number[], number[]]> {\n    const dataPromise = await loadOrderingDataProtobuf(universe, statpath, type)\n    return [dataPromise.value, dataPromise.populationPercentile]\n}\n\nexport interface ArticleOrderingListInternal {\n    longnames: string[]\n    typeIndices: number[]\n}\n\nexport async function loadOrdering(universe: string, statpath: string, type: string): Promise<ArticleOrderingListInternal> {\n    const idxLink = indexLink('world', type)\n    const dataPromise = loadProtobuf(idxLink, 'ArticleOrderingList')\n    const orderingPromise = loadOrderingProtobuf(universe, statpath, type)\n    const [data, ordering] = await Promise.all([dataPromise, orderingPromise])\n    const namesInOrder = (ordering as OrderList).orderIdxs.map((i: number) => data.longnames[i])\n    const typesInOrder = (ordering as OrderList).orderIdxs.map((i: number) => data.types[i])\n    return { longnames: namesInOrder, typeIndices: typesInOrder }\n}\n\n/**\n * Returns an array `r` where r contains numbers 0..length-1, but such that\n * iff indices[i] < indices[j], then r[i] < r[j]\n *\n * I.e., it returns the argsort of the argsort of indices.\n */\nfunction reindex(indices: number[]): number[] {\n    const pairs = indices.map((value, index) => ({ value, index }))\n    pairs.sort((a, b) => a.value - b.value)\n    const result = new Array<number>(indices.length)\n    for (let i = 0; i < pairs.length; i++) {\n        result[pairs[i].index] = i\n    }\n    return result\n}\n\nexport async function loadStatisticsPage(\n    statUniverse: string, statpath: string, articleType: string,\n): Promise<[NormalizeProto<{ value: number[], populationPercentile: number[] }>, string[]]> {\n    const orderingOriginal = await loadOrderingProtobuf(statUniverse, statpath, articleType)\n    const ordering = await loadOrdering(statUniverse, statpath, articleType)\n    const orderingData = await loadOrderingDataProtobuf(statUniverse, statpath, articleType)\n    assert(Array.isArray(orderingOriginal.orderIdxs), 'Ordering original must be an array')\n    const reorder = reindex(orderingOriginal.orderIdxs)\n    const articleNames = ordering.longnames\n    return [\n        {\n            value: reorder.map(i => orderingData.value[i]),\n            populationPercentile: reorder.map(i => orderingData.populationPercentile[i]),\n        },\n        articleNames,\n    ]\n}\n","import type_ordering_idx from '../data/type_ordering_idx'\nimport { StatName } from '../page_template/statistic-tree'\n\nimport { PageDescriptor } from './PageDescriptor'\n\nconst typesInOrder = Object.fromEntries(Object.entries(type_ordering_idx).map(([k, v]) => [v, k]))\n\nfunction shardBytes(longname: string): [string, string] {\n    // as bytes, in utf-8\n    const bytes = new TextEncoder().encode(longname)\n    const hash = new Uint32Array([0])\n    for (const byte of bytes) {\n        hash[0] = (hash[0] * 31 + byte) & 0xffffffff\n    }\n    // last 4 hex digits\n    let string = ''\n    for (let i = 0; i < 4; i++) {\n        string += (hash[0] & 0xf).toString(16)\n        hash[0] = hash[0] >> 4\n    }\n    // get first two and last two\n    return [\n        string.slice(0, 2),\n        string.slice(2, 3),\n    ]\n}\n\nfunction shardedFolderName(longname: string): string {\n    const sanitizedName = sanitize(longname)\n    const [a, b] = shardBytes(sanitizedName)\n    return `${a}/${b}`\n}\n\nexport function shardedName(longname: string): string {\n    const sanitizedName = sanitize(longname)\n    return `${shardedFolderName(longname)}/${sanitizedName}`\n}\n\nexport function shapeLink(longname: string): string {\n    return `/shape/${encodeURIComponent(shardedName(longname))}.gz`\n}\n\nexport function dataLink(longname: string): string {\n    return `/data/${encodeURIComponent(shardedName(longname))}.gz`\n}\n\nexport function symlinksLink(longname: string): string {\n    return `/data/${shardedFolderName(longname)}.symlinks.gz`\n}\n\nexport function indexLink(universe: string, typ: string): string {\n    return `/index/${universe}/${encodeURIComponent(sanitize(typ, false))}.gz`\n}\n\nexport function orderingLink(type: string, idx: number): string {\n    return `/order/${encodeURIComponent(sanitize(type, false))}_${idx}.gz`\n}\n\nexport function orderingDataLink(type: string, idx: number): string {\n    return `/order/${encodeURIComponent(sanitize(type, false))}_${idx}_data.gz`\n}\n\nexport function consolidatedShapeLink(typ: string): string {\n    return `/consolidated/shapes__${encodeURIComponent(sanitize(typ))}.gz`\n}\n\nexport function consolidatedStatsLink(typ: string): string {\n    return `/consolidated/stats__${encodeURIComponent(sanitize(typ))}.gz`\n}\n\nexport function searchIconLink(typeIdx: number): string {\n    return `/icons/search_icons/${typesInOrder[typeIdx]}.png`\n}\n\nexport function centroidsPath(universe: string, typ: string): string {\n    return `/centroids/${encodeURIComponent(universe)}_${encodeURIComponent(sanitize(typ))}.gz`\n}\n\nexport function statisticDescriptor(props: {\n    universe: string | undefined\n    statname: StatName\n    articleType: string\n    start: number\n    amount: number | 'All'\n    order: 'ascending' | 'descending'\n    highlight?: string\n}): PageDescriptor & { kind: 'statistic' } {\n    let start = props.start\n    // make start % amount == 0\n    if (props.amount !== 'All') {\n        start = start - 1\n        start = start - (start % props.amount)\n        start = start + 1\n    }\n    return {\n        kind: 'statistic',\n        statname: props.statname,\n        article_type: props.articleType,\n        start,\n        amount: props.amount,\n        order: props.order,\n        highlight: props.highlight,\n        universe: props.universe,\n    }\n}\n\nexport function sanitize(longname: string, spaces_around_slash = true): string {\n    let x = longname\n    if (spaces_around_slash) {\n        x = x.replaceAll('/', ' slash ')\n    }\n    else {\n        x = x.replaceAll('/', 'slash')\n    }\n    x = x.replaceAll('%', '%25')\n    return x\n}\n\nexport function universePath(universe: string): string {\n    return `/icons/flags/${encodeURIComponent(universe)}.png`\n}\n","import * as idb from 'idb'\n\nimport type_to_priority from './data/type_to_priority'\nimport { loadProtobuf } from './load_json'\nimport { DefaultMap } from './utils/DefaultMap'\nimport { bitap, bitapPerformance, bitCount, Haystack, toHaystack, toNeedle, toSignature } from './utils/bitap'\nimport { isHistoricalCD } from './utils/is_historical'\nimport { ISearchIndexMetadata } from './utils/protos'\n\nexport interface SearchResult {\n    longname: string\n    typeIndex: number\n}\n\nconst debugSearch: boolean = false\n\nfunction debug(arg: unknown): void {\n    if (debugSearch) {\n        // eslint-disable-next-line no-console -- Debug logging\n        console.log(arg)\n    }\n}\n\nconst debugSearchPerformance: boolean = false\n\nexport function debugPerformance(arg: unknown): void {\n    if (debugSearchPerformance) {\n        // eslint-disable-next-line no-console -- Debug logging\n        console.log(arg)\n    }\n}\n\nexport function normalize(a: string, handlePunctuation = true): string {\n    a = a.toLowerCase()\n    a = a.normalize('NFD')\n    a = a.replace(/[\\u0300-\\u036f]/g, '')\n    if (handlePunctuation) {\n        a = a.replace(/[,\\(\\)\\[\\]]/g, '')\n        a = a.replaceAll('-', ' ')\n    }\n    return a\n}\n\ninterface NormalizedSearchIndex {\n    entries: {\n        longname: string\n        tokens: Haystack[]\n        priority: number\n        signature: number\n        typeIndex: number\n    }[]\n    lengthOfLongestToken: number\n    maxPriority: number\n    mostTokens: number\n}\n\ninterface Result {\n    entry: NormalizedSearchIndex['entries'][number]\n    normalizedMatchScore: number // Lower is better ([0,1], where 0 is perfect match, and 1 is no matches)\n    normalizedPopulationRank: number // Lower is higher population (better) ([0,1], where 0 is highest population and 1 is lowest population)\n    normalizedPriority: number // Lower is better ([0,1] where 1 is least prioritized)\n    normalizedPositionScore: number // The absolute difference in position where tokens were found. Lower is better ([0, 1] where 0 is all tokens are in the right place, and 1 is all tokens are maximally distant in this result)\n    normalizedTokensWithIncompleteMatch: number // The number of tokens in the query that do NOT match \"completely\" (are the same length) with their tokens in the haystack. These matches may still have errors. ([0, 1], lower is better, where 0 means all tokens in the query match completely, and 1 means no tokens in the query match completely)\n    normalizedTokenSwapOrOverlap: number // The number of search tokens that are out-of-order or overlap with another token when they are matched against the haystack tokens ([0, 1], where 0 is no tokens are swapped or overlapped, and 1 is all tokens are swapped or overlapped)\n    normalizedPriorityType: 1 | 0 // Is this a priority type? 0 if true\n}\n\nconst weights = {\n    match: 5,\n    position: 5,\n    priority: 1.6,\n    population: 2,\n    incompleteMatches: 1,\n    swapOverlap: 1,\n    priorityType: 0.2,\n}\n\nconst sumOfWeights = Object.values(weights).reduce((total, value) => total + value, 0)\nconst normalizedWeights = Object.fromEntries(Object.entries(weights).map(([key, value]) => [key, value / sumOfWeights]))\n\nfunction combinedScore(result: Result): number {\n    return (result.normalizedMatchScore * normalizedWeights.match)\n        + (result.normalizedPositionScore * normalizedWeights.position)\n        + (result.normalizedPriority * normalizedWeights.priority)\n        + (result.normalizedPopulationRank * normalizedWeights.population)\n        + (result.normalizedTokensWithIncompleteMatch * normalizedWeights.incompleteMatches)\n        + (result.normalizedTokenSwapOrOverlap * normalizedWeights.swapOverlap)\n        + (result.normalizedPriorityType * normalizedWeights.priorityType)\n}\n\nfunction compareSearchResults(a: Result, b: Result): number {\n    return combinedScore(a) - combinedScore(b)\n}\n\nfunction tokenize(pattern: string): string[] {\n    const matchNoOverflow = /^ *([^ ]{1,31})(.*)$/.exec(pattern)\n    if (matchNoOverflow !== null) {\n        const [, token, rest] = matchNoOverflow\n        return [token, ...tokenize(rest)]\n    }\n\n    return []\n}\n\nexport interface SearchParams {\n    unnormalizedPattern: string\n    maxResults: number\n    showHistoricalCDs: boolean\n    prioritizeTypeIndex?: number\n}\n\nfunction search(searchIndex: NormalizedSearchIndex, { unnormalizedPattern, maxResults, showHistoricalCDs, prioritizeTypeIndex }: SearchParams): SearchResult[] {\n    const start = performance.now()\n\n    const pattern = normalize(unnormalizedPattern)\n\n    if (pattern === '') {\n        return []\n    }\n\n    let longestPatternToken = 0\n    const patternTokens = tokenize(pattern).map((token) => {\n        longestPatternToken = Math.max(longestPatternToken, token.length)\n        return toNeedle(token)\n    })\n\n    const results: Result[] = []\n\n    const maxErrors = 2\n    const maxMatchScore = patternTokens.length * (maxErrors + 1)\n    const maxPositionScore = patternTokens.length * Math.max(patternTokens.length, searchIndex.lengthOfLongestToken)\n\n    const bitapBuffers = Array.from({ length: maxErrors + 1 }, () => new Uint32Array(longestPatternToken + maxErrors + 1))\n\n    bitapPerformance.numBitapSignatureChecks = 0\n    bitapPerformance.numBitapSignatureSkips = 0\n\n    const patternSignature = toSignature(pattern)\n\n    let entriesPatternSkips = 0\n    let entriesPatternChecks = 0\n\n    entries: for (const [populationRank, entry] of searchIndex.entries.entries()) {\n        if (!showHistoricalCDs && isHistoricalCD(entry.typeIndex)) {\n            continue\n        }\n\n        entriesPatternChecks++\n        if (bitCount(patternSignature ^ (patternSignature & entry.signature)) > maxErrors) {\n            // This element doesn't have the correct letters to match this pattern\n            entriesPatternSkips++\n            continue\n        }\n\n        const normalizedPopulationRank = (populationRank / searchIndex.entries.length)\n\n        // If this entry wouldn't make it into the results even with a perfect match because of priority or population, continue\n        if (results.length === maxResults && compareSearchResults({\n            entry,\n            normalizedMatchScore: 0,\n            normalizedPositionScore: 0,\n            normalizedPriority: entry.priority / searchIndex.maxPriority,\n            normalizedPopulationRank,\n            normalizedTokensWithIncompleteMatch: 0,\n            normalizedTokenSwapOrOverlap: 0,\n            normalizedPriorityType: entry.typeIndex === prioritizeTypeIndex ? 0 : 1,\n        }, results[results.length - 1]) > 0) {\n            continue\n        }\n\n        let matchScore = 0\n        let positionScore = 0\n        let incompleteMatches = 0\n\n        let prevEntryTokenIndex = -1\n        let numSwapsOverlaps = 0\n\n        for (const [patternTokenIndex, needle] of patternTokens.entries()) {\n            let tokenMatchScore = maxErrors + 1\n            let tokenPositionScore = Math.max(patternTokens.length, searchIndex.lengthOfLongestToken)\n            let tokenIncompleteMatch = true\n            let tokenEntryTokenIndex: undefined | number\n\n            for (const [entryTokenIndex, entryToken] of entry.tokens.entries()) {\n                const searchResult = bitap(entryToken, needle, maxErrors, bitapBuffers)\n                const positionResult = Math.abs(patternTokenIndex - entryTokenIndex)\n                const incompleteMatchResult = Math.abs(entryToken.haystack.length - needle.length) - searchResult !== 0\n                if (searchResult < tokenMatchScore || (searchResult <= tokenMatchScore && positionResult < tokenPositionScore) || (searchResult <= tokenMatchScore && positionResult <= tokenPositionScore && incompleteMatchResult < tokenIncompleteMatch)) {\n                    tokenMatchScore = searchResult\n                    tokenPositionScore = positionResult\n                    tokenIncompleteMatch = incompleteMatchResult\n                    tokenEntryTokenIndex = entryTokenIndex\n                }\n            }\n\n            matchScore += tokenMatchScore\n            positionScore += tokenPositionScore\n            incompleteMatches += tokenIncompleteMatch ? 1 : 0\n            if (tokenEntryTokenIndex !== undefined) {\n                numSwapsOverlaps += prevEntryTokenIndex >= tokenEntryTokenIndex ? 1 : 0\n                prevEntryTokenIndex = tokenEntryTokenIndex\n            }\n\n            // If our match score is so high that we would not make it into the results, we can move on to the next entry\n            if (results.length === maxResults && compareSearchResults({\n                entry,\n                normalizedMatchScore: matchScore / maxMatchScore,\n                normalizedPositionScore: positionScore / maxPositionScore,\n                normalizedPriority: entry.priority / searchIndex.maxPriority,\n                normalizedPopulationRank,\n                normalizedTokensWithIncompleteMatch: incompleteMatches / patternTokens.length,\n                normalizedTokenSwapOrOverlap: numSwapsOverlaps / patternTokens.length,\n                normalizedPriorityType: entry.typeIndex === prioritizeTypeIndex ? 0 : 1,\n            }, results[results.length - 1]) > 0) {\n                continue entries\n            }\n        }\n\n        if (matchScore >= patternTokens.length * (maxErrors + 1)) {\n            // No match\n            continue\n        }\n\n        const result: Result = {\n            entry,\n            normalizedMatchScore: matchScore / maxMatchScore,\n            normalizedPositionScore: positionScore / maxPositionScore,\n            normalizedPriority: entry.priority / searchIndex.maxPriority,\n            normalizedPopulationRank,\n            normalizedTokensWithIncompleteMatch: incompleteMatches / patternTokens.length,\n            normalizedTokenSwapOrOverlap: numSwapsOverlaps / patternTokens.length,\n            normalizedPriorityType: entry.typeIndex === prioritizeTypeIndex ? 0 : 1,\n        }\n\n        let spliceIndex: number | undefined\n        for (let resultsIndex = Math.min(results.length, maxResults); resultsIndex >= 0; resultsIndex--) {\n            if (results.length <= resultsIndex || compareSearchResults(result, results[resultsIndex]) < 0) {\n                spliceIndex = resultsIndex\n            }\n            else {\n                break\n            }\n        }\n        if (spliceIndex !== undefined) {\n            results.splice(spliceIndex, 0, result)\n        }\n        if (results.length > maxResults) {\n            results.pop()\n        }\n    }\n\n    debug(bitapPerformance)\n    debug({ total: entriesPatternChecks, skips: entriesPatternSkips })\n\n    debug(results.map(result => ({\n        ...result,\n        combinedScore: combinedScore(result),\n    })))\n\n    debugPerformance(`Took ${performance.now() - start} ms to execute search`)\n\n    return results.map(result => result.entry)\n}\n\n// Potentially cached\nexport async function createIndex(cacheKey: string | undefined): Promise<(params: SearchParams) => SearchResult[]> {\n    let index: NormalizedSearchIndex | undefined\n    try {\n        if (cacheKey === undefined) {\n            throw new Error('No cache key specified')\n        }\n\n        let checkpoint = performance.now()\n\n        const db = await idb.openDB('SearchCache', 1, {\n            upgrade(database) {\n                database.createObjectStore('indexes')\n            },\n        })\n\n        const store = db.transaction('indexes', 'readonly').objectStore('indexes')\n\n        debugPerformance(`Took ${performance.now() - checkpoint}ms to open database`)\n        checkpoint = performance.now()\n\n        index = (await store.get(cacheKey)) as NormalizedSearchIndex | undefined\n\n        debugPerformance(`Took ${performance.now() - checkpoint}ms to get index from cache`)\n        checkpoint = performance.now()\n\n        if (index === undefined) {\n            debugPerformance('Cache miss')\n            index = await createIndexNoCache()\n\n            void (async () => {\n                const writeStore = db.transaction('indexes', 'readwrite').objectStore('indexes')\n                const keys = await writeStore.getAllKeys()\n                await Promise.all(keys.map(k => writeStore.delete(k)))\n                await writeStore.put(index, cacheKey)\n            })()\n        }\n        else {\n            debugPerformance('Cache hit')\n        }\n    }\n    catch (error) {\n        // This is going to fail during unit testing since we don't mock stuff\n        console.warn('Getting cached search index failed', error)\n        index = await createIndexNoCache()\n    }\n    return params => search(index, params)\n}\n\nasync function createIndexNoCache(): Promise<NormalizedSearchIndex> {\n    const rawIndex = await loadProtobuf('/index/pages_all.gz', 'SearchIndex')\n    return processRawSearchIndex(rawIndex)\n}\n\nfunction processRawSearchIndex(searchIndex: { elements: string[], metadata: ISearchIndexMetadata[] }): NormalizedSearchIndex {\n    const start = performance.now()\n    let lengthOfLongestToken = 0\n    let maxPriority = 0\n    let mostTokens = 0\n    const priorities = searchIndex.metadata.map(({ type }) => type_to_priority[type!])\n    const haystackCache = new DefaultMap<string, Haystack>((token) => {\n        if (token.length > lengthOfLongestToken) {\n            lengthOfLongestToken = token.length\n        }\n        return toHaystack(token)\n    })\n    const entries = searchIndex.elements.map((longname, index) => {\n        const normalizedLongname = normalize(longname)\n        const entryTokens = tokenize(normalizedLongname)\n        const tokens = entryTokens.map(token => haystackCache.get(token))\n        if (priorities[index] > maxPriority) {\n            maxPriority = priorities[index]\n        }\n        if (tokens.length > mostTokens) {\n            mostTokens = tokens.length\n        }\n        return {\n            longname,\n            tokens,\n            priority: priorities[index],\n            signature: toSignature(normalizedLongname),\n            typeIndex: searchIndex.metadata[index].type!,\n        }\n    })\n    debugPerformance(`Took ${performance.now() - start}ms to process search index`)\n    return { entries, lengthOfLongestToken, maxPriority, mostTokens }\n}\n\nexport async function getIndexCacheKey(): Promise<string | undefined> {\n    try {\n        const start = performance.now()\n        // location is sometimes a worker\n        const resources = ['/scripts/index.js', '/index/pages_all.gz', location.href]\n        const etags = await Promise.all(resources.map(async (resource) => {\n            const response = await fetch(resource, { method: 'HEAD' })\n            if (!response.ok) {\n                throw new Error(`${resource} is not OK`)\n            }\n            const etag = response.headers.get('etag')\n            if (etag === null) {\n                throw new Error(`${resource} does not have etag`)\n            }\n            return etag\n        }))\n\n        debugPerformance(`Took ${performance.now() - start} to get search cache key`)\n        return etags.join(',')\n    }\n    catch (error) {\n        console.warn('Getting search cache key failed', error)\n        return undefined\n    }\n}\n","import assert from 'assert'\n\nimport { LocInfo } from './location'\nimport { Decorated, ParseError } from './parser'\nimport { USSType } from './types-values'\n\nexport type UrbanStatsASTArg = (\n    { type: 'unnamed', value: UrbanStatsASTExpression } |\n    { type: 'named', name: Decorated<string>, value: UrbanStatsASTExpression })\n\nexport type UrbanStatsASTLHS = (\n    { type: 'identifier', name: Decorated<string> } |\n    { type: 'attribute', expr: UrbanStatsASTExpression, name: Decorated<string> })\n\nexport type UrbanStatsASTExpression = (\n    UrbanStatsASTLHS |\n    { type: 'constant', value: Decorated<{ type: 'number', value: number } | { type: 'string', value: string }> } |\n    { type: 'call', fn: UrbanStatsASTExpression, args: UrbanStatsASTArg[], entireLoc: LocInfo } |\n    { type: 'binaryOperator', operator: Decorated<string>, left: UrbanStatsASTExpression, right: UrbanStatsASTExpression } |\n    { type: 'unaryOperator', operator: Decorated<string>, expr: UrbanStatsASTExpression } |\n    { type: 'objectLiteral', entireLoc: LocInfo, properties: [string, UrbanStatsASTExpression][] } |\n    { type: 'vectorLiteral', entireLoc: LocInfo, elements: UrbanStatsASTExpression[] } |\n    { type: 'if', entireLoc: LocInfo, condition: UrbanStatsASTExpression, then: UrbanStatsASTStatement, else?: UrbanStatsASTStatement } |\n    { type: 'do', entireLoc: LocInfo, statements: UrbanStatsASTStatement[] } |\n    // for internal purposes only\n    { type: 'customNode', entireLoc: LocInfo, expr: UrbanStatsASTStatement, originalCode: string, expectedType?: USSType[] }\n)\n\nexport type UrbanStatsASTStatement = (\n    { type: 'assignment', lhs: UrbanStatsASTLHS, value: UrbanStatsASTExpression } |\n    { type: 'expression', value: UrbanStatsASTExpression } |\n    { type: 'statements', entireLoc: LocInfo, result: UrbanStatsASTStatement[] } |\n    { type: 'condition', entireLoc: LocInfo, condition: UrbanStatsASTExpression, rest: UrbanStatsASTStatement[] } |\n    { type: 'parseError', originalCode: string, errors: ParseError[] })\n\nexport type UrbanStatsAST = UrbanStatsASTArg | UrbanStatsASTExpression | UrbanStatsASTStatement\n\nexport function unify(...locations: LocInfo[]): LocInfo {\n    assert(locations.length > 0, 'At least one location must be provided for unification')\n    const startLine = locations.reduce((min, loc) => Math.min(min, loc.start.lineIdx), Number.MAX_VALUE)\n    const endLine = locations.reduce((max, loc) => Math.max(max, loc.end.lineIdx), -Number.MAX_VALUE)\n    const startCol = locations.reduce((min, loc) => Math.min(min, loc.start.colIdx), Number.MAX_VALUE)\n    const endCol = locations.reduce((max, loc) => Math.max(max, loc.end.colIdx), -Number.MAX_VALUE)\n    const startChar = locations.reduce((min, loc) => Math.min(min, loc.start.charIdx), Number.MAX_VALUE)\n    const endChar = locations.reduce((max, loc) => Math.max(max, loc.end.charIdx), -Number.MAX_VALUE)\n    return {\n        start: { block: locations[0].start.block, lineIdx: startLine, colIdx: startCol, charIdx: startChar },\n        end: { block: locations[0].end.block, lineIdx: endLine, colIdx: endCol, charIdx: endChar },\n    }\n}\n\nexport function locationOf(node: UrbanStatsAST): LocInfo {\n    /* c8 ignore start -- This function doesn't need to be tested in detail, as it is a simple location extractor */\n    switch (node.type) {\n        case 'unnamed':\n            return locationOf(node.value)\n        case 'named':\n            return unify(node.name.location, locationOf(node.value))\n        case 'constant':\n            return node.value.location\n        case 'identifier':\n            return node.name.location\n        case 'attribute':\n            return unify(node.name.location, locationOf(node.expr))\n        case 'call':\n            return node.entireLoc\n        case 'unaryOperator':\n            return unify(node.operator.location, locationOf(node.expr))\n        case 'binaryOperator':\n            return unify(locationOf(node.left), locationOf(node.right), node.operator.location)\n        case 'objectLiteral':\n        case 'vectorLiteral':\n        case 'if':\n        case 'do':\n        case 'condition':\n        case 'statements':\n            return node.entireLoc\n        case 'assignment':\n            return unify(locationOf(node.lhs), locationOf(node.value))\n        case 'expression':\n            return locationOf(node.value)\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        case 'customNode':\n            return node.entireLoc\n    }\n    /* c8 ignore stop */\n}\n\nexport function locationOfLastExpression(node: UrbanStatsAST): LocInfo {\n    switch (node.type) {\n        case 'assignment':\n            return locationOf(node.value)\n        case 'statements':\n            return locationOfLastExpression(node.result[node.result.length - 1])\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        default:\n            return locationOf(node)\n    }\n}\n\nexport function getAllParseErrors(node: UrbanStatsAST): ParseError[] {\n    const errors: ParseError[] = []\n\n    function collectErrors(n: UrbanStatsAST): void {\n        switch (n.type) {\n            case 'unnamed':\n                collectErrors(n.value)\n                break\n            case 'named':\n                collectErrors(n.value)\n                break\n            case 'constant':\n            case 'identifier':\n                // No parse errors in these\n                break\n            case 'attribute':\n                collectErrors(n.expr)\n                break\n            case 'call':\n                collectErrors(n.fn)\n                n.args.forEach(collectErrors)\n                break\n            case 'unaryOperator':\n                collectErrors(n.expr)\n                break\n            case 'binaryOperator':\n                collectErrors(n.left)\n                collectErrors(n.right)\n                break\n            case 'objectLiteral':\n                n.properties.forEach(([, value]) => {\n                    collectErrors(value)\n                })\n                break\n            case 'vectorLiteral':\n                n.elements.forEach(collectErrors)\n                break\n            case 'if':\n                collectErrors(n.condition)\n                collectErrors(n.then)\n                if (n.else) {\n                    collectErrors(n.else)\n                }\n                break\n            case 'do':\n                n.statements.forEach(collectErrors)\n                break\n            case 'assignment':\n                collectErrors(n.lhs)\n                collectErrors(n.value)\n                break\n            case 'expression':\n                collectErrors(n.value)\n                break\n            case 'statements':\n                n.result.forEach(collectErrors)\n                break\n            case 'condition':\n                collectErrors(n.condition)\n                n.rest.forEach(collectErrors)\n                break\n            case 'parseError':\n                errors.push(...n.errors)\n                break\n            case 'customNode':\n                collectErrors(n.expr)\n                break\n        }\n    }\n\n    collectErrors(node)\n    return errors\n}\n\nexport function toStatement(node: UrbanStatsASTExpression | UrbanStatsASTStatement): UrbanStatsASTStatement {\n    switch (node.type) {\n        case 'statements':\n        case 'assignment':\n        case 'expression':\n        case 'condition':\n        case 'parseError':\n            return node\n        default:\n            return { type: 'expression', value: node }\n    }\n}\n","import ColorLib from 'color'\n\nimport hueColors from '../../data/hueColors'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue, createConstantExpression } from '../types-values'\n\nimport { Color, hexToColor } from './color-utils'\nimport { camelToHuman } from './utils'\n\nexport const colorType = { type: 'opaque', name: 'color' } satisfies USSType\n\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError: true): Color | undefined\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number): Color\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (red < 0 || red > 1 || green < 0 || green > 1 || blue < 0 || blue > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`RGB values must be between 0 and 1, got (${red}, ${green}, ${blue}, ${alpha})`)\n    }\n    const r = Math.round(red * 255)\n    const g = Math.round(green * 255)\n    const b = Math.round(blue * 255)\n    const a = Math.round(alpha * 255)\n    return { r, g, b, a }\n}\n\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError: true): Color | undefined\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number): Color\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (hue < 0 || hue > 360 || saturation < 0 || saturation > 1 || value < 0 || value > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`HSV values must be (hue: 0-360, saturation: 0-1, value: 0-1, alpha: 0-1), got (${hue}, ${saturation}, ${value}, ${alpha})`)\n    }\n    const color = ColorLib.hsv(hue, saturation * 100, value * 100)\n    return {\n        r: Math.round(color.red()),\n        g: Math.round(color.green()),\n        b: Math.round(color.blue()),\n        a: Math.round(alpha * 255),\n    }\n}\n\nexport const rgb = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // red\n            { type: 'concrete', value: { type: 'number' } }, // green\n            { type: 'concrete', value: { type: 'number' } }, // blue\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: rgbToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (RGB)',\n        category: 'color',\n        namedArgs: { a: 'Alpha' },\n        longDescription: 'Creates a color using RGB (Red, Green, Blue) values. Each component ranges from 0 to 1, where 0 is no color and 1 is full intensity.',\n    },\n} satisfies USSValue\n\nexport const hsv = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // hue\n            { type: 'concrete', value: { type: 'number' } }, // saturation\n            { type: 'concrete', value: { type: 'number' } }, // value\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: hsvToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (HSV)',\n        category: 'color',\n        longDescription: 'Creates a color using HSV (Hue, Saturation, Value) values. Hue ranges from 0 to 360 degrees, saturation and value range from 0 to 1.',\n    },\n} satisfies USSValue\n\nexport const renderColor = {\n    type: {\n        type: 'function',\n        posArgs: [{ type: 'concrete', value: colorType }],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: { type: 'string' } },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): string => {\n        const color = (posArgs[0] as { type: 'opaque', value: { r: number, g: number, b: number, a: number } }).value\n        return doRender(color)\n    },\n    documentation: {\n        humanReadableName: 'Color to String',\n        category: 'color',\n        longDescription: 'Converts a color object to its hexadecimal string representation (e.g., \"#ff0000\" for red). If the alpha channel is not 255, it will be included in the string, e.g., \"#ff000088\" for red with 50% opacity.',\n    },\n} satisfies USSValue\n\nexport function doRender(color: Color, ignoreAlpha?: boolean): string {\n    const hex = (x: number): string => {\n        x = Math.round(x)\n        const hexValue = x.toString(16)\n        return hexValue.length === 1 ? `0${hexValue}` : hexValue\n    }\n    let h = `#${hex(color.r)}${hex(color.g)}${hex(color.b)}`\n    if (color.a !== 255 && !ignoreAlpha) {\n        h += hex(color.a)\n    }\n    return h\n}\n\nfunction drawFunction(functionName: string, param1: number, param2: number, param3: number, alpha: number, round?: number): string {\n    const format: (num: number) => string = round !== undefined ? num => num.toFixed(round) : num => num.toString()\n    const alphaPart = alpha !== 255 ? `, a=${format(alpha / 255)}` : ''\n    return `${functionName}(${format(param1)}, ${format(param2)}, ${format(param3)}${alphaPart})`\n}\n\nexport function rgbColorExpression(color: Color, { forceAlpha, round }: { forceAlpha?: number, round?: number } = {}): string {\n    return drawFunction('rgb', color.r / 255, color.g / 255, color.b / 255, forceAlpha ?? color.a, round)\n}\n\nexport function hsvColorExpression(color: Color, { forceAlpha, round }: { forceAlpha?: number, round?: number } = {}): string {\n    const c = ColorLib.rgb(color.r, color.g, color.b)\n    return drawFunction('hsv', c.hue(), c.saturationv() / 100, c.value() / 100, forceAlpha ?? color.a, round)\n}\n\nfunction colorConstant(name: string, value: string, isDefault?: boolean): [string, USSValue] {\n    const humanReadableName = camelToHuman(name)\n    const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1)\n    const color = hexToColor(value)\n    return [`color${capitalizedName}`, {\n        type: colorType,\n        value: { type: 'opaque', opaqueType: 'color', value: color },\n        documentation: {\n            humanReadableName,\n            category: 'color',\n            equivalentExpressions: [parseNoErrorAsExpression(rgbColorExpression(color, { round: 3 }), ''), parseNoErrorAsExpression(hsvColorExpression(color, { round: 3 }), '')],\n            isDefault,\n            longDescription: `Predefined color constant representing ${humanReadableName.toLowerCase()}.`,\n            documentationTable: 'predefined-colors',\n            selectorRendering: {\n                kind: 'gradientBackground',\n                ramp: [[0, value], [1, value]],\n            },\n        },\n    }] satisfies [string, USSValue]\n}\n\nexport const colorConstants = [\n    ...Object.entries(hueColors).map(([name, value]) => colorConstant(name, value)),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('white', '#ffffff'),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('black', '#000000', true),\n]\n","import { Inset } from '../../components/map'\nimport insets from '../../data/insets'\nimport { UrbanStatsASTExpression } from '../ast'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue } from '../types-values'\n\nexport const insetType = {\n    type: 'opaque',\n    name: 'inset',\n} satisfies USSType\n\nexport const insetsType = {\n    type: 'opaque',\n    name: 'insets',\n} satisfies USSType\n\nexport const boundsType = {\n    type: 'object',\n    properties: new Map([\n        ['west', { type: 'number' }],\n        ['east', { type: 'number' }],\n        ['north', { type: 'number' }],\n        ['south', { type: 'number' }],\n    ]),\n} satisfies USSType\n\nexport function constructInset(\n    screenBounds: { west: number, east: number, north: number, south: number },\n    mapBounds: { west: number, east: number, north: number, south: number },\n    mainMap: boolean,\n    name?: string,\n): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'inset',\n        value: {\n            bottomLeft: [screenBounds.west, screenBounds.south],\n            topRight: [screenBounds.east, screenBounds.north],\n            coordBox: [mapBounds.west, mapBounds.south, mapBounds.east, mapBounds.north],\n            mainMap,\n            name,\n        } satisfies Inset & { name?: string },\n    }\n}\n\nexport function constructInsets(insetList: Inset[]): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'insets',\n        value: insetList,\n    }\n}\n\nexport const constructInsetValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            screenBounds: { type: { type: 'concrete', value: boundsType } },\n            mapBounds: { type: { type: 'concrete', value: boundsType } },\n            mainMap: { type: { type: 'concrete', value: { type: 'boolean' } } },\n            name: { type: { type: 'concrete', value: { type: 'string' } } },\n        },\n        returnType: { type: 'concrete', value: insetType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const screenBoundsObj = namedArgs.screenBounds as Map<string, USSRawValue>\n        const mapBoundsObj = namedArgs.mapBounds as Map<string, USSRawValue>\n        const mainMap = namedArgs.mainMap as boolean\n        const name = namedArgs.name as string\n        return constructInset(\n            {\n                west: screenBoundsObj.get('west') as number,\n                east: screenBoundsObj.get('east') as number,\n                north: screenBoundsObj.get('north') as number,\n                south: screenBoundsObj.get('south') as number,\n            },\n            {\n                west: mapBoundsObj.get('west') as number,\n                east: mapBoundsObj.get('east') as number,\n                north: mapBoundsObj.get('north') as number,\n                south: mapBoundsObj.get('south') as number,\n            },\n            mainMap,\n            name,\n        )\n    },\n    documentation: {\n        humanReadableName: 'Custom Inset',\n        category: 'inset',\n        longDescription: 'Creates a custom map inset with specified screen bounds (bounding box of the inset on the screen, where bottom left corner has (0, 0) and top right corner has (1, 1)), map bounds (bounding box of the inset on the map, in longitude and latitude), and whether it is the main map (the interactive map).',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructInsetsValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [\n            {\n                type: 'concrete',\n                value: {\n                    type: 'vector',\n                    elementType: insetType,\n                },\n            },\n        ],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: insetsType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const insetsList = posArgs[0] as { type: 'opaque', opaqueType: 'inset', value: Inset }[]\n        return constructInsets(insetsList.map(item => item.value))\n    },\n    documentation: {\n        humanReadableName: 'Custom Insets',\n        category: 'inset',\n        isDefault: true,\n        longDescription: 'Creates a collection of map insets.',\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nfunction computeInsetConstantName(name: string): string {\n    name = name.replace(/[\\s,().-]/g, '')\n    name = name.replaceAll('+', 'Plus')\n    name = `inset${name}`\n    return name\n}\n\nexport function deconstruct(inset: typeof insets[keyof typeof insets][number] | Inset): UrbanStatsASTExpression {\n    const uss = `constructInset(screenBounds={ north: ${inset.topRight[1]}, east: ${inset.topRight[0]}, south: ${inset.bottomLeft[1]}, west: ${inset.bottomLeft[0]} }, mapBounds={ north: ${inset.coordBox[3]}, east: ${inset.coordBox[2]}, south: ${inset.coordBox[1]}, west: ${inset.coordBox[0]} }, mainMap=${inset.mainMap}, name=\"${inset.name}\")`\n    return parseNoErrorAsExpression(uss, '')\n}\n\nexport const insetConsts: [string, USSValue][] = Object.entries(insets).flatMap(([, regionInsets]) =>\n    regionInsets.map((inset) => {\n        const insetName = inset.name\n        const constantName = computeInsetConstantName(insetName)\n\n        return [\n            constantName,\n            {\n                type: insetType,\n                value: {\n                    type: 'opaque',\n                    opaqueType: 'inset',\n                    value: {\n                        bottomLeft: [...inset.bottomLeft] as [number, number],\n                        topRight: [...inset.topRight] as [number, number],\n                        // copy to get rid of readonly\n                        coordBox: [...inset.coordBox] as [number, number, number, number],\n                        mainMap: inset.mainMap,\n                        name: inset.name,\n                    } satisfies Inset,\n                },\n                documentation: {\n                    humanReadableName: insetName,\n                    category: 'inset',\n                    equivalentExpressions: [deconstruct(inset)],\n                    longDescription: `Predefined map inset for the region \"${insetName}\".`,\n                    documentationTable: 'predefined-insets',\n                },\n            } satisfies USSValue,\n        ] as [string, USSValue]\n    }),\n)\n\nexport const insetNameToConstantName = new Map<string, string>(\n    Object.entries(insets).flatMap(([, regionInsets]) =>\n        regionInsets.map((inset) => {\n            const insetName = inset.name\n            return [insetName, computeInsetConstantName(insetName)]\n        }),\n    ),\n)\n","import { USSType, USSValue, createConstantExpression } from '../types-values'\n\n// Functions can't be send over the worker boundary, so instead we must send descriptors\nexport interface LinearScaleDescriptor { kind: 'linear', min: number, max: number }\n\nexport type ScaleDescriptor =\n    LinearScaleDescriptor |\n    { kind: 'log', linearScale: LinearScaleDescriptor }\nexport type Scale = (values: number[], min?: number, max?: number, center?: number) => ScaleDescriptor\n\nexport interface ScaleInstance {\n    forward: (value: number) => number\n    inverse: (value: number) => number\n}\n\nexport const scaleType = {\n    type: 'opaque',\n    name: 'scale',\n} satisfies USSType\n\nexport function instantiate(descriptor: ScaleDescriptor): ScaleInstance {\n    switch (descriptor.kind) {\n        case 'linear':\n            const { min, max } = descriptor\n            if (min === max) {\n                // just arbitrarily map min <=> 0.5\n                return {\n                    forward: x => 0.5 + x - min,\n                    inverse: x => x - 0.5 + min,\n                }\n            }\n            const range = max - min\n\n            return {\n                forward: (value: number) => (value - min) / range,\n                inverse: (value: number) => value * range + min,\n            }\n        case 'log':\n            const { forward, inverse } = instantiate(descriptor.linearScale)\n            return {\n                forward: (value: number) => forward(Math.log(value)),\n                inverse: (value: number) => Math.exp(inverse(value)),\n            }\n    }\n}\n\nconst linearScale: Scale = (values: number[], min?: number, max?: number, center?: number) => {\n    values = values.filter(value => typeof value === 'number' && !isNaN(value) && isFinite(value))\n\n    let computedMin = min ?? Math.min(...values)\n    let computedMax = max ?? Math.max(...values)\n\n    if (center !== undefined) {\n        if (min !== undefined && max !== undefined) {\n            if (Math.abs(center - (min + max) / 2) > 1e-10) {\n                throw new Error(`Inconsistent parameters: center ${center} does not equal (min + max) / 2 = ${min + max} / 2`)\n            }\n        }\n        else if (min !== undefined) {\n            computedMax = 2 * center - min\n        }\n        else if (max !== undefined) {\n            computedMin = 2 * center - max\n        }\n        else {\n            const range = Math.max(computedMax - center, center - computedMin)\n            computedMin = center - range\n            computedMax = center + range\n        }\n    }\n    return {\n        kind: 'linear',\n        min: computedMin,\n        max: computedMax,\n    }\n}\n\nconst logScale: Scale = (values: number[], min?: number, max?: number, center?: number) => {\n    const logVals = values.map(Math.log)\n    const logMin = min !== undefined ? Math.log(min) : undefined\n    const logMax = max !== undefined ? Math.log(max) : undefined\n    const logCenter = center !== undefined ? Math.log(center) : undefined\n    const linearScaleDescriptor = linearScale(logVals, logMin, logMax, logCenter) as LinearScaleDescriptor\n    return {\n        kind: 'log',\n        linearScale: linearScaleDescriptor,\n    }\n}\n\nexport const linearScaleValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            min: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            center: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            max: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n        },\n        returnType: { type: 'concrete', value: scaleType },\n    },\n    value: (ctx, posArgs, namedArgs) => {\n        const min = namedArgs.min as number | null | undefined\n        const max = namedArgs.max as number | null | undefined\n        const center = namedArgs.center as number | null | undefined\n        // Return a scale function that closes over these params\n        return {\n            type: 'opaque',\n            opaqueType: 'scale',\n            value: (values: number[]) => linearScale(values, min ?? undefined, max ?? undefined, center ?? undefined),\n        }\n    },\n    documentation: {\n        humanReadableName: 'Linear Scale',\n        category: 'scale',\n        isDefault: true,\n        longDescription: 'Creates a linear scale that maps numeric values to a range. If min/max are not specified, they are computed from the data. Center parameter can be used to create symmetric ranges.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n    },\n} satisfies USSValue\n\nexport const logScaleValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            min: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            center: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            max: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n        },\n        returnType: { type: 'concrete', value: scaleType },\n    },\n    value: (ctx, posArgs, namedArgs) => {\n        const min = namedArgs.min as number | null | undefined\n        const max = namedArgs.max as number | null | undefined\n        const center = namedArgs.center as number | null | undefined\n        // Return a scale function that closes over these params\n        return {\n            type: 'opaque',\n            opaqueType: 'scale',\n            value: (values: number[]) => logScale(values, min ?? undefined, max ?? undefined, center ?? undefined),\n        }\n    },\n    documentation: {\n        humanReadableName: 'Logarithmic Scale',\n        category: 'scale',\n        longDescription: 'Creates a logarithmic scale that maps numeric values to a range using log transformation. Useful for data with wide ranges or exponential distributions. If min/max are not specified, they are computed from the data. Center parameter can be used to create symmetric ranges.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n    },\n} satisfies USSValue\n","import assert from 'assert'\n\nimport { Effect, InterpretationError } from './interpreter'\nimport { LocInfo } from './location'\nimport { USSValue } from './types-values'\n\nexport class Context {\n    #effect: (eff: Effect) => void\n    #error: (msg: string, location: LocInfo) => InterpretationError\n    #constants: Map<string, USSValue>\n    #variables: Map<string, USSValue>\n\n    constructor(effect: (eff: Effect) => void, error: (msg: string, location: LocInfo) => InterpretationError, constants: Map<string, USSValue>, variables: Map<string, USSValue>) {\n        this.#effect = effect\n        this.#error = error\n        this.#constants = constants\n        this.#variables = variables\n        for (const name of variables.keys()) {\n            assert(!constants.has(name), `Variable name \"${name}\" conflicts with a constant`)\n        }\n    }\n\n    effect(eff: Effect): void {\n        this.#effect(eff)\n    }\n\n    error(msg: string, location: LocInfo): InterpretationError {\n        return this.#error(msg, location)\n    }\n\n    getVariable(name: string): USSValue | undefined {\n        if (this.#constants.has(name)) {\n            return this.#constants.get(name)\n        }\n        return this.#variables.get(name)\n    }\n\n    assignVariable(name: string, value: USSValue): string | undefined {\n        if (this.#constants.has(name)) {\n            return `Cannot assign to constant \"${name}\"`\n        }\n        this.#variables.set(name, value)\n        return undefined\n    }\n\n    variableEntries(): IterableIterator<[string, USSValue]> {\n        return this.#variables.entries()\n    }\n\n    evolveVariables(variables: Map<string, USSValue>): Context {\n        return new Context(\n            this.#effect,\n            this.#error,\n            this.#constants,\n            variables,\n        )\n    }\n}\n","import { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTStatement, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTArg, locationOf, unify } from './ast'\nimport { Context } from './context'\nimport { addAdditionalDims, broadcastApply, broadcastCall } from './forward-broadcasting'\nimport { LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\nimport { splitMask } from './split-broadcasting'\nimport { renderType, unifyType, USSRawValue, USSType, USSValue, USSVectorType, ValueArg, undocValue, canUnifyTo } from './types-values'\n\nexport interface Effect { type: 'warning', message: string, location: LocInfo }\n\nexport function renderLocInfo(loc: LocInfo): string {\n    if (loc.start.lineIdx === loc.end.lineIdx) {\n        if (loc.start.colIdx + 1 === loc.end.colIdx) {\n            // Single character location\n            return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}`\n        }\n        return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}-${loc.end.colIdx}`\n    }\n    return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1} - ${loc.end.lineIdx + 1}:${loc.end.colIdx}`\n}\n\nexport class InterpretationError extends Error {\n    public value: string\n    constructor(message: string, public location: LocInfo) {\n        super(`${message} at ${renderLocInfo(location)}`)\n        this.name = 'InterpretationError'\n        this.value = message\n        this.location = location\n    }\n}\n\nexport function evaluate(expr: UrbanStatsASTExpression, env: Context): USSValue {\n    switch (expr.type) {\n        case 'constant':\n            const value = expr.value.node\n            if (value.type === 'number') {\n                return undocValue(value.value, { type: 'number' })\n            }\n            return undocValue(value.value satisfies string, { type: 'string' })\n        case 'identifier':\n            const varName = expr.name.node\n            const res = env.getVariable(varName)\n            if (res !== undefined) {\n                return res\n            }\n            throw env.error(`Undefined variable: ${varName}`, expr.name.location)\n        case 'attribute':\n            const obj = evaluate(expr.expr, env)\n            const attr = expr.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, undefined)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(expr))\n            }\n            return lookupResult.value\n        case 'call':\n            const func = evaluate(expr.fn, env)\n            const args = expr.args.map(arg => evaluateArg(arg, env))\n            const broadcastResult = broadcastCall(func, args, env, locationOf(expr))\n            if (broadcastResult.type === 'error') {\n                throw env.error(broadcastResult.message, locationOf(expr))\n            }\n            return broadcastResult.result\n        case 'unaryOperator':\n            const operand = evaluate(expr.expr, env)\n            return evaluateUnaryOperator(operand, expr.operator.node, env, locationOf(expr))\n        case 'binaryOperator':\n            const left = evaluate(expr.left, env)\n            const right = evaluate(expr.right, env)\n            return evaluateBinaryOperator(left, right, expr.operator.node, env, locationOf(expr))\n        case 'vectorLiteral':\n            const elements = expr.elements.map(e => evaluate(e, env))\n            let elementType = { type: 'elementOfEmptyVector' } as USSType | { type: 'elementOfEmptyVector' }\n            for (const e of elements) {\n                elementType = unifyType(elementType, e.type, () => {\n                    assert(elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(e.value)}`)\n                    return env.error(`vector literal contains heterogenous types ${renderType(elementType)} and ${renderType(e.type)}`, locationOf(expr))\n                })\n            }\n            return undocValue(elements.map(e => e.value), { type: 'vector', elementType })\n        case 'objectLiteral':\n            const ts = new Map<string, USSType>()\n            const vs = new Map<string, USSRawValue>()\n            for (const [name, e] of expr.properties) {\n                const v = evaluate(e, env)\n                if (ts.has(name)) {\n                    throw env.error(`Duplicate key ${name} in object literal`, locationOf(e))\n                }\n                ts.set(name, v.type)\n                vs.set(name, v.value)\n            }\n            return undocValue(vs, {\n                type: 'object',\n                properties: ts,\n            })\n        case 'if':\n            const condition = evaluate(expr.condition, env)\n            return splitMask(\n                env,\n                condition,\n                (v: USSValue, subEnv: Context): USSValue => {\n                    if (v.type.type !== 'boolean') {\n                        throw env.error(`Condition in if statement must be a boolean, but got ${renderType(v.type)}`, locationOf(expr.condition))\n                    }\n                    if (v.value) {\n                        return execute(expr.then, subEnv)\n                    }\n                    if (expr.else === undefined) {\n                        return undocValue(null, { type: 'null' })\n                    }\n                    return execute(expr.else, subEnv)\n                },\n                locationOf(expr.condition),\n                locationOf(expr),\n            )\n        case 'do':\n            if (expr.statements.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let doResult: USSValue = execute(expr.statements[0], env)\n            for (const statement of expr.statements.slice(1)) {\n                doResult = execute(statement, env)\n            }\n            return doResult\n        case 'customNode':\n            // This is a custom node for internal purposes, we just evaluate the expression\n            const result = execute(expr.expr, env)\n\n            // Check type if expectedType is provided\n            if (expr.expectedType && !expr.expectedType.some(t => canUnifyTo(result.type, t))) {\n                throw env.error(\n                    `Custom expression expected to return type ${expr.expectedType.map(t => renderType(t)).join(' or ')}, but got ${renderType(result.type)}`,\n                    locationOf(expr),\n                )\n            }\n\n            return result\n    }\n}\n\nexport function execute(expr: UrbanStatsASTStatement, env: Context): USSValue {\n    switch (expr.type) {\n        case 'condition':\n            if (expr.rest.length === 0) {\n                throw env.error('condition(..) must be followed by at least one statement', locationOf(expr))\n            }\n            return evaluate(\n                { type: 'if',\n                    condition: expr.condition,\n                    then: { type: 'statements', result: expr.rest, entireLoc: unify(...expr.rest.map(locationOf)) },\n                    entireLoc: expr.entireLoc,\n                },\n                env,\n            )\n        case 'assignment':\n            const value = evaluate(expr.value, env)\n            evaluateLHS(expr.lhs, value, env)\n            return value\n        case 'expression':\n            return evaluate(expr.value, env)\n        case 'statements':\n            if (expr.result.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let result: USSValue = execute(expr.result[0], env)\n            for (const statement of expr.result.slice(1)) {\n                result = execute(statement, env)\n            }\n            return result\n        case 'parseError':\n            assert(expr.errors.length > 0, 'parseError node must have at least one error')\n            throw env.error(\n                `Parse error: ${expr.errors.map(e => e.value).join(', ')}`,\n                expr.errors[0].location,\n            )\n    }\n}\n\nexport function evaluateLHS(lhs: UrbanStatsASTLHS, value: USSValue, env: Context): void {\n    switch (lhs.type) {\n        case 'identifier':\n            const varName = lhs.name.node\n            const err = env.assignVariable(varName, value)\n            if (err !== undefined) {\n                throw env.error(err, locationOf(lhs))\n            }\n            return\n        case 'attribute':\n            const obj = evaluate(lhs.expr, env)\n            const attr = lhs.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, value)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(lhs))\n            }\n            return\n    }\n}\n\nfunction evaluateArg(arg: UrbanStatsASTArg, env: Context): ValueArg {\n    switch (arg.type) {\n        case 'named':\n            return {\n                type: 'named',\n                name: arg.name.node,\n                value: evaluate(arg.value, env),\n            }\n        case 'unnamed':\n            return {\n                type: 'unnamed',\n                value: evaluate(arg.value, env),\n            }\n    }\n}\n\nfunction attrLookupOrSet(\n    obj: USSValue,\n    attr: string,\n    orSet: USSValue | undefined,\n): { type: 'success', value: USSValue } | { type: 'error', message: string } {\n    const type = obj.type\n    if (type.type === 'object') {\n        const val = obj.value\n        assert(val instanceof Map, `Expected object type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        const aT = type.properties.get(attr)\n        if (aT === undefined) {\n            return {\n                type: 'error',\n                message: `Attribute ${attr} not found in object of type ${renderType(type)}`,\n            }\n        }\n        if (orSet !== undefined) {\n            if (renderType(aT) !== renderType(orSet.type)) {\n                return {\n                    type: 'error',\n                    message: `Type mismatch: expected ${renderType(aT)} but got ${renderType(orSet.type)} for attribute ${attr} in object of type ${renderType(type)}`,\n                }\n            }\n            // If orSet is provided, we set the attribute to the value\n            val.set(attr, orSet.value)\n            return {\n                type: 'success',\n                value: undocValue(orSet.value, aT),\n            }\n        }\n        const content = val.get(attr)\n        assert(content !== undefined, `Expected attribute ${attr} to be defined in object, but got undefined at ${JSON.stringify(obj.value)}`)\n        return {\n            type: 'success',\n            value: undocValue(val.get(attr)!, aT),\n        }\n    }\n    if (type.type === 'vector') {\n        const val = obj.value\n        assert(val instanceof Array, `Expected vector type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        let orSetLookp: (idx: number) => USSValue | undefined = () => undefined\n        if (orSet !== undefined) {\n            if (orSet.type.type !== 'vector') {\n                orSet = undocValue(addAdditionalDims([val.length], orSet.value), { type: 'vector', elementType: orSet.type })\n            }\n            assert(Array.isArray(orSet.value), `It should be an array at this point`)\n            if (orSet.value.length !== val.length) {\n                return { type: 'error', message: `Expected vector of length ${val.length} but got ${orSet.value.length} for attribute ${attr} in object of type ${renderType(type)}` }\n            }\n            const v = orSet.value\n            const t = (orSet.type as USSVectorType).elementType\n            assert(t.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(orSet.value)}`)\n            orSetLookp = (idx: number) => {\n                return undocValue(v[idx], t)\n            }\n        }\n        const resultsOrErr = val.map((x, i) => {\n            assert(type.elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(obj.value)}`)\n            return attrLookupOrSet(undocValue(x, type.elementType), attr, orSetLookp(i))\n        })\n        if (resultsOrErr.some(r => r.type === 'error')) {\n            return { type: 'error', message: resultsOrErr.filter(r => r.type === 'error').map(r => (r as { type: 'error', message: string }).message)[0] }\n        }\n        const results = resultsOrErr.map(r => (r as { type: 'success', value: USSValue }).value)\n        const rawValue = results.map(r => r.value)\n        const typ = results[0].type\n        return {\n            type: 'success',\n            value: undocValue(rawValue, { type: 'vector', elementType: typ }),\n        }\n    }\n    return { type: 'error', message: `Cannot access attribute of type ${renderType(type)}. Only objects and vectors support attributes.` }\n}\n\nfunction evaluateUnaryOperator(operand: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.unary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.unary(operator, errLoc),\n        [operand],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n\nfunction evaluateBinaryOperator(left: USSValue, right: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.binary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.binary(operator, errLoc),\n        [left, right],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n","import { assert } from '../utils/defensive'\n\nimport { Block, LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\n\nconst nonExpressionOperators = ['=', ',', ';', '.', ':']\nconst operatorCharacters = '!@$%^&*-+=~`<>/?:|,;.'\n\nconst keywords = ['if', 'do', 'else', 'customNode', 'condition']\nexport type Keyword = (typeof keywords)[number]\n\ninterface NumericToken { type: 'number', value: number }\ninterface IdentifierToken { type: 'identifier', value: string }\ninterface KeywordToken { type: 'keyword', value: Keyword }\ninterface StringToken { type: 'string', value: string }\ninterface OperatorToken { type: 'operator', value: string }\ninterface BracketToken { type: 'bracket', value: '(' | ')' | '{' | '}' | '[' | ']' }\ninterface ErrorToken { type: 'error', value: string }\ntype NonErrorToken = NumericToken | IdentifierToken | KeywordToken | StringToken | OperatorToken | BracketToken\ntype Token = NonErrorToken | ErrorToken\n\nexport interface AnnotatedToken {\n    token: Token\n    location: LocInfo\n}\n\nexport type AnnotatedTokenWithValue = AnnotatedToken & { token: NonErrorToken }\n\ninterface GenericLexer {\n    firstToken: (ch: string) => boolean\n    innerToken: (ch: string) => boolean\n    parse: (string: string) => Token\n}\n\nfunction isDigit(ch: string): boolean {\n    return ch >= '0' && ch <= '9'\n}\nfunction isAlpha(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_'\n}\n\nexport function emptyLocation(ident: string): LocInfo {\n    return {\n        start: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n        end: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n    }\n}\n\nexport function parseNumber(input: string): number | undefined {\n    if (/^-?\\d*(\\.\\d+)?([eE][+-]?\\d+)?$/i.test(input)) {\n        // normal number format\n        const value = parseFloat(input)\n        if (isNaN(value)) {\n            return\n        }\n        return value\n    }\n    if (input.endsWith('k')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000\n    }\n    if (input.endsWith('m')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000000\n    }\n    return\n}\n\nconst identifierLexer: GenericLexer = {\n    firstToken: isAlpha,\n    innerToken: (ch: string): boolean => isAlpha(ch) || isDigit(ch),\n    parse: (string: string): Token => { return { type: keywords.includes(string) ? 'keyword' : 'identifier', value: string } },\n}\n\nfunction isOperator(string: string): boolean {\n    return nonExpressionOperators.includes(string) || expressionOperatorMap.has(string)\n}\n\nconst operatorLexer: GenericLexer = {\n    firstToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    innerToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    parse: (string: string): Token => {\n        if (isOperator(string)) {\n            return { type: 'operator', value: string }\n        }\n        return { type: 'error', value: `Invalid operator: ${string}` }\n    },\n}\n\nfunction lexLine(input: string, block: Block, lineNo: number, charIdxOffset: number): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    // one line\n    assert(!input.includes('\\n'), 'Input contains new line characters')\n    let idx = 0\n    lex: while (idx < input.length) {\n        const char = input[idx]\n        if (char === ' ') {\n            idx++\n            continue\n        }\n        if (char === '(' || char === ')' || char === '{' || char === '}' || char === '[' || char === ']') {\n            const token: AnnotatedToken = {\n                token: { type: 'bracket', value: char },\n                location: {\n                    start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                    end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n                },\n            }\n            tokens.push(token)\n            idx++\n            continue\n        }\n        if (isDigit(char)) {\n            let token\n            [idx, token] = lexNumber(input, idx, block, lineNo, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue\n            }\n        }\n        for (const lexer of [identifierLexer, operatorLexer]) {\n            let token\n            [idx, token] = lexGeneric(input, idx, block, lineNo, lexer, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue lex\n            }\n        }\n        let token\n        [idx, token] = lexString(input, idx, block, lineNo, charIdxOffset)\n        if (token !== undefined) {\n            tokens.push(token)\n            continue\n        }\n        tokens.push({\n            token: { type: 'error', value: `Unexpected character: ${char}` },\n            location: {\n                start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n            },\n        })\n        idx++\n    }\n    return tokens\n}\n\nexport function lex(block: Block, input: string): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    const lines = input.split('\\n')\n    let charIdx = 0\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i]\n        const lineTokens = lexLine(line, block, i, charIdx)\n        tokens.push(...lineTokens)\n        charIdx += line.length\n        tokens.push({\n            token: { type: 'operator', value: 'EOL' },\n            location: {\n                start: { block, lineIdx: i, colIdx: line.length, charIdx },\n                end: { block, lineIdx: i, colIdx: line.length, charIdx },\n            },\n        })\n        charIdx += 1 // newline\n    }\n    return tokens\n}\n\nfunction lexGeneric(\n    input: string,\n    idx: number,\n    block: Block,\n    lineNo: number,\n    lexer: GenericLexer,\n    charIdxOffset: number,\n): [number, AnnotatedToken | undefined] {\n    if (!lexer.firstToken(input[idx])) {\n        return [idx, undefined]\n    }\n\n    const start = idx\n    while (idx < input.length && lexer.innerToken(input[idx])) {\n        idx++\n    }\n    const token: AnnotatedToken = {\n        token: lexer.parse(input.slice(start, idx)),\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexString(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    if (input[idx] !== '\"') {\n        return [idx, undefined]\n    }\n    const start = idx\n    idx++\n    while (true) {\n        if (idx >= input.length) {\n            return [idx, { token: { type: 'error', value: 'Unterminated string' }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + start } } }]\n        }\n        if (input[idx] === '\"') {\n            idx++\n            break\n        }\n        if (input[idx] === '\\\\') {\n            idx += 2\n            continue\n        }\n        idx++\n    }\n    let result: string\n    try {\n        const resultObj: unknown = JSON.parse(input.slice(start, idx))\n        assert(typeof resultObj === 'string', `Invalid string: ${input.slice(start, idx)}`)\n        result = resultObj\n    }\n    catch (e) {\n        return [idx, { token: { type: 'error', value: `Invalid string: ${input.slice(start, idx)}: ${e}` }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'string', value: result },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexNumber(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    const numberFormat = /^\\d+(\\.\\d+)?([eE][+-]?\\d+|k|m)?/i\n    const match = numberFormat.exec(input.slice(idx))\n    if (!match) {\n        return [idx, undefined]\n    }\n    const numberStr = match[0]\n    const number = parseNumber(numberStr)\n    if (number === undefined) {\n        return [idx + numberStr.length, { token: { type: 'error', value: `Invalid number format: ${numberStr}` }, location: { start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx }, end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'number', value: number },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n            end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length },\n        },\n    }\n    return [idx + numberStr.length, token]\n}\n","export type Block = { type: 'single', ident: string } | { type: 'multi' }\n\nexport interface SingleLocationWithinBlock {\n    lineIdx: number\n    colIdx: number\n    charIdx: number\n}\nexport type SingleLocation = SingleLocationWithinBlock & { block: Block }\n\nexport interface LocInfo {\n    start: SingleLocation\n    end: SingleLocation\n}\n\nexport const noLocation = { start: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 }, end: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 } } satisfies LocInfo\n\nexport function extendBlockIdPositionalArg(blockIdent: string, position: number): string {\n    return `${blockIdent}_pos_${position}`\n}\n\nexport function extendBlockIdKwarg(blockIdent: string, argName: string): string {\n    return `${blockIdent}_${argName}`\n}\n\nexport function extendBlockIdVectorElement(blockIdent: string, index: number): string {\n    return `${blockIdent}_el_${index}`\n}\n\nexport function extendBlockIdObjectProperty(blockIdent: string, property: string): string {\n    return `${blockIdent}_prop_${property}`\n}\n","import { assert } from '../utils/defensive'\n\nimport { locationOf, unify, UrbanStatsAST, UrbanStatsASTArg, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTStatement } from './ast'\nimport { Context } from './context'\nimport { AnnotatedToken, AnnotatedTokenWithValue, lex, Keyword, emptyLocation } from './lexer'\nimport { noLocation, LocInfo, Block } from './location'\nimport { expressionOperatorMap, infixOperators, unaryOperators } from './operators'\nimport { USSType } from './types-values'\n\nexport interface Decorated<T> {\n    node: T\n    location: LocInfo\n}\n\nexport interface ParseError { type: 'error', value: string, location: LocInfo }\n\ntype USSInfixSequenceElement = { type: 'operator', operatorType: 'unary' | 'binary', value: Decorated<string> } | UrbanStatsASTExpression\n\nexport function toSExp(node: UrbanStatsAST): string {\n    /**\n     * For testing purposes, we convert the AST to a simple S-expression format.\n     */\n    switch (node.type) {\n        case 'unnamed':\n            return toSExp(node.value)\n        case 'named':\n            return `(named ${node.name.node} ${toSExp(node.value)})`\n        case 'constant':\n            return `(const ${node.value.node.value})`\n        case 'identifier':\n            return `(id ${node.name.node})`\n        case 'attribute':\n            return `(attr ${toSExp(node.expr)} ${node.name.node})`\n        case 'call':\n            return `(fn ${[node.fn, ...node.args].map(toSExp).join(' ')})`\n        case 'unaryOperator':\n            return `(${node.operator.node} ${toSExp(node.expr)})`\n        case 'binaryOperator':\n            return `(${node.operator.node} ${toSExp(node.left)} ${toSExp(node.right)})`\n        case 'vectorLiteral':\n            return `(vector ${node.elements.map(toSExp).join(' ')})`\n        case 'objectLiteral':\n            return `(object ${node.properties.map(([key, value]) => `(${key} ${toSExp(value)})`).join(' ')})`\n        case 'assignment':\n            return `(assign ${toSExp(node.lhs)} ${toSExp(node.value)})`\n        case 'expression':\n            return `(expr ${toSExp(node.value)})`\n        case 'statements':\n            return `(statements ${node.result.map(toSExp).join(' ')})`\n        case 'if':\n            return `(if ${toSExp(node.condition)} ${toSExp(node.then)}${node.else ? ` ${toSExp(node.else)}` : ''})`\n        case 'do':\n            return `(do ${node.statements.map(toSExp).join(' ')})`\n        case 'condition':\n            return `(condition ${toSExp(node.condition)} ${node.rest.map(toSExp).join(' ')})`\n        case 'parseError':\n            return `(parseError ${JSON.stringify(node.originalCode)} ${JSON.stringify(node.errors)})`\n        case 'customNode':\n            return `(customNode ${toSExp(node.expr)} ${JSON.stringify(node.originalCode)})`\n    }\n}\n\nclass ParseState {\n    tokens: AnnotatedTokenWithValue[]\n    index: number\n    constructor(tokens: AnnotatedTokenWithValue[]) {\n        this.tokens = tokens\n        this.index = 0\n    }\n\n    skipEOL(): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === 'operator' && token.token.value === 'EOL') {\n            this.index++\n            return true\n        }\n        return false\n    }\n\n    consumeTokenOfType(type: string, ...values: (string | number)[]): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === type && (values.length === 0 || values.includes(token.token.value))) {\n            this.index++\n            return true\n        }\n        if (this.skipEOL()) {\n            if (this.consumeTokenOfType(type, ...values)) {\n                return true\n            }\n            this.index-- // backtrack\n        }\n        return false\n    }\n\n    consumeOperator(...oneOfOps: string[]): boolean {\n        return this.consumeTokenOfType('operator', ...oneOfOps)\n    }\n\n    consumeBracket(...oneOfBrackets: string[]): boolean {\n        return this.consumeTokenOfType('bracket', ...oneOfBrackets)\n    }\n\n    consumeIdentifier(): boolean {\n        return this.consumeTokenOfType('identifier')\n    }\n\n    consumeKeyword(...oneOfKeywords: Keyword[]): boolean {\n        return this.consumeTokenOfType('keyword', ...oneOfKeywords)\n    }\n\n    maybeLastNonEOLToken(offset: number): AnnotatedTokenWithValue {\n        for (let i = this.index + offset; i >= 0; i--) {\n            const token = this.tokens[i]\n            if (token.token.type !== 'operator' || token.token.value !== 'EOL') {\n                return token\n            }\n        }\n        return this.tokens[this.index + offset]\n    }\n\n    parseSingleExpression(): UrbanStatsASTExpression | ParseError {\n        while (this.skipEOL()) { }\n        if (this.index >= this.tokens.length) {\n            return { type: 'error', value: 'Unexpected end of input', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const token = this.tokens[this.index]\n        switch (token.token.type) {\n            case 'number':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'number', value: token.token.value }, location: token.location } }\n            case 'string':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'string', value: token.token.value }, location: token.location } }\n            case 'identifier':\n                this.index++\n                return { type: 'identifier', name: { node: token.token.value, location: token.location } }\n            case 'keyword':\n                throw new Error(`Unexpected keyword ${token.token.value}`)\n            case 'bracket':\n                switch (token.token.value) {\n                    case '(':\n                        this.index++\n                        const expr = this.parseExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        if (!this.consumeBracket(')')) {\n                            return { type: 'error', value: 'Expected closing bracket ) to match this one', location: token.location }\n                        }\n                        return expr\n                    case '{':\n                        this.index++\n                        const startLoc = token.location\n                        const properties: [string, UrbanStatsASTExpression][] = []\n                        while (!this.consumeBracket('}')) {\n                            if (properties.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: `Expected comma , or closing bracket } after object field name; instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n                            }\n                            if (!this.consumeIdentifier()) {\n                                return { type: 'error', value: 'Expected identifier for object field name', location: this.maybeLastNonEOLToken(-1).location }\n                            }\n                            const keyToken = this.tokens[this.index - 1]\n                            assert(keyToken.token.type === 'identifier', `Expected identifier token, but got ${keyToken.token.type}`)\n                            if (!this.consumeOperator(':')) {\n                                return { type: 'error', value: `Expected : token after object field name`, location: keyToken.location }\n                            }\n                            const value = this.parseExpression()\n                            if (value.type === 'error') {\n                                return value\n                            }\n                            properties.push([keyToken.token.value, value])\n                        }\n                        const endLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'objectLiteral',\n                            entireLoc: unify(startLoc, endLoc),\n                            properties,\n                        }\n                    case '[':\n                        this.index++\n                        const vectorStartLoc = token.location\n                        const elements: UrbanStatsASTExpression[] = []\n                        while (!this.consumeBracket(']')) {\n                            if (elements.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: 'Expected comma , or closing bracket ] after vector element', location: this.maybeLastNonEOLToken(0).location }\n                            }\n                            const element = this.parseExpression()\n                            if (element.type === 'error') {\n                                return element\n                            }\n                            elements.push(element)\n                        }\n                        const vectorEndLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'vectorLiteral',\n                            entireLoc: unify(vectorStartLoc, vectorEndLoc),\n                            elements,\n                        }\n                }\n                return { type: 'error', value: `Unexpected bracket ${token.token.value}`, location: token.location }\n            case 'operator':\n                return { type: 'error', value: `Unexpected operator ${token.token.value}`, location: token.location }\n        }\n    }\n\n    parseArg(): UrbanStatsASTArg | ParseError {\n        const exprOrName = this.parseExpression()\n        if (exprOrName.type === 'error') {\n            return exprOrName\n        }\n        if (!this.consumeOperator('=')) {\n            return { type: 'unnamed', value: exprOrName }\n        }\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (exprOrName.type !== 'identifier') {\n            return { type: 'error', value: 'Expected identifier for named argument', location: locationOf(exprOrName) }\n        }\n        return {\n            type: 'named',\n            name: { node: exprOrName.name.node, location: exprOrName.name.location },\n            value: expr,\n        }\n    }\n\n    parseParenthesizedArgs(): { type: 'args', args: [UrbanStatsASTArg[], LocInfo] } | ParseError | undefined {\n        if (!this.consumeBracket('(')) {\n            return undefined\n        }\n        const startLoc = this.tokens[this.index - 1].location\n        const args: UrbanStatsASTArg[] = []\n        while (true) {\n            if (this.consumeBracket(')')) {\n                const endLoc = this.tokens[this.index - 1].location\n                return { type: 'args', args: [args, unify(startLoc, endLoc)] }\n            }\n            if (args.length > 0 && !this.consumeOperator(',')) {\n                return { type: 'error', value: `Expected comma , or closing bracket ); instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n            }\n            const arg = this.parseArg()\n            if (arg.type === 'error') {\n                return arg\n            }\n            args.push(arg)\n        }\n    }\n\n    parseFunctionalExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('customNode')) {\n            return this.parseCustomNodeExpression()\n        }\n\n        let fn = this.parseSingleExpression()\n        if (fn.type === 'error') {\n            return fn\n        }\n        while (true) {\n            let done = true\n            const args = this.parseParenthesizedArgs()\n            if (args !== undefined) {\n                done = false\n                if (args.type === 'error') {\n                    return args\n                }\n                fn = {\n                    type: 'call',\n                    fn,\n                    entireLoc: unify(locationOf(fn), args.args[1]),\n                    args: args.args[0],\n                }\n            }\n            if (this.consumeOperator('.')) {\n                done = false\n                if (!this.consumeIdentifier()) {\n                    return { type: 'error', value: 'Expected identifier after the dot', location: this.maybeLastNonEOLToken(-1).location }\n                }\n                const token = this.tokens[this.index - 1]\n                assert(token.token.type === 'identifier', `Expected identifier token, but got ${token.token.type}`)\n                fn = {\n                    type: 'attribute',\n                    expr: fn,\n                    name: { node: token.token.value, location: token.location },\n                }\n            }\n            if (done) {\n                break\n            }\n        }\n        return fn\n    }\n\n    parseExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('if')) {\n            return this.parseIfExpression()\n        }\n\n        if (this.consumeKeyword('do')) {\n            return this.parseDoExpression()\n        }\n\n        const operatorExpSequence: USSInfixSequenceElement[] = []\n        // State Machine with states expressionOrUnaryOperator; binaryOperator\n        let state: 'expressionOrUnaryOperator' | 'binaryOperator' = 'expressionOrUnaryOperator'\n        loop: while (true) {\n            switch (state) {\n                case 'expressionOrUnaryOperator': {\n                    if (this.consumeOperator(...unaryOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'unary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        continue\n                    }\n                    else {\n                        const expr = this.parseFunctionalExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        operatorExpSequence.push(expr)\n                        state = 'binaryOperator'\n                    }\n                }\n                    break\n                case 'binaryOperator': {\n                    if (this.consumeOperator(...infixOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'binary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        state = 'expressionOrUnaryOperator'\n                    }\n                    else {\n                        break loop\n                    }\n                }\n            }\n        }\n        return this.parseInfixSequence(operatorExpSequence)\n    }\n\n    parseInfixSequence(operatorExpSequence: USSInfixSequenceElement[]): UrbanStatsASTExpression | ParseError {\n        assert(operatorExpSequence.length !== 0, 'Expected expression')\n        if (operatorExpSequence.length === 1) {\n            assert(operatorExpSequence[0].type !== 'operator', `Unexpected operator ${JSON.stringify(operatorExpSequence[0])} at beginning of infix sequence`)\n            return operatorExpSequence[0]\n        }\n        // Get the highest precedence operator\n        const precedences = operatorExpSequence.map(x => x.type === 'operator' ? expressionOperatorMap.get(x.value.node)?.precedence ?? 0 : 0)\n        const maxPrecedence = Math.max(...precedences)\n        assert(maxPrecedence > 0, 'No valid operator found in infix sequence')\n        const index = precedences.findIndex(p => p === maxPrecedence)\n        assert(index > -1, 'No operator found with maximum precedence; this should not happen')\n        return this.parseInfixSequence(this.resolveOperator(operatorExpSequence, index))\n    }\n\n    resolveOperator(operatorExpSequence: USSInfixSequenceElement[], index: number): USSInfixSequenceElement[] {\n        assert(operatorExpSequence[index].type === 'operator', `Expected operator at index ${index}, but found expression: ${JSON.stringify(operatorExpSequence[index])}`)\n        const next = operatorExpSequence[index + 1]\n        if (next.type === 'operator') {\n            return this.resolveOperator(operatorExpSequence, index + 1)\n        }\n        switch (operatorExpSequence[index].operatorType) {\n            case 'unary': {\n                return [\n                    ...operatorExpSequence.slice(0, index),\n                    { type: 'unaryOperator', operator: operatorExpSequence[index].value, expr: next },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n            case 'binary': {\n                // Split the sequence into left and right parts\n                const left = operatorExpSequence[index - 1]\n                const right = operatorExpSequence[index + 1]\n                assert(left.type !== 'operator' && right.type !== 'operator', 'unreachable: left or right should not be an operator')\n                return [\n                    ...operatorExpSequence.slice(0, index - 1),\n                    { type: 'binaryOperator', operator: operatorExpSequence[index].value, left, right },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n        }\n    }\n\n    checkLHS(expr: UrbanStatsASTExpression): UrbanStatsASTLHS | ParseError {\n        switch (expr.type) {\n            case 'identifier':\n            case 'attribute':\n                return expr\n            case 'constant':\n            case 'call':\n            case 'unaryOperator':\n            case 'binaryOperator':\n            case 'vectorLiteral':\n            case 'objectLiteral':\n            case 'if':\n            case 'do':\n            case 'customNode':\n                return { type: 'error', value: 'Cannot assign to this expression', location: locationOf(expr) }\n        }\n    }\n\n    parseStatement(): UrbanStatsASTStatement | ParseError {\n        if (this.consumeKeyword('condition')) {\n            return this.parseConditionStatement()\n        }\n\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (this.consumeOperator('=')) {\n            const value = this.parseExpression()\n            if (value.type === 'error') {\n                return value\n            }\n            const lhs = this.checkLHS(expr)\n            if (lhs.type === 'error') {\n                return lhs\n            }\n            return { type: 'assignment', lhs, value }\n        }\n        return { type: 'expression', value: expr }\n    }\n\n    parseIfExpression(): UrbanStatsASTExpression | ParseError {\n        const ifToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after if', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const then = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after if block')\n        if (then.type === 'error') {\n            return then\n        }\n        let elseBranch: UrbanStatsASTStatement | undefined = undefined\n        if (this.consumeKeyword('else')) {\n            if (!this.consumeBracket('{')) {\n                return { type: 'error', value: 'Expected opening bracket { after else', location: this.maybeLastNonEOLToken(-1).location }\n            }\n            const eb = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after else block')\n            if (eb.type === 'error') {\n                return eb\n            }\n            elseBranch = eb\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'if',\n            entireLoc: unify(ifToken.location, lastToken.location),\n            condition,\n            then,\n            else: elseBranch,\n        }\n    }\n\n    parseDoExpression(): UrbanStatsASTExpression | ParseError {\n        const doToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after do', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const statements = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after do block')\n        if (statements.type === 'error') {\n            return statements\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'do',\n            entireLoc: unify(doToken.location, lastToken.location),\n            statements: statements.type === 'statements' ? statements.result : [statements],\n        }\n    }\n\n    parseConditionStatement(): UrbanStatsASTStatement | ParseError {\n        const conditionToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return {\n            type: 'condition',\n            entireLoc: unify(conditionToken.location, this.tokens[this.index - 1].location),\n            condition,\n            rest: [],\n        }\n    }\n\n    parseStatements(canEnd: boolean = false, end: () => boolean = () => false, errMsg: string = 'Expected end of line or ; after'): UrbanStatsASTStatement | ParseError {\n        const statements: UrbanStatsASTStatement[] = []\n        while (this.index < this.tokens.length) {\n            if (end()) {\n                break\n            }\n            while (this.skipEOL()) { }\n            if (this.index >= this.tokens.length) {\n                break\n            }\n            const statement = this.parseStatement()\n            if (statement.type === 'error') {\n                return statement\n            }\n            statements.push(statement)\n            if (end()) {\n                break\n            }\n            if (!this.consumeOperator('EOL', ';')) {\n                return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n            }\n            while (this.skipEOL()) { }\n        }\n        if (this.index === this.tokens.length && canEnd) {\n            return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return mergeStatements(\n            statements,\n            this.index > 0\n                ? this.tokens[this.index - 1].location\n                /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n                : undefined,\n        )\n    }\n\n    parseCustomNodeExpression(): UrbanStatsASTExpression | ParseError {\n        const argsRes = this.parseParenthesizedArgs()\n\n        if (argsRes === undefined) {\n            return { type: 'error', value: 'Expected arguments for customNode', location: this.maybeLastNonEOLToken(-1).location }\n        }\n\n        if (argsRes.type === 'error') {\n            return argsRes\n        }\n\n        const [args, locArg] = argsRes.args\n\n        const code = args[0]\n\n        if (args.length !== 1 || code.type !== 'unnamed') {\n            return { type: 'error', value: 'Incorrect arguments for customNode, expected 1 unnamed argument', location: argsRes.args[1] }\n        }\n\n        if (code.value.type !== 'constant' || code.value.value.node.type !== 'string') {\n            return { type: 'error', value: 'Expected string constant as argument to customNode', location: locationOf(code) }\n        }\n\n        const parseResult = parse(code.value.value.node.value, code.value.value.location.start.block)\n\n        if (parseResult.type === 'error') {\n            return {\n                type: 'customNode',\n                expr: {\n                    type: 'parseError',\n                    errors: parseResult.errors,\n                    originalCode: code.value.value.node.value,\n                },\n                originalCode: code.value.value.node.value,\n                entireLoc: locArg,\n            }\n        }\n\n        return {\n            type: 'customNode',\n            expr: parseResult,\n            originalCode: code.value.value.node.value,\n            entireLoc: locArg,\n        }\n    }\n}\n\nexport function mergeStatements(statements: UrbanStatsASTStatement[], fallbackLocation?: LocInfo): UrbanStatsASTStatement {\n    statements = gulpRestForConditions(statements)\n    if (statements.length === 1) {\n        return statements[0]\n    }\n    const entireLoc: LocInfo = statements.length > 0\n        ? unify(...statements.map(locationOf))\n        : fallbackLocation\n        /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n        ?? noLocation\n    return { type: 'statements', result: statements, entireLoc }\n}\n\nfunction gulpRestForConditions(statements: UrbanStatsASTStatement[]): UrbanStatsASTStatement[] {\n    /**\n     * Handle condition statements by gulping the next statement into the condition's rest.\n     */\n    const result: UrbanStatsASTStatement[] = []\n    for (let i = 0; i < statements.length; i++) {\n        const stmt = statements[i]\n        if (stmt.type === 'condition') {\n            stmt.rest.push(...gulpRestForConditions(statements.slice(i + 1)))\n            result.push(stmt)\n            break\n        }\n        result.push(stmt)\n    }\n    return result\n}\n\nexport function parse(code: string, block?: Block, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const tokens = lex(block ?? { type: 'multi' }, code)\n    return parseTokens(tokens, code, returnParseErrorNode)\n}\n\nexport function parseTokens(tokens: AnnotatedToken[], originalCode: string, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const lexErrors = tokens.filter(token => token.token.type === 'error')\n    if (lexErrors.length > 0) {\n        const errors: ParseError[] = lexErrors.map(token => ({ type: 'error' as const, value: `Unrecognized token: ${token.token.value}`, location: token.location }))\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors }\n        }\n        return { type: 'error', errors }\n    }\n    const state = new ParseState(tokens as AnnotatedTokenWithValue[]) // we checked for errors above, so this cast is safe\n    const stmts = state.parseStatements()\n    if (stmts.type === 'error') {\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors: [stmts] }\n        }\n        return { type: 'error', errors: [stmts] }\n    }\n    assert(state.index === state.tokens.length, `Parser did not consume all tokens: ${state.index} < ${state.tokens.length}`)\n    return stmts\n}\n\nfunction allExpressions(node: UrbanStatsASTStatement | UrbanStatsASTExpression): UrbanStatsASTExpression[] {\n    const expressions: UrbanStatsASTExpression[] = []\n    function helper(n: UrbanStatsASTStatement | UrbanStatsASTExpression | UrbanStatsASTArg): boolean {\n        switch (n.type) {\n            case 'unnamed':\n                helper(n.value)\n                return true\n            case 'named':\n                expressions.push(n.value)\n                helper(n.value)\n                return true\n            case 'constant':\n            case 'identifier':\n                expressions.push(n)\n                return true\n            case 'attribute':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'call':\n                expressions.push(n)\n                helper(n.fn)\n                n.args.forEach(helper)\n                return true\n            case 'unaryOperator':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'binaryOperator':\n                expressions.push(n)\n                helper(n.left)\n                helper(n.right)\n                return true\n            case 'objectLiteral':\n                expressions.push(n)\n                n.properties.forEach(([key, value]) => {\n                    expressions.push({ type: 'constant', value: { node: { type: 'string', value: key }, location: n.entireLoc } })\n                    helper(value)\n                })\n                return true\n            case 'vectorLiteral':\n                expressions.push(n)\n                n.elements.forEach(helper)\n                return true\n            case 'assignment':\n                helper(n.lhs)\n                helper(n.value)\n                return true\n            case 'expression':\n                helper(n.value)\n                return true\n            case 'statements':\n                n.result.forEach(helper)\n                return true\n            case 'if':\n                helper(n.condition)\n                helper(n.then)\n                if (n.else) {\n                    helper(n.else)\n                }\n                return true\n            case 'do':\n                n.statements.forEach(helper)\n                return true\n            case 'condition':\n                helper(n.condition)\n                n.rest.forEach(helper)\n                return true\n            case 'parseError':\n                return true\n            case 'customNode':\n                // do not actually put this in the expressions list, as is for internal use only\n                helper(n.expr)\n                return true\n        }\n    }\n    helper(node)\n    return expressions\n}\n\nfunction identifiersInExpr(node: UrbanStatsASTStatement | UrbanStatsASTExpression): Set<string> {\n    const identifiers = new Set<string>()\n    allExpressions(node).forEach((expr) => {\n        if (expr.type === 'identifier') {\n            identifiers.add(expr.name.node)\n        }\n    })\n    return identifiers\n}\n\nexport function allIdentifiers(node: UrbanStatsASTStatement | UrbanStatsASTExpression, ctx: Context): Set<string> {\n    const identifiers = identifiersInExpr(node)\n    while (true) {\n        // make sure to include identifiers from default values of function arguments pulled in by the identifiers\n        const newIdentifiers = new Set<string>()\n        identifiers.forEach((id) => {\n            const t = ctx.getVariable(id)?.type\n            if (t === undefined || t.type !== 'function') {\n                return\n            }\n            Object.entries(t.namedArgs).forEach(([, arg]) => {\n                const dv = arg.defaultValue\n                if (dv === undefined) {\n                    return\n                }\n                identifiersInExpr(dv).forEach((newId) => {\n                    if (!identifiers.has(newId)) {\n                        newIdentifiers.add(newId)\n                    }\n                })\n            })\n        })\n        if (newIdentifiers.size === 0) {\n            break\n        }\n        newIdentifiers.forEach(id => identifiers.add(id))\n    }\n    return identifiers\n}\n\nexport function unparse(node: UrbanStatsASTStatement | UrbanStatsASTExpression, opts: { indent?: number, inline?: boolean, simplify?: boolean, expressionalContext?: boolean } = {}): string {\n    if (opts.inline) {\n        assert(opts.expressionalContext ?? false, 'inline must be true if expressionalContext is true')\n    }\n    opts.indent = opts.indent ?? 0\n    function isSimpleExpression(expr: UrbanStatsASTExpression): boolean {\n        return expr.type === 'identifier' || expr.type === 'vectorLiteral' || expr.type === 'constant' || expr.type === 'customNode'\n    }\n    function indentSpaces(level: number): string {\n        return '    '.repeat(level)\n    }\n    switch (node.type) {\n        case 'customNode':\n            if (!opts.simplify) {\n                return `customNode(${JSON.stringify(node.originalCode.trim())})`\n            }\n            if (opts.expressionalContext && node.expr.type !== 'expression') {\n                return unparse({ type: 'do', statements: [node.expr], entireLoc: locationOf(node.expr) }, { ...opts, inline: true })\n            }\n            else {\n                return node.originalCode.trim()\n            }\n        case 'parseError':\n            return node.originalCode\n        case 'constant':\n            if (node.value.node.type === 'string') {\n                return `\"${node.value.node.value}\"`\n            }\n            else {\n                return node.value.node.value.toString()\n            }\n        case 'identifier':\n            return node.name.node\n        case 'attribute':\n            const exprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            return `${exprStr}.${node.name.node}`\n        case 'call':\n            const fnStr = unparse(node.fn, { ...opts, inline: true, expressionalContext: true })\n            const argsStr = node.args.map((arg) => {\n                switch (arg.type) {\n                    case 'unnamed':\n                        return unparse(arg.value, { ...opts, inline: true, expressionalContext: true })\n                    case 'named':\n                        return `${arg.name.node}=${unparse(arg.value, { ...opts, inline: true, expressionalContext: true })}`\n                }\n            })\n            const fnNeedsParens = !isSimpleExpression(node.fn)\n            const fnWithParens = fnNeedsParens ? `(${fnStr})` : fnStr\n            return `${fnWithParens}(${argsStr.join(', ')})`\n        case 'unaryOperator':\n            const unaryExprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            const needsParens = !isSimpleExpression(node.expr)\n            const exprWithParens = needsParens ? `(${unaryExprStr})` : unaryExprStr\n            return `${node.operator.node}${exprWithParens}`\n        case 'binaryOperator':\n            const leftStr = unparse(node.left, { ...opts, inline: true, expressionalContext: true })\n            const rightStr = unparse(node.right, { ...opts, inline: true, expressionalContext: true })\n            const opPrecedence = expressionOperatorMap.get(node.operator.node)?.precedence ?? 0\n            let leftWithParens = leftStr\n            if (node.left.type === 'binaryOperator') {\n                const leftOpPrecedence = expressionOperatorMap.get(node.left.operator.node)?.precedence ?? 0\n                if (leftOpPrecedence < opPrecedence) {\n                    leftWithParens = `(${leftStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.left)) {\n                leftWithParens = `(${leftStr})`\n            }\n            let rightWithParens = rightStr\n            if (node.right.type === 'binaryOperator') {\n                const rightOpPrecedence = expressionOperatorMap.get(node.right.operator.node)?.precedence ?? 0\n                if (rightOpPrecedence <= opPrecedence) {\n                    rightWithParens = `(${rightStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.right)) {\n                rightWithParens = `(${rightStr})`\n            }\n            return `${leftWithParens} ${node.operator.node} ${rightWithParens}`\n        case 'vectorLiteral':\n            const elementsStr = node.elements.map(elem => unparse(elem, { ...opts, inline: true, expressionalContext: true }))\n            return `[${elementsStr.join(', ')}]`\n        case 'objectLiteral':\n            const propertiesStr = node.properties.map(([key, value]) => {\n                const valueStr = unparse(value, { ...opts, inline: true, expressionalContext: true })\n                return `${key}: ${valueStr}`\n            })\n            return `{${propertiesStr.join(', ')}}`\n        case 'assignment':\n            const lhsStr = unparse(node.lhs, { ...opts, expressionalContext: true })\n            const valueStr = unparse(node.value, { ...opts, expressionalContext: true })\n            return opts.inline ? `${lhsStr} = ${valueStr}` : `${indentSpaces(opts.indent)}${lhsStr} = ${valueStr}`\n        case 'expression':\n            // despite being an expression, it is not in an expressional context if its parent is not\n            return opts.inline ? unparse(node.value, opts) : `${indentSpaces(opts.indent)}${unparse(node.value, opts)}`\n        case 'statements':\n            const statementsStr = node.result\n                .map(stmt => unparse(stmt, opts))\n                .filter(s => s !== '' && s !== 'do {  }')\n            return statementsStr.join(opts.inline ? '; ' : ';\\n')\n        case 'if':\n            const conditionStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const thenStr = unparse(node.then, { ...opts, indent: opts.indent + 1 })\n            let ifStr = opts.inline\n                ? `if (${conditionStr}) { ${thenStr} }`\n                : `if (${conditionStr}) {\\n${thenStr}\\n${indentSpaces(opts.indent)}}`\n            if (node.else) {\n                const elseStr = unparse(node.else, { ...opts, indent: opts.indent + 1 })\n                ifStr += opts.inline\n                    ? ` else { ${elseStr} }`\n                    : ` else {\\n${elseStr}\\n${indentSpaces(opts.indent)}}`\n            }\n            return ifStr\n        case 'do':\n            const doStatements = { type: 'statements' as const, result: node.statements, entireLoc: node.entireLoc }\n            const doStr = unparse(doStatements, { ...opts, indent: opts.indent + 1 })\n            return opts.inline\n                ? `do { ${doStr} }`\n                : `do {\\n${doStr}\\n${indentSpaces(opts.indent)}}`\n        case 'condition':\n            const condStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const restStatements = { type: 'statements' as const, result: node.rest, entireLoc: node.entireLoc }\n            const restStr = unparse(restStatements, opts)\n            // If condition is literal \"true\", elide it\n            if (opts.simplify && node.condition.type === 'identifier' && node.condition.name.node === 'true') {\n                return restStr\n            }\n            return `${indentSpaces(opts.indent)}condition (${condStr})\\n${restStr}`\n    }\n}\n\nexport function parseNoError(uss: string, blockId: string): UrbanStatsASTStatement {\n    const result = parse(uss, { type: 'single', ident: blockId }, true)\n    assert(result.type !== 'error', `Should not have an error`)\n    return result\n}\n\nexport function parseNoErrorAsCustomNode(uss: string, blockId: string, expectedType?: USSType[]): Extract<UrbanStatsASTExpression, { type: 'customNode' }> {\n    assert(!blockId.startsWith('undefined'), 'blockId must not start with \"undefined\"')\n    const result = parseNoError(uss, blockId)\n    return {\n        type: 'customNode',\n        expr: result,\n        originalCode: uss,\n        expectedType,\n        entireLoc: emptyLocation(blockId),\n    }\n}\n\nexport function parseNoErrorAsExpression(uss: string, blockId: string): UrbanStatsASTExpression {\n    const result = parseNoError(uss, blockId)\n    assert(result.type === 'expression', 'Must be expression')\n    return result.value\n}\n","import { Basemap } from '../mapper/settings/utils'\nimport { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTExpression } from './ast'\nimport { Color, hexToColor } from './constants/color-utils'\nimport { CMap, CMapRGB, Outline, PMap } from './constants/map'\nimport { RampT } from './constants/ramp'\nimport { Scale } from './constants/scale'\nimport { Context } from './context'\nimport { noLocation } from './location'\nimport { unparse } from './parser'\n\n// Define Inset and Insets types locally to avoid import issues\ninterface Inset { bottomLeft: [number, number], topRight: [number, number], coordBox?: [number, number, number, number], mainMap: boolean, name?: string }\ntype Insets = Inset[]\n\n// Define the tagged union for opaque values\nexport type USSOpaqueValue =\n    | { type: 'opaque', opaqueType: 'color', value: Color }\n    | { type: 'opaque', opaqueType: 'scale', value: Scale }\n    | { type: 'opaque', opaqueType: 'inset', value: Inset }\n    | { type: 'opaque', opaqueType: 'insets', value: Insets }\n    | { type: 'opaque', opaqueType: 'cMap', value: CMap }\n    | { type: 'opaque', opaqueType: 'cMapRGB', value: CMapRGB }\n    | { type: 'opaque', opaqueType: 'pMap', value: PMap }\n    | { type: 'opaque', opaqueType: 'outline', value: Outline }\n    | { type: 'opaque', opaqueType: 'unit', value: { unit: string } }\n    | { type: 'opaque', opaqueType: 'ramp', value: RampT }\n    | { type: 'opaque', opaqueType: 'basemap', value: Basemap }\n    | { type: 'opaque', opaqueType: 'geoFeatureHandle', value: string }\n    | { type: 'opaque', opaqueType: 'geoCentroidHandle', value: string }\n\ninterface USSNumberType {\n    type: 'number'\n}\n\ninterface USSStringType {\n    type: 'string'\n}\ninterface USSBooleanType {\n    type: 'boolean'\n}\n\ninterface USSNullType {\n    type: 'null'\n}\n\nexport interface USSOpaqueType {\n    type: 'opaque'\n    name: string\n    allowCustomExpression?: boolean\n}\n\nexport interface USSVectorType {\n    type: 'vector'\n    elementType: USSType | { type: 'elementOfEmptyVector' }\n}\n\nexport interface USSObjectType {\n    type: 'object'\n    properties: Map<string, USSType>\n}\n\nexport type USSFunctionArgType = { type: 'concrete', value: USSType } | { type: 'anyPrimitive' }\nexport type USSFunctionReturnType = { type: 'concrete', value: USSType } | { type: 'inferFromPrimitive' }\n\nexport interface NamedFunctionArgumentWithDocumentation {\n    type: USSFunctionArgType\n    defaultValue?: UrbanStatsASTExpression\n    documentation?: NamedFunctionArgumentDocumentation\n}\n\nexport interface USSFunctionType {\n    type: 'function'\n    posArgs: USSFunctionArgType[]\n    namedArgs: Record<string, NamedFunctionArgumentWithDocumentation>\n    returnType: USSFunctionReturnType\n}\n\ninterface NamedFunctionArgumentDocumentation {\n    hide?: boolean\n}\n\nexport type USSType = (\n    USSNumberType\n    | USSStringType\n    | USSBooleanType\n    | USSNullType\n    | USSOpaqueType\n    | USSObjectType\n    | USSVectorType\n    | USSFunctionType\n)\n\nexport type USSPrimitiveRawValue = (\n    number |\n    string |\n    boolean |\n    null\n)\n\nexport interface OriginalFunctionArgs {\n    posArgs: USSValue[]\n    namedArgs: Record<string, USSValue>\n}\n\nexport type USSRawValue = (\n    USSPrimitiveRawValue |\n    USSRawValue[] |\n    Map<string, USSRawValue> |\n    (\n        (\n            ctx: Context,\n            posArgs: USSRawValue[],\n            namedArgs: Record<string, USSRawValue>,\n            // only used occasionally, for functions that need to access the original arguments\n            // to e.g., access their documentation\n            originalArgs: OriginalFunctionArgs\n        ) => USSRawValue\n    ) |\n    USSOpaqueValue\n)\n\nexport const constantCategories = ['basic', 'color', 'math', 'regression', 'mapper', 'logic', 'map', 'scale', 'ramp', 'unit', 'inset'] as const\n\nexport type ConstantCategory = typeof constantCategories[number]\n\nexport type DocumentationTable = 'mapper-data-variables' | 'predefined-colors' | 'unit-types' | 'predefined-ramps' | 'predefined-insets' | 'logarithm-functions' | 'trigonometric-functions'\n\nexport type SelectorRendering = { kind: 'subtitleLongDescription' } | { kind: 'gradientBackground', ramp: RampT }\nexport interface Documentation {\n    humanReadableName: string\n    priority?: number\n    /**\n     * True if this is the canonical default value for its type (e.g., the default ramp or scale).\n     */\n    isDefault?: boolean\n    /**\n     * Human-readable names for named arguments. Maps argument name to display name.\n     */\n    namedArgs?: Record<string, string>\n    /**\n     * Should be included when a constant should be deconstructed into an expression for user editing\n     */\n    equivalentExpressions?: UrbanStatsASTExpression[]\n    /**\n     * Included for all bulit-in constants.\n     */\n    category?: ConstantCategory\n    /**\n     * Whether the constant should be grouped with other constants in a table in the documentation.\n     * If present, this field groups the constant with other similar ones.\n     */\n    documentationTable?: DocumentationTable\n    /**\n     * Included for all bulit-in constants. Will be displayed in the documentation.\n     */\n    longDescription?: string\n    /**\n     * Used when displaying this value in a selector\n     */\n    selectorRendering?: SelectorRendering\n    /**\n     * True if this is a custom constructor that should invoke edit icons elsewhere\n     */\n    customConstructor?: boolean\n    /**\n     * True if the constant is derived from a statistic column. These should all have type number[]\n     */\n    fromStatisticColumn?: boolean\n    /**\n     * True if this should be outputted in the context returned by the worker. If this is true, the value\n     * should also be serializable to JSON.\n     */\n    includedInOutputContext?: boolean\n}\n\nexport interface USSDocumentedType {\n    type: USSType\n    documentation?: Documentation\n\n}\n\nexport type TypeEnvironment = Map<string, USSDocumentedType>\n\nexport type USSValue = { value: USSRawValue } & USSDocumentedType\n\nexport function undocValue(value: USSRawValue, type: USSType): USSValue {\n    return {\n        type,\n        value,\n        documentation: undefined,\n    }\n}\n\nexport function createConstantExpression(value: number | string | boolean | null): UrbanStatsASTExpression {\n    // Create a simple constant expression for primitive values\n    if (typeof value === 'number') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'number', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'string') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'string', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'boolean') {\n        // For booleans, use identifier expressions that reference the predefined constants\n        return {\n            type: 'identifier',\n            name: { node: value.toString(), location: noLocation },\n        }\n    }\n    else {\n        // For null, use identifier expression that references the predefined null constant\n        return {\n            type: 'identifier',\n            name: { node: 'null', location: noLocation },\n        }\n    }\n}\n\nexport function unifyFunctionType(param: USSFunctionArgType, arg: USSType): boolean {\n    if (param.type === 'concrete') {\n        return renderType(param.value) === renderType(arg)\n    }\n    return arg.type === 'number' || arg.type === 'string' || arg.type === 'boolean' || arg.type === 'null'\n}\n\nexport function renderType(type: USSType): string {\n    if (type.type === 'number') {\n        return 'number'\n    }\n    if (type.type === 'string') {\n        return 'string'\n    }\n    if (type.type === 'boolean') {\n        return 'boolean'\n    }\n    if (type.type === 'vector') {\n        return `[${type.elementType.type === 'elementOfEmptyVector' ? '' : renderType(type.elementType)}]`\n    }\n    if (type.type === 'object') {\n        assert(type.properties instanceof Map, `Expected properties to be a Map, got ${typeof type.properties}`)\n        return `{${[...type.properties.entries()].sort().map(([k, v]) => `${k}: ${renderType(v)}`).join(', ')}}`\n    }\n    if (type.type === 'null') {\n        return 'null'\n    }\n    if (type.type === 'opaque') {\n        return type.name\n    }\n    return `(${type.posArgs.map(renderArgumentType).join(', ')}; ${Object.entries(type.namedArgs).map(([k, v]) => `${k}: ${renderKwargType(v)}`).join(', ')}) -> ${renderReturnType(type.returnType)}`\n}\n\nexport function renderArgumentType(arg: USSFunctionArgType): string {\n    if (arg.type === 'concrete') {\n        return renderType(arg.value)\n    }\n    return 'any'\n}\n\nexport function renderKwargType(arg: { type: USSFunctionArgType, defaultValue?: UrbanStatsASTExpression }): string {\n    const type = renderArgumentType(arg.type)\n    if (arg.defaultValue !== undefined) {\n        return `${type} = ${unparse(arg.defaultValue)}`\n    }\n    return type\n}\n\nfunction renderReturnType(ret: USSFunctionReturnType): string {\n    if (ret.type === 'concrete') {\n        return renderType(ret.value)\n    }\n    return 'any'\n}\n\nexport type ValueArg = (\n    { type: 'unnamed', value: USSValue } |\n    { type: 'named', name: string, value: USSValue }\n)\n\nexport function getPrimitiveType(value: USSRawValue, depth: number = 0): USSType {\n    if (depth === 0) {\n        if (typeof value === 'number') {\n            return { type: 'number' }\n        }\n        if (typeof value === 'string') {\n            return { type: 'string' }\n        }\n        if (typeof value === 'boolean') {\n            return { type: 'boolean' }\n        }\n        if (value === null) {\n            return { type: 'null' }\n        }\n    }\n    assert(Array.isArray(value), `Expected a primitive value, but got ${typeof value}`)\n    return getPrimitiveType(value[0], depth - 1)\n}\n\nexport function unifyType(\n    a: USSType | { type: 'elementOfEmptyVector' },\n    b: USSType | { type: 'elementOfEmptyVector' },\n    error: () => Error,\n): USSType | { type: 'elementOfEmptyVector' } {\n    if (a.type === 'elementOfEmptyVector') {\n        return b\n    }\n    if (b.type === 'elementOfEmptyVector') {\n        return a\n    }\n    if (renderType(a) === renderType(b)) {\n        return a\n    }\n    if (a.type === 'vector' && b.type === 'vector') {\n        return {\n            type: 'vector',\n            elementType: unifyType(a.elementType, b.elementType, error),\n        }\n    }\n    if (a.type === 'object' && b.type === 'object') {\n        if (JSON.stringify([...a.properties.keys()].sort()) !== JSON.stringify([...b.properties.keys()].sort())) {\n            throw error()\n        }\n        const properties = new Map<string, USSType>()\n        for (const [key, type] of a.properties) {\n            properties.set(key, type)\n        }\n        for (const [key, type] of b.properties) {\n            const res = unifyType(properties.get(key)!, type, error)\n            assert(res.type !== 'elementOfEmptyVector', `Unreachable`)\n            properties.set(key, res)\n        }\n        return {\n            type: 'object',\n            properties,\n        }\n    }\n    throw error()\n}\n\nexport function renderValue(input: USSValue): string {\n    function helper(value: USSValue, indent: string): string {\n        const type = value.type\n        switch (type.type) {\n            case 'boolean':\n            case 'null':\n            case 'number':\n                return `${value.value}`\n            case 'string':\n                return `\"${value.value}\"`\n            case 'opaque':\n                const opaqueValue = value.value as USSOpaqueValue\n                switch (opaqueValue.opaqueType) {\n                    case 'scale':\n                    case 'pMap':\n                    case 'cMap':\n                    case 'cMapRGB':\n                    case 'basemap':\n                    case 'inset':\n                    case 'insets':\n                    case 'geoFeatureHandle':\n                    case 'geoCentroidHandle':\n                    case 'unit':\n                        return `[${opaqueValue.opaqueType} object]`\n                    case 'color':\n                        const colorValue = opaqueValue.value as { r: number, g: number, b: number, a: number }\n                        if (colorValue.a === 255) {\n                            return `rgb(${colorValue.r / 255}, ${colorValue.g / 255}, ${colorValue.b / 255})`\n                        }\n                        else {\n                            return `rgb(${colorValue.r / 255}, ${colorValue.g / 255}, ${colorValue.b / 255}, a=${colorValue.a / 255})`\n                        }\n                    case 'outline':\n                        const outline = opaqueValue.value as { color: { r: number, g: number, b: number, a: number }, weight: number }\n                        const outlineColor = outline.color\n                        if (outlineColor.a === 255) {\n                            return `constructOutline(color=rgb(${outlineColor.r / 255}, ${outlineColor.g / 255}, ${outlineColor.b / 255}), weight=${outline.weight})`\n                        }\n                        else {\n                            return `constructOutline(color=rgb(${outlineColor.r / 255}, ${outlineColor.g / 255}, ${outlineColor.b / 255}, a=${outlineColor.a / 255}), weight=${outline.weight})`\n                        }\n                    case 'ramp':\n                        const ramp = opaqueValue.value\n                        const rampValue = ramp.map(\n                            ([position, color]) => {\n                                const contents: [string, USSRawValue][] = [\n                                        ['value', position] satisfies [string, USSRawValue],\n                                        ['color', { type: 'opaque', opaqueType: 'color', value: hexToColor(color) }] satisfies [string, USSRawValue],\n                                ] satisfies [string, USSRawValue][]\n                                return new Map(contents) satisfies Map<string, USSRawValue>\n                            },\n                        )\n                        const interior = undocValue(rampValue,\n                            {\n                                type: 'vector',\n                                elementType: {\n                                    type: 'object',\n                                    properties: new Map([\n                                        ['value', { type: 'number' }],\n                                        ['color', { type: 'opaque', name: 'color' }],\n                                    ]),\n                                },\n                            },\n                        )\n                        return `[ramp ${renderValue(interior)}]`\n                }\n            case 'vector':\n                const vector = value.value as USSRawValue[]\n                if (vector.length === 0) {\n                    return `[]`\n                }\n                // USSType assertion is OK since we handle zero-length vectors above\n                return `[\n${vector.map(element => `${indent}    ${helper(undocValue(element, type.elementType as USSType), `${indent}    `)}`).join(',\\n')}\n${indent}]`\n            case 'object':\n                const map = value.value as Map<string, USSRawValue>\n                if (map.size === 0) {\n                    return `{}`\n                }\n                return `{\n${Array.from(map.entries()).map(([key, element]) => `${indent}    ${key}: ${helper(undocValue(element, type.properties.get(key)!), `${indent}    `)}`).join(',\\n')}\n${indent}}`\n            case 'function':\n                return renderType(type)\n        }\n    }\n    return helper(input, '')\n}\n\nexport function canUnifyTo(a: USSType, b: USSType): boolean {\n    // returns true iff a can be used in a context where b is expected\n    if (renderType(a) === renderType(b)) {\n        return true\n    }\n    // at this point, the types are different\n    switch (b.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'null':\n        case 'opaque':\n            // these are all primitive types, so no way to substitute them\n            return false\n        case 'vector':\n            assert(b.elementType.type !== 'elementOfEmptyVector', `Unreachable`)\n            return canUnifyTo(a, b.elementType)\n        case 'object':\n            if (a.type !== 'object') {\n                return false\n            }\n            if (a.properties.size !== b.properties.size) {\n                return false\n            }\n            if (![...a.properties.keys()].every(key => b.properties.has(key))) {\n                return false\n            }\n            return [...a.properties.keys()].every(key => canUnifyTo(a.properties.get(key)!, b.properties.get(key)!))\n        case 'function':\n            return false\n    }\n}\n","import { emptyContext } from '../../unit/urban-stats-script-utils'\nimport { Inset, Insets } from '../components/map'\nimport insets from '../data/insets'\nimport validGeographies from '../data/mapper/used_geographies'\nimport statistic_path_list from '../data/statistic_path_list'\nimport statistic_variables_info from '../data/statistic_variables_info'\nimport { loadOrderingDataProtobuf, loadProtobuf } from '../load_json'\nimport { mapperContext, defaultTypeEnvironment } from '../mapper/context'\nimport { indexLink } from '../navigation/links'\nimport { Universe } from '../universe'\nimport { assert } from '../utils/defensive'\n\nimport { locationOfLastExpression, UrbanStatsASTExpression } from './ast'\nimport { insetNameToConstantName } from './constants/insets'\nimport { Context } from './context'\nimport { EditorError } from './editor-utils'\nimport { Effect, execute, InterpretationError } from './interpreter'\nimport { noLocation } from './location'\nimport { renderType, USSRawValue, USSValue } from './types-values'\nimport { USSExecutionRequest, USSExecutionResult } from './workerManager'\n\nlet mapperCache: {\n    universe: Universe\n    geographyKind: typeof validGeographies[number]\n    longnames: string[]\n    dataCache: Map<string, number[]>\n} | undefined\n\nasync function executeRequest(request: USSExecutionRequest): Promise<USSExecutionResult> {\n    let context, getWarnings\n    try {\n        ([context, getWarnings] = await contextForRequest(request))\n        const result = execute(request.stmts, context)\n\n        switch (request.descriptor.kind) {\n            case 'generic': {\n                break\n            }\n            case 'mapper': {\n                // no idea why we need this, but it's obviously correct from the switch\n                if (renderType(result.type) !== 'cMap' && renderType(result.type) !== 'cMapRGB' && renderType(result.type) !== 'pMap') {\n                    throw new InterpretationError(`USS expression did not return a cMap, cMapRGB, or pMap type, got: ${renderType(result.type)}`, locationOfLastExpression(request.stmts))\n                }\n                break\n            }\n        }\n        return {\n            resultingValue: { type: result.type, value: removeFunctions(result.value) },\n            error: getWarnings(),\n            context: new Map([...context.variableEntries()].filter(([,v]) => v.documentation?.includedInOutputContext)),\n        }\n    }\n    catch (error) {\n        let interpretationError: InterpretationError\n        if (error instanceof InterpretationError) {\n            interpretationError = error\n        }\n        else {\n            console.error('Unknown interpretation error', error)\n            interpretationError = new InterpretationError('Unknown interpretation error', noLocation)\n        }\n        return {\n            error: [{ type: 'error', value: interpretationError.value, location: interpretationError.location, kind: 'error' }, ...(getWarnings?.() ?? [])],\n            context: new Map(),\n        }\n    }\n}\n\nasync function contextForRequest(request: USSExecutionRequest): Promise<[Context, () => EditorError[]]> {\n    const effects: Effect[] = []\n    const getWarnings = (): EditorError[] => {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- just so if there's additonal types, we're safe\n        return effects.filter(eff => eff.type === 'warning').map(eff => ({\n            type: 'error',\n            value: eff.message,\n            location: eff.location,\n            kind: 'warning',\n        }))\n    }\n    switch (request.descriptor.kind) {\n        case 'generic':\n            return [emptyContext(effects), getWarnings]\n        case 'mapper':\n            return [await mapperContextForRequest(request as USSExecutionRequest & { descriptor: { kind: 'mapper' } }, effects), getWarnings]\n    }\n}\n\nasync function mapperContextForRequest(request: USSExecutionRequest & { descriptor: { kind: 'mapper' } }, effects: Effect[]): Promise<Context> {\n    const geographyKind = request.descriptor.geographyKind\n    const universe = request.descriptor.universe\n    const dte = defaultTypeEnvironment(universe)\n    if (!validGeographies.includes(geographyKind)) {\n        throw new Error('invalid geography')\n    }\n\n    // Load geography names and set up cache\n    let longnames: string[]\n\n    if (mapperCache?.geographyKind === geographyKind && mapperCache.universe === universe) {\n        longnames = mapperCache.longnames\n    }\n    else {\n        // Load geography names from index\n        const indexData = await loadProtobuf(indexLink(universe, geographyKind), 'ArticleOrderingList')\n        longnames = indexData.longnames\n        mapperCache = {\n            universe,\n            geographyKind,\n            longnames,\n            dataCache: new Map(),\n        }\n    }\n\n    const annotateType = (name: string, val: USSRawValue): USSValue => {\n        const typeInfo = dte.get(name)\n        assert(typeInfo !== undefined, `Type info for ${name} not found`)\n        return {\n            type: typeInfo.type,\n            documentation: typeInfo.documentation,\n            value: val,\n        }\n    }\n\n    const getVariable = async (name: string): Promise<USSValue | undefined> => {\n        assert(mapperCache !== undefined, 'mapperCache was initialized above and is never undefined after that')\n        if (name === 'geoName') {\n            return annotateType('geoName', longnames)\n        }\n        if (name === 'geo') {\n            return annotateType('geo', longnames.map(longname => ({ type: 'opaque', opaqueType: 'geoFeatureHandle', value: longname })))\n        }\n        if (name === 'geoCentroid') {\n            return annotateType('geoCentroid', longnames.map(longname => ({ type: 'opaque', opaqueType: 'geoCentroidHandle', value: longname })))\n        }\n        if (name === 'defaultInsets') {\n            return annotateType('defaultInsets', { type: 'opaque', opaqueType: 'insets', value: loadInset(request.descriptor.universe) })\n        }\n        const variableInfo = statistic_variables_info.variableNames.find(v => v.varName === name)\n        if (!variableInfo) {\n            return undefined\n        }\n        const index = variableInfo.index\n\n        // Check cache first\n        const existing = mapperCache.dataCache.get(name)\n        if (existing !== undefined) {\n            return annotateType(name, existing)\n        }\n\n        const statpath = statistic_path_list[index]\n\n        const variableData = await loadOrderingDataProtobuf(universe, statpath, geographyKind)\n        assert(Array.isArray(variableData.value), `Expected variable data for ${name} to be an array`)\n        mapperCache.dataCache.set(name, variableData.value)\n        return annotateType(name, variableData.value)\n    }\n\n    const context = await mapperContext(request.stmts, getVariable, effects, universe)\n    return context\n}\n\nfunction removeFunctions(value: USSRawValue): USSRawValue {\n    if (value instanceof Function) {\n        return null\n    }\n    else if (Array.isArray(value)) {\n        return value.map(removeFunctions)\n    }\n    else if (value instanceof Map) {\n        return new Map(Array.from(value.entries()).map(([k, v]) => [k, removeFunctions(v)]))\n    }\n    else if (value instanceof Object && value.value instanceof Function) {\n        assert(value.opaqueType === 'scale', 'only scales can have functions in their value')\n        return null\n    }\n    return value\n}\n\nonmessage = async (message: MessageEvent<{ request: USSExecutionRequest, id: number }>) => {\n    if (!('request' in message.data)) {\n        // Some other message (e.g. from React devtools)\n        return\n    }\n    const result = await executeRequest(message.data.request)\n    postMessage({ result, id: message.data.id })\n}\n\nexport function loadInset(universe: Universe): Insets {\n    const insetsU = insets[universe]\n    assert(insetsU.length > 0, `No insets for universe ${universe}`)\n    assert(insetsU[0].mainMap, `No main map for universe ${universe}`)\n    const insetsProc = insetsU.map((inset) => {\n        return {\n            bottomLeft: [inset.bottomLeft[0], inset.bottomLeft[1]],\n            topRight: [inset.topRight[0], inset.topRight[1]],\n            // copy to get rid of readonly\n            coordBox: [...inset.coordBox],\n            mainMap: inset.mainMap,\n        } satisfies Inset\n    })\n    return insetsProc\n}\n\nexport function loadInsetExpression(universe: Universe): UrbanStatsASTExpression {\n    const insetsU = insets[universe]\n    const names = insetsU.map(x => x.name)\n\n    const exprs = names.map((name) => {\n        const expr = insetNameToConstantName.get(name)\n        assert(expr !== undefined, `No inset constant for ${name}`)\n        return { type: 'identifier', name: { node: expr, location: noLocation } } satisfies UrbanStatsASTExpression\n    })\n\n    return {\n        type: 'call',\n        fn: { type: 'identifier', name: { node: 'constructInsets', location: noLocation } },\n        args: [{\n            type: 'unnamed',\n            value: {\n                type: 'vectorLiteral',\n                elements: exprs,\n                entireLoc: noLocation,\n            } satisfies UrbanStatsASTExpression,\n        }],\n        entireLoc: noLocation,\n    } satisfies UrbanStatsASTExpression\n}\n","export interface ReadonlyDefaultMap<K, V> extends ReadonlyMap<K, V> {\n    get: (key: K) => V\n}\n\nexport class DefaultMap<K, V> extends Map<K, V> implements ReadonlyDefaultMap<K, V> {\n    override get(key: K): V {\n        let result = super.get(key)\n        if (result === undefined) {\n            result = this.makeDefault(key)\n            this.set(key, result)\n        }\n        return result\n    }\n\n    constructor(private readonly makeDefault: (key: K) => V) {\n        super()\n    }\n}\n","import type_ordering_idx from '../data/type_ordering_idx'\n\nconst historicalCongressionals = Object.keys(type_ordering_idx).filter(\n    key => key.startsWith('Congressional District ('),\n)\nconst historicalCongressionalsIdx = historicalCongressionals.map(\n    key => type_ordering_idx[key],\n)\n\nexport function isHistoricalCD(typeOrTypeIndex: number | string): boolean {\n    if (typeof typeOrTypeIndex === 'string') {\n        return historicalCongressionals.includes(typeOrTypeIndex)\n    }\n    return historicalCongressionalsIdx.includes(typeOrTypeIndex)\n}\n","// getDefaultExport function for compatibility with non-ESM modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};\n","__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(\n\t\tObject.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t\t__webpack_require__.f[key](chunkId, promises);\n\t\t\treturn promises;\n\t\t}, [])\n\t);\n};","// This function allow to reference chunks\n__webpack_require__.u = (chunkId) => {\n  // return url for filenames not based on template\n  \n  // return url for filenames based on template\n  return \"\" + chunkId + \".js\"\n}","__webpack_require__.g = (() => {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n  module.paths = [];\n  if (!module.children) module.children = [];\n  return module;\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif (chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor (var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--)\n\t\t\tdeferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif (\n\t\t\t\t(priority & (1 === 0) || notFulfilled >= priority) &&\n\t\t\t\tObject.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))\n\t\t\t) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif (priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif (fulfilled) {\n\t\t\tdeferred.splice(i--, 1);\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};\n","__webpack_require__.rv = () => (\"1.3.15\")","var next = __webpack_require__.x\n__webpack_require__.x = () => {\n  return Promise.all([\"141\",\"90\",\"856\",\"680\",\"427\"].map(__webpack_require__.e, __webpack_require__)).then(next);\n}","var scriptUrl;\n\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n  // Technically we could use `document.currentScript instanceof window.HTMLScriptElement`,\n  // but an attacker could try to inject `<script>HTMLScriptElement = HTMLImageElement</script>`\n  // and use `<img name=\"currentScript\" src=\"https://attacker.controlled.server/\"></img>`\n  if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT') scriptUrl = document.currentScript.src;\n  if (!scriptUrl) {\n    var scripts = document.getElementsByTagName(\"script\");\n    if (scripts.length) {\n      var i = scripts.length - 1;\n      while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n    }\n  }\n}\n\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\",\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.',\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl","var installedChunks = {\"438\": 1,};\n// importScripts chunk loading\nvar installChunk = (data) => {\n    var [chunkIds, moreModules, runtime] = data;\n    for (var moduleId in moreModules) {\n        if (__webpack_require__.o(moreModules, moduleId)) {\n            __webpack_require__.m[moduleId] = moreModules[moduleId];\n        }\n    }\n    if (runtime) runtime(__webpack_require__);\n    while (chunkIds.length) installedChunks[chunkIds.pop()] = 1;\n    parentChunkLoadingFunction(data);\n};\n\n__webpack_require__.f.i = (chunkId, promises) => {\n    \n          // \"1\" is the signal for \"already loaded\n          if (!installedChunks[chunkId]) {\n            if (true) {\n              importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n            }\n          }\n          \n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkassets\"] = self[\"webpackChunkassets\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;","__webpack_require__.ruid = \"bundler=rspack@1.3.15\";\n"],"names":["loadProtobuf","filePath","name","errorOnMissing","perfCheckpoint","response","compressedBuffer","arr","result","performance","fetch","undefined","Error","debugPerformance","Uint8Array","gunzipSync","Buffer","Article","Feature","ArticleOrderingList","OrderLists","DataLists","ConsolidatedShapes","SearchIndex","QuizQuestionTronche","QuizFullData","CountsByArticleUniverseAndType","Symlinks","PointSeries","ArticleUniverseList","loadOrderingDataProtobuf","universe","statpath","type","links","idx","dataLists","index","res","universeIdx","universes","data_links","pullKey","key","statistic_path_list","current","i","orderingDataLink","universes_ordered","_","_universes_universes_i_universeIdxs","universeIndex","indexLink","typ","encodeURIComponent","sanitize","longname","spaces_around_slash","x","Object","type_ordering_idx","k","v","arg","weights","sumOfWeights","total","value","locationOfLastExpression","node","locationOf","assert","unify","_key","locations","startLine","min","loc","Math","Number","endLine","max","startCol","endCol","startChar","endChar","colorType","rgb","createConstantExpression","ctx","posArgs","namedArgs","alpha","rgbToColor","red","green","blue","tolerateError","r","g","b","a","hsv","hsvToColor","hue","saturation","color","ColorLib","renderColor","doRender","ignoreAlpha","hex","hexValue","h","drawFunction","functionName","param1","param2","param3","round","format","num","alphaPart","rgbColorExpression","_ref","forceAlpha","colorConstant","isDefault","humanReadableName","camelToHuman","capitalizedName","hexToColor","parseNoErrorAsExpression","hsvColorExpression","c","colorConstants","hueColors","insetType","insetsType","boundsType","Map","constructInsetValue","screenBounds","mapBounds","screenBoundsObj","mapBoundsObj","mainMap","constructInsetsValue","insetsList","item","computeInsetConstantName","insetConsts","insets","regionInsets","inset","uss","insetName","insetNameToConstantName","scaleType","linearScale","values","center","isNaN","isFinite","_Math","_Math1","computedMin","computedMax","range","linearScaleValue","logScaleValue","_effect","_error","_constants","_variables","Context","effect","error","constants","variables","_iteratorError","eff","msg","location","getVariable","assignVariable","variableEntries","evolveVariables","InterpretationError","message","renderLocInfo","p","evaluate","expr","env","undocValue","varName","lookupResult","attrLookupOrSet","func","args","broadcastResult","broadcastCall","evaluateUnaryOperator","operand","operator","errLoc","operatorObj","expressionOperatorMap","broadcastApply","evaluateBinaryOperator","left","right","elements","e","elementType","unifyType","JSON","renderType","ts","vs","_iteratorError1","condition","splitMask","subEnv","execute","doResult","_iteratorError2","statement","t","canUnifyTo","evaluateLHS","lhs","err","obj","attr","orSet","val","_instanceof","_type_of","aT","content","val1","Array","orSetLookp","addAdditionalDims","resultsOrErr","results","rawValue","nonExpressionOperators","operatorCharacters","keywords","isDigit","ch","isAlpha","parseNumber","input","parseFloat","component","component1","identifierLexer","string","operatorLexer","lex","block","tokens","lines","charIdx","line","lineTokens","lexLine","lineNo","charIdxOffset","char","token","token1","lexNumber","match","numberFormat","numberStr","number","_iter","lexer","token2","lexGeneric","start","token3","lexString","resultObj","_tokens","noLocation","unparse","opts","isSimpleExpression","indentSpaces","level","_opts_expressionalContext","_opts_indent","exprStr","fnStr","argsStr","fnNeedsParens","unaryExprStr","needsParens","exprWithParens","_expressionOperatorMap_get_precedence","_expressionOperatorMap_get_precedence1","_expressionOperatorMap_get_precedence2","leftStr","rightStr","opPrecedence","leftWithParens","leftOpPrecedence","rightWithParens","rightOpPrecedence","elementsStr","elem","propertiesStr","valueStr","lhsStr","statementsStr","stmt","s","conditionStr","thenStr","ifStr","elseStr","doStr","condStr","restStr","ParseState","skipEOL","consumeTokenOfType","consumeOperator","oneOfOps","consumeBracket","oneOfBrackets","consumeIdentifier","consumeKeyword","oneOfKeywords","maybeLastNonEOLToken","offset","parseSingleExpression","startLoc","properties","keyToken","endLoc","vectorStartLoc","element","vectorEndLoc","parseArg","exprOrName","parseParenthesizedArgs","parseFunctionalExpression","fn","done","parseExpression","operatorExpSequence","state","loop","unaryOperators","infixOperators","operator1","parseInfixSequence","precedences","maxPrecedence","resolveOperator","next","checkLHS","parseStatement","parseIfExpression","ifToken","then","elseBranch","eb","lastToken","parseDoExpression","doToken","statements","parseConditionStatement","conditionToken","parseStatements","canEnd","end","errMsg","mergeStatements","fallbackLocation","gulpRestForConditions","_stmt_rest","entireLoc","parseCustomNodeExpression","argsRes","_argsRes_args","locArg","code","parseResult","parse","returnParseErrorNode","parseTokens","originalCode","lexErrors","errors","stmts","identifiersInExpr","expressions","identifiers","Set","allExpressions","helper","n","allIdentifiers","newIdentifiers","id","_ctx_getVariable","dv","newId","blockId","getPrimitiveType","depth","key1","type1","unifyFunctionType","param","ret","renderArgumentType","renderReturnType","renderKwargType","mapperCache","loadInsetExpression","exprs","names","insetsU","onmessage","request","context","getWarnings","interpretationError","_getWarnings","effects","emptyContext","geographyKind","dte","longnames","annotateType","defaultTypeEnvironment","validGeographies","indexData","typeInfo","variableInfo","existing","variableData","statistic_variables_info","mapperContext","removeFunctions","Function","_v_documentation","console","postMessage","historicalCongressionals","Promise","globalThis","window","importScripts","self"],"mappings":"iEAq9BA,MAr9BwC,CACpC,oBAAqB,CACjB,IACA,IACA,IACA,GACH,CACD,oBAAqB,CACjB,IACA,IACH,CACD,mBAAoB,CAChB,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,qBAAsB,CAClB,IACA,GACH,CACD,wBAAyB,CACrB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,uBAAwB,CACpB,GACA,GACA,GACA,GACA,GACH,CACD,YAAa,CACT,IACA,IACH,CACD,IAAO,CACH,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,KAAQ,CACJ,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,yBAA0B,CACtB,IACA,IACH,CACD,iCAAkC,CAC9B,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACH,CACD,iCAAkC,CAC9B,IACA,IACH,CACD,iCAAkC,CAC9B,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,IACA,EACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,GACA,GACA,GACA,GACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,IACA,EACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,OAAU,CACN,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,kBAAmB,CACf,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,EACH,CACD,2BAA4B,CACxB,IACA,IACH,CACD,wBAAyB,CACrB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,IAAO,CACH,GACA,GACA,GACA,GACA,GACH,CACD,uBAAwB,CACpB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,cAAe,CACX,IACA,IACH,CACD,0BAA2B,CACvB,IACA,GACH,CACD,qBAAsB,CAClB,IACA,IACA,GACH,CACD,aAAgB,CACZ,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,kBAAmB,CACf,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,uBAAwB,CACpB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,wBAAyB,CACrB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,qBAAsB,CAClB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,aAAc,CACV,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,eAAgB,CACZ,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,IAAO,CACH,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,AACL,C,yCCp9BA,MAAe,CACX,KAAQ,UACR,OAAU,UACV,MAAS,UACT,OAAU,UACV,IAAO,UACP,KAAQ,UACR,SAAY,UACZ,KAAQ,UACR,OAAU,UACV,MAAS,UACT,KAAQ,SACZ,C,yCCZA,MAAe,CACX,oCACA,yBACA,oCACA,yBACA,oCACA,yBACA,oCACA,yBACA,oCACA,kBACA,cACA,eACA,eACA,gBACA,YACA,gBACA,mBACA,kBACA,aACA,iBACA,eACA,iBACA,mBACA,cACA,gBACA,kBACA,eACA,YACA,iBACA,gBACA,cACA,iBACA,cACA,eACA,eACA,UACA,eACA,eACA,sBACA,sBACA,SACA,cACA,cACA,qBACA,qBACA,OACA,cACA,mBACA,mBACA,0BACA,0BACA,QACA,aACA,aACA,oBACA,oBACA,YACA,YACA,mBACA,mBACA,OACA,YACA,YACA,mBACA,mBACA,QACA,aACA,aACA,oBACA,oBACA,OACA,YACA,YACA,mBACA,mBACA,QACA,aACA,aACA,oBACA,oBACA,OACA,YACA,YACA,mBACA,mBACA,OACA,QACA,aACA,aACA,oBACA,0BACA,sBACA,QACA,aACA,aACA,+BACA,wCACA,0BACA,cACA,kBACA,kBACA,2BACA,0BACA,wBACA,yBACA,8BACA,6BACA,kCACA,4BACA,2BACA,2BACA,4BACA,2BACA,4BACA,2BACA,2BACA,6BACA,uBACA,iBACA,wBACA,wBACA,+BACA,kBACA,yBACA,oBACA,kBACA,qBACA,oBACA,2BACA,sBACA,6BACA,kBACA,yBACA,kBACA,yBACA,uBACA,8BACA,oBACA,2BACA,iBACA,iBACA,mBACA,0BACA,oBACA,mBACA,oBACA,mBACA,oBACA,mBACA,oBACA,oBACA,cACA,mBACA,mBACA,8BACA,sBACA,4BACA,aACA,gBACA,sBACA,WACA,gBACA,gBACA,uBACA,uBACA,uBACA,4BACA,4BACA,gBACA,gCACA,+BACA,iCACA,6BACA,+BACA,6BACA,kBACA,uBACA,uBACA,iCACA,gCACA,kCACA,8BACA,gCACA,8BACA,2CACA,kDACA,oEACA,2EACA,sDACA,6DACA,+CACA,sDACA,wBACA,+BACA,gCACA,uCACA,iCACA,wCACA,6CACA,oDACA,uBACA,8BACA,mDACA,0DACA,yBACA,gCACA,yDACA,gEACA,wDACA,+DACA,4DACA,mEACA,iCACA,wCACA,8CACA,qDACA,wBACA,+BACA,0CACA,iDACA,qBACA,4BACA,2BACA,kCACA,0BACA,0BACA,6BACA,qBACA,wBACA,iBACA,mBACA,0BACA,yBACA,0BACA,4BACA,iBACA,uBACA,oBACA,2BACA,gCACA,uCACA,yBACA,gCACA,0CACA,4BACA,6BACA,kCACA,uBACA,yBACA,mBACA,qBACA,wBACA,qBACA,qBACA,qBACA,0BACA,0BACA,0BACA,gBACA,oBACA,oBACA,oBACA,oBACA,0BACA,SACA,cACA,cACA,sDACA,wEACA,uEACA,2DACA,sDACA,mDACA,qDACA,8DACA,wDACA,qGACA,8DACA,0FACA,kDACA,4CACA,+DACA,2DACA,+BACA,4DACA,oCACA,yCACA,2DACA,mDACA,oCACA,2CACA,wCACA,sBACA,2BACA,2BACA,sBACA,6BACA,kBACA,aACA,kBACA,kBACA,yBACA,yBACA,yBACA,qBACA,aACA,uBACA,qBACA,qBACA,uBACA,qBACA,qBACA,uBACA,sBACA,uBACA,mBACA,KACA,UACA,UACA,iBACA,0BACA,0BACA,0BACA,+BACA,+BACA,uBACA,uBACA,uBACA,4BACA,4BACA,aACA,aACA,gCACA,qCACA,aACA,+BACA,iCACA,4CACA,qCACA,gDACA,uCACA,8CACA,uCACA,8CACA,qCACA,4CACA,sCACA,6CACA,uCACA,8CACA,4BACA,2BACA,+BACA,4BACA,sCACA,UACA,eACA,eACA,+BACA,+BACA,yBACA,QACA,aACA,aACA,0BACA,kCACA,oBACA,qBACA,yBACA,6BACA,0BACA,0BACA,0BACA,0BACA,2BACH,A,wCCxXD,MAAe,CACX,QACA,SACA,OACA,SACA,gBACA,UACA,gBACA,UACA,uBACA,cACA,sBACA,WACA,UACA,UACA,SACA,YACA,UACA,YACA,QACA,aACA,yBACA,WACA,aACA,UACA,eACA,WACA,UACA,UACA,QACA,UACA,SACA,UACA,SACA,cACA,SACA,WACA,UACA,SACA,SACA,0BACA,mCACA,2BACA,QACA,cACA,cACA,eACA,QACA,WACA,QACA,WACA,aACA,OACA,aACA,mBACA,SACA,iBACA,UACA,WACA,UACA,WACA,qBACA,UACA,UACA,UACA,QACA,UACA,QACA,WACA,UACA,OACA,mBACA,aACA,gBACA,SACA,QACA,iBACA,UACA,UACA,WACA,QACA,YACA,YACA,aACA,SACA,oBACA,SACA,YACA,gBACA,SACA,WACA,UACA,QACA,UACA,YACA,UACA,SACA,cACA,QACA,OACA,OACA,UACA,QACA,SACA,UACA,SACA,QACA,QACA,aACA,WACA,WACA,UACA,wBACA,cACA,cACA,SACA,iBACA,aACA,OACA,UACA,cACA,gBACA,YACA,UACA,UACA,YACA,aACA,SACA,QACA,UACA,SACA,UACA,aACA,aACA,mBACA,kBACA,OACA,UACA,WACA,aACA,aACA,QACA,YACA,WACA,SACA,SACA,WACA,aACA,UACA,QACA,iBACA,UACA,YACA,cACA,SACA,QACA,QACA,OACA,cACA,OACA,SACA,OACA,mBACA,cACA,WACA,SACA,mBACA,qBACA,WACA,QACA,WACA,QACA,UACA,SACA,SACA,SACA,eACA,kBACA,aACA,QACA,SACA,YACA,+CACA,WACA,WACA,eACA,aACA,UACA,UACA,WACA,cACA,iCACA,cACA,QACA,WACA,2BACA,OACA,OACA,WACA,aACA,UACA,aACA,eACA,UACA,QACA,SACA,sBACA,SACA,WACA,UACA,SACA,MACA,UACA,aACA,eACA,mCACA,YACA,yBACA,UACA,UACA,QACA,QACA,eACA,SACA,WACA,eACA,cACA,eACA,gBACA,kBACA,gBACA,mBACA,gBACA,eACA,eACA,cACA,aACA,gBACA,eACA,YACA,cACA,gBACA,iBACA,aACA,gBACA,qBACA,gBACA,iBACA,mBACA,gBACA,eACA,gBACA,cACA,qBACA,kBACA,kBACA,gBACA,sBACA,oBACA,YACA,gBACA,cACA,oBACA,oBACA,sBACA,oBACA,iBACA,aACA,YACA,eACA,gBACA,kBACA,qBACA,iBACA,eACA,sBACA,YACA,gCACA,mBACA,yBACA,4BACA,kBACA,2BACA,mBACA,wBACA,oCACA,gCACA,sBACA,kBACA,kBACA,+BACA,iBACA,uBACA,gBACH,A,2jDCrPM,SAAeA,EAAaC,CAAgB,CAAEC,CAAY,E,IAAEC,EAAAA,CAAAA,CAAAA,UAAAA,MAAAA,CAAAA,IAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,EAAAA,SAAAA,CAAAA,EAAAA,C,wBAC3DC,EAEEC,EAQAC,EAQAC,EA0BIC,E,iDA1CO,OAFbJ,EAAiBK,YAAY,GAAG,GAEnB,C,EAAMC,MAAMT,G,QAC7B,GAAII,AADEA,CAAAA,EAAW,UACJ,MAAM,CAAG,KAAOA,EAAS,MAAM,CAAG,IAAK,CAChD,GAAI,CAACF,EACD,MAAO,C,EAAAQ,O,AAEX,OAAM,AAAIC,MAAO,oCAAoDP,MAAAA,CAAjBJ,EAAS,UAA4BI,MAAAA,CAApBA,EAAS,MAAM,CAAC,MAAwB,OA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"}