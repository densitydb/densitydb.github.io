{"version":3,"file":"sharedUSSWorker.js","sources":["webpack://assets/./src/data/hueColors.ts","webpack://assets/./src/page_template/color-themes.ts","webpack://assets/./src/urban-stats-script/ast.ts","webpack://assets/./src/urban-stats-script/constants/color.ts","webpack://assets/./src/urban-stats-script/constants/insets.ts","webpack://assets/./src/urban-stats-script/constants/rich-text.ts","webpack://assets/./src/urban-stats-script/constants/scale.ts","webpack://assets/./src/urban-stats-script/constants/text-box.ts","webpack://assets/./src/urban-stats-script/lexer.ts","webpack://assets/./src/urban-stats-script/location.ts","webpack://assets/./src/urban-stats-script/parser.ts","webpack://assets/./src/urban-stats-script/types-values.ts","webpack://assets/./src/urban-stats-script/worker.ts","webpack://assets/./src/urban-stats-script/context.ts","webpack://assets/./src/urban-stats-script/forward-broadcasting.ts","webpack://assets/./src/urban-stats-script/split-broadcasting.ts","webpack://assets/./src/urban-stats-script/interpreter.ts","webpack://assets/./unit/urban-stats-script-utils.ts","webpack://assets/./src/data/mapper/used_geographies.ts","webpack://assets/./src/data/statistic_path_list.ts","webpack://assets/./src/data/data_links.ts","webpack://assets/./src/data/universes_ordered.ts","webpack://assets/./src/navigation/links.ts","webpack://assets/./src/search.ts","webpack://assets/./src/utils/DefaultMap.ts","webpack://assets/./src/utils/restricted-types.ts","webpack://assets/./src/load_json.ts","webpack://assets/./src/mapper/context.ts","webpack://assets/./src/utils/math.ts","webpack://assets/webpack/runtime/compat_get_default_export","webpack://assets/webpack/runtime/define_property_getters","webpack://assets/webpack/runtime/ensure_chunk","webpack://assets/webpack/runtime/get javascript chunk filename","webpack://assets/webpack/runtime/global","webpack://assets/webpack/runtime/has_own_property","webpack://assets/webpack/runtime/make_namespace_object","webpack://assets/webpack/runtime/node_module_decorator","webpack://assets/webpack/runtime/on_chunk_loaded","webpack://assets/webpack/runtime/rspack_version","webpack://assets/webpack/runtime/startup_chunk_dependencies","webpack://assets/webpack/runtime/auto_public_path","webpack://assets/webpack/runtime/import_scripts_chunk_loading","webpack://assets/webpack/runtime/rspack_unique_id"],"sourcesContent":["export default {\n    \"blue\": \"#5a7dc3\",\n    \"orange\": \"#f7aa41\",\n    \"brown\": \"#af6707\",\n    \"purple\": \"#975ac3\",\n    \"red\": \"#f96d6d\",\n    \"grey\": \"#8e8e8e\",\n    \"darkGrey\": \"#4e525a\",\n    \"pink\": \"#c767b0\",\n    \"yellow\": \"#b8a32f\",\n    \"green\": \"#8ac35a\",\n    \"cyan\": \"#07a5af\"\n} as const","import hueColors from '../data/hueColors'\n\nexport interface HueColors {\n    blue: string\n    orange: string\n    brown: string\n    purple: string\n    red: string\n    grey: string\n    darkGrey: string\n    pink: string\n    yellow: string\n    green: string\n    cyan: string\n}\n\nexport interface Colors {\n    background: string\n    cleanBackground: string\n    slightlyDifferentBackground: string\n    cleanSlightlyDifferentBackground: string\n    slightlyDifferentBackgroundFocused: string\n    highlight: string\n    textMain: string\n    textMainOpposite: string\n    textPointer: string\n    borderShadow: string\n    borderNonShadow: string\n    ordinalTextColor: string\n    unselectedButton: string\n    selectedButton: string\n    selectedButtonText: string\n    blueLink: string\n    mapInsetBorderColor: string\n    buttonTextWhite: string\n    bannerURL: string\n    mixPct: number\n    hueColors: HueColors\n    screenshotFooterUrl: string\n    pencilIcon: string\n    wikidataURL: string\n    mapperBannerURL: string\n}\n\nexport interface JuxtastatColors {\n    correct: string\n    incorrect: string\n    correctEmoji: string\n    incorrectEmoji: string\n    lifeEmoji: string\n    lifeLostEmoji: string\n}\n\nconst defaultHueColors: HueColors = hueColors\n\nexport type Theme = 'Light Mode' | 'Dark Mode'\n\n/* eslint-disable no-restricted-syntax -- Allowing hex colors for themes */\nexport const colorThemes: Record<Theme, Colors> = {\n    'Light Mode': {\n        background: '#fff8f0',\n        cleanBackground: '#ffffff',\n        slightlyDifferentBackground: '#f7f1e8',\n        cleanSlightlyDifferentBackground: '#faf7f2',\n        slightlyDifferentBackgroundFocused: '#ffe0e0',\n        highlight: '#d4b5e2',\n        textMain: '#000000',\n        textMainOpposite: '#ffffff',\n        textPointer: '#222222',\n        borderShadow: '#333333',\n        borderNonShadow: '#cccccc',\n        ordinalTextColor: '#444444',\n        unselectedButton: '#e6e9ef',\n        selectedButton: '#4e525a',\n        selectedButtonText: '#ffffff',\n        blueLink: '#22f',\n        mapInsetBorderColor: '#000000',\n        buttonTextWhite: '#ffffff',\n        bannerURL: '/banner.png',\n        mixPct: 70,\n        hueColors: defaultHueColors,\n        screenshotFooterUrl: 'screenshot_footer.svg',\n        pencilIcon: '/pencil-light.png',\n        wikidataURL: '/wikidata-light.svg',\n        mapperBannerURL: '/mapper-banner.png',\n    },\n    'Dark Mode': {\n        background: '#00060f',\n        cleanBackground: '#000000',\n        slightlyDifferentBackground: '#080e17',\n        cleanSlightlyDifferentBackground: '#080e17',\n        slightlyDifferentBackgroundFocused: '#3d2900',\n        highlight: '#3b1d49',\n        textMain: '#dddddd',\n        textMainOpposite: '#000000',\n        textPointer: '#dddddd',\n        borderShadow: '#cccccc',\n        borderNonShadow: '#333333',\n        ordinalTextColor: '#bbbbbb',\n        unselectedButton: '#303030',\n        selectedButton: '#a2a6ae',\n        selectedButtonText: '#000000',\n        blueLink: '#aaaaff',\n        mapInsetBorderColor: '#000000',\n        buttonTextWhite: '#ffffff',\n        bannerURL: '/banner-dark.png',\n        mixPct: 50,\n        hueColors: defaultHueColors,\n        screenshotFooterUrl: 'screenshot_footer_dark.svg',\n        pencilIcon: '/pencil-dark.png',\n        wikidataURL: '/wikidata-dark.svg',\n        mapperBannerURL: '/mapper-banner-dark.png',\n    },\n}\n/* eslint-enable no-restricted-syntax -- Allowing hex colors for themes */\n","import assert from 'assert'\n\nimport { LocInfo } from './location'\nimport { Decorated, ParseError } from './parser'\nimport { USSType } from './types-values'\n\nexport type UrbanStatsASTArg = (\n    { type: 'unnamed', value: UrbanStatsASTExpression } |\n    { type: 'named', name: Decorated<string>, value: UrbanStatsASTExpression })\n\nexport type UrbanStatsASTLHS = (\n    { type: 'identifier', name: Decorated<string> } |\n    { type: 'attribute', expr: UrbanStatsASTExpression, name: Decorated<string> })\n\nexport type UrbanStatsASTExpression = (\n    UrbanStatsASTLHS |\n    { type: 'constant', value: Decorated<{ type: 'number', value: number } | { type: 'string', value: string }> } |\n    { type: 'call', fn: UrbanStatsASTExpression, args: UrbanStatsASTArg[], entireLoc: LocInfo } |\n    { type: 'binaryOperator', operator: Decorated<string>, left: UrbanStatsASTExpression, right: UrbanStatsASTExpression } |\n    { type: 'unaryOperator', operator: Decorated<string>, expr: UrbanStatsASTExpression } |\n    { type: 'objectLiteral', entireLoc: LocInfo, properties: [string, UrbanStatsASTExpression][] } |\n    { type: 'vectorLiteral', entireLoc: LocInfo, elements: UrbanStatsASTExpression[] } |\n    { type: 'if', entireLoc: LocInfo, condition: UrbanStatsASTExpression, then: UrbanStatsASTStatement, else?: UrbanStatsASTStatement } |\n    { type: 'do', entireLoc: LocInfo, statements: UrbanStatsASTStatement[] } |\n    // for internal purposes only\n    { type: 'customNode', entireLoc: LocInfo, expr: UrbanStatsASTStatement, originalCode: string, expectedType?: USSType[] }\n)\n\nexport type UrbanStatsASTStatement = (\n    { type: 'assignment', lhs: UrbanStatsASTLHS, value: UrbanStatsASTExpression } |\n    { type: 'expression', value: UrbanStatsASTExpression } |\n    { type: 'statements', entireLoc: LocInfo, result: UrbanStatsASTStatement[] } |\n    { type: 'condition', entireLoc: LocInfo, condition: UrbanStatsASTExpression, rest: UrbanStatsASTStatement[] } |\n    { type: 'parseError', originalCode: string, errors: ParseError[] })\n\nexport type UrbanStatsAST = UrbanStatsASTArg | UrbanStatsASTExpression | UrbanStatsASTStatement\n\nexport function unify(...locations: LocInfo[]): LocInfo {\n    assert(locations.length > 0, 'At least one location must be provided for unification')\n    const startLine = locations.reduce((min, loc) => Math.min(min, loc.start.lineIdx), Number.MAX_VALUE)\n    const endLine = locations.reduce((max, loc) => Math.max(max, loc.end.lineIdx), -Number.MAX_VALUE)\n    const startCol = locations.reduce((min, loc) => Math.min(min, loc.start.colIdx), Number.MAX_VALUE)\n    const endCol = locations.reduce((max, loc) => Math.max(max, loc.end.colIdx), -Number.MAX_VALUE)\n    const startChar = locations.reduce((min, loc) => Math.min(min, loc.start.charIdx), Number.MAX_VALUE)\n    const endChar = locations.reduce((max, loc) => Math.max(max, loc.end.charIdx), -Number.MAX_VALUE)\n    return {\n        start: { block: locations[0].start.block, lineIdx: startLine, colIdx: startCol, charIdx: startChar },\n        end: { block: locations[0].end.block, lineIdx: endLine, colIdx: endCol, charIdx: endChar },\n    }\n}\n\nexport function locationOf(node: UrbanStatsAST): LocInfo {\n    /* c8 ignore start -- This function doesn't need to be tested in detail, as it is a simple location extractor */\n    switch (node.type) {\n        case 'unnamed':\n            return locationOf(node.value)\n        case 'named':\n            return unify(node.name.location, locationOf(node.value))\n        case 'constant':\n            return node.value.location\n        case 'identifier':\n            return node.name.location\n        case 'attribute':\n            return unify(node.name.location, locationOf(node.expr))\n        case 'call':\n            return node.entireLoc\n        case 'unaryOperator':\n            return unify(node.operator.location, locationOf(node.expr))\n        case 'binaryOperator':\n            return unify(locationOf(node.left), locationOf(node.right), node.operator.location)\n        case 'objectLiteral':\n        case 'vectorLiteral':\n        case 'if':\n        case 'do':\n        case 'condition':\n        case 'statements':\n            return node.entireLoc\n        case 'assignment':\n            return unify(locationOf(node.lhs), locationOf(node.value))\n        case 'expression':\n            return locationOf(node.value)\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        case 'customNode':\n            return node.entireLoc\n    }\n    /* c8 ignore stop */\n}\n\nexport function locationOfLastExpression(node: UrbanStatsAST): LocInfo {\n    switch (node.type) {\n        case 'assignment':\n            return locationOf(node.value)\n        case 'statements':\n            return locationOfLastExpression(node.result[node.result.length - 1])\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        default:\n            return locationOf(node)\n    }\n}\n\nexport function getAllParseErrors(node: UrbanStatsAST): ParseError[] {\n    const errors: ParseError[] = []\n\n    function collectErrors(n: UrbanStatsAST): void {\n        switch (n.type) {\n            case 'unnamed':\n                collectErrors(n.value)\n                break\n            case 'named':\n                collectErrors(n.value)\n                break\n            case 'constant':\n            case 'identifier':\n                // No parse errors in these\n                break\n            case 'attribute':\n                collectErrors(n.expr)\n                break\n            case 'call':\n                collectErrors(n.fn)\n                n.args.forEach(collectErrors)\n                break\n            case 'unaryOperator':\n                collectErrors(n.expr)\n                break\n            case 'binaryOperator':\n                collectErrors(n.left)\n                collectErrors(n.right)\n                break\n            case 'objectLiteral':\n                n.properties.forEach(([, value]) => {\n                    collectErrors(value)\n                })\n                break\n            case 'vectorLiteral':\n                n.elements.forEach(collectErrors)\n                break\n            case 'if':\n                collectErrors(n.condition)\n                collectErrors(n.then)\n                if (n.else) {\n                    collectErrors(n.else)\n                }\n                break\n            case 'do':\n                n.statements.forEach(collectErrors)\n                break\n            case 'assignment':\n                collectErrors(n.lhs)\n                collectErrors(n.value)\n                break\n            case 'expression':\n                collectErrors(n.value)\n                break\n            case 'statements':\n                n.result.forEach(collectErrors)\n                break\n            case 'condition':\n                collectErrors(n.condition)\n                n.rest.forEach(collectErrors)\n                break\n            case 'parseError':\n                errors.push(...n.errors)\n                break\n            case 'customNode':\n                collectErrors(n.expr)\n                break\n        }\n    }\n\n    collectErrors(node)\n    return errors\n}\n\nexport function toStatement(node: UrbanStatsASTExpression | UrbanStatsASTStatement): UrbanStatsASTStatement {\n    switch (node.type) {\n        case 'statements':\n        case 'assignment':\n        case 'expression':\n        case 'condition':\n        case 'parseError':\n            return node\n        default:\n            return { type: 'expression', value: node }\n    }\n}\n","import hueColors from '../../data/hueColors'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue, createConstantExpression } from '../types-values'\n\nimport { Color, doRender, hexToColor, hsvColorExpression, rgbColorExpression } from './color-utils'\nimport { camelToHuman } from './utils'\n\nexport const colorType = { type: 'opaque', name: 'color' } satisfies USSType\n\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError: true): Color | undefined\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number): Color\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (red < 0 || red > 1 || green < 0 || green > 1 || blue < 0 || blue > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`RGB values must be between 0 and 1, got (${red}, ${green}, ${blue}, ${alpha})`)\n    }\n    return { r: red, g: green, b: blue, a: alpha }\n}\n\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError: true): Color | undefined\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number): Color\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (hue < 0 || hue > 360 || saturation < 0 || saturation > 1 || value < 0 || value > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`HSV values must be (hue: 0-360, saturation: 0-1, value: 0-1, alpha: 0-1), got (${hue}, ${saturation}, ${value}, ${alpha})`)\n    }\n    return {\n        h: hue,\n        s: saturation,\n        v: value,\n        a: alpha,\n    }\n}\n\nexport const rgb = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // red\n            { type: 'concrete', value: { type: 'number' } }, // green\n            { type: 'concrete', value: { type: 'number' } }, // blue\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: rgbToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (RGB)',\n        category: 'color',\n        namedArgs: { a: 'Alpha' },\n        longDescription: 'Creates a color using RGB (Red, Green, Blue) values. Each component ranges from 0 to 1, where 0 is no color and 1 is full intensity.',\n    },\n} satisfies USSValue\n\nexport const hsv = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // hue\n            { type: 'concrete', value: { type: 'number' } }, // saturation\n            { type: 'concrete', value: { type: 'number' } }, // value\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: hsvToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (HSV)',\n        category: 'color',\n        longDescription: 'Creates a color using HSV (Hue, Saturation, Value) values. Hue ranges from 0 to 360 degrees, saturation and value range from 0 to 1.',\n    },\n} satisfies USSValue\n\nexport const renderColor = {\n    type: {\n        type: 'function',\n        posArgs: [{ type: 'concrete', value: colorType }],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: { type: 'string' } },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): string => {\n        const color = (posArgs[0] as { type: 'opaque', value: { r: number, g: number, b: number, a: number } }).value\n        return doRender(color)\n    },\n    documentation: {\n        humanReadableName: 'Color to String',\n        category: 'color',\n        longDescription: 'Converts a color object to its hexadecimal string representation (e.g., \"#ff0000\" for red). If the alpha channel is not 255, it will be included in the string, e.g., \"#ff000088\" for red with 50% opacity.',\n    },\n} satisfies USSValue\n\nfunction colorConstant(name: string, value: string, isDefault?: boolean): [string, USSValue] {\n    const round = 3 // Min value that doesn't introduce error into hex expressions (with conversions)\n    const humanReadableName = camelToHuman(name)\n    const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1)\n    const color = hexToColor(value, round)\n    return [`color${capitalizedName}`, {\n        type: colorType,\n        value: { type: 'opaque', opaqueType: 'color', value: color },\n        documentation: {\n            humanReadableName,\n            category: 'color',\n            equivalentExpressions: [parseNoErrorAsExpression(rgbColorExpression(color, { round }), ''), parseNoErrorAsExpression(hsvColorExpression(color, { round }), '')],\n            isDefault,\n            longDescription: `Predefined color constant representing ${humanReadableName.toLowerCase()}.`,\n            documentationTable: 'predefined-colors',\n            selectorRendering: {\n                kind: 'gradientBackground',\n                ramp: [[0, value], [1, value]],\n            },\n        },\n    }] satisfies [string, USSValue]\n}\n\nexport const colorConstants = [\n    ...Object.entries(hueColors).map(([name, value]) => colorConstant(name, value)),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('white', '#ffffff'),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('black', '#000000', true),\n]\n","import { round } from 'mathjs'\n\nimport insets from '../../data/insets'\nimport { UrbanStatsASTExpression } from '../ast'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue } from '../types-values'\n\nexport interface Inset {\n    bottomLeft: [number, number]\n    topRight: [number, number]\n    coordBox: [number, number, number, number]\n    mainMap: boolean\n    name?: string\n}\n\nexport const insetType = {\n    type: 'opaque',\n    name: 'inset',\n} satisfies USSType\n\nexport const insetsType = {\n    type: 'opaque',\n    name: 'insets',\n} satisfies USSType\n\nexport const boundsType = {\n    type: 'object',\n    properties: new Map([\n        ['west', { type: 'number' }],\n        ['east', { type: 'number' }],\n        ['north', { type: 'number' }],\n        ['south', { type: 'number' }],\n    ]),\n} satisfies USSType\n\nexport function constructInset(\n    screenBounds: { west: number, east: number, north: number, south: number },\n    mapBounds: { west: number, east: number, north: number, south: number },\n    mainMap: boolean,\n    name?: string,\n): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'inset',\n        value: {\n            bottomLeft: [screenBounds.west, screenBounds.south],\n            topRight: [screenBounds.east, screenBounds.north],\n            coordBox: [mapBounds.west, mapBounds.south, mapBounds.east, mapBounds.north],\n            mainMap,\n            name,\n        } satisfies Inset & { name?: string },\n    }\n}\n\nexport function constructInsets(insetList: Inset[]): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'insets',\n        value: insetList,\n    }\n}\n\nexport const constructInsetValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            screenBounds: { type: { type: 'concrete', value: boundsType } },\n            mapBounds: { type: { type: 'concrete', value: boundsType } },\n            mainMap: { type: { type: 'concrete', value: { type: 'boolean' } } },\n            name: { type: { type: 'concrete', value: { type: 'string' } } },\n        },\n        returnType: { type: 'concrete', value: insetType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const screenBoundsObj = namedArgs.screenBounds as Map<string, USSRawValue>\n        const mapBoundsObj = namedArgs.mapBounds as Map<string, USSRawValue>\n        const mainMap = namedArgs.mainMap as boolean\n        const name = namedArgs.name as string\n        return constructInset(\n            {\n                west: screenBoundsObj.get('west') as number,\n                east: screenBoundsObj.get('east') as number,\n                north: screenBoundsObj.get('north') as number,\n                south: screenBoundsObj.get('south') as number,\n            },\n            {\n                west: mapBoundsObj.get('west') as number,\n                east: mapBoundsObj.get('east') as number,\n                north: mapBoundsObj.get('north') as number,\n                south: mapBoundsObj.get('south') as number,\n            },\n            mainMap,\n            name,\n        )\n    },\n    documentation: {\n        humanReadableName: 'Custom Inset',\n        category: 'inset',\n        longDescription: 'Creates a custom map inset with specified screen bounds (bounding box of the inset on the screen, where bottom left corner has (0, 0) and top right corner has (1, 1)), map bounds (bounding box of the inset on the map, in longitude and latitude), and whether it is the main map (the interactive map).',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructInsetsValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [\n            {\n                type: 'concrete',\n                value: {\n                    type: 'vector',\n                    elementType: insetType,\n                },\n            },\n        ],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: insetsType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const insetsList = posArgs[0] as { type: 'opaque', opaqueType: 'inset', value: Inset }[]\n        return constructInsets(insetsList.map(item => item.value))\n    },\n    documentation: {\n        humanReadableName: 'Custom Insets',\n        category: 'inset',\n        isDefault: true,\n        longDescription: 'Creates a collection of map insets.',\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nfunction computeInsetConstantName(name: string): string {\n    name = name.replace(/[\\s,().-]/g, '')\n    name = name.replaceAll('+', 'Plus')\n    name = `inset${name}`\n    return name\n}\n\nexport function deconstruct(inset: typeof insets[keyof typeof insets][number] | Inset): UrbanStatsASTExpression {\n    const uss = `constructInset(screenBounds={ north: ${round(inset.topRight[1], 3)}, east: ${round(inset.topRight[0], 3)}, south: ${round(inset.bottomLeft[1], 3)}, west: ${round(inset.bottomLeft[0], 3)} }, mapBounds={ north: ${round(inset.coordBox[3], 3)}, east: ${round(inset.coordBox[2], 3)}, south: ${round(inset.coordBox[1], 3)}, west: ${round(inset.coordBox[0], 3)} }, mainMap=${inset.mainMap}, name=\"${inset.name}\")`\n    return parseNoErrorAsExpression(uss, '')\n}\n\nexport const insetConsts: [string, USSValue][] = Object.entries(insets).flatMap(([, regionInsets]) =>\n    regionInsets.map((inset) => {\n        const insetName = inset.name\n        const constantName = computeInsetConstantName(insetName)\n\n        return [\n            constantName,\n            {\n                type: insetType,\n                value: {\n                    type: 'opaque',\n                    opaqueType: 'inset',\n                    value: {\n                        bottomLeft: [...inset.bottomLeft] as [number, number],\n                        topRight: [...inset.topRight] as [number, number],\n                        // copy to get rid of readonly\n                        coordBox: [...inset.coordBox] as [number, number, number, number],\n                        mainMap: inset.mainMap,\n                        name: inset.name,\n                    } satisfies Inset,\n                },\n                documentation: {\n                    humanReadableName: insetName,\n                    category: 'inset',\n                    equivalentExpressions: [deconstruct(inset)],\n                    longDescription: `Predefined map inset for the region \"${insetName}\".`,\n                    documentationTable: 'predefined-insets',\n                },\n            } satisfies USSValue,\n        ] as [string, USSValue]\n    }),\n)\n\nexport const insetNameToConstantName = new Map<string, string>(\n    Object.entries(insets).flatMap(([, regionInsets]) =>\n        regionInsets.map((inset) => {\n            const insetName = inset.name\n            return [insetName, computeInsetConstantName(insetName)]\n        }),\n    ),\n)\n","import { z } from 'zod'\n\nimport { RemoveOptionals, SwapKeysValues } from '../../utils/types'\nimport { Context } from '../context'\nimport { createConstantExpression, NamedFunctionArgumentWithDocumentation, USSRawValue, USSType, USSValue } from '../types-values'\n\nimport { colorType } from './color'\nimport { Color, hexToColor } from './color-utils'\n\nexport type RichTextDocument = RichTextSegment[]\n\nexport function documentLength(document: RichTextDocument): number {\n    return document.reduce((sum, segment) => sum + (typeof segment.insert === 'string' ? segment.insert.length : 1), 0)\n}\n\nconst colorSchema = z.string().transform((c) => {\n    try {\n        return hexToColor(c)\n    }\n    catch {\n        console.warn(`${c} is not a valid color`)\n        return undefined\n    }\n})\n\nexport const richTextAttributesSchema = z.object({\n    size: z.optional(z.string().transform((s) => {\n        if (!s.endsWith('px')) {\n            console.warn(`Font size ${s} does not end with \"px\"`)\n            return undefined\n        }\n        const pixels = s.slice(0, s.length - 2)\n        const result = parseFloat(pixels)\n        if (!isFinite(result)) {\n            console.warn(`Font pixels ${pixels} is not a valid number`)\n            return undefined\n        }\n        return result\n    })),\n    font: z.optional(z.string()),\n    // Sometimes when selecting a different colored formula along with text, color is an array. In that case, just take the first one\n    color: z.optional(z.union([colorSchema, z.array(colorSchema).transform(array => array.length === 0 ? undefined : array[0])])),\n    bold: z.optional(z.boolean()),\n    italic: z.optional(z.boolean()),\n    underline: z.optional(z.boolean()),\n    strike: z.optional(z.boolean()),\n    list: z.optional(z.union([z.literal('ordered'), z.literal('bullet'), z.literal('')])),\n    indent: z.optional(z.number()),\n    align: z.optional(z.enum(['', 'center', 'right', 'justify'])),\n})\n\nexport const richTextSegmentSchema = z.object({\n    insert: z.union([\n        z.string(),\n        z.object({ formula: z.string() }),\n        z.object({ image: z.string().refine(link => !link.startsWith('data:')) }), // Images must be linked, not enough room to store them in the url\n    ]),\n    attributes: z.optional(richTextAttributesSchema),\n})\n\nexport type RichTextSegment = z.infer<typeof richTextSegmentSchema>\n\nexport type RichTextAttributes = RemoveOptionals<RichTextSegment>['attributes']\n\nexport const richTextDocumentType = {\n    type: 'opaque',\n    name: 'richTextDocument',\n} satisfies USSType\n\nexport const richTextSegmentType = {\n    type: 'opaque',\n    name: 'richTextSegment',\n} satisfies USSType\n\nexport const constructRichTextDocumentValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'vector', elementType: richTextSegmentType } },\n        ],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: richTextDocumentType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        let segmentsList = (posArgs[0] as { type: 'opaque', opaqueType: 'richTextSegment', value: RichTextSegment }[]).map(({ value }) => value)\n        if (segmentsList.length === 0) {\n            segmentsList = [{ insert: '\\n' }] // bugs on applying attributes to empty text without this\n        }\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextDocument',\n            value: segmentsList,\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text Document',\n        category: 'richText',\n        longDescription: 'Creates a rich text document from a list of rich text segments.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const richTextListType = {\n    type: 'opaque',\n    name: 'richTextList',\n} satisfies USSType\n\nexport const richTextAlignType = {\n    type: 'opaque',\n    name: 'richTextAlign',\n} satisfies USSType\n\nconst attributesNamedArgs: { [K in keyof RemoveOptionals<RichTextSegment>['attributes']]-?: NamedFunctionArgumentWithDocumentation } = {\n    size: {\n        type: { type: 'concrete', value: { type: 'number' } },\n        defaultValue: createConstantExpression(null),\n    },\n    font: {\n        type: { type: 'concrete', value: { type: 'string' } },\n        defaultValue: createConstantExpression(null),\n    },\n    color: {\n        type: { type: 'concrete', value: colorType },\n        defaultValue: createConstantExpression(null),\n    },\n    bold: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    italic: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    underline: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    strike: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    list: {\n        type: { type: 'concrete', value: richTextListType },\n        defaultValue: createConstantExpression(null),\n    },\n    indent: {\n        type: { type: 'concrete', value: { type: 'number' } },\n        defaultValue: createConstantExpression(null),\n    },\n    align: {\n        type: { type: 'concrete', value: richTextAlignType },\n        defaultValue: createConstantExpression(null),\n    },\n}\n\nfunction attributesFromNamedArgs(namedArgs: Record<string, USSRawValue>): RichTextSegment['attributes'] {\n    const color = (namedArgs.color as ({ value: Color } | null))?.value\n\n    const entries = Object.entries({\n        size: (namedArgs.size as number | null) ?? undefined,\n        font: (namedArgs.font as string | null) ?? undefined,\n        color,\n        bold: (namedArgs.bold as boolean | null) ?? undefined,\n        italic: (namedArgs.italic as boolean | null) ?? undefined,\n        underline: (namedArgs.underline as boolean | null) ?? undefined,\n        list: (namedArgs.list as { value: RichTextAttributes['list'] } | null)?.value,\n        indent: (namedArgs.indent as number | null) ?? undefined,\n        align: (namedArgs.align as { value: RichTextAttributes['align'] } | null)?.value,\n        strike: (namedArgs.strike as boolean | null) ?? undefined,\n    }).filter(([, v]) => v !== undefined)\n\n    if (entries.length === 0) {\n        return undefined\n    }\n\n    return Object.fromEntries(entries)\n}\n\nconst richTextSegmentConstructorType: USSType = {\n    type: 'function',\n    posArgs: [\n        { type: 'concrete', value: { type: 'string' } },\n    ],\n    namedArgs: attributesNamedArgs,\n    returnType: { type: 'concrete', value: richTextSegmentType },\n}\n\nexport const constructRichTextStringSegmentValue: USSValue = {\n    type: richTextSegmentConstructorType,\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const text = posArgs[0] as string\n        const attributes = attributesFromNamedArgs(namedArgs)\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextSegment',\n            value: {\n                insert: text,\n                ...(attributes && { attributes }),\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text String Segment',\n        category: 'richText',\n        longDescription: 'Creates a rich text segment containing a plain string. The string can have optional formatting attributes.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructRichTextFormulaSegmentValue: USSValue = {\n    type: richTextSegmentConstructorType,\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const formula = posArgs[0] as string\n        const attributes = attributesFromNamedArgs(namedArgs)\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextSegment',\n            value: {\n                insert: { formula },\n                ...(attributes && { attributes }),\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text Formula Segment',\n        category: 'richText',\n        longDescription: 'Creates a rich text segment containing a formula. The formula is represented as a string and can have optional formatting attributes.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructRichTextImageSegmentValue: USSValue = {\n    type: richTextSegmentConstructorType,\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const image = posArgs[0] as string\n        const attributes = attributesFromNamedArgs(namedArgs)\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextSegment',\n            value: {\n                insert: { image },\n                ...(attributes && { attributes }),\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text Image Segment',\n        category: 'richText',\n        longDescription: 'Creates a rich text segment containing an image. The image is represented as a URL string and can have optional formatting attributes.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const alignIdentifierToValue = {\n    alignLeft: '',\n    alignCenter: 'center',\n    alignRight: 'right',\n    alignJustify: 'justify',\n} as const\n\nexport const alignValueToIdentifer: SwapKeysValues<typeof alignIdentifierToValue> = {\n    '': 'alignLeft',\n    'center': 'alignCenter',\n    'right': 'alignRight',\n    'justify': 'alignJustify',\n}\n\nfunction alignConstant(value: RichTextAttributes['align']): USSValue {\n    return {\n        type: richTextAlignType,\n        value: { type: 'opaque', opaqueType: 'richTextAlign', value },\n        documentation: {\n            humanReadableName: `Align ${value === '' ? 'Left' : value.charAt(0).toUpperCase() + value.slice(1)}`,\n            category: 'richText',\n            longDescription: `Specifies the alignment of the text as ${value === '' ? 'left' : value}.`,\n            selectorRendering: { kind: 'subtitleLongDescription' },\n            customConstructor: false,\n        },\n    }\n}\n\nexport const listIdentifierToValue = {\n    listOrdered: 'ordered',\n    listBullet: 'bullet',\n    listNone: '',\n} as const\n\nexport const listValueToIdentifier: SwapKeysValues<typeof listIdentifierToValue> = {\n    ordered: 'listOrdered',\n    bullet: 'listBullet',\n    ['']: 'listNone',\n}\n\nfunction listConstant(value: RichTextAttributes['list']): USSValue {\n    return {\n        type: richTextListType,\n        value: { type: 'opaque', opaqueType: 'richTextList', value },\n        documentation: {\n            humanReadableName: `List ${(value && value.charAt(0).toUpperCase() + value.slice(1)) || 'None'}`,\n            category: 'richText',\n            longDescription: `Specifies the list type as ${value || 'none'}.`,\n            selectorRendering: { kind: 'subtitleLongDescription' },\n            customConstructor: false,\n        },\n    }\n}\n\nexport const richTextConstants: [string, USSValue][] = [\n    ['rtfDocument', constructRichTextDocumentValue],\n    ['rtfString', constructRichTextStringSegmentValue],\n    ['rtfFormula', constructRichTextFormulaSegmentValue],\n    ['rtfImage', constructRichTextImageSegmentValue],\n    ...Object.entries(alignIdentifierToValue).map(([id, value]) => [id, alignConstant(value)] satisfies [unknown, unknown]),\n    ...Object.entries(listIdentifierToValue).map(([id, value]) => [id, listConstant(value)] satisfies [unknown, unknown]),\n]\n","import { USSType, USSValue, createConstantExpression } from '../types-values'\n\n// Functions can't be send over the worker boundary, so instead we must send descriptors\nexport interface LinearScaleDescriptor { kind: 'linear', min: number, max: number }\n\nexport type ScaleDescriptor =\n    LinearScaleDescriptor |\n    { kind: 'log', linearScale: LinearScaleDescriptor }\nexport type Scale = (values: number[], min?: number, max?: number, center?: number) => ScaleDescriptor\n\nexport interface ScaleInstance {\n    forward: (value: number) => number\n    inverse: (value: number) => number\n}\n\nexport const scaleType = {\n    type: 'opaque',\n    name: 'scale',\n} satisfies USSType\n\nexport function instantiate(descriptor: ScaleDescriptor): ScaleInstance {\n    switch (descriptor.kind) {\n        case 'linear':\n            const { min, max } = descriptor\n            if (min === max) {\n                // just arbitrarily map min <=> 0.5\n                return {\n                    forward: x => 0.5 + x - min,\n                    inverse: x => x - 0.5 + min,\n                }\n            }\n            const range = max - min\n\n            return {\n                forward: (value: number) => (value - min) / range,\n                inverse: (value: number) => value * range + min,\n            }\n        case 'log':\n            const { forward, inverse } = instantiate(descriptor.linearScale)\n            return {\n                forward: (value: number) => forward(Math.log(value)),\n                inverse: (value: number) => Math.exp(inverse(value)),\n            }\n    }\n}\n\nconst linearScale: Scale = (values: number[], min?: number, max?: number, center?: number) => {\n    values = values.filter(value => typeof value === 'number' && !isNaN(value) && isFinite(value))\n\n    let computedMin = min ?? Math.min(...values)\n    let computedMax = max ?? Math.max(...values)\n\n    if (center !== undefined) {\n        if (min !== undefined && max !== undefined) {\n            if (Math.abs(center - (min + max) / 2) > 1e-10) {\n                throw new Error(`Inconsistent parameters: center ${center} does not equal (min + max) / 2 = ${min + max} / 2`)\n            }\n        }\n        else if (min !== undefined) {\n            computedMax = 2 * center - min\n        }\n        else if (max !== undefined) {\n            computedMin = 2 * center - max\n        }\n        else {\n            const range = Math.max(computedMax - center, center - computedMin)\n            computedMin = center - range\n            computedMax = center + range\n        }\n    }\n    return {\n        kind: 'linear',\n        min: computedMin,\n        max: computedMax,\n    }\n}\n\nconst logScale: Scale = (values: number[], min?: number, max?: number, center?: number) => {\n    const logVals = values.map(Math.log)\n    const logMin = min !== undefined ? Math.log(min) : undefined\n    const logMax = max !== undefined ? Math.log(max) : undefined\n    const logCenter = center !== undefined ? Math.log(center) : undefined\n    const linearScaleDescriptor = linearScale(logVals, logMin, logMax, logCenter) as LinearScaleDescriptor\n    return {\n        kind: 'log',\n        linearScale: linearScaleDescriptor,\n    }\n}\n\nexport const linearScaleValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            min: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            center: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            max: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n        },\n        returnType: { type: 'concrete', value: scaleType },\n    },\n    value: (ctx, posArgs, namedArgs) => {\n        const min = namedArgs.min as number | null | undefined\n        const max = namedArgs.max as number | null | undefined\n        const center = namedArgs.center as number | null | undefined\n        // Return a scale function that closes over these params\n        return {\n            type: 'opaque',\n            opaqueType: 'scale',\n            value: (values: number[]) => linearScale(values, min ?? undefined, max ?? undefined, center ?? undefined),\n        }\n    },\n    documentation: {\n        humanReadableName: 'Linear Scale',\n        category: 'scale',\n        isDefault: true,\n        longDescription: 'Creates a linear scale that maps numeric values to a range. If min/max are not specified, they are computed from the data. Center parameter can be used to create symmetric ranges.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n    },\n} satisfies USSValue\n\nexport const logScaleValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            min: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            center: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            max: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n        },\n        returnType: { type: 'concrete', value: scaleType },\n    },\n    value: (ctx, posArgs, namedArgs) => {\n        const min = namedArgs.min as number | null | undefined\n        const max = namedArgs.max as number | null | undefined\n        const center = namedArgs.center as number | null | undefined\n        // Return a scale function that closes over these params\n        return {\n            type: 'opaque',\n            opaqueType: 'scale',\n            value: (values: number[]) => logScale(values, min ?? undefined, max ?? undefined, center ?? undefined),\n        }\n    },\n    documentation: {\n        humanReadableName: 'Logarithmic Scale',\n        category: 'scale',\n        longDescription: 'Creates a logarithmic scale that maps numeric values to a range using log transformation. Useful for data with wide ranges or exponential distributions. If min/max are not specified, they are computed from the data. Center parameter can be used to create symmetric ranges.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n    },\n} satisfies USSValue\n","import { round } from 'mathjs'\n\nimport { colorThemes } from '../../page_template/color-themes'\nimport { UrbanStatsASTExpression } from '../ast'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue } from '../types-values'\n\nimport { colorType } from './color'\nimport { Color, deconstructColor, hexToColor } from './color-utils'\nimport { boundsType } from './insets'\nimport { alignValueToIdentifer, listValueToIdentifier, RichTextDocument, richTextDocumentType, RichTextSegment } from './rich-text'\n\nexport interface TextBox {\n    bottomLeft: [number, number]\n    topRight: [number, number]\n    text: RichTextDocument\n    backgroundColor: Color\n    borderColor: Color\n    borderWidth: number\n}\n\nexport const defaults = {\n    backgroundColor: hexToColor(colorThemes['Light Mode'].background),\n    borderColor: hexToColor(colorThemes['Light Mode'].borderShadow),\n    borderWidth: 1,\n}\n\nexport function deconstruct(textBox: TextBox): UrbanStatsASTExpression {\n    const uss = `textBox(\n        screenBounds={\n            north: ${round(textBox.topRight[1], 3)},\n            east: ${round(textBox.topRight[0], 3)},\n            south: ${round(textBox.bottomLeft[1], 3)},\n            west: ${round(textBox.bottomLeft[0], 3)}\n        },\n        text=${deconstructRichTextDocument(textBox.text)},\n        backgroundColor=${deconstructColor(textBox.backgroundColor)},\n        borderColor=${deconstructColor(textBox.borderColor)},\n        borderWidth=${textBox.borderWidth}\n    )`\n    return parseNoErrorAsExpression(uss, '')\n}\n\nfunction deconstructRichTextDocument(doc: RichTextDocument): string {\n    return `rtfDocument([${doc.map(deconstructRichTextSegment).join(', ')}])`\n}\n\nfunction deconstructRichTextSegment(segment: RichTextSegment): string {\n    if (typeof segment.insert === 'string') {\n        return `rtfString(${JSON.stringify(segment.insert)}${deconstructRichTextAttributes(segment.attributes)})`\n    }\n    if ('formula' in segment.insert) {\n        return `rtfFormula(\"${segment.insert.formula}\"${deconstructRichTextAttributes(segment.attributes)})`\n    }\n    if ('image' in segment.insert) {\n        return `rtfImage(\"${segment.insert.image}\"${deconstructRichTextAttributes(segment.attributes)})`\n    }\n    throw new Error()\n}\n\nfunction deconstructRichTextAttributes(attributes: RichTextSegment['attributes']): string {\n    if (attributes === undefined) {\n        return ''\n    }\n    const list = Object.entries(attributes).filter(([, value]) => value !== undefined)\n    if (list.length === 0) {\n        return ''\n    }\n    return `, ${list.flatMap((pair) => {\n        if (pair[1] === undefined) {\n            return []\n        }\n\n        const value = (() => {\n            switch (pair[0]) {\n                case 'align':\n                    return [alignValueToIdentifer[pair[1]]]\n                case 'list':\n                    return [listValueToIdentifier[pair[1]]]\n                case 'color':\n                    return deconstructColor(pair[1])\n                case 'bold':\n                case 'italic':\n                case 'underline':\n                case 'strike':\n                    return pair[1] ? 'true' : 'false'\n                case 'size':\n                case 'indent':\n                    return pair[1].toString()\n                case 'font':\n                    return `\"${pair[1]}\"`\n            }\n        })()\n\n        return `${pair[0]}=${value}`\n    }).join(', ')}`\n}\n\nexport const textBoxType = {\n    type: 'opaque',\n    name: 'textBox',\n} satisfies USSType\n\nexport const constructTextBoxValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            screenBounds: { type: { type: 'concrete', value: boundsType } },\n            text: { type: { type: 'concrete', value: richTextDocumentType } },\n            backgroundColor: { type: { type: 'concrete', value: colorType }, defaultValue: parseNoErrorAsExpression(deconstructColor(defaults.backgroundColor), '') },\n            borderColor: { type: { type: 'concrete', value: colorType }, defaultValue: parseNoErrorAsExpression(deconstructColor(defaults.borderColor), '') },\n            borderWidth: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: parseNoErrorAsExpression(`${defaults.borderWidth}`, '') },\n        },\n        returnType: { type: 'concrete', value: textBoxType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const screenBounds = namedArgs.screenBounds as Map<string, USSRawValue>\n\n        const text = (namedArgs.text as { type: 'opaque', opaqueType: 'richTextDocument', value: RichTextDocument }).value\n        const backgroundColor = (namedArgs.backgroundColor as { type: 'opaque', opaqueType: 'color', value: Color }).value\n        const borderColor = (namedArgs.borderColor as { type: 'opaque', opaqueType: 'color', value: Color }).value\n        const borderWidth = namedArgs.borderWidth as number\n\n        return {\n            type: 'opaque',\n            opaqueType: 'textBox',\n            value: {\n                bottomLeft: [screenBounds.get('west') as number, screenBounds.get('south') as number],\n                topRight: [screenBounds.get('east') as number, screenBounds.get('north') as number],\n                text,\n                backgroundColor,\n                borderColor,\n                borderWidth,\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Map Text Box',\n        category: 'map',\n        longDescription: 'Create a text box on the map with specified screen bounds (bounding box of the inset on the screen, where bottom left corner has (0, 0) and top right corner has (1, 1))',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n","import { assert } from '../utils/defensive'\n\nimport { Block, LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\n\nconst nonExpressionOperators = ['=', ',', ';', '.', ':']\nconst operatorCharacters = '!@$%^&*-+=~`<>/?:|,;.'\n\nconst keywords = ['if', 'do', 'else', 'customNode', 'condition']\nexport type Keyword = (typeof keywords)[number]\n\ninterface NumericToken { type: 'number', value: number }\ninterface IdentifierToken { type: 'identifier', value: string }\ninterface KeywordToken { type: 'keyword', value: Keyword }\ninterface StringToken { type: 'string', value: string }\ninterface OperatorToken { type: 'operator', value: string }\ninterface BracketToken { type: 'bracket', value: '(' | ')' | '{' | '}' | '[' | ']' }\ninterface ErrorToken { type: 'error', value: string }\ntype NonErrorToken = NumericToken | IdentifierToken | KeywordToken | StringToken | OperatorToken | BracketToken\ntype Token = NonErrorToken | ErrorToken\n\nexport interface AnnotatedToken {\n    token: Token\n    location: LocInfo\n}\n\nexport type AnnotatedTokenWithValue = AnnotatedToken & { token: NonErrorToken }\n\ninterface GenericLexer {\n    firstToken: (ch: string) => boolean\n    innerToken: (ch: string) => boolean\n    parse: (string: string) => Token\n}\n\nfunction isDigit(ch: string): boolean {\n    return ch >= '0' && ch <= '9'\n}\nfunction isAlpha(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_'\n}\n\nexport function emptyLocation(ident: string): LocInfo {\n    return {\n        start: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n        end: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n    }\n}\n\nexport function parseNumber(input: string): number | undefined {\n    if (/^-?\\d*(\\.\\d+)?([eE][+-]?\\d+)?$/i.test(input)) {\n        // normal number format\n        const value = parseFloat(input)\n        if (isNaN(value)) {\n            return\n        }\n        return value\n    }\n    if (input.endsWith('k')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000\n    }\n    if (input.endsWith('m')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000000\n    }\n    return\n}\n\nconst identifierLexer: GenericLexer = {\n    firstToken: isAlpha,\n    innerToken: (ch: string): boolean => isAlpha(ch) || isDigit(ch),\n    parse: (string: string): Token => { return { type: keywords.includes(string) ? 'keyword' : 'identifier', value: string } },\n}\n\nexport function allOperators(): string[] {\n    const ops = new Set<string>(nonExpressionOperators)\n    for (const op of expressionOperatorMap.keys()) {\n        ops.add(op)\n    }\n    // sort operators in descending length order to ensure longest match first\n    return Array.from(ops).sort((a, b) => b.length - a.length)\n}\n\nfunction tokenizeOperators(input: string): string[] | undefined {\n    const allOps = allOperators()\n    // console.log(allOps)\n    const tokens: string[] = []\n    let idx = 0\n    while (idx < input.length) {\n        let didMatch = false\n        for (const op of allOps) {\n            if (input.startsWith(op, idx)) {\n                tokens.push(op)\n                idx += op.length\n                didMatch = true\n                break\n            }\n        }\n        if (!didMatch)\n            return undefined\n    }\n    if (idx !== input.length) {\n        return undefined\n    }\n    return tokens\n}\n\nfunction lexOperators(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken[]] {\n    const [finalIdx, supertok] = lexGeneric(input, idx, block, lineNo, operatorLexer, charIdxOffset)\n    if (finalIdx === idx) {\n        return [idx, []]\n    }\n    // console.log(supertok)\n    assert(supertok !== undefined, 'unreachable')\n    assert(supertok.token.type === 'operator', 'unreachable')\n    const tokenizedOperators = tokenizeOperators(supertok.token.value)\n    // console.log(tokenizedOperators)\n    if (tokenizedOperators === undefined) {\n        return [finalIdx, [\n            {\n                token: { type: 'error', value: `Invalid operator sequence: ${supertok.token.value}` },\n                location: supertok.location,\n            },\n        ]]\n    }\n    let start = idx\n    const separatedTokens = tokenizedOperators.map((op) => {\n        const location: LocInfo = {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: start + op.length, charIdx: charIdxOffset + start + op.length },\n        }\n        start += op.length\n        return {\n            token: { type: 'operator', value: op },\n            location,\n        } satisfies AnnotatedToken\n    })\n    // console.log(separatedTokens)\n    return [finalIdx, separatedTokens]\n}\n\nconst operatorLexer: GenericLexer = {\n    firstToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    innerToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    parse: (string: string): Token => {\n        return { type: 'operator', value: string }\n    },\n}\n\nfunction lexLine(input: string, block: Block, lineNo: number, charIdxOffset: number): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    // one line\n    assert(!input.includes('\\n'), 'Input contains new line characters')\n    let idx = 0\n    lex: while (idx < input.length) {\n        const char = input[idx]\n        if (char === ' ') {\n            idx++\n            continue\n        }\n        if (char === '(' || char === ')' || char === '{' || char === '}' || char === '[' || char === ']') {\n            const token: AnnotatedToken = {\n                token: { type: 'bracket', value: char },\n                location: {\n                    start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                    end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n                },\n            }\n            tokens.push(token)\n            idx++\n            continue\n        }\n        if (isDigit(char)) {\n            let token\n            [idx, token] = lexNumber(input, idx, block, lineNo, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue\n            }\n        }\n        for (const lexer of [identifierLexer]) {\n            let token\n            [idx, token] = lexGeneric(input, idx, block, lineNo, lexer, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue lex\n            }\n        }\n        {\n            let toks\n            [idx, toks] = lexOperators(input, idx, block, lineNo, charIdxOffset)\n            if (toks.length > 0) {\n                tokens.push(...toks)\n                continue\n            }\n        }\n        let token\n        [idx, token] = lexString(input, idx, block, lineNo, charIdxOffset)\n        if (token !== undefined) {\n            tokens.push(token)\n            continue\n        }\n        tokens.push({\n            token: { type: 'error', value: `Unexpected character: ${char}` },\n            location: {\n                start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n            },\n        })\n        idx++\n    }\n    return tokens\n}\n\nexport function lex(block: Block, input: string): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    const lines = input.split('\\n')\n    let charIdx = 0\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i]\n        const lineTokens = lexLine(line, block, i, charIdx)\n        tokens.push(...lineTokens)\n        charIdx += line.length\n        tokens.push({\n            token: { type: 'operator', value: 'EOL' },\n            location: {\n                start: { block, lineIdx: i, colIdx: line.length, charIdx },\n                end: { block, lineIdx: i, colIdx: line.length, charIdx },\n            },\n        })\n        charIdx += 1 // newline\n    }\n    return tokens\n}\n\nfunction lexGeneric(\n    input: string,\n    idx: number,\n    block: Block,\n    lineNo: number,\n    lexer: GenericLexer,\n    charIdxOffset: number,\n): [number, AnnotatedToken | undefined] {\n    if (!lexer.firstToken(input[idx])) {\n        return [idx, undefined]\n    }\n\n    const start = idx\n    while (idx < input.length && lexer.innerToken(input[idx])) {\n        idx++\n    }\n    const token: AnnotatedToken = {\n        token: lexer.parse(input.slice(start, idx)),\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexString(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    if (input[idx] !== '\"') {\n        return [idx, undefined]\n    }\n    const start = idx\n    idx++\n    while (true) {\n        if (idx >= input.length) {\n            return [idx, { token: { type: 'error', value: 'Unterminated string' }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + start } } }]\n        }\n        if (input[idx] === '\"') {\n            idx++\n            break\n        }\n        if (input[idx] === '\\\\') {\n            idx += 2\n            continue\n        }\n        idx++\n    }\n    let result: string\n    try {\n        const resultObj: unknown = JSON.parse(input.slice(start, idx))\n        assert(typeof resultObj === 'string', `Invalid string: ${input.slice(start, idx)}`)\n        result = resultObj\n    }\n    catch (e) {\n        return [idx, { token: { type: 'error', value: `Invalid string: ${input.slice(start, idx)}: ${e}` }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'string', value: result },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexNumber(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    const numberFormat = /^\\d+(\\.\\d+)?([eE][+-]?\\d+|k|m)?/i\n    const match = numberFormat.exec(input.slice(idx))\n    if (!match) {\n        return [idx, undefined]\n    }\n    const numberStr = match[0]\n    const number = parseNumber(numberStr)\n    if (number === undefined) {\n        return [idx + numberStr.length, { token: { type: 'error', value: `Invalid number format: ${numberStr}` }, location: { start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx }, end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'number', value: number },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n            end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length },\n        },\n    }\n    return [idx + numberStr.length, token]\n}\n","export type Block = { type: 'single', ident: string } | { type: 'multi' }\n\nexport interface SingleLocationWithinBlock {\n    lineIdx: number\n    colIdx: number\n    charIdx: number\n}\nexport type SingleLocation = SingleLocationWithinBlock & { block: Block }\n\nexport interface LocInfo {\n    start: SingleLocation\n    end: SingleLocation\n}\n\nexport const noLocation = { start: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 }, end: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 } } satisfies LocInfo\n\nexport function extendBlockIdPositionalArg(blockIdent: string, position: number): string {\n    return `${blockIdent}_pos_${position}`\n}\n\nexport function extendBlockIdKwarg(blockIdent: string, argName: string): string {\n    return `${blockIdent}_${argName}`\n}\n\nexport function extendBlockIdVectorElement(blockIdent: string, index: number): string {\n    return `${blockIdent}_el_${index}`\n}\n\nexport function extendBlockIdObjectProperty(blockIdent: string, property: string): string {\n    return `${blockIdent}_prop_${property}`\n}\n","import { assert } from '../utils/defensive'\n\nimport { locationOf, unify, UrbanStatsAST, UrbanStatsASTArg, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTStatement } from './ast'\nimport { Context } from './context'\nimport { AnnotatedToken, AnnotatedTokenWithValue, lex, Keyword, emptyLocation } from './lexer'\nimport { noLocation, LocInfo, Block } from './location'\nimport { expressionOperatorMap, infixOperators, unaryOperators } from './operators'\nimport { USSType } from './types-values'\n\nexport interface Decorated<T> {\n    node: T\n    location: LocInfo\n}\n\nexport interface ParseError { type: 'error', value: string, location: LocInfo }\n\ntype USSInfixSequenceElement = { type: 'operator', operatorType: 'unary' | 'binary', value: Decorated<string> } | UrbanStatsASTExpression\n\nexport function toSExp(node: UrbanStatsAST): string {\n    /**\n     * For testing purposes, we convert the AST to a simple S-expression format.\n     */\n    switch (node.type) {\n        case 'unnamed':\n            return toSExp(node.value)\n        case 'named':\n            return `(named ${node.name.node} ${toSExp(node.value)})`\n        case 'constant':\n            return `(const ${node.value.node.value})`\n        case 'identifier':\n            return `(id ${node.name.node})`\n        case 'attribute':\n            return `(attr ${toSExp(node.expr)} ${node.name.node})`\n        case 'call':\n            return `(fn ${[node.fn, ...node.args].map(toSExp).join(' ')})`\n        case 'unaryOperator':\n            return `(${node.operator.node} ${toSExp(node.expr)})`\n        case 'binaryOperator':\n            return `(${node.operator.node} ${toSExp(node.left)} ${toSExp(node.right)})`\n        case 'vectorLiteral':\n            return `(vector ${node.elements.map(toSExp).join(' ')})`\n        case 'objectLiteral':\n            return `(object ${node.properties.map(([key, value]) => `(${key} ${toSExp(value)})`).join(' ')})`\n        case 'assignment':\n            return `(assign ${toSExp(node.lhs)} ${toSExp(node.value)})`\n        case 'expression':\n            return `(expr ${toSExp(node.value)})`\n        case 'statements':\n            return `(statements ${node.result.map(toSExp).join(' ')})`\n        case 'if':\n            return `(if ${toSExp(node.condition)} ${toSExp(node.then)}${node.else ? ` ${toSExp(node.else)}` : ''})`\n        case 'do':\n            return `(do ${node.statements.map(toSExp).join(' ')})`\n        case 'condition':\n            return `(condition ${toSExp(node.condition)} ${node.rest.map(toSExp).join(' ')})`\n        case 'parseError':\n            return `(parseError ${JSON.stringify(node.originalCode)} ${JSON.stringify(node.errors)})`\n        case 'customNode':\n            return `(customNode ${toSExp(node.expr)} ${JSON.stringify(node.originalCode)})`\n    }\n}\n\nclass ParseState {\n    tokens: AnnotatedTokenWithValue[]\n    index: number\n    constructor(tokens: AnnotatedTokenWithValue[]) {\n        this.tokens = tokens\n        this.index = 0\n    }\n\n    skipEOL(): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === 'operator' && token.token.value === 'EOL') {\n            this.index++\n            return true\n        }\n        return false\n    }\n\n    consumeTokenOfType(type: string, ...values: (string | number)[]): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === type && (values.length === 0 || values.includes(token.token.value))) {\n            this.index++\n            return true\n        }\n        if (this.skipEOL()) {\n            if (this.consumeTokenOfType(type, ...values)) {\n                return true\n            }\n            this.index-- // backtrack\n        }\n        return false\n    }\n\n    consumeOperator(...oneOfOps: string[]): boolean {\n        return this.consumeTokenOfType('operator', ...oneOfOps)\n    }\n\n    consumeBracket(...oneOfBrackets: string[]): boolean {\n        return this.consumeTokenOfType('bracket', ...oneOfBrackets)\n    }\n\n    consumeIdentifier(): boolean {\n        return this.consumeTokenOfType('identifier')\n    }\n\n    consumeKeyword(...oneOfKeywords: Keyword[]): boolean {\n        return this.consumeTokenOfType('keyword', ...oneOfKeywords)\n    }\n\n    maybeLastNonEOLToken(offset: number): AnnotatedTokenWithValue {\n        for (let i = this.index + offset; i >= 0; i--) {\n            const token = this.tokens[i]\n            if (token.token.type !== 'operator' || token.token.value !== 'EOL') {\n                return token\n            }\n        }\n        return this.tokens[this.index + offset]\n    }\n\n    parseSingleExpression(): UrbanStatsASTExpression | ParseError {\n        while (this.skipEOL()) { }\n        if (this.index >= this.tokens.length) {\n            return { type: 'error', value: 'Unexpected end of input', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const token = this.tokens[this.index]\n        switch (token.token.type) {\n            case 'number':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'number', value: token.token.value }, location: token.location } }\n            case 'string':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'string', value: token.token.value }, location: token.location } }\n            case 'identifier':\n                this.index++\n                return { type: 'identifier', name: { node: token.token.value, location: token.location } }\n            case 'keyword':\n                return { type: 'error', value: `Unexpected keyword ${token.token.value}`, location: token.location }\n            case 'bracket':\n                switch (token.token.value) {\n                    case '(':\n                        this.index++\n                        const expr = this.parseExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        if (!this.consumeBracket(')')) {\n                            return { type: 'error', value: 'Expected closing bracket ) to match this one', location: token.location }\n                        }\n                        return expr\n                    case '{':\n                        this.index++\n                        const startLoc = token.location\n                        const properties: [string, UrbanStatsASTExpression][] = []\n                        while (!this.consumeBracket('}')) {\n                            if (properties.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: `Expected comma , or closing bracket } after object field name; instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n                            }\n                            if (!this.consumeIdentifier()) {\n                                return { type: 'error', value: 'Expected identifier for object field name', location: this.maybeLastNonEOLToken(-1).location }\n                            }\n                            const keyToken = this.tokens[this.index - 1]\n                            assert(keyToken.token.type === 'identifier', `Expected identifier token, but got ${keyToken.token.type}`)\n                            if (!this.consumeOperator(':')) {\n                                return { type: 'error', value: `Expected : token after object field name`, location: keyToken.location }\n                            }\n                            const value = this.parseExpression()\n                            if (value.type === 'error') {\n                                return value\n                            }\n                            properties.push([keyToken.token.value, value])\n                        }\n                        const endLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'objectLiteral',\n                            entireLoc: unify(startLoc, endLoc),\n                            properties,\n                        }\n                    case '[':\n                        this.index++\n                        const vectorStartLoc = token.location\n                        const elements: UrbanStatsASTExpression[] = []\n                        while (!this.consumeBracket(']')) {\n                            if (elements.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: 'Expected comma , or closing bracket ] after vector element', location: this.maybeLastNonEOLToken(0).location }\n                            }\n                            const element = this.parseExpression()\n                            if (element.type === 'error') {\n                                return element\n                            }\n                            elements.push(element)\n                        }\n                        const vectorEndLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'vectorLiteral',\n                            entireLoc: unify(vectorStartLoc, vectorEndLoc),\n                            elements,\n                        }\n                }\n                return { type: 'error', value: `Unexpected bracket ${token.token.value}`, location: token.location }\n            case 'operator':\n                return { type: 'error', value: `Unexpected operator ${token.token.value}`, location: token.location }\n        }\n    }\n\n    parseArg(): UrbanStatsASTArg | ParseError {\n        const exprOrName = this.parseExpression()\n        if (exprOrName.type === 'error') {\n            return exprOrName\n        }\n        if (!this.consumeOperator('=')) {\n            return { type: 'unnamed', value: exprOrName }\n        }\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (exprOrName.type !== 'identifier') {\n            return { type: 'error', value: 'Expected identifier for named argument', location: locationOf(exprOrName) }\n        }\n        return {\n            type: 'named',\n            name: { node: exprOrName.name.node, location: exprOrName.name.location },\n            value: expr,\n        }\n    }\n\n    parseParenthesizedArgs(): { type: 'args', args: [UrbanStatsASTArg[], LocInfo] } | ParseError | undefined {\n        if (!this.consumeBracket('(')) {\n            return undefined\n        }\n        const startLoc = this.tokens[this.index - 1].location\n        const args: UrbanStatsASTArg[] = []\n        while (true) {\n            if (this.consumeBracket(')')) {\n                const endLoc = this.tokens[this.index - 1].location\n                return { type: 'args', args: [args, unify(startLoc, endLoc)] }\n            }\n            if (args.length > 0 && !this.consumeOperator(',')) {\n                return { type: 'error', value: `Expected comma , or closing bracket ); instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n            }\n            const arg = this.parseArg()\n            if (arg.type === 'error') {\n                return arg\n            }\n            args.push(arg)\n        }\n    }\n\n    parseFunctionalExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('customNode')) {\n            return this.parseCustomNodeExpression()\n        }\n\n        let fn = this.parseSingleExpression()\n        if (fn.type === 'error') {\n            return fn\n        }\n        while (true) {\n            let done = true\n            const args = this.parseParenthesizedArgs()\n            if (args !== undefined) {\n                done = false\n                if (args.type === 'error') {\n                    return args\n                }\n                fn = {\n                    type: 'call',\n                    fn,\n                    entireLoc: unify(locationOf(fn), args.args[1]),\n                    args: args.args[0],\n                }\n            }\n            if (this.consumeOperator('.')) {\n                done = false\n                if (!this.consumeIdentifier()) {\n                    return { type: 'error', value: 'Expected identifier after the dot', location: this.maybeLastNonEOLToken(-1).location }\n                }\n                const token = this.tokens[this.index - 1]\n                assert(token.token.type === 'identifier', `Expected identifier token, but got ${token.token.type}`)\n                fn = {\n                    type: 'attribute',\n                    expr: fn,\n                    name: { node: token.token.value, location: token.location },\n                }\n            }\n            if (done) {\n                break\n            }\n        }\n        return fn\n    }\n\n    parseExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('if')) {\n            return this.parseIfExpression()\n        }\n\n        if (this.consumeKeyword('do')) {\n            return this.parseDoExpression()\n        }\n\n        const operatorExpSequence: USSInfixSequenceElement[] = []\n        // State Machine with states expressionOrUnaryOperator; binaryOperator\n        let state: 'expressionOrUnaryOperator' | 'binaryOperator' = 'expressionOrUnaryOperator'\n        loop: while (true) {\n            switch (state) {\n                case 'expressionOrUnaryOperator': {\n                    if (this.consumeOperator(...unaryOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'unary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        continue\n                    }\n                    else {\n                        const expr = this.parseFunctionalExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        operatorExpSequence.push(expr)\n                        state = 'binaryOperator'\n                    }\n                }\n                    break\n                case 'binaryOperator': {\n                    if (this.consumeOperator(...infixOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'binary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        state = 'expressionOrUnaryOperator'\n                    }\n                    else {\n                        break loop\n                    }\n                }\n            }\n        }\n        return this.parseInfixSequence(operatorExpSequence)\n    }\n\n    parseInfixSequence(operatorExpSequence: USSInfixSequenceElement[]): UrbanStatsASTExpression | ParseError {\n        assert(operatorExpSequence.length !== 0, 'Expected expression')\n        if (operatorExpSequence.length === 1) {\n            assert(operatorExpSequence[0].type !== 'operator', `Unexpected operator ${JSON.stringify(operatorExpSequence[0])} at beginning of infix sequence`)\n            return operatorExpSequence[0]\n        }\n        // Get the highest precedence operator\n        const precedences = operatorExpSequence.map(x => x.type === 'operator' ? expressionOperatorMap.get(x.value.node)?.precedence ?? 0 : 0)\n        const maxPrecedence = Math.max(...precedences)\n        assert(maxPrecedence > 0, 'No valid operator found in infix sequence')\n        const index = precedences.findIndex(p => p === maxPrecedence)\n        assert(index > -1, 'No operator found with maximum precedence; this should not happen')\n        return this.parseInfixSequence(this.resolveOperator(operatorExpSequence, index))\n    }\n\n    resolveOperator(operatorExpSequence: USSInfixSequenceElement[], index: number): USSInfixSequenceElement[] {\n        assert(operatorExpSequence[index].type === 'operator', `Expected operator at index ${index}, but found expression: ${JSON.stringify(operatorExpSequence[index])}`)\n        const next = operatorExpSequence[index + 1]\n        if (next.type === 'operator') {\n            return this.resolveOperator(operatorExpSequence, index + 1)\n        }\n        switch (operatorExpSequence[index].operatorType) {\n            case 'unary': {\n                return [\n                    ...operatorExpSequence.slice(0, index),\n                    { type: 'unaryOperator', operator: operatorExpSequence[index].value, expr: next },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n            case 'binary': {\n                // Split the sequence into left and right parts\n                const left = operatorExpSequence[index - 1]\n                const right = operatorExpSequence[index + 1]\n                assert(left.type !== 'operator' && right.type !== 'operator', 'unreachable: left or right should not be an operator')\n                return [\n                    ...operatorExpSequence.slice(0, index - 1),\n                    { type: 'binaryOperator', operator: operatorExpSequence[index].value, left, right },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n        }\n    }\n\n    checkLHS(expr: UrbanStatsASTExpression): UrbanStatsASTLHS | ParseError {\n        switch (expr.type) {\n            case 'identifier':\n            case 'attribute':\n                return expr\n            case 'constant':\n            case 'call':\n            case 'unaryOperator':\n            case 'binaryOperator':\n            case 'vectorLiteral':\n            case 'objectLiteral':\n            case 'if':\n            case 'do':\n            case 'customNode':\n                return { type: 'error', value: 'Cannot assign to this expression', location: locationOf(expr) }\n        }\n    }\n\n    parseStatement(): UrbanStatsASTStatement | ParseError {\n        if (this.consumeKeyword('condition')) {\n            return this.parseConditionStatement()\n        }\n\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (this.consumeOperator('=')) {\n            const value = this.parseExpression()\n            if (value.type === 'error') {\n                return value\n            }\n            const lhs = this.checkLHS(expr)\n            if (lhs.type === 'error') {\n                return lhs\n            }\n            return { type: 'assignment', lhs, value }\n        }\n        return { type: 'expression', value: expr }\n    }\n\n    parseIfExpression(): UrbanStatsASTExpression | ParseError {\n        const ifToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after if', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const then = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after if block')\n        if (then.type === 'error') {\n            return then\n        }\n        let elseBranch: UrbanStatsASTStatement | undefined = undefined\n        if (this.consumeKeyword('else')) {\n            if (!this.consumeBracket('{')) {\n                return { type: 'error', value: 'Expected opening bracket { after else', location: this.maybeLastNonEOLToken(-1).location }\n            }\n            const eb = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after else block')\n            if (eb.type === 'error') {\n                return eb\n            }\n            elseBranch = eb\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'if',\n            entireLoc: unify(ifToken.location, lastToken.location),\n            condition,\n            then,\n            else: elseBranch,\n        }\n    }\n\n    parseDoExpression(): UrbanStatsASTExpression | ParseError {\n        const doToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after do', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const statements = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after do block')\n        if (statements.type === 'error') {\n            return statements\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'do',\n            entireLoc: unify(doToken.location, lastToken.location),\n            statements: statements.type === 'statements' ? statements.result : [statements],\n        }\n    }\n\n    parseConditionStatement(): UrbanStatsASTStatement | ParseError {\n        const conditionToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return {\n            type: 'condition',\n            entireLoc: unify(conditionToken.location, this.tokens[this.index - 1].location),\n            condition,\n            rest: [],\n        }\n    }\n\n    parseStatements(canEnd: boolean = false, end: () => boolean = () => false, errMsg: string = 'Expected end of line or ; after'): UrbanStatsASTStatement | ParseError {\n        const statements: UrbanStatsASTStatement[] = []\n        while (this.index < this.tokens.length) {\n            if (end()) {\n                break\n            }\n            while (this.skipEOL()) { }\n            if (this.index >= this.tokens.length) {\n                break\n            }\n            const statement = this.parseStatement()\n            if (statement.type === 'error') {\n                return statement\n            }\n            statements.push(statement)\n            if (end()) {\n                break\n            }\n            if (!this.consumeOperator('EOL', ';')) {\n                return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n            }\n            while (this.skipEOL()) { }\n        }\n        if (this.index === this.tokens.length && canEnd) {\n            return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return mergeStatements(\n            statements,\n            this.index > 0\n                ? this.tokens[this.index - 1].location\n                /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n                : undefined,\n        )\n    }\n\n    parseCustomNodeExpression(): UrbanStatsASTExpression | ParseError {\n        const argsRes = this.parseParenthesizedArgs()\n\n        if (argsRes === undefined) {\n            return { type: 'error', value: 'Expected arguments for customNode', location: this.maybeLastNonEOLToken(-1).location }\n        }\n\n        if (argsRes.type === 'error') {\n            return argsRes\n        }\n\n        const [args, locArg] = argsRes.args\n\n        const code = args[0]\n\n        if (args.length !== 1 || code.type !== 'unnamed') {\n            return { type: 'error', value: 'Incorrect arguments for customNode, expected 1 unnamed argument', location: argsRes.args[1] }\n        }\n\n        if (code.value.type !== 'constant' || code.value.value.node.type !== 'string') {\n            return { type: 'error', value: 'Expected string constant as argument to customNode', location: locationOf(code) }\n        }\n\n        const parseResult = parse(code.value.value.node.value, code.value.value.location.start.block)\n\n        if (parseResult.type === 'error') {\n            return {\n                type: 'customNode',\n                expr: {\n                    type: 'parseError',\n                    errors: parseResult.errors,\n                    originalCode: code.value.value.node.value,\n                },\n                originalCode: code.value.value.node.value,\n                entireLoc: locArg,\n            }\n        }\n\n        return {\n            type: 'customNode',\n            expr: parseResult,\n            originalCode: code.value.value.node.value,\n            entireLoc: locArg,\n        }\n    }\n}\n\nexport function mergeStatements(statements: UrbanStatsASTStatement[], fallbackLocation?: LocInfo): UrbanStatsASTStatement {\n    statements = gulpRestForConditions(statements)\n    if (statements.length === 1) {\n        return statements[0]\n    }\n    const entireLoc: LocInfo = statements.length > 0\n        ? unify(...statements.map(locationOf))\n        : fallbackLocation\n        /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n        ?? noLocation\n    return { type: 'statements', result: statements, entireLoc }\n}\n\nfunction gulpRestForConditions(statements: UrbanStatsASTStatement[]): UrbanStatsASTStatement[] {\n    /**\n     * Handle condition statements by gulping the next statement into the condition's rest.\n     */\n    const result: UrbanStatsASTStatement[] = []\n    for (let i = 0; i < statements.length; i++) {\n        const stmt = statements[i]\n        if (stmt.type === 'condition') {\n            stmt.rest.push(...gulpRestForConditions(statements.slice(i + 1)))\n            result.push(stmt)\n            break\n        }\n        result.push(stmt)\n    }\n    return result\n}\n\nexport function parse(code: string, block?: Block, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const tokens = lex(block ?? { type: 'multi' }, code)\n    return parseTokens(tokens, code, returnParseErrorNode)\n}\n\nexport function parseTokens(tokens: AnnotatedToken[], originalCode: string, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const lexErrors = tokens.filter(token => token.token.type === 'error')\n    if (lexErrors.length > 0) {\n        const errors: ParseError[] = lexErrors.map(token => ({ type: 'error' as const, value: `Unrecognized token: ${token.token.value}`, location: token.location }))\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors }\n        }\n        return { type: 'error', errors }\n    }\n    const state = new ParseState(tokens as AnnotatedTokenWithValue[]) // we checked for errors above, so this cast is safe\n    const stmts = state.parseStatements()\n    if (stmts.type === 'error') {\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors: [stmts] }\n        }\n        return { type: 'error', errors: [stmts] }\n    }\n    assert(state.index === state.tokens.length, `Parser did not consume all tokens: ${state.index} < ${state.tokens.length}`)\n    return stmts\n}\n\nfunction allExpressions(node: UrbanStatsASTStatement | UrbanStatsASTExpression): UrbanStatsASTExpression[] {\n    const expressions: UrbanStatsASTExpression[] = []\n    function helper(n: UrbanStatsASTStatement | UrbanStatsASTExpression | UrbanStatsASTArg): boolean {\n        switch (n.type) {\n            case 'unnamed':\n                helper(n.value)\n                return true\n            case 'named':\n                expressions.push(n.value)\n                helper(n.value)\n                return true\n            case 'constant':\n            case 'identifier':\n                expressions.push(n)\n                return true\n            case 'attribute':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'call':\n                expressions.push(n)\n                helper(n.fn)\n                n.args.forEach(helper)\n                return true\n            case 'unaryOperator':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'binaryOperator':\n                expressions.push(n)\n                helper(n.left)\n                helper(n.right)\n                return true\n            case 'objectLiteral':\n                expressions.push(n)\n                n.properties.forEach(([key, value]) => {\n                    expressions.push({ type: 'constant', value: { node: { type: 'string', value: key }, location: n.entireLoc } })\n                    helper(value)\n                })\n                return true\n            case 'vectorLiteral':\n                expressions.push(n)\n                n.elements.forEach(helper)\n                return true\n            case 'assignment':\n                helper(n.lhs)\n                helper(n.value)\n                return true\n            case 'expression':\n                helper(n.value)\n                return true\n            case 'statements':\n                n.result.forEach(helper)\n                return true\n            case 'if':\n                helper(n.condition)\n                helper(n.then)\n                if (n.else) {\n                    helper(n.else)\n                }\n                return true\n            case 'do':\n                n.statements.forEach(helper)\n                return true\n            case 'condition':\n                helper(n.condition)\n                n.rest.forEach(helper)\n                return true\n            case 'parseError':\n                return true\n            case 'customNode':\n                // do not actually put this in the expressions list, as is for internal use only\n                helper(n.expr)\n                return true\n        }\n    }\n    helper(node)\n    return expressions\n}\n\nfunction identifiersInExpr(node: UrbanStatsASTStatement | UrbanStatsASTExpression): Set<string> {\n    const identifiers = new Set<string>()\n    allExpressions(node).forEach((expr) => {\n        if (expr.type === 'identifier') {\n            identifiers.add(expr.name.node)\n        }\n    })\n    return identifiers\n}\n\nexport function allIdentifiers(node: UrbanStatsASTStatement | UrbanStatsASTExpression, ctx: Context): Set<string> {\n    const identifiers = identifiersInExpr(node)\n    while (true) {\n        // make sure to include identifiers from default values of function arguments pulled in by the identifiers\n        const newIdentifiers = new Set<string>()\n        identifiers.forEach((id) => {\n            const t = ctx.getVariable(id)?.type\n            if (t === undefined || t.type !== 'function') {\n                return\n            }\n            Object.entries(t.namedArgs).forEach(([, arg]) => {\n                const dv = arg.defaultValue\n                if (dv === undefined) {\n                    return\n                }\n                identifiersInExpr(dv).forEach((newId) => {\n                    if (!identifiers.has(newId)) {\n                        newIdentifiers.add(newId)\n                    }\n                })\n            })\n        })\n        if (newIdentifiers.size === 0) {\n            break\n        }\n        newIdentifiers.forEach(id => identifiers.add(id))\n    }\n    return identifiers\n}\n\nexport function unparse(node: UrbanStatsASTStatement | UrbanStatsASTExpression, opts: { indent?: number, inline?: boolean, simplify?: boolean, expressionalContext?: boolean, wrap?: boolean } = {}): string {\n    if (opts.inline) {\n        assert(opts.expressionalContext ?? false, 'expressionalContext must be true if inline is true')\n    }\n    opts.indent = opts.indent ?? 0\n    opts.wrap = opts.wrap ?? true\n    function isSimpleExpression(expr: UrbanStatsASTExpression): boolean {\n        return expr.type === 'identifier' || expr.type === 'vectorLiteral' || expr.type === 'constant' || expr.type === 'customNode'\n    }\n    function indentSpaces(level: number): string {\n        return '    '.repeat(level)\n    }\n\n    const characterLimit = 80 - indentSpaces(opts.indent).length\n\n    switch (node.type) {\n        case 'customNode':\n            if (!opts.simplify) {\n                return `customNode(${JSON.stringify(node.originalCode.trim())})`\n            }\n            if (opts.expressionalContext && node.expr.type !== 'expression') {\n                return unparse({ type: 'do', statements: [node.expr], entireLoc: locationOf(node.expr) }, { ...opts, inline: true })\n            }\n            else {\n                return node.originalCode.trim()\n            }\n        case 'parseError':\n            return node.originalCode\n        case 'constant':\n            if (node.value.node.type === 'string') {\n                return JSON.stringify(node.value.node.value)\n            }\n            else {\n                return node.value.node.value.toString()\n            }\n        case 'identifier':\n            return node.name.node\n        case 'attribute':\n            const exprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            return `${exprStr}.${node.name.node}`\n        case 'call': {\n            const fnStr = unparse(node.fn, { ...opts, inline: true, expressionalContext: true })\n            const argsStr = node.args.map((arg) => {\n                switch (arg.type) {\n                    case 'unnamed':\n                        return unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: false })\n                    case 'named':\n                        return `${arg.name.node}=${unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: false })}`\n                }\n            })\n            const fnNeedsParens = !isSimpleExpression(node.fn)\n            const fnWithParens = fnNeedsParens ? `(${fnStr})` : fnStr\n            const notWrapped = `${fnWithParens}(${argsStr.join(', ')})`\n            if (notWrapped.length > characterLimit && opts.wrap) {\n                // Special case for one unnamed argument that's a vector literal\n                if (node.args.length === 1 && node.args[0].type === 'unnamed' && node.args[0].value.type === 'vectorLiteral') {\n                    return `${fnWithParens}(${unparse(node.args[0].value, { ...opts, inline: true, expressionalContext: true, wrap: true })})`\n                }\n                const wrappedArgs = node.args.map((arg) => {\n                    switch (arg.type) {\n                        case 'unnamed':\n                            return `${indentSpaces(opts.indent! + 1)}${unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: true, indent: opts.indent! + 1 })}`\n                        case 'named':\n                            return `${indentSpaces(opts.indent! + 1)}${arg.name.node}=${unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: true, indent: opts.indent! + 1 })}`\n                    }\n                })\n                return `${fnWithParens}(\\n${wrappedArgs.join(',\\n')}\\n${indentSpaces(opts.indent)})`\n            }\n            return notWrapped\n        }\n        case 'unaryOperator':\n            const unaryExprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            const needsParens = !isSimpleExpression(node.expr)\n            const exprWithParens = needsParens ? `(${unaryExprStr})` : unaryExprStr\n            return `${node.operator.node}${exprWithParens}`\n        case 'binaryOperator':\n            const leftStr = unparse(node.left, { ...opts, inline: true, expressionalContext: true })\n            const rightStr = unparse(node.right, { ...opts, inline: true, expressionalContext: true })\n            const opPrecedence = expressionOperatorMap.get(node.operator.node)?.precedence ?? 0\n            let leftWithParens = leftStr\n            if (node.left.type === 'binaryOperator') {\n                const leftOpPrecedence = expressionOperatorMap.get(node.left.operator.node)?.precedence ?? 0\n                if (leftOpPrecedence < opPrecedence) {\n                    leftWithParens = `(${leftStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.left)) {\n                leftWithParens = `(${leftStr})`\n            }\n            let rightWithParens = rightStr\n            if (node.right.type === 'binaryOperator') {\n                const rightOpPrecedence = expressionOperatorMap.get(node.right.operator.node)?.precedence ?? 0\n                if (rightOpPrecedence <= opPrecedence) {\n                    rightWithParens = `(${rightStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.right)) {\n                rightWithParens = `(${rightStr})`\n            }\n            return `${leftWithParens} ${node.operator.node} ${rightWithParens}`\n        case 'vectorLiteral': {\n            const elementsStr = node.elements.map(elem => unparse(elem, { ...opts, inline: true, expressionalContext: true, wrap: false }))\n            const notWrapped = `[${elementsStr.join(', ')}]`\n            if (notWrapped.length > characterLimit && opts.wrap) {\n                const wrappedElements = node.elements.map(elem => `${indentSpaces(opts.indent! + 1)}${unparse(elem, { ...opts, inline: true, expressionalContext: true, wrap: true, indent: opts.indent! + 1 })}`)\n                return `[\\n${wrappedElements.join(',\\n')}\\n${indentSpaces(opts.indent)}]`\n            }\n            return notWrapped\n        }\n        case 'objectLiteral': {\n            const propertiesStr = node.properties.map(([key, value]) => {\n                const valueStr = unparse(value, { ...opts, inline: true, expressionalContext: true, wrap: false })\n                return `${key}: ${valueStr}`\n            })\n            const notWrapped = `{${propertiesStr.join(', ')}}`\n            if (notWrapped.length > characterLimit && opts.wrap) {\n                const wrappedProperties = node.properties.map(([key, value]) => {\n                    const valueStr = unparse(value, { ...opts, inline: true, expressionalContext: true, wrap: true })\n                    return `${indentSpaces(opts.indent! + 1)}${key}: ${valueStr}`\n                })\n                return `{\\n${wrappedProperties.join(',\\n')}\\n${indentSpaces(opts.indent)}}`\n            }\n            return notWrapped\n        }\n        case 'assignment':\n            const lhsStr = unparse(node.lhs, { ...opts, expressionalContext: true })\n            const valueStr = unparse(node.value, { ...opts, expressionalContext: true })\n            return opts.inline ? `${lhsStr} = ${valueStr}` : `${indentSpaces(opts.indent)}${lhsStr} = ${valueStr}`\n        case 'expression':\n            // despite being an expression, it is not in an expressional context if its parent is not\n            return opts.inline ? unparse(node.value, opts) : `${indentSpaces(opts.indent)}${unparse(node.value, opts)}`\n        case 'statements':\n            const statementsStr = node.result\n                .map(stmt => unparse(stmt, opts))\n                .filter(s => s !== '' && s !== 'do {  }')\n            return statementsStr.join(opts.inline ? '; ' : ';\\n')\n        case 'if':\n            const conditionStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const thenStr = unparse(node.then, { ...opts, indent: opts.indent + 1 })\n            let ifStr = opts.inline\n                ? `if (${conditionStr}) { ${thenStr} }`\n                : `if (${conditionStr}) {\\n${thenStr}\\n${indentSpaces(opts.indent)}}`\n            if (node.else) {\n                const elseStr = unparse(node.else, { ...opts, indent: opts.indent + 1 })\n                ifStr += opts.inline\n                    ? ` else { ${elseStr} }`\n                    : ` else {\\n${elseStr}\\n${indentSpaces(opts.indent)}}`\n            }\n            return ifStr\n        case 'do':\n            const doStatements = { type: 'statements' as const, result: node.statements, entireLoc: node.entireLoc }\n            const doStr = unparse(doStatements, { ...opts, indent: opts.indent + 1 })\n            return opts.inline\n                ? `do { ${doStr} }`\n                : `do {\\n${doStr}\\n${indentSpaces(opts.indent)}}`\n        case 'condition':\n            const condStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const restStatements = { type: 'statements' as const, result: node.rest, entireLoc: node.entireLoc }\n            const restStr = unparse(restStatements, opts)\n            // If condition is literal \"true\", elide it\n            if (opts.simplify && node.condition.type === 'identifier' && node.condition.name.node === 'true') {\n                return restStr\n            }\n            return `${indentSpaces(opts.indent)}condition (${condStr})\\n${restStr}`\n    }\n}\n\nexport function parseNoError(uss: string, blockId: string): UrbanStatsASTStatement {\n    const result = parse(uss, { type: 'single', ident: blockId }, true)\n    assert(result.type !== 'error', `Should not have an error`)\n    return result\n}\n\nexport function parseNoErrorAsCustomNode(uss: string, blockId: string, expectedType?: USSType[]): Extract<UrbanStatsASTExpression, { type: 'customNode' }> {\n    assert(!blockId.startsWith('undefined'), 'blockId must not start with \"undefined\"')\n    const result = parseNoError(uss, blockId)\n    return {\n        type: 'customNode',\n        expr: result,\n        originalCode: uss,\n        expectedType,\n        entireLoc: emptyLocation(blockId),\n    }\n}\n\nexport function parseNoErrorAsExpression(uss: string, blockId: string): UrbanStatsASTExpression {\n    const result = parseNoError(uss, blockId)\n    assert(result.type === 'expression', `Must be expression, got ${JSON.stringify(result)}`)\n    return result.value\n}\n","import { Basemap } from '../mapper/settings/utils'\nimport { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTExpression } from './ast'\nimport { Color, deconstructColor, hexToColor } from './constants/color-utils'\nimport { CMap, CMapRGB, Outline, PMap } from './constants/map'\nimport { RampT } from './constants/ramp'\nimport { RichTextAttributes, RichTextDocument, RichTextSegment } from './constants/rich-text'\nimport { Scale } from './constants/scale'\nimport { TextBox } from './constants/text-box'\nimport { Context } from './context'\nimport { noLocation } from './location'\nimport { unparse } from './parser'\n\n// Define Inset and Insets types locally to avoid import issues\ninterface Inset { bottomLeft: [number, number], topRight: [number, number], coordBox?: [number, number, number, number], mainMap: boolean, name?: string }\ntype Insets = Inset[]\n\n// Define the tagged union for opaque values\nexport type USSOpaqueValue =\n    | { type: 'opaque', opaqueType: 'color', value: Color }\n    | { type: 'opaque', opaqueType: 'scale', value: Scale }\n    | { type: 'opaque', opaqueType: 'inset', value: Inset }\n    | { type: 'opaque', opaqueType: 'insets', value: Insets }\n    | { type: 'opaque', opaqueType: 'cMap', value: CMap }\n    | { type: 'opaque', opaqueType: 'cMapRGB', value: CMapRGB }\n    | { type: 'opaque', opaqueType: 'pMap', value: PMap }\n    | { type: 'opaque', opaqueType: 'outline', value: Outline }\n    | { type: 'opaque', opaqueType: 'unit', value: { unit: string } }\n    | { type: 'opaque', opaqueType: 'ramp', value: RampT }\n    | { type: 'opaque', opaqueType: 'basemap', value: Basemap }\n    | { type: 'opaque', opaqueType: 'geoFeatureHandle', value: string }\n    | { type: 'opaque', opaqueType: 'geoCentroidHandle', value: string }\n    | { type: 'opaque', opaqueType: 'textBox', value: TextBox }\n    | { type: 'opaque', opaqueType: 'richTextDocument', value: RichTextDocument }\n    | { type: 'opaque', opaqueType: 'richTextSegment', value: RichTextSegment }\n    | { type: 'opaque', opaqueType: 'richTextList', value: RichTextAttributes['list'] }\n    | { type: 'opaque', opaqueType: 'richTextAlign', value: RichTextAttributes['align'] }\n\ninterface USSNumberType {\n    type: 'number'\n}\n\ninterface USSStringType {\n    type: 'string'\n}\ninterface USSBooleanType {\n    type: 'boolean'\n}\n\ninterface USSNullType {\n    type: 'null'\n}\n\nexport interface USSOpaqueType {\n    type: 'opaque'\n    name: string\n    allowCustomExpression?: boolean\n}\n\nexport interface USSVectorType {\n    type: 'vector'\n    elementType: USSType | { type: 'elementOfEmptyVector' }\n}\n\nexport interface USSObjectType {\n    type: 'object'\n    properties: Map<string, USSType>\n}\n\nexport type USSFunctionArgType = { type: 'concrete', value: USSType } | { type: 'anyPrimitive' }\nexport type USSFunctionReturnType = { type: 'concrete', value: USSType } | { type: 'inferFromPrimitive' }\n\nexport interface NamedFunctionArgumentWithDocumentation {\n    type: USSFunctionArgType\n    defaultValue?: UrbanStatsASTExpression\n    documentation?: NamedFunctionArgumentDocumentation\n}\n\nexport interface USSFunctionType {\n    type: 'function'\n    posArgs: USSFunctionArgType[]\n    namedArgs: Record<string, NamedFunctionArgumentWithDocumentation>\n    returnType: USSFunctionReturnType\n}\n\ninterface NamedFunctionArgumentDocumentation {\n    hide?: boolean\n}\n\nexport type USSType = (\n    USSNumberType\n    | USSStringType\n    | USSBooleanType\n    | USSNullType\n    | USSOpaqueType\n    | USSObjectType\n    | USSVectorType\n    | USSFunctionType\n)\n\nexport type USSPrimitiveRawValue = (\n    number |\n    string |\n    boolean |\n    null\n)\n\nexport interface OriginalFunctionArgs {\n    posArgs: USSValue[]\n    namedArgs: Record<string, USSValue>\n}\n\nexport type USSRawValue = (\n    USSPrimitiveRawValue |\n    USSRawValue[] |\n    Map<string, USSRawValue> |\n    (\n        (\n            ctx: Context,\n            posArgs: USSRawValue[],\n            namedArgs: Record<string, USSRawValue>,\n            // only used occasionally, for functions that need to access the original arguments\n            // to e.g., access their documentation\n            originalArgs: OriginalFunctionArgs\n        ) => USSRawValue\n    ) |\n    USSOpaqueValue\n)\n\nexport const constantCategories = ['basic', 'color', 'math', 'regression', 'mapper', 'logic', 'map', 'scale', 'ramp', 'unit', 'inset', 'richText'] as const\n\nexport type ConstantCategory = typeof constantCategories[number]\n\nexport type DocumentationTable = 'mapper-data-variables' | 'predefined-colors' | 'unit-types' | 'predefined-ramps' | 'predefined-insets' | 'logarithm-functions' | 'trigonometric-functions'\n\nexport type SelectorRendering = { kind: 'subtitleLongDescription' } | { kind: 'gradientBackground', ramp: RampT }\nexport interface Documentation {\n    humanReadableName: string\n    priority?: number\n    /**\n     * True if this is the canonical default value for its type (e.g., the default ramp or scale).\n     */\n    isDefault?: boolean\n    /**\n     * Human-readable names for named arguments. Maps argument name to display name.\n     */\n    namedArgs?: Record<string, string>\n    /**\n     * Should be included when a constant should be deconstructed into an expression for user editing\n     */\n    equivalentExpressions?: UrbanStatsASTExpression[]\n    /**\n     * Included for all bulit-in constants.\n     */\n    category?: ConstantCategory\n    /**\n     * Whether the constant should be grouped with other constants in a table in the documentation.\n     * If present, this field groups the constant with other similar ones.\n     */\n    documentationTable?: DocumentationTable\n    /**\n     * Included for all bulit-in constants. Will be displayed in the documentation.\n     */\n    longDescription?: string\n    /**\n     * Used when displaying this value in a selector\n     */\n    selectorRendering?: SelectorRendering\n    /**\n     * True if this is a custom constructor that should invoke edit icons elsewhere\n     */\n    customConstructor?: boolean\n    /**\n     * True if the constant is derived from a statistic column. These should all have type number[]\n     */\n    fromStatisticColumn?: boolean\n    /**\n     * True if this should be outputted in the context returned by the worker. If this is true, the value\n     * should also be serializable to JSON.\n     */\n    includedInOutputContext?: boolean\n}\n\nexport interface USSDocumentedType {\n    type: USSType\n    documentation?: Documentation\n\n}\n\nexport type TypeEnvironment = Map<string, USSDocumentedType>\n\nexport type USSValue = { value: USSRawValue } & USSDocumentedType\n\nexport function undocValue(value: USSRawValue, type: USSType): USSValue {\n    return {\n        type,\n        value,\n        documentation: undefined,\n    }\n}\n\nexport function createConstantExpression(value: number | string | boolean | null): UrbanStatsASTExpression {\n    // Create a simple constant expression for primitive values\n    if (typeof value === 'number') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'number', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'string') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'string', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'boolean') {\n        // For booleans, use identifier expressions that reference the predefined constants\n        return {\n            type: 'identifier',\n            name: { node: value.toString(), location: noLocation },\n        }\n    }\n    else {\n        // For null, use identifier expression that references the predefined null constant\n        return {\n            type: 'identifier',\n            name: { node: 'null', location: noLocation },\n        }\n    }\n}\n\nexport function unifyFunctionType(param: USSFunctionArgType, arg: USSType): boolean {\n    if (param.type === 'concrete') {\n        return renderType(param.value) === renderType(arg)\n    }\n    return arg.type === 'number' || arg.type === 'string' || arg.type === 'boolean' || arg.type === 'null'\n}\n\nexport function renderType(type: USSType): string {\n    if (type.type === 'number') {\n        return 'number'\n    }\n    if (type.type === 'string') {\n        return 'string'\n    }\n    if (type.type === 'boolean') {\n        return 'boolean'\n    }\n    if (type.type === 'vector') {\n        return `[${type.elementType.type === 'elementOfEmptyVector' ? '' : renderType(type.elementType)}]`\n    }\n    if (type.type === 'object') {\n        assert(type.properties instanceof Map, `Expected properties to be a Map, got ${typeof type.properties}`)\n        return `{${[...type.properties.entries()].sort().map(([k, v]) => `${k}: ${renderType(v)}`).join(', ')}}`\n    }\n    if (type.type === 'null') {\n        return 'null'\n    }\n    if (type.type === 'opaque') {\n        return type.name\n    }\n    return `(${type.posArgs.map(renderArgumentType).join(', ')}; ${Object.entries(type.namedArgs).map(([k, v]) => `${k}: ${renderKwargType(v)}`).join(', ')}) -> ${renderReturnType(type.returnType)}`\n}\n\nexport function renderArgumentType(arg: USSFunctionArgType): string {\n    if (arg.type === 'concrete') {\n        return renderType(arg.value)\n    }\n    return 'any'\n}\n\nexport function renderKwargType(arg: { type: USSFunctionArgType, defaultValue?: UrbanStatsASTExpression }): string {\n    const type = renderArgumentType(arg.type)\n    if (arg.defaultValue !== undefined) {\n        return `${type} = ${unparse(arg.defaultValue)}`\n    }\n    return type\n}\n\nfunction renderReturnType(ret: USSFunctionReturnType): string {\n    if (ret.type === 'concrete') {\n        return renderType(ret.value)\n    }\n    return 'any'\n}\n\nexport type ValueArg = (\n    { type: 'unnamed', value: USSValue } |\n    { type: 'named', name: string, value: USSValue }\n)\n\nexport function getPrimitiveType(value: USSRawValue, depth: number = 0): USSType {\n    if (depth === 0) {\n        if (typeof value === 'number') {\n            return { type: 'number' }\n        }\n        if (typeof value === 'string') {\n            return { type: 'string' }\n        }\n        if (typeof value === 'boolean') {\n            return { type: 'boolean' }\n        }\n        if (value === null) {\n            return { type: 'null' }\n        }\n    }\n    assert(Array.isArray(value), `Expected a primitive value, but got ${typeof value}`)\n    return getPrimitiveType(value[0], depth - 1)\n}\n\nexport function unifyType(\n    a: USSType | { type: 'elementOfEmptyVector' },\n    b: USSType | { type: 'elementOfEmptyVector' },\n    error: () => Error,\n): USSType | { type: 'elementOfEmptyVector' } {\n    if (a.type === 'elementOfEmptyVector') {\n        return b\n    }\n    if (b.type === 'elementOfEmptyVector') {\n        return a\n    }\n    if (renderType(a) === renderType(b)) {\n        return a\n    }\n    if (a.type === 'vector' && b.type === 'vector') {\n        return {\n            type: 'vector',\n            elementType: unifyType(a.elementType, b.elementType, error),\n        }\n    }\n    if (a.type === 'object' && b.type === 'object') {\n        if (JSON.stringify([...a.properties.keys()].sort()) !== JSON.stringify([...b.properties.keys()].sort())) {\n            throw error()\n        }\n        const properties = new Map<string, USSType>()\n        for (const [key, type] of a.properties) {\n            properties.set(key, type)\n        }\n        for (const [key, type] of b.properties) {\n            const res = unifyType(properties.get(key)!, type, error)\n            assert(res.type !== 'elementOfEmptyVector', `Unreachable`)\n            properties.set(key, res)\n        }\n        return {\n            type: 'object',\n            properties,\n        }\n    }\n    throw error()\n}\n\nexport function renderValue(input: USSValue): string {\n    function helper(value: USSValue, indent: string): string {\n        const type = value.type\n        switch (type.type) {\n            case 'boolean':\n            case 'null':\n            case 'number':\n                return `${value.value}`\n            case 'string':\n                return `\"${value.value}\"`\n            case 'opaque':\n                const opaqueValue = value.value as USSOpaqueValue\n                switch (opaqueValue.opaqueType) {\n                    case 'scale':\n                    case 'pMap':\n                    case 'cMap':\n                    case 'cMapRGB':\n                    case 'basemap':\n                    case 'inset':\n                    case 'insets':\n                    case 'geoFeatureHandle':\n                    case 'geoCentroidHandle':\n                    case 'unit':\n                    case 'textBox':\n                    case 'richTextDocument':\n                    case 'richTextSegment':\n                    case 'richTextAlign':\n                    case 'richTextList':\n                        return `[${opaqueValue.opaqueType} object]`\n                    case 'color':\n                        return deconstructColor(opaqueValue.value)\n                    case 'outline':\n                        const outline = opaqueValue.value\n                        return `constructOutline(color=${deconstructColor(outline.color)}, weight=${outline.weight})`\n                    case 'ramp':\n                        const ramp = opaqueValue.value\n                        const rampValue = ramp.map(\n                            ([position, color]) => {\n                                const contents: [string, USSRawValue][] = [\n                                        ['value', position] satisfies [string, USSRawValue],\n                                        ['color', { type: 'opaque', opaqueType: 'color', value: hexToColor(color) }] satisfies [string, USSRawValue],\n                                ] satisfies [string, USSRawValue][]\n                                return new Map(contents) satisfies Map<string, USSRawValue>\n                            },\n                        )\n                        const interior = undocValue(rampValue,\n                            {\n                                type: 'vector',\n                                elementType: {\n                                    type: 'object',\n                                    properties: new Map([\n                                        ['value', { type: 'number' }],\n                                        ['color', { type: 'opaque', name: 'color' }],\n                                    ]),\n                                },\n                            },\n                        )\n                        return `[ramp ${renderValue(interior)}]`\n                }\n            case 'vector':\n                const vector = value.value as USSRawValue[]\n                if (vector.length === 0) {\n                    return `[]`\n                }\n                // USSType assertion is OK since we handle zero-length vectors above\n                return `[\n${vector.map(element => `${indent}    ${helper(undocValue(element, type.elementType as USSType), `${indent}    `)}`).join(',\\n')}\n${indent}]`\n            case 'object':\n                const map = value.value as Map<string, USSRawValue>\n                if (map.size === 0) {\n                    return `{}`\n                }\n                return `{\n${Array.from(map.entries()).map(([key, element]) => `${indent}    ${key}: ${helper(undocValue(element, type.properties.get(key)!), `${indent}    `)}`).join(',\\n')}\n${indent}}`\n            case 'function':\n                return renderType(type)\n        }\n    }\n    return helper(input, '')\n}\n\nexport function canUnifyTo(a: USSType, b: USSType): boolean {\n    // returns true iff a can be used in a context where b is expected\n    if (renderType(a) === renderType(b)) {\n        return true\n    }\n    // at this point, the types are different\n    switch (b.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'null':\n        case 'opaque':\n            // these are all primitive types, so no way to substitute them\n            return false\n        case 'vector':\n            assert(b.elementType.type !== 'elementOfEmptyVector', `Unreachable`)\n            return canUnifyTo(a, b.elementType)\n        case 'object':\n            if (a.type !== 'object') {\n                return false\n            }\n            if (a.properties.size !== b.properties.size) {\n                return false\n            }\n            if (![...a.properties.keys()].every(key => b.properties.has(key))) {\n                return false\n            }\n            return [...a.properties.keys()].every(key => canUnifyTo(a.properties.get(key)!, b.properties.get(key)!))\n        case 'function':\n            return false\n    }\n}\n","import { emptyContext } from '../../unit/urban-stats-script-utils'\nimport validGeographies from '../data/mapper/used_geographies'\nimport statistic_path_list from '../data/statistic_path_list'\nimport statistic_variables_info from '../data/statistic_variables_info'\nimport { loadOrderingDataProtobuf, loadProtobuf } from '../load_json'\nimport { mapperContext, defaultTypeEnvironment, loadInsets } from '../mapper/context'\nimport { indexLink } from '../navigation/links'\nimport { Universe } from '../universe'\nimport { assert } from '../utils/defensive'\n\nimport { locationOfLastExpression } from './ast'\nimport { Context } from './context'\nimport { EditorError } from './editor-utils'\nimport { Effect, execute, InterpretationError } from './interpreter'\nimport { noLocation } from './location'\nimport { renderType, USSRawValue, USSValue } from './types-values'\nimport { USSExecutionRequest, USSExecutionResult } from './workerManager'\n\nlet mapperCache: {\n    universe: Universe\n    geographyKind: typeof validGeographies[number]\n    longnames: string[]\n    dataCache: Map<string, number[]>\n} | undefined\n\nasync function executeRequest(request: USSExecutionRequest): Promise<USSExecutionResult> {\n    let context, getWarnings\n    try {\n        ([context, getWarnings] = await contextForRequest(request))\n        const result = execute(request.stmts, context)\n\n        switch (request.descriptor.kind) {\n            case 'generic': {\n                break\n            }\n            case 'mapper': {\n                // no idea why we need this, but it's obviously correct from the switch\n                if (renderType(result.type) !== 'cMap' && renderType(result.type) !== 'cMapRGB' && renderType(result.type) !== 'pMap') {\n                    throw new InterpretationError(`USS expression did not return a cMap, cMapRGB, or pMap type, got: ${renderType(result.type)}`, locationOfLastExpression(request.stmts))\n                }\n                break\n            }\n        }\n        return {\n            resultingValue: { type: result.type, value: removeFunctions(result.value) },\n            error: getWarnings(),\n            context: new Map([...context.variableEntries()].filter(([,v]) => v.documentation?.includedInOutputContext)),\n        }\n    }\n    catch (error) {\n        let interpretationError: InterpretationError\n        if (error instanceof InterpretationError) {\n            interpretationError = error\n        }\n        else {\n            console.error('Unknown interpretation error', error)\n            interpretationError = new InterpretationError('Unknown interpretation error', noLocation)\n        }\n        return {\n            error: [{ type: 'error', value: interpretationError.value, location: interpretationError.location, kind: 'error' }, ...(getWarnings?.() ?? [])],\n            context: new Map(),\n        }\n    }\n}\n\nasync function contextForRequest(request: USSExecutionRequest): Promise<[Context, () => EditorError[]]> {\n    const effects: Effect[] = []\n    const getWarnings = (): EditorError[] => {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- just so if there's additonal types, we're safe\n        return effects.filter(eff => eff.type === 'warning').map(eff => ({\n            type: 'error',\n            value: eff.message,\n            location: eff.location,\n            kind: 'warning',\n        }))\n    }\n    switch (request.descriptor.kind) {\n        case 'generic':\n            return [emptyContext(effects), getWarnings]\n        case 'mapper':\n            return [await mapperContextForRequest(request as USSExecutionRequest & { descriptor: { kind: 'mapper' } }, effects), getWarnings]\n    }\n}\n\nasync function mapperContextForRequest(request: USSExecutionRequest & { descriptor: { kind: 'mapper' } }, effects: Effect[]): Promise<Context> {\n    const geographyKind = request.descriptor.geographyKind\n    const universe = request.descriptor.universe\n    const dte = defaultTypeEnvironment(universe)\n    if (!validGeographies.includes(geographyKind)) {\n        throw new Error('invalid geography')\n    }\n\n    // Load geography names and set up cache\n    let longnames: string[]\n\n    if (mapperCache?.geographyKind === geographyKind && mapperCache.universe === universe) {\n        longnames = mapperCache.longnames\n    }\n    else {\n        // Load geography names from index\n        const indexData = await loadProtobuf(indexLink(universe, geographyKind), 'ArticleOrderingList')\n        longnames = indexData.longnames\n        mapperCache = {\n            universe,\n            geographyKind,\n            longnames,\n            dataCache: new Map(),\n        }\n    }\n\n    const annotateType = (name: string, val: USSRawValue): USSValue => {\n        const typeInfo = dte.get(name)\n        assert(typeInfo !== undefined, `Type info for ${name} not found`)\n        return {\n            type: typeInfo.type,\n            documentation: typeInfo.documentation,\n            value: val,\n        }\n    }\n\n    const getVariable = async (name: string): Promise<USSValue | undefined> => {\n        assert(mapperCache !== undefined, 'mapperCache was initialized above and is never undefined after that')\n        if (name === 'geoName') {\n            return annotateType('geoName', longnames)\n        }\n        if (name === 'geo') {\n            return annotateType('geo', longnames.map(longname => ({ type: 'opaque', opaqueType: 'geoFeatureHandle', value: longname })))\n        }\n        if (name === 'geoCentroid') {\n            return annotateType('geoCentroid', longnames.map(longname => ({ type: 'opaque', opaqueType: 'geoCentroidHandle', value: longname })))\n        }\n        if (name === 'defaultInsets') {\n            return annotateType('defaultInsets', { type: 'opaque', opaqueType: 'insets', value: loadInsets(request.descriptor.universe) })\n        }\n        const variableInfo = statistic_variables_info.variableNames.find(v => v.varName === name)\n        if (!variableInfo) {\n            return undefined\n        }\n        const index = variableInfo.index\n\n        // Check cache first\n        const existing = mapperCache.dataCache.get(name)\n        if (existing !== undefined) {\n            return annotateType(name, existing)\n        }\n\n        const statpath = statistic_path_list[index]\n\n        const variableData = await loadOrderingDataProtobuf(universe, statpath, geographyKind)\n        assert(Array.isArray(variableData.value), `Expected variable data for ${name} to be an array`)\n        mapperCache.dataCache.set(name, variableData.value)\n        return annotateType(name, variableData.value)\n    }\n\n    const context = await mapperContext(request.stmts, getVariable, effects, universe)\n    return context\n}\n\nfunction removeFunctions(value: USSRawValue): USSRawValue {\n    if (value instanceof Function) {\n        return null\n    }\n    else if (Array.isArray(value)) {\n        return value.map(removeFunctions)\n    }\n    else if (value instanceof Map) {\n        return new Map(Array.from(value.entries()).map(([k, v]) => [k, removeFunctions(v)]))\n    }\n    else if (value instanceof Object && value.value instanceof Function) {\n        assert(value.opaqueType === 'scale', 'only scales can have functions in their value')\n        return null\n    }\n    return value\n}\n\nonmessage = async (message: MessageEvent<{ request: USSExecutionRequest, id: number }>) => {\n    if (!('request' in message.data)) {\n        // Some other message (e.g. from React devtools)\n        return\n    }\n    const result = await executeRequest(message.data.request)\n    postMessage({ result, id: message.data.id })\n}\n","import assert from 'assert'\n\nimport { Effect, InterpretationError } from './interpreter'\nimport { LocInfo } from './location'\nimport { USSValue } from './types-values'\n\nexport class Context {\n    #effect: (eff: Effect) => void\n    #error: (msg: string, location: LocInfo) => InterpretationError\n    #constants: Map<string, USSValue>\n    #variables: Map<string, USSValue>\n\n    constructor(effect: (eff: Effect) => void, error: (msg: string, location: LocInfo) => InterpretationError, constants: Map<string, USSValue>, variables: Map<string, USSValue>) {\n        this.#effect = effect\n        this.#error = error\n        this.#constants = constants\n        this.#variables = variables\n        for (const name of variables.keys()) {\n            assert(!constants.has(name), `Variable name \"${name}\" conflicts with a constant`)\n        }\n    }\n\n    effect(eff: Effect): void {\n        this.#effect(eff)\n    }\n\n    error(msg: string, location: LocInfo): InterpretationError {\n        return this.#error(msg, location)\n    }\n\n    getVariable(name: string): USSValue | undefined {\n        if (this.#constants.has(name)) {\n            return this.#constants.get(name)\n        }\n        return this.#variables.get(name)\n    }\n\n    assignVariable(name: string, value: USSValue): string | undefined {\n        if (this.#constants.has(name)) {\n            return `Cannot assign to constant \"${name}\"`\n        }\n        this.#variables.set(name, value)\n        return undefined\n    }\n\n    variableEntries(): IterableIterator<[string, USSValue]> {\n        return this.#variables.entries()\n    }\n\n    evolveVariables(variables: Map<string, USSValue>): Context {\n        return new Context(\n            this.#effect,\n            this.#error,\n            this.#constants,\n            variables,\n        )\n    }\n}\n","import { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTExpression } from './ast'\nimport { Context } from './context'\nimport { InterpretationError, evaluate } from './interpreter'\nimport { LocInfo } from './location'\nimport { USSValue, USSType, USSVectorType, USSObjectType, renderType, USSRawValue, USSFunctionType, ValueArg, unifyFunctionType as unifyFunctionArgType, renderArgumentType, getPrimitiveType, undocValue, OriginalFunctionArgs, USSFunctionArgType } from './types-values'\n\ninterface PredicateDescriptor {\n    role: string\n    typeDesc: string\n}\n\nexport function locateType(value: USSValue, predicate: (t: USSType) => boolean, predicateDescriptor: PredicateDescriptor): TypeLocationResult {\n    if (predicate(value.type)) {\n        // cast is safe because we checked the type\n        return { type: 'success', result: [[], value.type, value.value] }\n    }\n    const overallType = value.type\n    if (overallType.type === 'vector') {\n        return locateTypeVector(value as USSValue & { type: USSVectorType }, predicate, predicateDescriptor)\n    }\n    if (overallType.type === 'object' && [...overallType.properties.values()].some(t => t.type === 'vector')) {\n        return locateTypeObject(value as USSValue & { type: USSObjectType }, predicate, predicateDescriptor)\n    }\n    return {\n        type: 'error',\n        message: `Expected ${predicateDescriptor.role} to be a ${predicateDescriptor.typeDesc} (or vector thereof) but got ${renderType(value.type)}`,\n    }\n}\n\nfunction locateTypeVector(\n    value: USSValue & { type: USSVectorType },\n    predicate: (t: USSType) => boolean,\n    predicateDescriptor: PredicateDescriptor,\n): TypeLocationResult {\n    const t = value.type.elementType\n    if (t.type === 'elementOfEmptyVector') {\n        return {\n            type: 'error',\n            message: `${predicateDescriptor.role} is an empty vector whose type cannot be inferred`,\n        }\n    }\n    const subtypesOrErrors = (value as { type: USSVectorType, value: USSRawValue[] }).value.map(fn => locateType({\n        type: t,\n        value: fn,\n        documentation: value.documentation,\n    }, predicate, predicateDescriptor))\n    assert(subtypesOrErrors.length !== 0, `Expected at least one vector element, but got an empty vector`)\n    if (subtypesOrErrors.some(x => x.type === 'error')) {\n        return subtypesOrErrors.find(x => x.type === 'error')!\n    }\n    const subresults = (subtypesOrErrors as { type: 'success', result: TypeLocationSuccess } []).map(x => x.result)\n    const prefixes = subresults.map(x => x[0])\n    const types = subresults.map(x => x[1])\n    const values = subresults.map(x => x[2])\n    if (prefixes.some(x => JSON.stringify(x) !== JSON.stringify(prefixes[0]))) {\n        return {\n            type: 'error',\n            message: `Jagged vector (nested vector where not all are the same length) cannot be broadcasted`,\n        }\n    }\n    /* c8 ignore start */\n    // I don't think this can happen, but let's be safe\n    if (types.some(x => renderType(x) !== renderType(types[0]))) {\n        return {\n            type: 'error',\n            message: `Array of different types cannot be broadcasted: ${types.map(renderType).join(', ')}`,\n        }\n    }\n    /* c8 ignore stop */\n    return { type: 'success', result: [[prefixes.length, ...prefixes[0]], types[0], values] }\n}\n\nfunction locateTypeObject(\n    value: USSValue & { type: USSObjectType },\n    predicate: (t: USSType) => boolean,\n    predicateDescriptor: PredicateDescriptor,\n): TypeLocationResult {\n    const toBroadcast = [...value.type.properties.entries()].filter(([, t]) => t.type === 'vector').map(([k]) => k)\n    assert(toBroadcast.length !== 0, `Expected an object with at least one vector property, but got ${renderType(value.type)}`)\n    const rawValue = value.value as Map<string, USSRawValue>\n    const firstDims = toBroadcast.map((k) => {\n        const subValue = rawValue.get(k)\n        assert(subValue !== undefined, `Expected object to have property ${k}, but it is undefined`)\n        assert(typeof subValue === 'object' && Array.isArray(subValue), `Expected object property ${k} to be a vector, but got ${typeof subValue}`)\n        return subValue.length\n    })\n    if (firstDims.some(x => x !== firstDims[0])) {\n        return {\n            type: 'error',\n            message: `Object properties ${toBroadcast.join(', ')} have different lengths (${firstDims.join(', ')}), cannot be broadcasted`,\n        }\n    }\n    const newRawValues: Map<string, USSRawValue>[] = []\n    for (let i = 0; i < firstDims[0]; i++) {\n        const newRawValue = new Map<string, USSRawValue>()\n        for (const k of rawValue.keys()) {\n            if (!toBroadcast.includes(k)) {\n                newRawValue.set(k, rawValue.get(k)!)\n                continue\n            }\n            const subValue = rawValue.get(k)\n            assert(subValue !== undefined && Array.isArray(subValue), `Expected object to have property ${k} as a vector, but it is undefined or not a vector`)\n            newRawValue.set(k, subValue[i])\n        }\n        newRawValues.push(newRawValue)\n    }\n    const r: [string, USSType][] = []\n    for (const [k, t] of value.type.properties.entries()) {\n        if (!toBroadcast.includes(k)) {\n            r.push([k, t])\n            continue\n        }\n        assert(t.type === 'vector', `Expected object property ${k} to be a vector, but got ${renderType(t)}`)\n        if (t.elementType.type === 'elementOfEmptyVector') {\n            return {\n                type: 'error',\n                message: `Cannot broadcast object property ${k} because its type is an empty vector with no inferred type`,\n            }\n        }\n        r.push([\n            k,\n            t.elementType,\n        ])\n    }\n    return locateType({\n        value: newRawValues,\n        type: {\n            type: 'vector',\n            elementType: {\n                type: 'object',\n                properties: new Map(r),\n            },\n        },\n        documentation: value.documentation,\n    }, predicate, predicateDescriptor)\n}\n\ntype TypeLocationSuccess = [number[], USSType, USSRawValue]\n\ntype TypeLocationResult = { type: 'success', result: TypeLocationSuccess } | BroadcastError\n\nfunction locateFunctionAndArguments(\n    fn: USSValue,\n    posArgs: USSValue[],\n    kwArgs: [string, USSValue][],\n    ctx: Context,\n): { type: 'success', result: [TypeLocationSuccess, TypeLocationSuccess[], TypeLocationSuccess[]] } | BroadcastError {\n    const fnLocatedOrError = locateType(fn, t => t.type === 'function', { role: 'function', typeDesc: 'function' })\n    if (fnLocatedOrError.type === 'error') {\n        return fnLocatedOrError\n    }\n    const fnLocated = fnLocatedOrError.result\n    const fnType = fnLocated[1]\n    assert(fnType.type === 'function', `Expected a function type, but got ${renderType(fnType)}`)\n    if (fnType.posArgs.length !== posArgs.length) {\n        return {\n            type: 'error',\n            message: `Function expects ${fnType.posArgs.length} positional arguments, but received ${posArgs.length}`,\n        }\n    }\n    const usingDefaults = []\n    for (const k of Object.keys(fnType.namedArgs)) {\n        if (!kwArgs.some(x => x[0] === k)) {\n            const na = fnType.namedArgs[k]\n            const defaultValue = evaluateDefault(na, ctx)\n            if (defaultValue !== undefined) {\n                kwArgs.push([k, defaultValue])\n                usingDefaults.push(k)\n            }\n            else {\n                return {\n                    type: 'error',\n                    message: `Function expects named argument ${k}, but it was not provided`,\n                }\n            }\n        }\n    }\n    for (const [name] of kwArgs) {\n        if (!Object.keys(fnType.namedArgs).includes(name)) {\n            return {\n                type: 'error',\n                message: `Function does not expect named argument ${name}, but it was provided`,\n            }\n        }\n    }\n    assert(\n        JSON.stringify(Object.keys(fnType.namedArgs).sort()) === JSON.stringify(kwArgs.map(x => x[0]).sort()),\n        `Function expects arguments named ${Object.keys(fnType.namedArgs).join(', ')}, but received [${kwArgs.map(x => x[0]).join(', ')}]`,\n    )\n    const posArgsLocated: TypeLocationSuccess[] = []\n    for (let i = 0; i < fnType.posArgs.length; i++) {\n        const posArgLocated = locateType(posArgs[i], t => unifyFunctionArgType(fnType.posArgs[i], t), { role: `positional argument ${i + 1}`, typeDesc: renderArgumentType(fnType.posArgs[i]) })\n        if (posArgLocated.type === 'error') {\n            return posArgLocated\n        }\n        posArgsLocated.push(posArgLocated.result)\n    }\n\n    const kwArgsLocated: TypeLocationSuccess[] = []\n    for (const [name, value] of kwArgs) {\n        const isNullable = usingDefaults.includes(name)\n        const kwArgLocated = locateType(value, t => unifyFunctionArgType(fnType.namedArgs[name].type, t) || (isNullable && t.type === 'null'), { role: `named argument ${name}`, typeDesc: renderArgumentType(fnType.namedArgs[name].type) })\n        if (kwArgLocated.type === 'error') {\n            return kwArgLocated\n        }\n        kwArgsLocated.push(kwArgLocated.result)\n    }\n    return {\n        type: 'success',\n        result: [fnLocated, posArgsLocated, kwArgsLocated],\n    }\n}\n\ninterface BroadcastError {\n    type: 'error'\n    message: string\n}\n\nfunction evaluateDefault(na: { type: USSFunctionArgType, defaultValue?: UrbanStatsASTExpression }, ctx: Context): USSValue | undefined {\n    if (!na.defaultValue) {\n        return undefined\n    }\n    assert(na.type.type === 'concrete', `Expected named argument to have a concrete type`)\n    // Since we removed raw default values, all default values are now expressions\n    return evaluate(na.defaultValue, ctx)\n}\n\nfunction expandDims(values: TypeLocationSuccess[], descriptors: string[]): { type: 'success', result: TypeLocationSuccess[] } | BroadcastError {\n    /**\n     * Expands the dimensions of the given values to the largest vector size, aligning the last axes.\n     * This is used to prepare the values for broadcasting.\n     */\n    let maximalExpansionSize: number[] = []\n    let maximalExpansionIdx = -1\n    for (let i = 0; i < values.length; i++) {\n        const [prefix] = values[i]\n        if (prefix.length > maximalExpansionSize.length) {\n            maximalExpansionSize = prefix\n            maximalExpansionIdx = i\n        }\n    }\n    for (let i = 0; i < values.length; i++) {\n        const [prefix] = values[i]\n        const off = maximalExpansionSize.length - prefix.length\n        if (!prefix.every((x, j) => x === maximalExpansionSize[j + off])) {\n            return {\n                type: 'error',\n                message: `Incompatibility between the shape of ${descriptors[i]} (${prefix.join(', ')}) and the shape of ${descriptors[maximalExpansionIdx]} (${maximalExpansionSize.join(', ')})`,\n            }\n        }\n    }\n    const newValues: TypeLocationSuccess[] = values.map((value) => {\n        const [prefix, type, rawValue] = value\n\n        return [maximalExpansionSize, type, addAdditionalDims(maximalExpansionSize.slice(0, maximalExpansionSize.length - prefix.length), rawValue)]\n    })\n    return { type: 'success', result: newValues }\n}\n\nexport function addAdditionalDims(dims: number[], rawValue: USSRawValue): USSRawValue {\n    /**\n     * Expands the dimensions of the given raw value to the given dimensions.\n     * This is used to prepare the values for broadcasting.\n     */\n    if (dims.length === 0) {\n        return rawValue\n    }\n    return addAdditionalDims(\n        dims.slice(0, dims.length - 1),\n        Array.from({ length: dims[dims.length - 1] }, () => rawValue),\n    )\n}\n\nfunction mapSeveral(\n    fn: USSRawValue,\n    posArgs: USSRawValue[],\n    argumentNames: string[],\n    kwArgs: USSRawValue[],\n    originalArgs: OriginalFunctionArgs,\n    depth: number,\n    ctx: Context,\n    locInfo: LocInfo,\n): USSRawValue {\n    /**\n     * Maps the given function to the positional and keyword arguments, returning a new value.\n     * The function is expected to be a function that takes the positional and keyword arguments.\n     */\n    if (depth === 0) {\n        assert(typeof fn === 'function', `Expected a function, but got ${typeof fn}`)\n        const kw = Object.fromEntries(kwArgs.map((v, i) => [argumentNames[i], v]))\n        try {\n            return (fn as (c: Context, pA: USSRawValue[], nA: Record<string, USSRawValue>, oA: OriginalFunctionArgs) => USSRawValue)(\n                ctx, posArgs, kw, originalArgs,\n            )\n        }\n        catch (e) {\n            if (e instanceof InterpretationError) {\n                throw e\n            }\n            throw ctx.error(`Error while executing function: ${e}`, locInfo)\n        }\n    }\n    assert(Array.isArray(fn), `Expected an array of functions, but got ${typeof fn}`)\n    return Array.from({ length: fn.length }, (_, i) => {\n        const posArgsI = posArgs.map((x) => {\n            assert(Array.isArray(x), `Expected an array of positional arguments, but got ${typeof x}`)\n            return x[i]\n        })\n        const kwArgsI = kwArgs.map((x) => {\n            assert(Array.isArray(x), `Expected an array of keyword arguments, but got ${typeof x}`)\n            return x[i]\n        })\n        return mapSeveral(\n            fn[i],\n            posArgsI,\n            argumentNames,\n            kwArgsI,\n            originalArgs,\n            depth - 1,\n            ctx,\n            locInfo,\n        )\n    })\n}\n\nfunction nestedVectorType(type: USSType, depth: number): USSType {\n    if (depth === 0) {\n        return type\n    }\n    return {\n        type: 'vector',\n        elementType: nestedVectorType(type, depth - 1),\n    }\n}\n\nexport function broadcastApply(\n    fn: USSValue,\n    posArgs: USSValue[],\n    kwArgs: [string, USSValue][],\n    ctx: Context,\n    locInfo: LocInfo,\n): { type: 'success', result: USSValue } | BroadcastError {\n    /**\n     * Broadcasts a function to the given arguments. The function itself can be a vector, but the types\n     * of the functions must all be the same.\n     *\n     * Broadcasting works by expanding values to the largest vector size, and then zippering the computation\n     * across the vectors. The last axes are always preferentially aligned, i.e.,\n     *\n     * [f, g]([[1, 2], [3, 4]]) => [[f(1), g(3)], [f(2), g(4)]]\n     *\n     * If the function cannot be broadcast to the arguments, an error is returned.\n     */\n    const result = locateFunctionAndArguments(fn, posArgs, kwArgs, ctx)\n    if (result.type === 'error') {\n        return result\n    }\n    let [fnLocated, posArgsLocated, kwArgsLocated] = result.result\n    let allTogether = [fnLocated, ...posArgsLocated, ...kwArgsLocated]\n    const descriptors = ['function', ...posArgsLocated.map((x, i) => `positional argument ${i + 1}`), ...kwArgs.map(x => `named argument ${x[0]}`)]\n    const allTogetherOrErr = expandDims(allTogether, descriptors)\n    if (allTogetherOrErr.type === 'error') {\n        return allTogetherOrErr\n    }\n    allTogether = allTogetherOrErr.result\n    // console.log('allTogether', allTogether)\n    fnLocated = allTogether[0]\n    posArgsLocated = allTogether.slice(1, 1 + posArgsLocated.length)\n    kwArgsLocated = allTogether.slice(1 + posArgsLocated.length)\n    const depth = fnLocated[0].length\n\n    const resulting: USSRawValue = mapSeveral(\n        fnLocated[2],\n        posArgsLocated.map(x => x[2]),\n        kwArgs.map(x => x[0]),\n        kwArgsLocated.map(x => x[2]),\n        { posArgs, namedArgs: Object.fromEntries(kwArgs) },\n        depth,\n        ctx,\n        locInfo,\n    )\n\n    // console.log('resulting', resulting, 'fnLocated', fnLocated, 'posArgsLocated', posArgsLocated, 'kwArgsLocated', kwArgsLocated)\n    const returnTypeOrInfer = (fnLocated[1] as USSFunctionType).returnType\n    const returnType = returnTypeOrInfer.type === 'inferFromPrimitive' ? getPrimitiveType(resulting, depth) : returnTypeOrInfer.value\n    return {\n        type: 'success',\n        result: undocValue(resulting, nestedVectorType(returnType, depth)),\n    }\n}\n\nexport function broadcastCall(fn: USSValue, args: ValueArg[], ctx: Context, locInfo: LocInfo): { type: 'success', result: USSValue } | BroadcastError {\n    /**\n     * Broadcasts a function to the given arguments. The function itself can be a vector, but the types\n     * of the functions must all be the same.\n     *\n     * Broadcasting works by expanding values to the largest vector size, and then zippering the computation\n     * across the vectors. The last axes are always preferentially aligned, i.e.,\n     *\n     * [f, g]([[1, 2], [3, 4]]) => [[f(1), g(3)], [f(2), g(4)]]\n     *\n     * If the function cannot be broadcast to the arguments, an error is returned.\n     */\n    const posArgs = args.filter(x => x.type === 'unnamed').map(x => x.value)\n    const kwArgs = args.filter(x => x.type === 'named').map(x => [x.name, x.value] satisfies [string, USSValue])\n    return broadcastApply(fn, posArgs, kwArgs, ctx, locInfo)\n}\n","import { assert } from '../utils/defensive'\n\nimport { Context } from './context'\nimport { LocInfo } from './location'\nimport { getPrimitiveType, renderType, undocValue, unifyType, USSPrimitiveRawValue, USSRawValue, USSType, USSValue, USSVectorType } from './types-values'\n\nfunction collectUniqueMaskValues(collectIn: Set<USSPrimitiveRawValue>, mask: USSValue): boolean {\n    const t = mask.type\n    switch (t.type) {\n        case 'boolean':\n        case 'number':\n        case 'string':\n        case 'null':\n            collectIn.add(mask.value as USSPrimitiveRawValue)\n            return true\n        case 'vector':\n            const et = t.elementType\n            if (et.type === 'elementOfEmptyVector') {\n                // If the mask is an empty vector, we can just return true\n                return true\n            }\n            const results = (mask.value as USSRawValue[]).map(x => collectUniqueMaskValues(collectIn, undocValue(x, et)))\n            return results.every(x => x)\n        case 'object':\n        case 'function':\n        case 'opaque':\n            // We don't support objects or functions as masks, so we return false\n            return false\n    }\n}\n\nfunction repeatMany(value: USSValue, count: number): { type: 'success', value: USSValue & { type: USSVectorType } } | { type: 'error', message: string } {\n    const vt = value.type\n    if (vt.type === 'vector') {\n        assert(value.value instanceof Array, 'unreachable')\n        if (value.value.length !== count) {\n            return { type: 'error', message: `Expected vector of length ${count}, but got ${value.value.length}` }\n        }\n        return { type: 'success', value: { type: vt, value: value.value } }\n    }\n    if (vt.type === 'object') {\n        const newTypes = new Map<string, USSType>()\n        const newProperties = new Map<string, USSRawValue[]>()\n        for (const [k, v] of vt.properties.entries()) {\n            assert(value.value instanceof Map, 'unreachable')\n            const vVal = value.value.get(k)\n            assert(vVal !== undefined, 'unreachable')\n            const result = repeatMany(undocValue(vVal, v), count)\n            if (result.type === 'error') {\n                return result\n            }\n            assert(result.value.value instanceof Array, 'unreachable')\n            assert(result.value.type.elementType.type !== 'elementOfEmptyVector', 'unreachable')\n            newProperties.set(k, result.value.value)\n            newTypes.set(k, result.value.type.elementType)\n        }\n        return {\n            type: 'success',\n            value: {\n                type: { type: 'vector', elementType: { type: 'object', properties: newTypes } },\n                value: Array.from({ length: count }, (_, idx) => new Map(Array.from(newProperties.entries()).map(([k, v]) => [k, v[idx]]))),\n                documentation: value.documentation,\n            },\n        }\n    }\n    return {\n        type: 'success',\n        value: {\n            type: { type: 'vector', elementType: value.type },\n            value: Array.from({ length: count }, () => value.value),\n            documentation: value.documentation,\n        },\n    }\n}\n\nfunction indexMaskComposite(value: USSValue, mask: USSValue, reference: USSPrimitiveRawValue): { type: 'success', value: USSValue & { type: USSVectorType } } | { type: 'error', message: string } {\n    /**\n     * Indexes the value using the mask. The mask is expected to be a vector of numbers, strings, or booleans.\n     * If the mask is not a valid mask, an error is returned.\n     */\n    const valueType = value.type\n    const maskType = mask.type\n    switch (maskType.type) {\n        case 'boolean':\n        case 'number':\n        case 'string':\n        case 'null':\n            const retval = mask.value === reference ? [value.value] : []\n            return { type: 'success', value: { type: { type: 'vector', elementType: valueType }, value: retval, documentation: value.documentation } }\n        case 'vector':\n            const maskVector = mask.value as USSRawValue[]\n            if (valueType.type !== 'vector') {\n                const repeated = repeatMany(value, maskVector.length)\n                if (repeated.type === 'error') {\n                    return repeated\n                }\n                return indexMaskComposite(repeated.value, mask, reference)\n            }\n            const valueVector = value.value as USSRawValue[]\n            if (maskVector.length !== valueVector.length) {\n                return { type: 'error', message: `Mask length ${maskVector.length} does not match value length ${valueVector.length}` }\n            }\n            let referenceType: USSType | undefined | { type: 'elementOfEmptyVector' } = undefined\n            const results: USSRawValue[] = []\n            for (let i = 0; i < maskVector.length; i++) {\n                assert(valueType.elementType.type !== 'elementOfEmptyVector', `Value element type cannot be elementOfEmptyVector, got ${renderType(valueType)}`)\n                assert(maskType.elementType.type !== 'elementOfEmptyVector', `Mask element type cannot be elementOfEmptyVector, got ${renderType(maskType)}`)\n                const resultsOrErr = indexMaskComposite(\n                    { type: valueType.elementType, value: valueVector[i], documentation: value.documentation },\n                    { type: maskType.elementType, value: maskVector[i], documentation: mask.documentation },\n                    reference,\n                )\n                if (resultsOrErr.type === 'error') {\n                    return resultsOrErr\n                }\n                results.push(...(resultsOrErr.value.value as USSRawValue[]))\n                const elt = resultsOrErr.value.type.elementType\n                referenceType = referenceType === undefined ? elt : unifyType(referenceType, elt, () => new Error('Should be unreachable'))\n            }\n            assert(referenceType !== undefined, 'already handled empty vector case')\n            return { type: 'success', value: { type: { type: 'vector', elementType: referenceType }, value: results, documentation: value.documentation } }\n        /* c8 ignore start */\n        // If we reach here, it means the mask is not a valid mask. We checked for this earlier.\n        case 'object':\n        case 'function':\n        case 'opaque':\n            throw new Error('this case was already handled earlier, should not be reachable')\n        /* c8 ignore stop */\n    }\n}\n\nexport function indexMask(value: USSValue, mask: USSValue, reference: USSPrimitiveRawValue): { type: 'success', value: USSValue } | { type: 'error', message: string } {\n    switch (value.type.type) {\n        case 'vector':\n        case 'object':\n            return indexMaskComposite(value, mask, reference)\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'null':\n        case 'opaque':\n        case 'function':\n            return { type: 'success', value }\n    }\n}\n\nexport function indexMaskIntoContext(\n    env: Context,\n    mask: USSValue,\n    reference: USSPrimitiveRawValue,\n): { type: 'success', value: Context } | { type: 'error', message: string } {\n    /**\n     * Indexes the mask into the context, returning a new context with the indexed values.\n     * The mask is expected to be a vector of numbers, strings, or booleans.\n     * If the mask is not a valid mask, an error is returned.\n     * The reference is used to determine which values to keep in the context.\n     */\n    const newEnv = new Map<string, USSValue>()\n    for (const [key, value] of env.variableEntries()) {\n        const indexed = indexMask(value, mask, reference)\n        if (indexed.type === 'error') {\n            return { type: 'error', message: `Error indexing variable ${key}: ${indexed.message}` }\n        }\n        newEnv.set(key, indexed.value)\n    }\n    return {\n        type: 'success',\n        value: env.evolveVariables(newEnv),\n    }\n}\n\nfunction index(v: USSValue, i: number): USSValue {\n    const valueType = v.type\n    if (valueType.type === 'vector') {\n        const valueVector = v.value as USSRawValue[]\n        assert (i >= 0 && i < valueVector.length, `Index ${i} out of bounds for vector of length ${valueVector.length}`)\n        assert(valueType.elementType.type !== 'elementOfEmptyVector', `Unreachable: should have failed earlier if elementType was elementOfEmptyVector`)\n        return { type: valueType.elementType, value: valueVector[i], documentation: v.documentation }\n    }\n    return v // If the value is not a vector, we just return it as is; broadcasting\n}\n\nfunction indexType(v: USSType): USSType {\n    /**\n     * Indexes the type of a value, returning the type of the indexed value.\n     * If the value is not a vector, we just return the type as is.\n     */\n    if (v.type === 'vector') {\n        assert(v.elementType.type !== 'elementOfEmptyVector', `Unreachable: should have failed earlier if elementType was elementOfEmptyVector`)\n        return v.elementType\n    }\n    return v // If the value is not a vector, we just return it as is; broadcasting\n}\n\nfunction defaultValueForType(type: USSType): USSRawValue {\n    switch (type.type) {\n        case 'number':\n            return NaN\n        case 'string':\n            return ''\n        case 'boolean':\n            return false\n        case 'null':\n            return null\n        case 'vector':\n            return []\n        case 'object':\n            return new Map<string, USSRawValue>([...type.properties.entries()].map(([k, v]) => [k, defaultValueForType(v)]))\n        case 'function':\n            return () => {\n                throw new Error(`no default value for function type ${renderType(type)}`)\n            }\n        case 'opaque':\n            throw new Error(`no default value for opaque type ${renderType(type)}`)\n    }\n}\n\ntype MergeResult = { type: 'success', value: USSValue } | { type: 'error', message: string }\n\nfunction mergeValuesViaMasksSpecialCaseMap(\n    values: USSValue[],\n): MergeResult | undefined {\n    /**\n     * Special case for maps; we handle the case where exactly one value is present.\n     */\n    const nonNullValues = values.filter(x => x.type.type !== 'null')\n    if (nonNullValues.length !== 1) {\n        // If there are no non-null values or more than one, we cannot merge\n        return undefined\n    }\n    const nonNullValue = nonNullValues[0]\n    if (nonNullValue.type.type !== 'opaque' || (nonNullValue.type.name !== 'cMap' && nonNullValue.type.name !== 'cMapRGB' && nonNullValue.type.name !== 'pMap')) {\n        // If the non-null value is not a map, this is not a special case we handle\n        return undefined\n    }\n    return {\n        type: 'success',\n        value: nonNullValue,\n    }\n}\n\n/**\n * Attempt to coerce the given value to the given type. This is used to ensure splitMask\n * does not change the type of the value when possible.\n */\nfunction attemptCoerceToType(value: USSValue, toType: USSType): USSValue | undefined {\n    if (renderType(value.type) === renderType(toType)) {\n        // success!\n        return value\n    }\n    if (value.type.type === 'vector') {\n        const contents = value.value as USSRawValue[]\n        if (contents.length > 0 && contents.every(x => x === contents[0])) {\n            assert(value.type.elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType was elementOfEmptyVector but contents is non-empty`)\n            // all elements are the same, we can coerce\n            return attemptCoerceToType({\n                type: value.type.elementType,\n                value: contents[0],\n                documentation: value.documentation,\n            }, toType)\n        }\n    }\n    return undefined\n}\n\nexport function mergeValuesViaMasks(\n    values: USSValue[],\n    mask: USSValue & { type: USSVectorType },\n    references: USSPrimitiveRawValue[],\n): MergeResult {\n    // special cases\n    const specialCase = mergeValuesViaMasksSpecialCaseMap(values)\n    if (specialCase !== undefined) {\n        return specialCase\n    }\n\n    const types = values.map(x => x.type).filter(x => x.type !== 'null').map(indexType)\n    if (types.length === 0) {\n        return { type: 'success', value: undocValue(null, { type: 'null' }) }\n    }\n    const firstType = types[0]\n    if (types.some(x => renderType(x) !== renderType(firstType))) {\n        const uniqueTypeReprs = Array.from(new Set(types.map(renderType))).sort()\n        return { type: 'error', message: `Cannot merge values of different types: ${uniqueTypeReprs.join(', ')}` }\n    }\n\n    assert (values.length === references.length, `Expected the number of values (${values.length}) to match the number of references (${references.length})`)\n    const mType = mask.type\n    if (mType.elementType.type !== 'boolean' && mType.elementType.type !== 'number' && mType.elementType.type !== 'string') {\n        return { type: 'error', message: `Cannot condition on a mask of type ${renderType(mType)}` }\n    }\n    const maskVector = mask.value as USSPrimitiveRawValue[]\n    const indices = Array.from({ length: values.length }, () => 0)\n    const result: (USSValue | undefined)[] = []\n    for (let i = 0; i < maskVector.length; i++) {\n        const whichValue = references.indexOf(maskVector[i])\n        assert (whichValue !== -1, `Reference ${references[i]} not found in mask}`)\n        // special case null values.\n        result.push(values[whichValue].type.type === 'null' ? undefined : index(values[whichValue], indices[whichValue]))\n        indices[whichValue]++\n    }\n    let defaultV: USSRawValue | undefined = undefined\n    const finalRes = result.map(\n        (x) => {\n            if (x !== undefined) {\n                return x.value\n            }\n            if (defaultV === undefined) {\n                defaultV = defaultValueForType(firstType)\n            }\n            return defaultV satisfies USSRawValue\n        },\n    )\n    const finalResValue = {\n        type: { type: 'vector', elementType: types[0] },\n        value: finalRes,\n        documentation: values.find(x => x.documentation !== undefined)?.documentation,\n    } satisfies USSValue\n    return {\n        type: 'success',\n        value: attemptCoerceToType(finalResValue, firstType) ?? finalResValue,\n    }\n}\n\nexport function splitMask(env: Context, mask: USSValue, fn: (value: USSValue, subEnv: Context) => USSValue, errLocCondition: LocInfo, errLocIf: LocInfo): USSValue {\n    /**\n     * Splits the mask into its unique values and applies the function to each value.\n     * The function is expected to return a USSValue.\n     * If the mask is not a valid mask, an error is thrown.\n     */\n    const collectIn = new Set<USSPrimitiveRawValue>()\n    if (!collectUniqueMaskValues(collectIn, mask)) {\n        throw env.error(`Conditional mask must be a vector of numbers, strings, or booleans, but got ${renderType(mask.type)}`, errLocCondition)\n    }\n    const uniqueValueArray = Array.from(collectIn).sort((a, b) => {\n        // stringify the values to compare them\n        const sa = JSON.stringify(a)\n        const sb = JSON.stringify(b)\n        if (sa < sb) return -1\n        if (sa > sb) return 1\n        return 0\n    })\n    if (uniqueValueArray.length === 0) {\n        throw env.error(`Conditional mask must have at least one unique value, but got none`, errLocCondition)\n    }\n    const maskType = mask.type\n    if (uniqueValueArray.length === 1) {\n        // if there is only one unique value, we can just return the result of the function\n        return fn({ type: getPrimitiveType(uniqueValueArray[0]), value: uniqueValueArray[0], documentation: mask.documentation }, env)\n    }\n    assert(maskType.type === 'vector', 'unreachable')\n    const outEnvsValues = uniqueValueArray.map((value) => {\n        const subEnv = indexMaskIntoContext(env, mask, value)\n        if (subEnv.type === 'error') {\n            throw env.error(`Conditional error: ${subEnv.message}`, errLocCondition)\n        }\n        assert(maskType.elementType.type !== 'elementOfEmptyVector', `Unreachable: should have failed earlier if elementType was elementOfEmptyVector`)\n        const result = fn({ type: getPrimitiveType(value), value, documentation: mask.documentation }, subEnv.value)\n        return [result, subEnv.value] satisfies [USSValue, Context]\n    })\n    const newVars = new Map<string, USSValue>()\n    const allKeys = new Set<string>()\n    for (const [, subEnv] of outEnvsValues) {\n        for (const [k] of subEnv.variableEntries()) {\n            allKeys.add(k)\n        }\n    }\n    for (const k of allKeys) {\n        const values = outEnvsValues.map(([, subEnv]) => subEnv.getVariable(k) ?? undocValue(null, { type: 'null' }) satisfies USSValue)\n        assert(mask.type.type === 'vector', 'unreachable')\n        const merged = mergeValuesViaMasks(values, mask as USSValue & { type: USSVectorType }, uniqueValueArray)\n        if (merged.type === 'error') {\n            throw env.error(`Error merging values for variable ${k}: ${merged.message}`, errLocIf)\n        }\n        if (merged.value.type.type === 'null') {\n            // If the merged value is null, we don't add it to the new variables\n            continue\n        }\n        newVars.set(k, merged.value)\n    }\n    for (const [k, v] of newVars.entries()) {\n        const err = env.assignVariable(k, v)\n        assert(err === undefined, `Error assigning variable ${k}: ${err}`)\n    }\n    const mergedValues = mergeValuesViaMasks(\n        outEnvsValues.map(([v]) => v),\n        mask as USSValue & { type: USSVectorType },\n        uniqueValueArray,\n    )\n    if (mergedValues.type === 'error') {\n        // If the types do not match, return null\n        return undocValue(null, { type: 'null' })\n    }\n    return mergedValues.value\n}\n","import { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTStatement, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTArg, locationOf, unify } from './ast'\nimport { Context } from './context'\nimport { addAdditionalDims, broadcastApply, broadcastCall } from './forward-broadcasting'\nimport { LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\nimport { splitMask } from './split-broadcasting'\nimport { renderType, unifyType, USSRawValue, USSType, USSValue, USSVectorType, ValueArg, undocValue, canUnifyTo } from './types-values'\n\nexport interface Effect { type: 'warning', message: string, location: LocInfo }\n\nexport function renderLocInfo(loc: LocInfo): string {\n    if (loc.start.lineIdx === loc.end.lineIdx) {\n        if (loc.start.colIdx + 1 === loc.end.colIdx) {\n            // Single character location\n            return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}`\n        }\n        return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}-${loc.end.colIdx}`\n    }\n    return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1} - ${loc.end.lineIdx + 1}:${loc.end.colIdx}`\n}\n\nexport class InterpretationError extends Error {\n    public value: string\n    constructor(message: string, public location: LocInfo) {\n        super(`${message} at ${renderLocInfo(location)}`)\n        this.name = 'InterpretationError'\n        this.value = message\n        this.location = location\n    }\n}\n\nexport function evaluate(expr: UrbanStatsASTExpression, env: Context): USSValue {\n    switch (expr.type) {\n        case 'constant':\n            const value = expr.value.node\n            if (value.type === 'number') {\n                return undocValue(value.value, { type: 'number' })\n            }\n            return undocValue(value.value satisfies string, { type: 'string' })\n        case 'identifier':\n            const varName = expr.name.node\n            const res = env.getVariable(varName)\n            if (res !== undefined) {\n                return res\n            }\n            throw env.error(`Undefined variable: ${varName}`, expr.name.location)\n        case 'attribute':\n            const obj = evaluate(expr.expr, env)\n            const attr = expr.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, undefined)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(expr))\n            }\n            return lookupResult.value\n        case 'call':\n            const func = evaluate(expr.fn, env)\n            const args = expr.args.map(arg => evaluateArg(arg, env))\n            const broadcastResult = broadcastCall(func, args, env, locationOf(expr))\n            if (broadcastResult.type === 'error') {\n                throw env.error(broadcastResult.message, locationOf(expr))\n            }\n            return broadcastResult.result\n        case 'unaryOperator':\n            const operand = evaluate(expr.expr, env)\n            return evaluateUnaryOperator(operand, expr.operator.node, env, locationOf(expr))\n        case 'binaryOperator':\n            const left = evaluate(expr.left, env)\n            const right = evaluate(expr.right, env)\n            return evaluateBinaryOperator(left, right, expr.operator.node, env, locationOf(expr))\n        case 'vectorLiteral':\n            const elements = expr.elements.map(e => evaluate(e, env))\n            let elementType = { type: 'elementOfEmptyVector' } as USSType | { type: 'elementOfEmptyVector' }\n            for (const e of elements) {\n                elementType = unifyType(elementType, e.type, () => {\n                    assert(elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(e.value)}`)\n                    return env.error(`vector literal contains heterogenous types ${renderType(elementType)} and ${renderType(e.type)}`, locationOf(expr))\n                })\n            }\n            return undocValue(elements.map(e => e.value), { type: 'vector', elementType })\n        case 'objectLiteral':\n            const ts = new Map<string, USSType>()\n            const vs = new Map<string, USSRawValue>()\n            for (const [name, e] of expr.properties) {\n                const v = evaluate(e, env)\n                if (ts.has(name)) {\n                    throw env.error(`Duplicate key ${name} in object literal`, locationOf(e))\n                }\n                ts.set(name, v.type)\n                vs.set(name, v.value)\n            }\n            return undocValue(vs, {\n                type: 'object',\n                properties: ts,\n            })\n        case 'if':\n            const condition = evaluate(expr.condition, env)\n            return splitMask(\n                env,\n                condition,\n                (v: USSValue, subEnv: Context): USSValue => {\n                    if (v.type.type !== 'boolean') {\n                        throw env.error(`Condition in if statement must be a boolean, but got ${renderType(v.type)}`, locationOf(expr.condition))\n                    }\n                    if (v.value) {\n                        return execute(expr.then, subEnv)\n                    }\n                    if (expr.else === undefined) {\n                        return undocValue(null, { type: 'null' })\n                    }\n                    return execute(expr.else, subEnv)\n                },\n                locationOf(expr.condition),\n                locationOf(expr),\n            )\n        case 'do':\n            if (expr.statements.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let doResult: USSValue = execute(expr.statements[0], env)\n            for (const statement of expr.statements.slice(1)) {\n                doResult = execute(statement, env)\n            }\n            return doResult\n        case 'customNode':\n            // This is a custom node for internal purposes, we just evaluate the expression\n            const result = execute(expr.expr, env)\n\n            // Check type if expectedType is provided\n            if (expr.expectedType && !expr.expectedType.some(t => canUnifyTo(result.type, t))) {\n                throw env.error(\n                    `Custom expression expected to return type ${expr.expectedType.map(t => renderType(t)).join(' or ')}, but got ${renderType(result.type)}`,\n                    locationOf(expr),\n                )\n            }\n\n            return result\n    }\n}\n\nexport function execute(expr: UrbanStatsASTStatement, env: Context): USSValue {\n    switch (expr.type) {\n        case 'condition':\n            if (expr.rest.length === 0) {\n                throw env.error('condition(..) must be followed by at least one statement', locationOf(expr))\n            }\n            return evaluate(\n                { type: 'if',\n                    condition: expr.condition,\n                    then: { type: 'statements', result: expr.rest, entireLoc: unify(...expr.rest.map(locationOf)) },\n                    entireLoc: expr.entireLoc,\n                },\n                env,\n            )\n        case 'assignment':\n            const value = evaluate(expr.value, env)\n            evaluateLHS(expr.lhs, value, env)\n            return value\n        case 'expression':\n            return evaluate(expr.value, env)\n        case 'statements':\n            if (expr.result.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let result: USSValue = execute(expr.result[0], env)\n            for (const statement of expr.result.slice(1)) {\n                result = execute(statement, env)\n            }\n            return result\n        case 'parseError':\n            assert(expr.errors.length > 0, 'parseError node must have at least one error')\n            throw env.error(\n                `Parse error: ${expr.errors.map(e => e.value).join(', ')}`,\n                expr.errors[0].location,\n            )\n    }\n}\n\nexport function evaluateLHS(lhs: UrbanStatsASTLHS, value: USSValue, env: Context): void {\n    switch (lhs.type) {\n        case 'identifier':\n            const varName = lhs.name.node\n            const err = env.assignVariable(varName, value)\n            if (err !== undefined) {\n                throw env.error(err, locationOf(lhs))\n            }\n            return\n        case 'attribute':\n            const obj = evaluate(lhs.expr, env)\n            const attr = lhs.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, value)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(lhs))\n            }\n            return\n    }\n}\n\nfunction evaluateArg(arg: UrbanStatsASTArg, env: Context): ValueArg {\n    switch (arg.type) {\n        case 'named':\n            return {\n                type: 'named',\n                name: arg.name.node,\n                value: evaluate(arg.value, env),\n            }\n        case 'unnamed':\n            return {\n                type: 'unnamed',\n                value: evaluate(arg.value, env),\n            }\n    }\n}\n\nfunction attrLookupOrSet(\n    obj: USSValue,\n    attr: string,\n    orSet: USSValue | undefined,\n): { type: 'success', value: USSValue } | { type: 'error', message: string } {\n    const type = obj.type\n    if (type.type === 'object') {\n        const val = obj.value\n        assert(val instanceof Map, `Expected object type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        const aT = type.properties.get(attr)\n        if (aT === undefined) {\n            return {\n                type: 'error',\n                message: `Attribute ${attr} not found in object of type ${renderType(type)}`,\n            }\n        }\n        if (orSet !== undefined) {\n            if (renderType(aT) !== renderType(orSet.type)) {\n                return {\n                    type: 'error',\n                    message: `Type mismatch: expected ${renderType(aT)} but got ${renderType(orSet.type)} for attribute ${attr} in object of type ${renderType(type)}`,\n                }\n            }\n            // If orSet is provided, we set the attribute to the value\n            val.set(attr, orSet.value)\n            return {\n                type: 'success',\n                value: undocValue(orSet.value, aT),\n            }\n        }\n        const content = val.get(attr)\n        assert(content !== undefined, `Expected attribute ${attr} to be defined in object, but got undefined at ${JSON.stringify(obj.value)}`)\n        return {\n            type: 'success',\n            value: undocValue(val.get(attr)!, aT),\n        }\n    }\n    if (type.type === 'vector') {\n        const val = obj.value\n        assert(val instanceof Array, `Expected vector type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        let orSetLookp: (idx: number) => USSValue | undefined = () => undefined\n        if (orSet !== undefined) {\n            if (orSet.type.type !== 'vector') {\n                orSet = undocValue(addAdditionalDims([val.length], orSet.value), { type: 'vector', elementType: orSet.type })\n            }\n            assert(Array.isArray(orSet.value), `It should be an array at this point`)\n            if (orSet.value.length !== val.length) {\n                return { type: 'error', message: `Expected vector of length ${val.length} but got ${orSet.value.length} for attribute ${attr} in object of type ${renderType(type)}` }\n            }\n            const v = orSet.value\n            const t = (orSet.type as USSVectorType).elementType\n            assert(t.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(orSet.value)}`)\n            orSetLookp = (idx: number) => {\n                return undocValue(v[idx], t)\n            }\n        }\n        const resultsOrErr = val.map((x, i) => {\n            assert(type.elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(obj.value)}`)\n            return attrLookupOrSet(undocValue(x, type.elementType), attr, orSetLookp(i))\n        })\n        if (resultsOrErr.some(r => r.type === 'error')) {\n            return { type: 'error', message: resultsOrErr.filter(r => r.type === 'error').map(r => (r as { type: 'error', message: string }).message)[0] }\n        }\n        const results = resultsOrErr.map(r => (r as { type: 'success', value: USSValue }).value)\n        const rawValue = results.map(r => r.value)\n        const typ = results[0].type\n        return {\n            type: 'success',\n            value: undocValue(rawValue, { type: 'vector', elementType: typ }),\n        }\n    }\n    return { type: 'error', message: `Cannot access attribute of type ${renderType(type)}. Only objects and vectors support attributes.` }\n}\n\nfunction evaluateUnaryOperator(operand: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.unary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.unary(operator, errLoc),\n        [operand],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n\nfunction evaluateBinaryOperator(left: USSValue, right: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.binary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.binary(operator, errLoc),\n        [left, right],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n","/* c8 ignore start */\n\nimport assert from 'assert'\n\nimport { UrbanStatsASTStatement, UrbanStatsASTExpression } from '../src/urban-stats-script/ast'\nimport { defaultConstants } from '../src/urban-stats-script/constants/constants'\nimport { Context } from '../src/urban-stats-script/context'\nimport { Effect, InterpretationError } from '../src/urban-stats-script/interpreter'\nimport { LocInfo } from '../src/urban-stats-script/location'\nimport { parse, toSExp, unparse } from '../src/urban-stats-script/parser'\nimport { USSRawValue, USSType, USSValue, createConstantExpression, OriginalFunctionArgs } from '../src/urban-stats-script/types-values'\n\nexport const numType = { type: 'number' } satisfies USSType\nexport const boolType = { type: 'boolean' } satisfies USSType\nexport const stringType = { type: 'string' } satisfies USSType\nexport const numVectorType = { type: 'vector', elementType: numType } satisfies USSType\nexport const numMatrixType = { type: 'vector', elementType: numVectorType } satisfies USSType\nexport const multiObjType = {\n    type: 'object',\n    properties: new Map<string, USSType>([\n        ['a', numType],\n        ['b', numVectorType],\n    ]),\n} satisfies USSType\nexport const multiObjVectorType = {\n    type: 'vector',\n    elementType: multiObjType,\n} satisfies USSType\n\nexport const testFnType = {\n    type: 'function',\n    posArgs: [{ type: 'concrete', value: numType }], namedArgs: { a: { type: { type: 'concrete', value: numType } } }, returnType: { type: 'concrete', value: numType } } satisfies USSType\n\nexport const testFn1: USSRawValue = (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => (posArgs[0] as number) * (posArgs[0] as number) + (namedArgs.a as number)\nexport const testFn2: USSRawValue = (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => (posArgs[0] as number) * (posArgs[0] as number) * (posArgs[0] as number) + (namedArgs.a as number)\n\nexport const testFnTypeWithDefault = {\n    type: 'function',\n    posArgs: [{ type: 'concrete', value: numType }],\n    namedArgs: { a: { type: { type: 'concrete', value: numType } }, b: { type: { type: 'concrete', value: numType }, defaultValue: createConstantExpression(1) } },\n    returnType: { type: 'concrete', value: numType },\n} satisfies USSType\n\nexport const testFnWithDefault: USSRawValue = (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue =>\n    (posArgs[0] as number) * (posArgs[0] as number) * (posArgs[0] as number) + (namedArgs.a as number) + 10 * (namedArgs.b as number)\n\nexport const testObjType = {\n    type: 'object',\n    properties: new Map<string, USSType>([\n        ['u', numType],\n        ['v', numType],\n    ]),\n} satisfies USSType\n\nexport const multiArgFnType = {\n    type: 'function',\n    posArgs: [{ type: 'concrete', value: numType }, { type: 'concrete', value: numVectorType }],\n    namedArgs: { a: { type: { type: 'concrete', value: numType } }, b: { type: { type: 'concrete', value: testObjType } } },\n    returnType: { type: 'concrete', value: numVectorType },\n} satisfies USSType\n\nexport function testFnMultiArg(ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue {\n    const x = posArgs[0] as number\n    const y = posArgs[1] as number[]\n    const a = namedArgs.a as number\n    const b = namedArgs.b as Map<string, USSRawValue>\n    return [\n        x,\n        y.reduce((acc, val) => acc + val, 0),\n        y.reduce((acc, val) => acc + val * val, 0),\n        a,\n        b.get('u') as number,\n        b.get('v') as number,\n    ]\n}\n\nexport function testingContext(effectsOut: Effect[], errorsOut: { msg: string, location: LocInfo }[], env: Map<string, USSValue>): Context {\n    return new Context(\n        (eff: Effect) => effectsOut.push(eff),\n        (msg: string, location: LocInfo) => {\n            const error = new InterpretationError(msg, location)\n            errorsOut.push({ msg, location })\n            return error\n        },\n        defaultConstants,\n        env,\n    )\n}\n\nexport function emptyContext(effects: Effect[] | undefined = undefined): Context {\n    return new Context(\n        (eff) => {\n            if (effects !== undefined) {\n                effects.push(eff)\n            }\n        },\n        (msg: string, location: LocInfo) => {\n            return new InterpretationError(msg, location)\n        },\n        defaultConstants,\n        new Map<string, USSValue>(),\n    )\n}\n\nexport function emptyContextWithInsets(effects: Effect[] | undefined = undefined): Context {\n    const insetContinentalUSA = defaultConstants.get('insetContinentalUSA')\n    const insetHawaii = defaultConstants.get('insetHawaii')\n    const insetAlaska = defaultConstants.get('insetAlaska')\n    const insetGuam = defaultConstants.get('insetGuam')\n    const insetPuertoRicoUSVI = defaultConstants.get('insetPuertoRicoPlusUSVI')\n    const constructInsets = defaultConstants.get('constructInsets')\n\n    assert(insetContinentalUSA !== undefined, 'Expected insetContinentalUSA to be defined in defaultConstants')\n    assert(insetHawaii !== undefined, 'Expected insetHawaii to be defined in defaultConstants')\n    assert(insetAlaska !== undefined, 'Expected insetAlaska to be defined in defaultConstants')\n    assert(insetGuam !== undefined, 'Expected insetGuam to be defined in defaultConstants')\n    assert(insetPuertoRicoUSVI !== undefined, 'Expected insetPuertoRicoPlusUSVI to be defined in defaultConstants')\n    assert(constructInsets !== undefined, 'Expected constructInsets to be defined in defaultConstants')\n\n    // Create a USA insets collection from the individual insets\n    const insetArray = [insetContinentalUSA.value, insetHawaii.value, insetAlaska.value, insetGuam.value, insetPuertoRicoUSVI.value]\n\n    // Cast to function type and call\n    const constructInsetsFunc = constructInsets.value as (\n        ctx: Context,\n        posArgs: USSRawValue[],\n        namedArgs: Record<string, USSRawValue>,\n        originalArgs?: OriginalFunctionArgs\n    ) => USSRawValue\n\n    const usaInsets = constructInsetsFunc({} as Context, [insetArray], {})\n\n    // Create a default geo variable with geoFeatureHandle type\n    const defaultGeo = [\n        { type: 'opaque' as const, opaqueType: 'geoFeatureHandle' as const, value: 'A' },\n        { type: 'opaque' as const, opaqueType: 'geoFeatureHandle' as const, value: 'B' },\n        { type: 'opaque' as const, opaqueType: 'geoFeatureHandle' as const, value: 'C' },\n    ]\n\n    return new Context(\n        (eff) => {\n            if (effects !== undefined) {\n                effects.push(eff)\n            }\n        },\n        (msg: string, location: LocInfo) => {\n            return new InterpretationError(msg, location)\n        },\n        defaultConstants,\n        new Map<string, USSValue>([\n            ['defaultInsets', { type: { type: 'opaque', name: 'insets' }, value: usaInsets, documentation: { humanReadableName: 'USA Insets' } }],\n            ['geo', { type: { type: 'vector', elementType: { type: 'opaque', name: 'geoFeatureHandle' } }, value: defaultGeo, documentation: { humanReadableName: 'Geography' } }],\n        ]),\n    )\n}\n\nfunction checkUnparseForInline(parsed: UrbanStatsASTExpression | UrbanStatsASTStatement | { type: 'error' }, inline: boolean): void {\n    if (parsed.type === 'error') {\n        return\n    }\n    const unparsed = unparse(parsed, { inline, expressionalContext: inline })\n    const reparsed = parse(unparsed, { type: 'single', ident: 'test' })\n    if (reparsed.type === 'error') {\n        throw new Error(`Reparsed AST of\\n${unparsed}\\nis an error: ${JSON.stringify(reparsed)}`)\n    }\n    assert.deepStrictEqual(toSExp(parsed), toSExp(reparsed), `Unparsed and reparsed rendering do not match:\\n\\t${toSExp(parsed)}\\nUnparsed: ${unparsed}\\nReparsed:\\n\\t${toSExp(reparsed)}`)\n}\n\nfunction checkUnparse(parsed: UrbanStatsASTExpression | UrbanStatsASTStatement | { type: 'error' }): void {\n    checkUnparseForInline(parsed, false)\n    checkUnparseForInline(parsed, true)\n}\n\nexport function parseExpr(input: string): UrbanStatsASTExpression {\n    const parsed = parse(input, { type: 'single', ident: 'test' })\n    checkUnparse(parsed)\n    if (parsed.type !== 'expression') {\n        throw new Error(`Expected an expression, but got ${JSON.stringify(parsed)}`)\n    }\n    return parsed.value\n}\n\nexport function parseProgram(input: string): UrbanStatsASTStatement {\n    const parsed = parse(input, { type: 'single', ident: 'test' })\n    checkUnparse(parsed)\n    if (parsed.type !== 'assignment' && parsed.type !== 'statements' && parsed.type !== 'expression' && parsed.type !== 'condition') {\n        throw new Error(`Expected an assignment or statements, but got ${JSON.stringify(parsed)}`)\n    }\n    return parsed\n}\n/* c8 ignore end */\n","export default [\n    \"County\",\n    \"MSA\",\n    \"CSA\",\n    \"Urban Area\",\n    \"ZIP\",\n    \"CCD\",\n    \"City\",\n    \"Neighborhood\",\n    \"Congressional District\",\n    \"State House District\",\n    \"State Senate District\",\n    \"Congressional District (1780s)\",\n    \"Congressional District (1790s)\",\n    \"Congressional District (1800s)\",\n    \"Congressional District (1810s)\",\n    \"Congressional District (1820s)\",\n    \"Congressional District (1830s)\",\n    \"Congressional District (1840s)\",\n    \"Congressional District (1850s)\",\n    \"Congressional District (1860s)\",\n    \"Congressional District (1870s)\",\n    \"Congressional District (1880s)\",\n    \"Congressional District (1890s)\",\n    \"Congressional District (1900s)\",\n    \"Congressional District (1910s)\",\n    \"Congressional District (1920s)\",\n    \"Congressional District (1930s)\",\n    \"Congressional District (1940s)\",\n    \"Congressional District (1950s)\",\n    \"Congressional District (1960s)\",\n    \"Congressional District (1970s)\",\n    \"Congressional District (1980s)\",\n    \"Congressional District (1990s)\",\n    \"Congressional District (2000s)\",\n    \"Congressional District (2010s)\",\n    \"Congressional District (2020s)\",\n    \"Native Area\",\n    \"Native Statistical Area\",\n    \"Native Subdivision\",\n    \"School District\",\n    \"Judicial District\",\n    \"Judicial Circuit\",\n    \"County Cross CD\",\n    \"USDA County Type\",\n    \"Hospital Referral Region\",\n    \"Hospital Service Area\",\n    \"Media Market\",\n    \"CA Census Division\",\n    \"CA Census Subdivision\",\n    \"CA Population Center\",\n    \"CA CMA\",\n    \"CA Riding\",\n    \"Continent\",\n    \"Country\",\n    \"Subnational Region\",\n    \"Urban Center\",\n    \"Metropolitan Cluster\",\n    \"5M Person Circle\",\n    \"10M Person Circle\",\n    \"20M Person Circle\",\n    \"50M Person Circle\",\n    \"100M Person Circle\",\n    \"200M Person Circle\",\n    \"500M Person Circle\",\n    \"1B Person Circle\"\n] as const","export default [\n    \"2008 Presidential Election-margin\",\n    \"2008-2012 Swing-margin\",\n    \"2012 Presidential Election-margin\",\n    \"2012-2016 Swing-margin\",\n    \"2016 Presidential Election-margin\",\n    \"2016-2020 Swing-margin\",\n    \"2020 Presidential Election-margin\",\n    \"2020-2024 Swing-margin\",\n    \"2024 Presidential Election-margin\",\n    \"ARTHRITIS_cdc_2\",\n    \"BINGE_cdc_2\",\n    \"BPHIGH_cdc_2\",\n    \"CANCER_cdc_2\",\n    \"CASTHMA_cdc_2\",\n    \"CHD_cdc_2\",\n    \"CHECKUP_cdc_2\",\n    \"CHOLSCREEN_cdc_2\",\n    \"COGNITION_cdc_2\",\n    \"COPD_cdc_2\",\n    \"CSMOKING_cdc_2\",\n    \"DENTAL_cdc_2\",\n    \"DIABETES_cdc_2\",\n    \"DISABILITY_cdc_2\",\n    \"GHLTH_cdc_2\",\n    \"HEARING_cdc_2\",\n    \"INDEPLIVE_cdc_2\",\n    \"KIDNEY_cdc_2\",\n    \"LPA_cdc_2\",\n    \"MOBILITY_cdc_2\",\n    \"OBESITY_cdc_2\",\n    \"PHLTH_cdc_2\",\n    \"SELFCARE_cdc_2\",\n    \"SLEEP_cdc_2\",\n    \"STROKE_cdc_2\",\n    \"VISION_cdc_2\",\n    \"ad_0.25\",\n    \"ad_0.25_2000\",\n    \"ad_0.25_2010\",\n    \"ad_0.25_change_2000\",\n    \"ad_0.25_change_2010\",\n    \"ad_0.5\",\n    \"ad_0.5_2000\",\n    \"ad_0.5_2010\",\n    \"ad_0.5_change_2000\",\n    \"ad_0.5_change_2010\",\n    \"ad_1\",\n    \"ad_1.609344\",\n    \"ad_1.609344_2000\",\n    \"ad_1.609344_2010\",\n    \"ad_1.609344_change_2000\",\n    \"ad_1.609344_change_2010\",\n    \"ad_16\",\n    \"ad_16_2000\",\n    \"ad_16_2010\",\n    \"ad_16_change_2000\",\n    \"ad_16_change_2010\",\n    \"ad_1_2000\",\n    \"ad_1_2010\",\n    \"ad_1_change_2000\",\n    \"ad_1_change_2010\",\n    \"ad_2\",\n    \"ad_2_2000\",\n    \"ad_2_2010\",\n    \"ad_2_change_2000\",\n    \"ad_2_change_2010\",\n    \"ad_32\",\n    \"ad_32_2000\",\n    \"ad_32_2010\",\n    \"ad_32_change_2000\",\n    \"ad_32_change_2010\",\n    \"ad_4\",\n    \"ad_4_2000\",\n    \"ad_4_2010\",\n    \"ad_4_change_2000\",\n    \"ad_4_change_2010\",\n    \"ad_64\",\n    \"ad_64_2000\",\n    \"ad_64_2010\",\n    \"ad_64_change_2000\",\n    \"ad_64_change_2010\",\n    \"ad_8\",\n    \"ad_8_2000\",\n    \"ad_8_2010\",\n    \"ad_8_change_2000\",\n    \"ad_8_change_2010\",\n    \"area\",\n    \"asian\",\n    \"asian_2000\",\n    \"asian_2010\",\n    \"birthplace_non_us\",\n    \"birthplace_us_not_state\",\n    \"birthplace_us_state\",\n    \"black\",\n    \"black_2000\",\n    \"black_2010\",\n    \"citizenship_citizen_by_birth\",\n    \"citizenship_citizen_by_naturalization\",\n    \"citizenship_not_citizen\",\n    \"compactness\",\n    \"days_above_90_4\",\n    \"days_below_40_4\",\n    \"days_between_40_and_90_4\",\n    \"days_dewpoint_-inf_50_4\",\n    \"days_dewpoint_50_70_4\",\n    \"days_dewpoint_70_inf_4\",\n    \"density_2021_pw_0.25_canada\",\n    \"density_2021_pw_0.5_canada\",\n    \"density_2021_pw_1.609344_canada\",\n    \"density_2021_pw_16_canada\",\n    \"density_2021_pw_1_canada\",\n    \"density_2021_pw_2_canada\",\n    \"density_2021_pw_32_canada\",\n    \"density_2021_pw_4_canada\",\n    \"density_2021_pw_64_canada\",\n    \"density_2021_pw_8_canada\",\n    \"education_field_business\",\n    \"education_field_humanities\",\n    \"education_field_stem\",\n    \"education_grad\",\n    \"education_grad_canada\",\n    \"education_high_school\",\n    \"education_high_school_canada\",\n    \"education_ugrad\",\n    \"education_ugrad_canada\",\n    \"female_grad_gap_4\",\n    \"female_hs_gap_4\",\n    \"female_ugrad_gap_4\",\n    \"generation_boomer\",\n    \"generation_boomer_canada\",\n    \"generation_genalpha\",\n    \"generation_genalpha_canada\",\n    \"generation_genx\",\n    \"generation_genx_canada\",\n    \"generation_genz\",\n    \"generation_genz_canada\",\n    \"generation_millenial\",\n    \"generation_millenial_canada\",\n    \"generation_silent\",\n    \"generation_silent_canada\",\n    \"gpw_aw_density\",\n    \"gpw_population\",\n    \"gpw_pw_density_1\",\n    \"gpw_pw_density_1.609344\",\n    \"gpw_pw_density_16\",\n    \"gpw_pw_density_2\",\n    \"gpw_pw_density_32\",\n    \"gpw_pw_density_4\",\n    \"gpw_pw_density_64\",\n    \"gpw_pw_density_8\",\n    \"gridded_elevation\",\n    \"gridded_hilliness\",\n    \"hawaiian_pi\",\n    \"hawaiian_pi_2000\",\n    \"hawaiian_pi_2010\",\n    \"heating_bottled_tank_lp_gas\",\n    \"heating_electricity\",\n    \"heating_feul_oil_kerosene\",\n    \"heating_no\",\n    \"heating_other\",\n    \"heating_utility_gas\",\n    \"hispanic\",\n    \"hispanic_2000\",\n    \"hispanic_2010\",\n    \"homogeneity_250_2000\",\n    \"homogeneity_250_2010\",\n    \"homogeneity_250_2020\",\n    \"homogeneity_250_diff_2000\",\n    \"homogeneity_250_diff_2010\",\n    \"hours_sunny_4\",\n    \"household_income_50_to_100cad\",\n    \"household_income_50k_to_100k\",\n    \"household_income_above_100_cad\",\n    \"household_income_over_100k\",\n    \"household_income_under_50cad\",\n    \"household_income_under_50k\",\n    \"housing_per_pop\",\n    \"housing_per_pop_2000\",\n    \"housing_per_pop_2010\",\n    \"individual_income_50_to_100cad\",\n    \"individual_income_50k_to_100k\",\n    \"individual_income_above_100_cad\",\n    \"individual_income_over_100k\",\n    \"individual_income_under_50cad\",\n    \"individual_income_under_50k\",\n    \"industry_accommodation_and_food_services\",\n    \"industry_accommodation_and_food_services_canada\",\n    \"industry_administrative_and_support_and_waste_management_services\",\n    \"industry_administrative_and_support_and_waste_management_services_canada\",\n    \"industry_agriculture,_forestry,_fishing_and_hunting\",\n    \"industry_agriculture,_forestry,_fishing_and_hunting_canada\",\n    \"industry_arts,_entertainment,_and_recreation\",\n    \"industry_arts,_entertainment,_and_recreation_canada\",\n    \"industry_construction\",\n    \"industry_construction_canada\",\n    \"industry_educational_services\",\n    \"industry_educational_services_canada\",\n    \"industry_finance_and_insurance\",\n    \"industry_finance_and_insurance_canada\",\n    \"industry_health_care_and_social_assistance\",\n    \"industry_health_care_and_social_assistance_canada\",\n    \"industry_information\",\n    \"industry_information_canada\",\n    \"industry_management_of_companies_and_enterprises\",\n    \"industry_management_of_companies_and_enterprises_canada\",\n    \"industry_manufacturing\",\n    \"industry_manufacturing_canada\",\n    \"industry_mining,_quarrying,_and_oil_and_gas_extraction\",\n    \"industry_mining,_quarrying,_and_oil_and_gas_extraction_canada\",\n    \"industry_other_services,_except_public_administration\",\n    \"industry_other_services,_except_public_administration_canada\",\n    \"industry_professional,_scientific,_and_technical_services\",\n    \"industry_professional,_scientific,_and_technical_services_canada\",\n    \"industry_public_administration\",\n    \"industry_public_administration_canada\",\n    \"industry_real_estate_and_rental_and_leasing\",\n    \"industry_real_estate_and_rental_and_leasing_canada\",\n    \"industry_retail_trade\",\n    \"industry_retail_trade_canada\",\n    \"industry_transportation_and_warehousing\",\n    \"industry_transportation_and_warehousing_canada\",\n    \"industry_utilities\",\n    \"industry_utilities_canada\",\n    \"industry_wholesale_trade\",\n    \"industry_wholesale_trade_canada\",\n    \"insurance_coverage_govt\",\n    \"insurance_coverage_none\",\n    \"insurance_coverage_private\",\n    \"internet_no_access\",\n    \"language_english_only\",\n    \"language_other\",\n    \"language_spanish\",\n    \"lapop10share_usda_fra_1\",\n    \"lapop1share_usda_fra_1\",\n    \"lapop20share_usda_fra_1\",\n    \"lapophalfshare_usda_fra_1\",\n    \"lico_at_canada\",\n    \"life_expectancy_2019\",\n    \"marriage_divorced\",\n    \"marriage_divorced_canada\",\n    \"marriage_married_not_divorced\",\n    \"marriage_married_not_divorced_canada\",\n    \"marriage_never_married\",\n    \"marriage_never_married_canada\",\n    \"mean_dist_Active Superfund Site_updated\",\n    \"mean_dist_Airport_updated\",\n    \"mean_dist_Hospital_updated\",\n    \"mean_dist_Public School_updated\",\n    \"mean_high_dewpoint_4\",\n    \"mean_high_heat_index_4\",\n    \"mean_high_temp_4\",\n    \"mean_high_temp_djf\",\n    \"mean_high_temp_fall_4\",\n    \"mean_high_temp_jja\",\n    \"mean_high_temp_mam\",\n    \"mean_high_temp_son\",\n    \"mean_high_temp_spring_4\",\n    \"mean_high_temp_summer_4\",\n    \"mean_high_temp_winter_4\",\n    \"mean_low_temp\",\n    \"mean_low_temp_djf\",\n    \"mean_low_temp_jja\",\n    \"mean_low_temp_mam\",\n    \"mean_low_temp_son\",\n    \"median_household_income\",\n    \"native\",\n    \"native_2000\",\n    \"native_2010\",\n    \"occupation_architecture_and_engineering_occupations\",\n    \"occupation_arts,_design,_entertainment,_sports,_and_media_occupations\",\n    \"occupation_building_and_grounds_cleaning_and_maintenance_occupations\",\n    \"occupation_business_and_financial_operations_occupations\",\n    \"occupation_community_and_social_service_occupations\",\n    \"occupation_computer_and_mathematical_occupations\",\n    \"occupation_construction_and_extraction_occupations\",\n    \"occupation_educational_instruction,_and_library_occupations\",\n    \"occupation_farming,_fishing,_and_forestry_occupations\",\n    \"occupation_firefighting_and_prevention,_and_other_protective_service_workers_including_supervisors\",\n    \"occupation_food_preparation_and_serving_related_occupations\",\n    \"occupation_health_diagnosing_and_treating_practitioners_and_other_technical_occupations\",\n    \"occupation_health_technologists_and_technicians\",\n    \"occupation_healthcare_support_occupations\",\n    \"occupation_installation,_maintenance,_and_repair_occupations\",\n    \"occupation_law_enforcement_workers_including_supervisors\",\n    \"occupation_legal_occupations\",\n    \"occupation_life,_physical,_and_social_science_occupations\",\n    \"occupation_management_occupations\",\n    \"occupation_material_moving_occupations\",\n    \"occupation_office_and_administrative_support_occupations\",\n    \"occupation_personal_care_and_service_occupations\",\n    \"occupation_production_occupations\",\n    \"occupation_sales_and_related_occupations\",\n    \"occupation_transportation_occupations\",\n    \"other  slash  mixed\",\n    \"other  slash  mixed_2000\",\n    \"other  slash  mixed_2010\",\n    \"park_percent_1km_v2\",\n    \"performance_score_adj_2019\",\n    \"pm_25_2018_2022\",\n    \"population\",\n    \"population_2000\",\n    \"population_2010\",\n    \"population_2021_canada\",\n    \"population_change_2000\",\n    \"population_change_2010\",\n    \"poverty_below_line\",\n    \"rainfall_4\",\n    \"rent_1br_750_to_1500\",\n    \"rent_1br_over_1500\",\n    \"rent_1br_under_750\",\n    \"rent_2br_750_to_1500\",\n    \"rent_2br_over_1500\",\n    \"rent_2br_under_750\",\n    \"rent_burden_20_to_40\",\n    \"rent_burden_over_40\",\n    \"rent_burden_under_20\",\n    \"rent_or_own_rent\",\n    \"sd\",\n    \"sd_2000\",\n    \"sd_2010\",\n    \"sd_2021_canada\",\n    \"segregation_250_10_2000\",\n    \"segregation_250_10_2010\",\n    \"segregation_250_10_2020\",\n    \"segregation_250_10_diff_2000\",\n    \"segregation_250_10_diff_2010\",\n    \"segregation_250_2000\",\n    \"segregation_250_2010\",\n    \"segregation_250_2020\",\n    \"segregation_250_diff_2000\",\n    \"segregation_250_diff_2010\",\n    \"snowfall_4\",\n    \"sors_child\",\n    \"sors_cohabiting_partnered_gay\",\n    \"sors_cohabiting_partnered_straight\",\n    \"sors_other\",\n    \"sors_unpartnered_householder\",\n    \"traffic_fatalities_last_decade\",\n    \"traffic_fatalities_last_decade_per_capita\",\n    \"traffic_fatalities_ped_last_decade\",\n    \"traffic_fatalities_ped_last_decade_per_capita\",\n    \"transportation_commute_time_15_to_29\",\n    \"transportation_commute_time_15_to_29_canada\",\n    \"transportation_commute_time_30_to_59\",\n    \"transportation_commute_time_30_to_59_canada\",\n    \"transportation_commute_time_median\",\n    \"transportation_commute_time_median_canada\",\n    \"transportation_commute_time_over_60\",\n    \"transportation_commute_time_over_60_canada\",\n    \"transportation_commute_time_under_15\",\n    \"transportation_commute_time_under_15_canada\",\n    \"transportation_means_bike\",\n    \"transportation_means_car\",\n    \"transportation_means_transit\",\n    \"transportation_means_walk\",\n    \"transportation_means_worked_at_home\",\n    \"vacancy\",\n    \"vacancy_2000\",\n    \"vacancy_2010\",\n    \"vehicle_ownership_at_least_1\",\n    \"vehicle_ownership_at_least_2\",\n    \"vehicle_ownership_none\",\n    \"white\",\n    \"white_2000\",\n    \"white_2010\",\n    \"wind_speed_over_10mph_4\",\n    \"within_Active Superfund Site_10\",\n    \"within_Airport_30\",\n    \"within_Hospital_10\",\n    \"within_Public School_2\",\n    \"year_built_1969_or_earlier\",\n    \"year_built_1970_to_1979\",\n    \"year_built_1980_to_1989\",\n    \"year_built_1990_to_1999\",\n    \"year_built_2000_to_2009\",\n    \"year_built_2010_or_later\"\n] as const","const value: Record<string, number[]> = {\n    \"10M Person Circle\": [\n        105,\n        105,\n        105,\n        60\n    ],\n    \"20M Person Circle\": [\n        205,\n        170\n    ],\n    \"5M Person Circle\": [\n        54,\n        54,\n        54,\n        54,\n        54,\n        54,\n        51\n    ],\n    \"CA Census Division\": [\n        285,\n        90\n    ],\n    \"CA Census Subdivision\": [\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        15\n    ],\n    \"CA Population Center\": [\n        82,\n        82,\n        82,\n        82,\n        47\n    ],\n    \"CA Riding\": [\n        247,\n        128\n    ],\n    \"CCD\": [\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3\n    ],\n    \"City\": [\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3\n    ],\n    \"Congressional District\": [\n        192,\n        183\n    ],\n    \"Congressional District (1810s)\": [\n        328,\n        47\n    ],\n    \"Congressional District (1820s)\": [\n        344,\n        31\n    ],\n    \"Congressional District (1830s)\": [\n        288,\n        87\n    ],\n    \"Congressional District (1840s)\": [\n        230,\n        145\n    ],\n    \"Congressional District (1850s)\": [\n        241,\n        134\n    ],\n    \"Congressional District (1860s)\": [\n        295,\n        80\n    ],\n    \"Congressional District (1870s)\": [\n        153,\n        153,\n        69\n    ],\n    \"Congressional District (1880s)\": [\n        140,\n        140,\n        95\n    ],\n    \"Congressional District (1890s)\": [\n        169,\n        169,\n        37\n    ],\n    \"Congressional District (1900s)\": [\n        168,\n        168,\n        39\n    ],\n    \"Congressional District (1910s)\": [\n        124,\n        124,\n        124,\n        3\n    ],\n    \"Congressional District (1920s)\": [\n        169,\n        169,\n        37\n    ],\n    \"Congressional District (1930s)\": [\n        168,\n        168,\n        39\n    ],\n    \"Congressional District (1940s)\": [\n        149,\n        149,\n        77\n    ],\n    \"Congressional District (1950s)\": [\n        162,\n        162,\n        51\n    ],\n    \"Congressional District (1960s)\": [\n        82,\n        82,\n        82,\n        82,\n        47\n    ],\n    \"Congressional District (1970s)\": [\n        152,\n        152,\n        71\n    ],\n    \"Congressional District (1980s)\": [\n        139,\n        139,\n        97\n    ],\n    \"Congressional District (1990s)\": [\n        122,\n        122,\n        122,\n        9\n    ],\n    \"Congressional District (2000s)\": [\n        154,\n        154,\n        67\n    ],\n    \"Congressional District (2010s)\": [\n        161,\n        161,\n        53\n    ],\n    \"County\": [\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        26,\n        11\n    ],\n    \"County Cross CD\": [\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        23,\n        7\n    ],\n    \"Hospital Referral Region\": [\n        263,\n        112\n    ],\n    \"Hospital Service Area\": [\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25\n    ],\n    \"MSA\": [\n        88,\n        88,\n        88,\n        88,\n        23\n    ],\n    \"Metropolitan Cluster\": [\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3\n    ],\n    \"Native Area\": [\n        223,\n        152\n    ],\n    \"Native Statistical Area\": [\n        290,\n        85\n    ],\n    \"Native Subdivision\": [\n        181,\n        181,\n        13\n    ],\n    \"Neighborhood\": [\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        3\n    ],\n    \"School District\": [\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        4\n    ],\n    \"State House District\": [\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        18,\n        15\n    ],\n    \"State Senate District\": [\n        43,\n        43,\n        43,\n        43,\n        43,\n        43,\n        43,\n        43,\n        31\n    ],\n    \"Subnational Region\": [\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25,\n        25\n    ],\n    \"Urban Area\": [\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        32,\n        23\n    ],\n    \"Urban Center\": [\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        6\n    ],\n    \"ZIP\": [\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3\n    ]\n}\nexport default value","export default [\n    \"world\",\n    \"Africa\",\n    \"Asia\",\n    \"Europe\",\n    \"North America\",\n    \"Oceania\",\n    \"South America\",\n    \"Andorra\",\n    \"United Arab Emirates\",\n    \"Afghanistan\",\n    \"Antigua and Barbuda\",\n    \"Anguilla\",\n    \"Albania\",\n    \"Armenia\",\n    \"Angola\",\n    \"Argentina\",\n    \"Austria\",\n    \"Australia\",\n    \"Aruba\",\n    \"Azerbaijan\",\n    \"Bosnia and Herzegovina\",\n    \"Barbados\",\n    \"Bangladesh\",\n    \"Belgium\",\n    \"Burkina Faso\",\n    \"Bulgaria\",\n    \"Bahrain\",\n    \"Burundi\",\n    \"Benin\",\n    \"Bermuda\",\n    \"Brunei\",\n    \"Bolivia\",\n    \"Brazil\",\n    \"The Bahamas\",\n    \"Bhutan\",\n    \"Botswana\",\n    \"Belarus\",\n    \"Belize\",\n    \"Canada\",\n    \"Cocos (Keeling) Islands\",\n    \"Democratic Republic of the Congo\",\n    \"Central African Republic\",\n    \"Congo\",\n    \"Switzerland\",\n    \"Ivory Coast\",\n    \"Cook Islands\",\n    \"Chile\",\n    \"Cameroon\",\n    \"China\",\n    \"Colombia\",\n    \"Costa Rica\",\n    \"Cuba\",\n    \"Cape Verde\",\n    \"Christmas Island\",\n    \"Cyprus\",\n    \"Czech Republic\",\n    \"Germany\",\n    \"Djibouti\",\n    \"Denmark\",\n    \"Dominica\",\n    \"Dominican Republic\",\n    \"Algeria\",\n    \"Ecuador\",\n    \"Estonia\",\n    \"Egypt\",\n    \"Eritrea\",\n    \"Spain\",\n    \"Ethiopia\",\n    \"Finland\",\n    \"Fiji\",\n    \"Falkland Islands\",\n    \"Micronesia\",\n    \"Faroe Islands\",\n    \"France\",\n    \"Gabon\",\n    \"United Kingdom\",\n    \"Grenada\",\n    \"Georgia\",\n    \"Guernsey\",\n    \"Ghana\",\n    \"Gibraltar\",\n    \"Greenland\",\n    \"The Gambia\",\n    \"Guinea\",\n    \"Equatorial Guinea\",\n    \"Greece\",\n    \"Guatemala\",\n    \"Guinea-Bissau\",\n    \"Guyana\",\n    \"Honduras\",\n    \"Croatia\",\n    \"Haiti\",\n    \"Hungary\",\n    \"Indonesia\",\n    \"Ireland\",\n    \"Israel\",\n    \"Isle of Man\",\n    \"India\",\n    \"Iraq\",\n    \"Iran\",\n    \"Iceland\",\n    \"Italy\",\n    \"Jersey\",\n    \"Jamaica\",\n    \"Jordan\",\n    \"Japan\",\n    \"Kenya\",\n    \"Kyrgyzstan\",\n    \"Cambodia\",\n    \"Kiribati\",\n    \"Comoros\",\n    \"Saint Kitts and Nevis\",\n    \"North Korea\",\n    \"South Korea\",\n    \"Kuwait\",\n    \"Cayman Islands\",\n    \"Kazakhstan\",\n    \"Laos\",\n    \"Lebanon\",\n    \"Saint Lucia\",\n    \"Liechtenstein\",\n    \"Sri Lanka\",\n    \"Liberia\",\n    \"Lesotho\",\n    \"Lithuania\",\n    \"Luxembourg\",\n    \"Latvia\",\n    \"Libya\",\n    \"Morocco\",\n    \"Monaco\",\n    \"Moldova\",\n    \"Montenegro\",\n    \"Madagascar\",\n    \"Marshall Islands\",\n    \"North Macedonia\",\n    \"Mali\",\n    \"Myanmar\",\n    \"Mongolia\",\n    \"Mauritania\",\n    \"Montserrat\",\n    \"Malta\",\n    \"Mauritius\",\n    \"Maldives\",\n    \"Malawi\",\n    \"Mexico\",\n    \"Malaysia\",\n    \"Mozambique\",\n    \"Namibia\",\n    \"Niger\",\n    \"Norfolk Island\",\n    \"Nigeria\",\n    \"Nicaragua\",\n    \"Netherlands\",\n    \"Norway\",\n    \"Nepal\",\n    \"Nauru\",\n    \"Niue\",\n    \"New Zealand\",\n    \"Oman\",\n    \"Panama\",\n    \"Peru\",\n    \"Papua New Guinea\",\n    \"Philippines\",\n    \"Pakistan\",\n    \"Poland\",\n    \"Pitcairn Islands\",\n    \"State of Palestine\",\n    \"Portugal\",\n    \"Palau\",\n    \"Paraguay\",\n    \"Qatar\",\n    \"Romania\",\n    \"Serbia\",\n    \"Russia\",\n    \"Rwanda\",\n    \"Saudi Arabia\",\n    \"Solomon Islands\",\n    \"Seychelles\",\n    \"Sudan\",\n    \"Sweden\",\n    \"Singapore\",\n    \"Saint Helena, Ascension and Tristan da Cunha\",\n    \"Slovenia\",\n    \"Slovakia\",\n    \"Sierra Leone\",\n    \"San Marino\",\n    \"Senegal\",\n    \"Somalia\",\n    \"Suriname\",\n    \"South Sudan\",\n    \"S\\u00e3o Tom\\u00e9 and Pr\\u00edncipe\",\n    \"El Salvador\",\n    \"Syria\",\n    \"Eswatini\",\n    \"Turks and Caicos Islands\",\n    \"Chad\",\n    \"Togo\",\n    \"Thailand\",\n    \"Tajikistan\",\n    \"Tokelau\",\n    \"East Timor\",\n    \"Turkmenistan\",\n    \"Tunisia\",\n    \"Tonga\",\n    \"Turkey\",\n    \"Trinidad and Tobago\",\n    \"Tuvalu\",\n    \"Tanzania\",\n    \"Ukraine\",\n    \"Uganda\",\n    \"USA\",\n    \"Uruguay\",\n    \"Uzbekistan\",\n    \"Vatican City\",\n    \"Saint Vincent and the Grenadines\",\n    \"Venezuela\",\n    \"British Virgin Islands\",\n    \"Vietnam\",\n    \"Vanuatu\",\n    \"Samoa\",\n    \"Yemen\",\n    \"South Africa\",\n    \"Zambia\",\n    \"Zimbabwe\",\n    \"Alabama, USA\",\n    \"Alaska, USA\",\n    \"Arizona, USA\",\n    \"Arkansas, USA\",\n    \"California, USA\",\n    \"Colorado, USA\",\n    \"Connecticut, USA\",\n    \"Delaware, USA\",\n    \"Florida, USA\",\n    \"Georgia, USA\",\n    \"Hawaii, USA\",\n    \"Idaho, USA\",\n    \"Illinois, USA\",\n    \"Indiana, USA\",\n    \"Iowa, USA\",\n    \"Kansas, USA\",\n    \"Kentucky, USA\",\n    \"Louisiana, USA\",\n    \"Maine, USA\",\n    \"Maryland, USA\",\n    \"Massachusetts, USA\",\n    \"Michigan, USA\",\n    \"Minnesota, USA\",\n    \"Mississippi, USA\",\n    \"Missouri, USA\",\n    \"Montana, USA\",\n    \"Nebraska, USA\",\n    \"Nevada, USA\",\n    \"New Hampshire, USA\",\n    \"New Jersey, USA\",\n    \"New Mexico, USA\",\n    \"New York, USA\",\n    \"North Carolina, USA\",\n    \"North Dakota, USA\",\n    \"Ohio, USA\",\n    \"Oklahoma, USA\",\n    \"Oregon, USA\",\n    \"Pennsylvania, USA\",\n    \"Rhode Island, USA\",\n    \"South Carolina, USA\",\n    \"South Dakota, USA\",\n    \"Tennessee, USA\",\n    \"Texas, USA\",\n    \"Utah, USA\",\n    \"Vermont, USA\",\n    \"Virginia, USA\",\n    \"Washington, USA\",\n    \"West Virginia, USA\",\n    \"Wisconsin, USA\",\n    \"Wyoming, USA\",\n    \"American Samoa, USA\",\n    \"Guam, USA\",\n    \"Northern Mariana Islands, USA\",\n    \"Puerto Rico, USA\",\n    \"US Virgin Islands, USA\",\n    \"District of Columbia, USA\",\n    \"Alberta, Canada\",\n    \"British Columbia, Canada\",\n    \"Manitoba, Canada\",\n    \"New Brunswick, Canada\",\n    \"Newfoundland and Labrador, Canada\",\n    \"Northwest Territories, Canada\",\n    \"Nova Scotia, Canada\",\n    \"Nunavut, Canada\",\n    \"Ontario, Canada\",\n    \"Prince Edward Island, Canada\",\n    \"Quebec, Canada\",\n    \"Saskatchewan, Canada\",\n    \"Yukon, Canada\"\n] as const","import type { StatisticDescriptor } from '../components/statistic-panel'\nimport type_ordering_idx from '../data/type_ordering_idx'\n\nimport { PageDescriptor } from './PageDescriptor'\n\nconst typesInOrder = Object.fromEntries(Object.entries(type_ordering_idx).map(([k, v]) => [v, k]))\n\nfunction shardBytes(longname: string): [string, string] {\n    // as bytes, in utf-8\n    const bytes = new TextEncoder().encode(longname)\n    const hash = new Uint32Array([0])\n    for (const byte of bytes) {\n        hash[0] = (hash[0] * 31 + byte) & 0xffffffff\n    }\n    // last 4 hex digits\n    let string = ''\n    for (let i = 0; i < 4; i++) {\n        string += (hash[0] & 0xf).toString(16)\n        hash[0] = hash[0] >> 4\n    }\n    // get first two and last two\n    return [\n        string.slice(0, 2),\n        string.slice(2, 3),\n    ]\n}\n\nfunction shardedFolderName(longname: string): string {\n    const sanitizedName = sanitize(longname)\n    const [a, b] = shardBytes(sanitizedName)\n    return `${a}/${b}`\n}\n\nexport function shardedName(longname: string): string {\n    const sanitizedName = sanitize(longname)\n    return `${shardedFolderName(longname)}/${sanitizedName}`\n}\n\nexport function shapeLink(longname: string): string {\n    return `/shape/${encodeURIComponent(shardedName(longname))}.gz`\n}\n\nexport function dataLink(longname: string): string {\n    return `/data/${encodeURIComponent(shardedName(longname))}.gz`\n}\n\nexport function symlinksLink(longname: string): string {\n    return `/data/${shardedFolderName(longname)}.symlinks.gz`\n}\n\nexport function indexLink(universe: string, typ: string): string {\n    return `/index/${universe}/${encodeURIComponent(sanitize(typ, false))}.gz`\n}\n\nexport function orderingLink(type: string, idx: number): string {\n    return `/order/${encodeURIComponent(sanitize(type, false))}_${idx}.gz`\n}\n\nexport function orderingDataLink(type: string, idx: number): string {\n    return `/order/${encodeURIComponent(sanitize(type, false))}_${idx}_data.gz`\n}\n\nexport function consolidatedShapeLink(typ: string): string {\n    return `/consolidated/shapes__${encodeURIComponent(sanitize(typ))}.gz`\n}\n\nexport function consolidatedStatsLink(typ: string): string {\n    return `/consolidated/stats__${encodeURIComponent(sanitize(typ))}.gz`\n}\n\nexport function searchIconLink(typeIdx: number): string {\n    return `/icons/search_icons/${typesInOrder[typeIdx]}.png`\n}\n\nexport function centroidsPath(universe: string, typ: string): string {\n    return `/centroids/${encodeURIComponent(universe)}_${encodeURIComponent(sanitize(typ))}.gz`\n}\n\nexport function statisticDescriptor(props: {\n    universe: string | undefined\n    statDesc: StatisticDescriptor\n    articleType: string\n    start: number\n    amount: number | 'All'\n    order: 'ascending' | 'descending'\n    highlight?: string\n}): PageDescriptor & { kind: 'statistic' } {\n    let start = props.start\n    // make start % amount == 0\n    if (props.amount !== 'All') {\n        start = start - 1\n        start = start - (start % props.amount)\n        start = start + 1\n    }\n    return {\n        kind: 'statistic',\n        statname: props.statDesc.statname,\n        article_type: props.articleType,\n        start,\n        amount: props.amount,\n        order: props.order,\n        highlight: props.highlight,\n        universe: props.universe,\n    }\n}\n\nexport function sanitize(longname: string, spaces_around_slash = true): string {\n    let x = longname\n    if (spaces_around_slash) {\n        x = x.replaceAll('/', ' slash ')\n    }\n    else {\n        x = x.replaceAll('/', 'slash')\n    }\n    x = x.replaceAll('%', '%25')\n    return x\n}\n\nexport function universePath(universe: string): string {\n    return `/icons/flags/${encodeURIComponent(universe)}.png`\n}\n","import * as idb from 'idb'\n\nimport type_to_priority from './data/type_to_priority'\nimport { loadProtobuf } from './load_json'\nimport { DefaultMap } from './utils/DefaultMap'\nimport { bitap, bitapPerformance, bitCount, Haystack, toHaystack, toNeedle, toSignature } from './utils/bitap'\nimport { ISearchIndexMetadata } from './utils/protos'\nimport { isAllowedToBeShown, ShowGeographySettings } from './utils/restricted-types'\n\nexport interface SearchResult {\n    longname: string\n    typeIndex: number\n}\n\nconst debugSearch: boolean = false\n\nfunction debug(arg: unknown): void {\n    if (debugSearch) {\n        // eslint-disable-next-line no-console -- Debug logging\n        console.log(arg)\n    }\n}\n\nconst debugSearchPerformance: boolean = false\n\nexport function debugPerformance(arg: unknown): void {\n    if (debugSearchPerformance) {\n        // eslint-disable-next-line no-console -- Debug logging\n        console.log(arg)\n    }\n}\n\nexport function normalize(a: string, handlePunctuation = true): string {\n    a = a.toLowerCase()\n    a = a.normalize('NFD')\n    a = a.replace(/[\\u0300-\\u036f]/g, '')\n    if (handlePunctuation) {\n        a = a.replace(/[,\\(\\)\\[\\]]/g, '')\n        a = a.replaceAll('-', ' ')\n    }\n    return a\n}\n\ninterface NormalizedSearchIndex {\n    entries: {\n        longname: string\n        tokens: Haystack[]\n        priority: number\n        signature: number\n        typeIndex: number\n    }[]\n    lengthOfLongestToken: number\n    maxPriority: number\n    mostTokens: number\n}\n\ninterface Result {\n    entry: NormalizedSearchIndex['entries'][number]\n    normalizedMatchScore: number // Lower is better ([0,1], where 0 is perfect match, and 1 is no matches)\n    normalizedPopulationRank: number // Lower is higher population (better) ([0,1], where 0 is highest population and 1 is lowest population)\n    normalizedPriority: number // Lower is better ([0,1] where 1 is least prioritized)\n    normalizedPositionScore: number // The absolute difference in position where tokens were found. Lower is better ([0, 1] where 0 is all tokens are in the right place, and 1 is all tokens are maximally distant in this result)\n    normalizedTokensWithIncompleteMatch: number // The number of tokens in the query that do NOT match \"completely\" (are the same length) with their tokens in the haystack. These matches may still have errors. ([0, 1], lower is better, where 0 means all tokens in the query match completely, and 1 means no tokens in the query match completely)\n    normalizedTokenSwapOrOverlap: number // The number of search tokens that are out-of-order or overlap with another token when they are matched against the haystack tokens ([0, 1], where 0 is no tokens are swapped or overlapped, and 1 is all tokens are swapped or overlapped)\n    normalizedPriorityType: 1 | 0 // Is this a priority type? 0 if true\n}\n\nconst weights = {\n    match: 5,\n    position: 5,\n    priority: 1.6,\n    population: 2,\n    incompleteMatches: 1,\n    swapOverlap: 1,\n    priorityType: 0.2,\n}\n\nconst sumOfWeights = Object.values(weights).reduce((total, value) => total + value, 0)\nconst normalizedWeights = Object.fromEntries(Object.entries(weights).map(([key, value]) => [key, value / sumOfWeights]))\n\nfunction combinedScore(result: Result): number {\n    return (result.normalizedMatchScore * normalizedWeights.match)\n        + (result.normalizedPositionScore * normalizedWeights.position)\n        + (result.normalizedPriority * normalizedWeights.priority)\n        + (result.normalizedPopulationRank * normalizedWeights.population)\n        + (result.normalizedTokensWithIncompleteMatch * normalizedWeights.incompleteMatches)\n        + (result.normalizedTokenSwapOrOverlap * normalizedWeights.swapOverlap)\n        + (result.normalizedPriorityType * normalizedWeights.priorityType)\n}\n\nfunction compareSearchResults(a: Result, b: Result): number {\n    return combinedScore(a) - combinedScore(b)\n}\n\nfunction tokenize(pattern: string): string[] {\n    const matchNoOverflow = /^ *([^ ]{1,31})(.*)$/.exec(pattern)\n    if (matchNoOverflow !== null) {\n        const [, token, rest] = matchNoOverflow\n        return [token, ...tokenize(rest)]\n    }\n\n    return []\n}\n\nexport interface SearchParams {\n    unnormalizedPattern: string\n    maxResults: number\n    showSettings: ShowGeographySettings\n    prioritizeTypeIndex?: number\n}\n\nfunction search(searchIndex: NormalizedSearchIndex, { unnormalizedPattern, maxResults, showSettings, prioritizeTypeIndex }: SearchParams): SearchResult[] {\n    const start = performance.now()\n\n    const pattern = normalize(unnormalizedPattern)\n\n    if (pattern === '') {\n        return []\n    }\n\n    let longestPatternToken = 0\n    const patternTokens = tokenize(pattern).map((token) => {\n        longestPatternToken = Math.max(longestPatternToken, token.length)\n        return toNeedle(token)\n    })\n\n    const results: Result[] = []\n\n    const maxErrors = 2\n    const maxMatchScore = patternTokens.length * (maxErrors + 1)\n    const maxPositionScore = patternTokens.length * Math.max(patternTokens.length, searchIndex.lengthOfLongestToken)\n\n    const bitapBuffers = Array.from({ length: maxErrors + 1 }, () => new Uint32Array(longestPatternToken + maxErrors + 1))\n\n    bitapPerformance.numBitapSignatureChecks = 0\n    bitapPerformance.numBitapSignatureSkips = 0\n\n    const patternSignature = toSignature(pattern)\n\n    let entriesPatternSkips = 0\n    let entriesPatternChecks = 0\n\n    entries: for (const [populationRank, entry] of searchIndex.entries.entries()) {\n        if (!isAllowedToBeShown(entry.typeIndex, showSettings)) {\n            continue\n        }\n\n        entriesPatternChecks++\n        if (bitCount(patternSignature ^ (patternSignature & entry.signature)) > maxErrors) {\n            // This element doesn't have the correct letters to match this pattern\n            entriesPatternSkips++\n            continue\n        }\n\n        const normalizedPopulationRank = (populationRank / searchIndex.entries.length)\n\n        // If this entry wouldn't make it into the results even with a perfect match because of priority or population, continue\n        if (results.length === maxResults && compareSearchResults({\n            entry,\n            normalizedMatchScore: 0,\n            normalizedPositionScore: 0,\n            normalizedPriority: entry.priority / searchIndex.maxPriority,\n            normalizedPopulationRank,\n            normalizedTokensWithIncompleteMatch: 0,\n            normalizedTokenSwapOrOverlap: 0,\n            normalizedPriorityType: entry.typeIndex === prioritizeTypeIndex ? 0 : 1,\n        }, results[results.length - 1]) > 0) {\n            continue\n        }\n\n        let matchScore = 0\n        let positionScore = 0\n        let incompleteMatches = 0\n\n        let prevEntryTokenIndex = -1\n        let numSwapsOverlaps = 0\n\n        for (const [patternTokenIndex, needle] of patternTokens.entries()) {\n            let tokenMatchScore = maxErrors + 1\n            let tokenPositionScore = Math.max(patternTokens.length, searchIndex.lengthOfLongestToken)\n            let tokenIncompleteMatch = true\n            let tokenEntryTokenIndex: undefined | number\n\n            for (const [entryTokenIndex, entryToken] of entry.tokens.entries()) {\n                const searchResult = bitap(entryToken, needle, maxErrors, bitapBuffers)\n                const positionResult = Math.abs(patternTokenIndex - entryTokenIndex)\n                const incompleteMatchResult = Math.abs(entryToken.haystack.length - needle.length) - searchResult !== 0\n                if (searchResult < tokenMatchScore || (searchResult <= tokenMatchScore && positionResult < tokenPositionScore) || (searchResult <= tokenMatchScore && positionResult <= tokenPositionScore && incompleteMatchResult < tokenIncompleteMatch)) {\n                    tokenMatchScore = searchResult\n                    tokenPositionScore = positionResult\n                    tokenIncompleteMatch = incompleteMatchResult\n                    tokenEntryTokenIndex = entryTokenIndex\n                }\n            }\n\n            matchScore += tokenMatchScore\n            positionScore += tokenPositionScore\n            incompleteMatches += tokenIncompleteMatch ? 1 : 0\n            if (tokenEntryTokenIndex !== undefined) {\n                numSwapsOverlaps += prevEntryTokenIndex >= tokenEntryTokenIndex ? 1 : 0\n                prevEntryTokenIndex = tokenEntryTokenIndex\n            }\n\n            // If our match score is so high that we would not make it into the results, we can move on to the next entry\n            if (results.length === maxResults && compareSearchResults({\n                entry,\n                normalizedMatchScore: matchScore / maxMatchScore,\n                normalizedPositionScore: positionScore / maxPositionScore,\n                normalizedPriority: entry.priority / searchIndex.maxPriority,\n                normalizedPopulationRank,\n                normalizedTokensWithIncompleteMatch: incompleteMatches / patternTokens.length,\n                normalizedTokenSwapOrOverlap: numSwapsOverlaps / patternTokens.length,\n                normalizedPriorityType: entry.typeIndex === prioritizeTypeIndex ? 0 : 1,\n            }, results[results.length - 1]) > 0) {\n                continue entries\n            }\n        }\n\n        if (matchScore >= patternTokens.length * (maxErrors + 1)) {\n            // No match\n            continue\n        }\n\n        const result: Result = {\n            entry,\n            normalizedMatchScore: matchScore / maxMatchScore,\n            normalizedPositionScore: positionScore / maxPositionScore,\n            normalizedPriority: entry.priority / searchIndex.maxPriority,\n            normalizedPopulationRank,\n            normalizedTokensWithIncompleteMatch: incompleteMatches / patternTokens.length,\n            normalizedTokenSwapOrOverlap: numSwapsOverlaps / patternTokens.length,\n            normalizedPriorityType: entry.typeIndex === prioritizeTypeIndex ? 0 : 1,\n        }\n\n        let spliceIndex: number | undefined\n        for (let resultsIndex = Math.min(results.length, maxResults); resultsIndex >= 0; resultsIndex--) {\n            if (results.length <= resultsIndex || compareSearchResults(result, results[resultsIndex]) < 0) {\n                spliceIndex = resultsIndex\n            }\n            else {\n                break\n            }\n        }\n        if (spliceIndex !== undefined) {\n            results.splice(spliceIndex, 0, result)\n        }\n        if (results.length > maxResults) {\n            results.pop()\n        }\n    }\n\n    debug(bitapPerformance)\n    debug({ total: entriesPatternChecks, skips: entriesPatternSkips })\n\n    debug(results.map(result => ({\n        ...result,\n        combinedScore: combinedScore(result),\n    })))\n\n    debugPerformance(`Took ${performance.now() - start} ms to execute search`)\n\n    return results.map(result => result.entry)\n}\n\n// Potentially cached\nexport async function createIndex(cacheKey: string | undefined): Promise<(params: SearchParams) => SearchResult[]> {\n    let index: NormalizedSearchIndex | undefined\n    try {\n        if (cacheKey === undefined) {\n            throw new Error('No cache key specified')\n        }\n\n        let checkpoint = performance.now()\n\n        const db = await idb.openDB('SearchCache', 1, {\n            upgrade(database) {\n                database.createObjectStore('indexes')\n            },\n        })\n\n        const store = db.transaction('indexes', 'readonly').objectStore('indexes')\n\n        debugPerformance(`Took ${performance.now() - checkpoint}ms to open database`)\n        checkpoint = performance.now()\n\n        index = (await store.get(cacheKey)) as NormalizedSearchIndex | undefined\n\n        debugPerformance(`Took ${performance.now() - checkpoint}ms to get index from cache`)\n        checkpoint = performance.now()\n\n        if (index === undefined) {\n            debugPerformance('Cache miss')\n            index = await createIndexNoCache()\n\n            void (async () => {\n                const writeStore = db.transaction('indexes', 'readwrite').objectStore('indexes')\n                const keys = await writeStore.getAllKeys()\n                await Promise.all(keys.map(k => writeStore.delete(k)))\n                await writeStore.put(index, cacheKey)\n            })()\n        }\n        else {\n            debugPerformance('Cache hit')\n        }\n    }\n    catch (error) {\n        // This is going to fail during unit testing since we don't mock stuff\n        console.warn('Getting cached search index failed', error)\n        index = await createIndexNoCache()\n    }\n    return params => search(index, params)\n}\n\nasync function createIndexNoCache(): Promise<NormalizedSearchIndex> {\n    const rawIndex = await loadProtobuf('/index/pages_all.gz', 'SearchIndex')\n    return processRawSearchIndex(rawIndex)\n}\n\nfunction processRawSearchIndex(searchIndex: { elements: string[], metadata: ISearchIndexMetadata[] }): NormalizedSearchIndex {\n    const start = performance.now()\n    let lengthOfLongestToken = 0\n    let maxPriority = 0\n    let mostTokens = 0\n    const priorities = searchIndex.metadata.map(({ type }) => type_to_priority[type!])\n    const haystackCache = new DefaultMap<string, Haystack>((token) => {\n        if (token.length > lengthOfLongestToken) {\n            lengthOfLongestToken = token.length\n        }\n        return toHaystack(token)\n    })\n    const entries = searchIndex.elements.map((longname, index) => {\n        const normalizedLongname = normalize(longname)\n        const entryTokens = tokenize(normalizedLongname)\n        const tokens = entryTokens.map(token => haystackCache.get(token))\n        if (priorities[index] > maxPriority) {\n            maxPriority = priorities[index]\n        }\n        if (tokens.length > mostTokens) {\n            mostTokens = tokens.length\n        }\n        return {\n            longname,\n            tokens,\n            priority: priorities[index],\n            signature: toSignature(normalizedLongname),\n            typeIndex: searchIndex.metadata[index].type!,\n        }\n    })\n    debugPerformance(`Took ${performance.now() - start}ms to process search index`)\n    return { entries, lengthOfLongestToken, maxPriority, mostTokens }\n}\n\nexport async function getIndexCacheKey(): Promise<string | undefined> {\n    try {\n        const start = performance.now()\n        // location is sometimes a worker\n        const resources = ['/scripts/index.js', '/index/pages_all.gz', location.href]\n        const etags = await Promise.all(resources.map(async (resource) => {\n            const response = await fetch(resource, { method: 'HEAD' })\n            if (!response.ok) {\n                throw new Error(`${resource} is not OK`)\n            }\n            const etag = response.headers.get('etag')\n            if (etag === null) {\n                throw new Error(`${resource} does not have etag`)\n            }\n            return etag\n        }))\n\n        debugPerformance(`Took ${performance.now() - start} to get search cache key`)\n        return etags.join(',')\n    }\n    catch (error) {\n        console.warn('Getting search cache key failed', error)\n        return undefined\n    }\n}\n","export interface ReadonlyDefaultMap<K, V> extends ReadonlyMap<K, V> {\n    get: (key: K) => V\n}\n\nexport class DefaultMap<K, V> extends Map<K, V> implements ReadonlyDefaultMap<K, V> {\n    override get(key: K): V {\n        let result = super.get(key)\n        if (result === undefined) {\n            result = this.makeDefault(key)\n            this.set(key, result)\n        }\n        return result\n    }\n\n    constructor(private readonly makeDefault: (key: K) => V) {\n        super()\n    }\n}\n","import type_ordering_idx from '../data/type_ordering_idx'\n\nexport interface ShowGeographySettings {\n    // eslint-disable-next-line no-restricted-syntax -- matches localStorage keys\n    show_historical_cds: boolean\n    // eslint-disable-next-line no-restricted-syntax -- matches localStorage keys\n    show_person_circles: boolean\n}\n\nconst historicalCongressionals = Object.keys(type_ordering_idx).filter(\n    key => key.startsWith('Congressional District ('),\n)\nconst historicalCongressionalsIdx = historicalCongressionals.map(\n    key => type_ordering_idx[key],\n)\n\nconst populationCircles = Object.entries(type_ordering_idx).filter(([name]) => name.endsWith('Person Circle')).map(([,index]) => index)\n\nfunction isHistoricalCD(typeOrTypeIndex: number | string): boolean {\n    if (typeof typeOrTypeIndex === 'string') {\n        return historicalCongressionals.includes(typeOrTypeIndex)\n    }\n    return historicalCongressionalsIdx.includes(typeOrTypeIndex)\n}\n\nfunction isPopulationCircle(typeOrTypeIndex: number | string): boolean {\n    if (typeof typeOrTypeIndex === 'string') {\n        return Object.keys(type_ordering_idx).filter(name => name.endsWith('Person Circle')).includes(typeOrTypeIndex)\n    }\n    return populationCircles.includes(typeOrTypeIndex)\n}\n\nexport function isAllowedToBeShown(typeOrTypeIndex: number | string, settings: ShowGeographySettings): boolean {\n    if (!settings.show_historical_cds && isHistoricalCD(typeOrTypeIndex)) {\n        return false\n    }\n    if (!settings.show_person_circles && isPopulationCircle(typeOrTypeIndex)) {\n        return false\n    }\n    return true\n}\n","import { gunzipSync } from 'zlib'\n\nimport data_links from './data/data_links'\nimport order_links from './data/order_links'\nimport statistic_path_list from './data/statistic_path_list'\nimport universes_ordered from './data/universes_ordered'\nimport { indexLink, orderingDataLink, orderingLink } from './navigation/links'\nimport { debugPerformance } from './search'\nimport { Universe } from './universe'\nimport { assert } from './utils/defensive'\nimport {\n    Article, ConsolidatedShapes, CountsByArticleUniverseAndType, DataLists,\n    Feature, IOrderList, OrderList,\n    OrderLists,\n    QuizFullData,\n    QuizQuestionTronche,\n    SearchIndex,\n    ArticleOrderingList,\n    Symlinks,\n    PointSeries,\n    ArticleUniverseList,\n} from './utils/protos'\nimport { NormalizeProto } from './utils/types'\n\n// from https://stackoverflow.com/a/4117299/1549476\n\n// Load JSON text from server hosted file and return JSON parsed object\nexport async function loadJSON(filePath: string): Promise<unknown> {\n    const response = await fetch(filePath, { headers: { 'Content-Type': 'application/json' } })\n    if (response.status < 200 || response.status > 299) {\n        throw new Error(`Expected response status 2xx for ${filePath}, got ${response.status}: ${response.statusText}`)\n    }\n    return response.json()\n}\n\n// Load a protobuf file from the server\nexport async function loadProtobuf(filePath: string, name: 'Article', errorOnMissing: boolean): Promise<Article | undefined>\nexport async function loadProtobuf(filePath: string, name: 'Feature', errorOnMissing: boolean): Promise<Feature>\nexport async function loadProtobuf(filePath: string, name: 'ArticleOrderingList'): Promise<ArticleOrderingList>\nexport async function loadProtobuf(filePath: string, name: 'OrderLists'): Promise<OrderLists>\nexport async function loadProtobuf(filePath: string, name: 'DataLists'): Promise<DataLists>\nexport async function loadProtobuf(filePath: string, name: 'ConsolidatedShapes'): Promise<ConsolidatedShapes>\nexport async function loadProtobuf(filePath: string, name: 'SearchIndex'): Promise<SearchIndex>\nexport async function loadProtobuf(filePath: string, name: 'QuizQuestionTronche'): Promise<QuizQuestionTronche>\nexport async function loadProtobuf(filePath: string, name: 'QuizFullData'): Promise<QuizFullData>\nexport async function loadProtobuf(filePath: string, name: 'CountsByArticleUniverseAndType'): Promise<CountsByArticleUniverseAndType>\nexport async function loadProtobuf(filePath: string, name: 'Symlinks'): Promise<Symlinks>\nexport async function loadProtobuf(filePath: string, name: 'PointSeries'): Promise<PointSeries>\nexport async function loadProtobuf(filePath: string, name: 'ArticleUniverseList'): Promise<ArticleUniverseList>\nexport async function loadProtobuf(filePath: string, name: string, errorOnMissing: boolean = true): Promise<Article | Feature | ArticleOrderingList | OrderLists | DataLists | ConsolidatedShapes | SearchIndex | QuizQuestionTronche | QuizFullData | CountsByArticleUniverseAndType | Symlinks | PointSeries | ArticleUniverseList | undefined> {\n    let perfCheckpoint = performance.now()\n\n    const response = await fetch(filePath)\n    if (response.status < 200 || response.status > 299) {\n        if (!errorOnMissing) {\n            return undefined\n        }\n        throw new Error(`Expected response status 2xx for ${filePath}, got ${response.status}: ${response.statusText}`)\n    }\n\n    const compressedBuffer = await response.arrayBuffer()\n\n    if (name === 'SearchIndex') {\n        debugPerformance(`Took ${performance.now() - perfCheckpoint}ms networking to load search index`)\n    }\n    perfCheckpoint = performance.now()\n\n    const buffer = gunzipSync(Buffer.from(compressedBuffer))\n    const arr = new Uint8Array(buffer)\n\n    if (name === 'SearchIndex') {\n        debugPerformance(`Took ${performance.now() - perfCheckpoint}ms to decompress search index`)\n    }\n    perfCheckpoint = performance.now()\n\n    if (name === 'Article') {\n        return Article.decode(arr)\n    }\n    else if (name === 'Feature') {\n        return Feature.decode(arr)\n    }\n    else if (name === 'ArticleOrderingList') {\n        return ArticleOrderingList.decode(arr)\n    }\n    else if (name === 'OrderLists') {\n        return OrderLists.decode(arr)\n    }\n    else if (name === 'DataLists') {\n        return DataLists.decode(arr)\n    }\n    else if (name === 'ConsolidatedShapes') {\n        return ConsolidatedShapes.decode(arr)\n    }\n    else if (name === 'SearchIndex') {\n        const result = SearchIndex.decode(arr)\n        debugPerformance(`Took ${performance.now() - perfCheckpoint}ms to decode search index`)\n        return result\n    }\n    else if (name === 'QuizQuestionTronche') {\n        return QuizQuestionTronche.decode(arr)\n    }\n    else if (name === 'QuizFullData') {\n        return QuizFullData.decode(arr)\n    }\n    else if (name === 'CountsByArticleUniverseAndType') {\n        return CountsByArticleUniverseAndType.decode(arr)\n    }\n    else if (name === 'Symlinks') {\n        return Symlinks.decode(arr)\n    }\n    else if (name === 'PointSeries') {\n        return PointSeries.decode(arr)\n    }\n    else if (name === 'ArticleUniverseList') {\n        return ArticleUniverseList.decode(arr)\n    }\n    else {\n        throw new Error('protobuf type not recognized (see load_json.ts)')\n    }\n}\n\nfunction pullKey(arr: number[], key: string): number {\n    const idx = statistic_path_list.indexOf(key as ElementOf<typeof statistic_path_list>)\n    if (idx === -1) {\n        throw new Error(`statistic path not found: ${key}`)\n    }\n    let current = 0\n    for (let i = 0; i < arr.length; i++) {\n        current += arr[i]\n        if (idx < current) {\n            return i\n        }\n    }\n    throw new Error('index not found')\n}\n\nexport async function loadUniverses(type: string): Promise<ArticleUniverseList> {\n    return loadProtobuf(`/universes/${type}.gz`, 'ArticleUniverseList')\n}\n\nasync function loadOrderingProtobuf(universe: string, statpath: string, type: string): Promise<IOrderList> {\n    const universeIdx = universes_ordered.indexOf(universe as Universe)\n    const links = order_links\n    const idx = type in links ? pullKey(links[type], statpath) : 0\n    const orderLink = orderingLink(type, idx)\n    const orderLists = await loadProtobuf(orderLink, 'OrderLists')\n    const index = orderLists.statnames.indexOf(statpath)\n    const res = orderLists.orderLists[index]\n    const universes = await loadUniverses(type)\n    const orderIndices = res.orderIdxs?.filter(i => universes.universes[i].universeIdxs?.includes(universeIdx))\n    return { orderIdxs: orderIndices }\n}\n\nexport async function loadOrderingDataProtobuf(universe: string, statpath: string, type: string): Promise<{\n    value: number[]\n    populationPercentile: number[]\n}> {\n    const links = data_links\n    const idx = type in links ? pullKey(links[type], statpath) : 0\n    const orderLink = orderingDataLink(type, idx)\n    const dataLists = await loadProtobuf(orderLink, 'DataLists')\n    const index = dataLists.statnames.indexOf(statpath)\n    const res = dataLists.dataLists[index]\n    const universeIdx = universes_ordered.indexOf(universe as Universe)\n    const universes = await loadUniverses(type)\n    return {\n        value: res.value!.filter((_, i) => universes.universes[i].universeIdxs?.includes(universeIdx)),\n        populationPercentile: res.populationPercentileByUniverse!.flatMap((_, i) => {\n            const universeIndex = universes.universes[i].universeIdxs!.indexOf(universeIdx)\n            if (universeIndex === -1) {\n                return []\n            }\n            return [res.populationPercentileByUniverse![i].populationPercentile![universeIndex]]\n        }),\n    }\n}\n\nexport async function loadDataInIndexOrder(\n    universe: string, statpath: string, type: string,\n): Promise<[number[], number[]]> {\n    const dataPromise = await loadOrderingDataProtobuf(universe, statpath, type)\n    return [dataPromise.value, dataPromise.populationPercentile]\n}\n\nexport interface ArticleOrderingListInternal {\n    longnames: string[]\n    typeIndices: number[]\n}\n\nexport async function loadOrdering(universe: string, statpath: string, type: string): Promise<ArticleOrderingListInternal> {\n    const idxLink = indexLink('world', type)\n    const dataPromise = loadProtobuf(idxLink, 'ArticleOrderingList')\n    const orderingPromise = loadOrderingProtobuf(universe, statpath, type)\n    const [data, ordering] = await Promise.all([dataPromise, orderingPromise])\n    const namesInOrder = (ordering as OrderList).orderIdxs.map((i: number) => data.longnames[i])\n    const typesInOrder = (ordering as OrderList).orderIdxs.map((i: number) => data.types[i])\n    return { longnames: namesInOrder, typeIndices: typesInOrder }\n}\n\n/**\n * Returns an array `r` where r contains numbers 0..length-1, but such that\n * iff indices[i] < indices[j], then r[i] < r[j]\n *\n * I.e., it returns the argsort of the argsort of indices.\n */\nfunction reindex(indices: number[]): number[] {\n    const pairs = indices.map((value, index) => ({ value, index }))\n    pairs.sort((a, b) => a.value - b.value)\n    const result = new Array<number>(indices.length)\n    for (let i = 0; i < pairs.length; i++) {\n        result[pairs[i].index] = i\n    }\n    return result\n}\n\nexport async function loadStatisticsPage(\n    statUniverse: string, statpath: string, articleType: string,\n): Promise<[NormalizeProto<{ value: number[], populationPercentile: number[] }>, string[]]> {\n    const orderingOriginal = await loadOrderingProtobuf(statUniverse, statpath, articleType)\n    const ordering = await loadOrdering(statUniverse, statpath, articleType)\n    const orderingData = await loadOrderingDataProtobuf(statUniverse, statpath, articleType)\n    assert(Array.isArray(orderingOriginal.orderIdxs), 'Ordering original must be an array')\n    const reorder = reindex(orderingOriginal.orderIdxs)\n    const articleNames = ordering.longnames\n    return [\n        {\n            value: reorder.map(i => orderingData.value[i]),\n            populationPercentile: reorder.map(i => orderingData.populationPercentile[i]),\n        },\n        articleNames,\n    ]\n}\n","import insets from '../data/insets'\nimport statistic_variables_info from '../data/statistic_variables_info'\nimport { Universe } from '../universe'\nimport { UrbanStatsASTExpression, UrbanStatsASTStatement } from '../urban-stats-script/ast'\nimport { defaultConstants } from '../urban-stats-script/constants/constants'\nimport { Inset, insetNameToConstantName } from '../urban-stats-script/constants/insets'\nimport { Context } from '../urban-stats-script/context'\nimport { Effect, InterpretationError } from '../urban-stats-script/interpreter'\nimport { noLocation } from '../urban-stats-script/location'\nimport { allIdentifiers } from '../urban-stats-script/parser'\nimport { TypeEnvironment, USSValue } from '../urban-stats-script/types-values'\nimport { assert } from '../utils/defensive'\nimport { firstNonNan } from '../utils/math'\n\nexport async function mapperContext(stmts: UrbanStatsASTStatement, getVariable: (name: string) => Promise<USSValue | undefined>, effects: Effect[], universe: Universe): Promise<Context> {\n    const ctx = new Context(\n        (eff) => { effects.push(eff) },\n        (msg, loc) => { return new InterpretationError(msg, loc) },\n        defaultConstants,\n        new Map(),\n    )\n\n    await addVariablesToContext(ctx, stmts, getVariable, universe)\n    return ctx\n}\n\nasync function addVariablesToContext(ctx: Context, stmts: UrbanStatsASTStatement, getVariable: (name: string) => Promise<USSValue | undefined>, universe: Universe): Promise<void> {\n    const dte = defaultTypeEnvironment(universe)\n    const ids = allIdentifiers(stmts, ctx)\n\n    const variables = [...statistic_variables_info.variableNames.map(v => v.varName), 'geoName', 'geo', 'geoCentroid', 'defaultInsets']\n\n    // Some variables are always loaded, regardless of whether they are used in the statements\n    // This is helpful for some operations, such as CSV export\n    const forceName = (name: string): boolean => name === 'geoName'\n\n    // Load all variables in parallel\n    const variablePromises = variables\n        .filter(name => ids.has(name) || forceName(name))\n        .map(async (name) => {\n            const va = await getVariable(name)\n            if (va !== undefined) {\n                ctx.assignVariable(name, va)\n            }\n        })\n\n    await Promise.all(variablePromises)\n\n    // Handle multi-source variables in parallel\n    const multiSourcePromises = statistic_variables_info.multiSourceVariables\n        .filter(([name]) => ids.has(name))\n        .map(async ([name, info]) => {\n            const subvars = info.individualVariables\n            const vsPromise: Promise<USSValue | undefined>[] = []\n            for (const subvar of subvars) {\n                const existing = ctx.getVariable(subvar)\n                if (existing !== undefined) {\n                    vsPromise.push(Promise.resolve(existing))\n                }\n                else {\n                    vsPromise.push(getVariable(subvar))\n                }\n            }\n            const vs = await Promise.all(vsPromise)\n            const values = vs.map(v => v?.value as (undefined | number[]))\n            if (values.some(v => v === undefined)) {\n                return\n            }\n            const valuesNotNull = values as number[][] // cast is fine because we checked for undefined above\n            const value = valuesNotNull[0].map((_, i) => firstNonNan(valuesNotNull.map(v => v[i]))) // take first non-NaN value\n\n            const typeInfo = dte.get(name)!\n            ctx.assignVariable(name, {\n                type: typeInfo.type,\n                value,\n                documentation: typeInfo.documentation,\n            })\n        })\n\n    await Promise.all(multiSourcePromises)\n}\n\nexport const defaultTypeEnvironment = (universe: Universe | undefined): TypeEnvironment => {\n    const te: TypeEnvironment = new Map()\n\n    for (const [key, value] of defaultConstants) {\n        te.set(key, value)\n    }\n\n    te.set('geoName', {\n        type: { type: 'vector', elementType: { type: 'string' } },\n        documentation: {\n            humanReadableName: 'Default Universe Geography Names',\n            category: 'mapper',\n            longDescription: 'A vector containing the names of geographic units for the current universe. Each element represents a geographic unit (e.g., census block, county) and can be used for labeling and identification purposes in mapping and spatial analysis.',\n            includedInOutputContext: true,\n        },\n    })\n\n    te.set('geo', {\n        type: { type: 'vector', elementType: { type: 'opaque', name: 'geoFeatureHandle' } },\n        documentation: {\n            humanReadableName: 'Default Universe Geography',\n            category: 'map',\n            longDescription: 'A vector containing geographic feature handles for the current universe. Each element represents a geographic unit (e.g., census block, county) that can be used for mapping and spatial analysis.',\n        },\n    })\n\n    te.set('geoCentroid', {\n        type: { type: 'vector', elementType: { type: 'opaque', name: 'geoCentroidHandle' } },\n        documentation: {\n            humanReadableName: 'Default Universe Geography (Centroids)',\n            category: 'mapper',\n            longDescription: 'A vector containing geographic centroid handles for the current universe. Each element represents the center point of a geographic unit, useful for point-based visualizations and distance calculations.',\n        },\n    })\n\n    te.set('defaultInsets', {\n        type: { type: 'opaque', name: 'insets' },\n        documentation: {\n            humanReadableName: 'Default Insets',\n            category: 'mapper',\n            longDescription: 'Predefined map inset configurations for the current universe (whatever that is). E.g., for the US, it would be the continental US, Alaska, Hawaii, Puerto Rico, and Guam.',\n            equivalentExpressions: universe !== undefined ? [loadInsetExpression(universe)] : [],\n            selectorRendering: { kind: 'subtitleLongDescription' },\n        },\n    })\n\n    for (const variableInfo of statistic_variables_info.variableNames) {\n        const order = variableInfo.order\n        te.set(variableInfo.varName, {\n            type: { type: 'vector', elementType: { type: 'number' } },\n            documentation: {\n                humanReadableName: variableInfo.humanReadableName,\n                priority: variableInfo.comesFromMultiSourceSet ? 1000 + order : order,\n                category: 'mapper',\n                longDescription: `Data from ${variableInfo.humanReadableName}`,\n                documentationTable: 'mapper-data-variables',\n                includedInOutputContext: true,\n                fromStatisticColumn: true,\n            },\n        })\n    }\n    for (const [name, info] of statistic_variables_info.multiSourceVariables) {\n        // Find the minimum priority of the individual variables (using raw order values)\n        const individualPriorities = info.individualVariables.map((varName) => {\n            const variableInfo = statistic_variables_info.variableNames.find(v => v.varName === varName)\n            assert(variableInfo !== undefined, `Variable info for ${varName} not found`)\n            return variableInfo.order\n        })\n        const minPriority = Math.min(...individualPriorities)\n\n        te.set(name, {\n            type: { type: 'vector', elementType: { type: 'number' } },\n            documentation: {\n                humanReadableName: info.humanReadableName,\n                priority: minPriority,\n                category: 'mapper',\n                longDescription: `Data from ${info.humanReadableName} (from whatever source is most reliable)`,\n                documentationTable: 'mapper-data-variables',\n                isDefault: name === 'density_pw_1km',\n                selectorRendering: { kind: 'subtitleLongDescription' },\n                includedInOutputContext: true,\n                fromStatisticColumn: true,\n            },\n        })\n    }\n\n    return te\n}\n\nexport function loadInsets(universe: Universe): Inset[] {\n    const insetsU = insets[universe]\n    assert(insetsU.length > 0, `No insets for universe ${universe}`)\n    assert(insetsU[0].mainMap, `No main map for universe ${universe}`)\n    const insetsProc = insetsU.map((inset) => {\n        return {\n            bottomLeft: [inset.bottomLeft[0], inset.bottomLeft[1]],\n            topRight: [inset.topRight[0], inset.topRight[1]],\n            // copy to get rid of readonly\n            coordBox: [...inset.coordBox],\n            mainMap: inset.mainMap,\n        } satisfies Inset\n    })\n    return insetsProc\n}\n\nexport function loadInsetExpression(universe: Universe): UrbanStatsASTExpression {\n    const insetsU = insets[universe]\n    const names = insetsU.map(x => x.name)\n\n    const exprs = names.map((name) => {\n        const expr = insetNameToConstantName.get(name)\n        assert(expr !== undefined, `No inset constant for ${name}`)\n        return { type: 'identifier', name: { node: expr, location: noLocation } } satisfies UrbanStatsASTExpression\n    })\n\n    return {\n        type: 'call',\n        fn: { type: 'identifier', name: { node: 'constructInsets', location: noLocation } },\n        args: [{\n            type: 'unnamed',\n            value: {\n                type: 'vectorLiteral',\n                elements: exprs,\n                entireLoc: noLocation,\n            } satisfies UrbanStatsASTExpression,\n        }],\n        entireLoc: noLocation,\n    } satisfies UrbanStatsASTExpression\n}\n","export function firstNonNan(numbers: number[]): number {\n    for (const num of numbers) {\n        if (!isNaN(num)) {\n            return num\n        }\n    }\n    return NaN\n}\n","// getDefaultExport function for compatibility with non-ESM modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};\n","__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(\n\t\tObject.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t\t__webpack_require__.f[key](chunkId, promises);\n\t\t\treturn promises;\n\t\t}, [])\n\t);\n};","// This function allow to reference chunks\n__webpack_require__.u = (chunkId) => {\n  // return url for filenames not based on template\n  \n  // return url for filenames based on template\n  return \"\" + chunkId + \".js\"\n}","__webpack_require__.g = (() => {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n  module.paths = [];\n  if (!module.children) module.children = [];\n  return module;\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif (chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor (var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--)\n\t\t\tdeferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif (\n\t\t\t\t(priority & (1 === 0) || notFulfilled >= priority) &&\n\t\t\t\tObject.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))\n\t\t\t) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif (priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif (fulfilled) {\n\t\t\tdeferred.splice(i--, 1);\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};\n","__webpack_require__.rv = () => (\"1.3.15\")","var next = __webpack_require__.x\n__webpack_require__.x = () => {\n  return Promise.all([\"597\",\"90\",\"879\",\"680\",\"257\",\"427\"].map(__webpack_require__.e, __webpack_require__)).then(next);\n}","var scriptUrl;\n\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n  // Technically we could use `document.currentScript instanceof window.HTMLScriptElement`,\n  // but an attacker could try to inject `<script>HTMLScriptElement = HTMLImageElement</script>`\n  // and use `<img name=\"currentScript\" src=\"https://attacker.controlled.server/\"></img>`\n  if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT') scriptUrl = document.currentScript.src;\n  if (!scriptUrl) {\n    var scripts = document.getElementsByTagName(\"script\");\n    if (scripts.length) {\n      var i = scripts.length - 1;\n      while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n    }\n  }\n}\n\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\",\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.',\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl","var installedChunks = {\"438\": 1,};\n// importScripts chunk loading\nvar installChunk = (data) => {\n    var [chunkIds, moreModules, runtime] = data;\n    for (var moduleId in moreModules) {\n        if (__webpack_require__.o(moreModules, moduleId)) {\n            __webpack_require__.m[moduleId] = moreModules[moduleId];\n        }\n    }\n    if (runtime) runtime(__webpack_require__);\n    while (chunkIds.length) installedChunks[chunkIds.pop()] = 1;\n    parentChunkLoadingFunction(data);\n};\n\n__webpack_require__.f.i = (chunkId, promises) => {\n    \n          // \"1\" is the signal for \"already loaded\n          if (!installedChunks[chunkId]) {\n            if (true) {\n              importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n            }\n          }\n          \n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkassets\"] = self[\"webpackChunkassets\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;","__webpack_require__.ruid = \"bundler=rspack@1.3.15\";\n"],"names":["defaultHueColors","hueColors","colorThemes","locationOfLastExpression","node","locationOf","assert","unify","_key","locations","startLine","min","loc","Math","Number","endLine","max","startCol","endCol","startChar","endChar","colorType","rgb","createConstantExpression","ctx","posArgs","namedArgs","alpha","rgbToColor","red","green","blue","tolerateError","Error","hsv","hsvToColor","hue","saturation","value","renderColor","color","doRender","colorConstant","name","isDefault","humanReadableName","camelToHuman","capitalizedName","hexToColor","parseNoErrorAsExpression","rgbColorExpression","round","hsvColorExpression","colorConstants","Object","insetType","insetsType","boundsType","Map","constructInsetValue","screenBounds","mapBounds","screenBoundsObj","mapBoundsObj","mainMap","constructInsetsValue","insetsList","item","computeInsetConstantName","insetConsts","insets","regionInsets","inset","uss","insetName","insetNameToConstantName","colorSchema","z","c","console","richTextAttributesSchema","s","pixels","result","parseFloat","isFinite","array","undefined","link","richTextDocumentType","richTextSegmentType","richTextListType","richTextAlignType","attributesFromNamedArgs","_namedArgs_color","_namedArgs_list","_namedArgs_align","_namedArgs_size","_namedArgs_font","_namedArgs_bold","_namedArgs_italic","_namedArgs_underline","_namedArgs_indent","_namedArgs_strike","entries","v","richTextSegmentConstructorType","richTextConstants","segmentsList","text","attributes","formula","image","id","scaleType","linearScale","values","center","isNaN","_Math","_Math1","computedMin","computedMax","range","linearScaleValue","logScaleValue","defaults","textBoxType","constructTextBoxValue","deconstructColor","backgroundColor","borderColor","borderWidth","nonExpressionOperators","operatorCharacters","keywords","isDigit","ch","isAlpha","parseNumber","input","component","component1","identifierLexer","string","operatorLexer","lex","block","tokens","lines","charIdx","i","line","lineTokens","lexLine","lineNo","charIdxOffset","idx","char","token","token1","lexNumber","match","numberFormat","numberStr","number","_iter","lexer","token2","lexGeneric","toks","lexOperators","_lexGeneric","finalIdx","supertok","tokenizedOperators","tokenizeOperators","allOps","allOperators","ops","Set","_iteratorError","expressionOperatorMap","op","Array","a","b","didMatch","start","location","_tokens","token3","lexString","resultObj","JSON","e","noLocation","unparse","opts","isSimpleExpression","expr","indentSpaces","level","_opts_expressionalContext","_opts_indent","_opts_wrap","characterLimit","exprStr","fnStr","argsStr","arg","fnWithParens","fnNeedsParens","notWrapped","wrappedArgs","unaryExprStr","needsParens","exprWithParens","_expressionOperatorMap_get_precedence","_expressionOperatorMap_get_precedence1","_expressionOperatorMap_get_precedence2","leftStr","rightStr","opPrecedence","leftWithParens","leftOpPrecedence","rightWithParens","rightOpPrecedence","elementsStr","elem","notWrapped1","wrappedElements","propertiesStr","key","valueStr","notWrapped2","wrappedProperties","lhsStr","statementsStr","stmt","conditionStr","thenStr","ifStr","elseStr","doStr","condStr","restStr","ParseState","skipEOL","consumeTokenOfType","type","consumeOperator","oneOfOps","consumeBracket","oneOfBrackets","consumeIdentifier","consumeKeyword","oneOfKeywords","maybeLastNonEOLToken","offset","parseSingleExpression","startLoc","properties","keyToken","endLoc","vectorStartLoc","elements","element","vectorEndLoc","parseArg","exprOrName","parseParenthesizedArgs","args","parseFunctionalExpression","fn","done","parseExpression","operatorExpSequence","state","loop","unaryOperators","operator","infixOperators","operator1","parseInfixSequence","precedences","x","maxPrecedence","index","p","resolveOperator","next","left","right","checkLHS","parseStatement","lhs","parseIfExpression","ifToken","condition","then","elseBranch","eb","lastToken","parseDoExpression","doToken","statements","parseConditionStatement","conditionToken","parseStatements","canEnd","end","errMsg","statement","mergeStatements","fallbackLocation","gulpRestForConditions","_stmt_rest","entireLoc","parseCustomNodeExpression","argsRes","_argsRes_args","locArg","code","parseResult","parse","returnParseErrorNode","parseTokens","originalCode","lexErrors","errors","stmts","identifiersInExpr","expressions","identifiers","allExpressions","helper","n","allIdentifiers","newIdentifiers","_ctx_getVariable","t","dv","newId","blockId","getPrimitiveType","depth","_type_of","unifyType","error","renderType","_iteratorError1","key1","type1","res","canUnifyTo","undocValue","unifyFunctionType","param","ret","_instanceof","k","renderArgumentType","renderReturnType","renderKwargType","mapperCache","_effect","_error","_constants","_variables","Context","effect","constants","variables","eff","msg","getVariable","assignVariable","variableEntries","evolveVariables","locateType","predicate","predicateDescriptor","overallType","locateTypeVector","subtypesOrErrors","subresults","prefixes","types","locateTypeObject","toBroadcast","rawValue","firstDims","subValue","newRawValues","newRawValue","r","k1","addAdditionalDims","dims","broadcastApply","kwArgs","locInfo","locateFunctionAndArguments","posArgLocated","unifyFunctionArgType","fnType","posArgsLocated","fnLocatedOrError","fnLocated","usingDefaults","na","defaultValue","evaluateDefault","evaluate","kwArgsLocated","_iteratorError2","isNullable","kwArgLocated","_result_result","allTogether","allTogetherOrErr","expandDims","descriptors","maximalExpansionSize","maximalExpansionIdx","prefix","_values_i","i1","off","j","_value","resulting","mapSeveral","argumentNames","originalArgs","kw","InterpretationError","_","posArgsI","kwArgsI","returnTypeOrInfer","returnType","nestedVectorType","indexType","mergeValuesViaMasks","mask","references","_values_find","_attemptCoerceToType","specialCase","mergeValuesViaMasksSpecialCaseMap","nonNullValues","nonNullValue","firstType","uniqueTypeReprs","mType","maskVector","indices","whichValue","valueType","valueVector","defaultV","finalRes","defaultValueForType","NaN","finalResValue","attemptCoerceToType","toType","contents","message","renderLocInfo","env","varName","lookupResult","attrLookupOrSet","func","broadcastResult","evaluateUnaryOperator","operand","errLoc","operatorObj","evaluateBinaryOperator","elementType","ts","vs","splitMask","errLocCondition","errLocIf","collectIn","collectUniqueMaskValues","et","results","uniqueValueArray","sa","sb","maskType","outEnvsValues","subEnv","indexMaskIntoContext","reference","newEnv","indexed","indexMask","indexMaskComposite","repeated","repeatMany","count","vt","newTypes","newProperties","vVal","referenceType","resultsOrErr","_results","elt","newVars","allKeys","_subEnv_getVariable","merged","_iteratorError3","_$err","mergedValues","execute","doResult","evaluateLHS","err","obj","attr","orSet","val","aT","content","val1","orSetLookp","typ","sanitize","longname","spaces_around_slash","type_ordering_idx","debugPerformance","historicalCongressionals","weights","sumOfWeights","total","loadProtobuf","filePath","errorOnMissing","perfCheckpoint","response","compressedBuffer","arr","performance","fetch","Uint8Array","gunzipSync","Buffer","Article","Feature","ArticleOrderingList","OrderLists","DataLists","ConsolidatedShapes","SearchIndex","QuizQuestionTronche","QuizFullData","CountsByArticleUniverseAndType","Symlinks","PointSeries","ArticleUniverseList","defaultTypeEnvironment","universe","te","defaultConstants","exprs","names","insetsU","statistic_variables_info","variableInfo","order","info","individualPriorities","minPriority","onmessage","request","context","getWarnings","interpretationError","_getWarnings","effects","emptyContext","geographyKind","dte","longnames","annotateType","validGeographies","encodeURIComponent","indexData","typeInfo","existing","statpath","variableData","statistic_path_list","links","dataLists","universeIdx","universes","data_links","pullKey","current","universes_ordered","_universes_universes_i_universeIdxs","universeIndex","ids","Promise","va","subvars","vsPromise","subvar","valuesNotNull","firstNonNan","numbers","num","removeFunctions","Function","_v_documentation","postMessage","globalThis","window","Symbol","importScripts","self"],"mappings":"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QAAU,mCAAmD,OAAjBzL,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAAWpG,GAAM,iDAAgD,CACzI,C,eC3PqC,AAG8FnO,GAAAA,EAAAA,EAAAA,AAAAA,EAAyB,GCvC5J,MAAe,CACX,SACA,MACA,MACA,aACA,MACA,MACA,OACA,eACA,yBACA,uBACA,wBACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,iCACA,cACA,0BACA,qBACA,kBACA,oBACA,mBACA,kBACA,mBACA,2BACA,wBACA,eACA,qBACA,wBACA,uBACA,SACA,YACA,YACA,UACA,qBACA,eACA,uBACA,mBACA,oBACA,oBACA,oBACA,qBACA,qBACA,qBACA,mBACH,CClED,EAAe,CACX,oCACA,yBACA,oCACA,yBACA,oCACA,yBACA,oCACA,yBACA,oCACA,kBACA,cACA,eACA,eACA,gBACA,YACA,gBACA,mBACA,kBACA,aACA,iBACA,eACA,iBACA,mBACA,cACA,gBACA,kBACA,eACA,YACA,iBACA,gBACA,cACA,iBACA,cACA,eACA,eACA,UACA,eACA,eACA,sBACA,sBACA,SACA,cACA,cACA,qBACA,qBACA,OACA,cACA,mBACA,mBACA,0BACA,0BACA,QACA,aACA,aACA,oBACA,oBACA,YACA,YACA,mBACA,mBACA,OACA,YACA,YACA,mBACA,mBACA,QACA,aACA,aACA,oBACA,oBACA,OACA,YACA,YACA,mBACA,mBACA,QACA,aACA,aACA,oBACA,oBACA,OACA,YACA,YACA,mBACA,mBACA,OACA,QACA,aACA,aACA,oBACA,0BACA,sBACA,QACA,aACA,aACA,+BACA,wCACA,0BACA,cACA,kBACA,kBACA,2BACA,0BACA,wBACA,yBACA,8BACA,6BACA,kCACA,4BACA,2BACA,2BACA,4BACA,2BACA,4BACA,2BACA,2BACA,6BACA,uBACA,iBACA,wBACA,wBACA,+BACA,kBACA,yBACA,oBACA,kBACA,qBACA,oBACA,2BACA,sBACA,6BACA,kBACA,yBACA,kBACA,yBACA,uBACA,8BACA,oBACA,2BACA,iBACA,iBACA,mBACA,0BACA,oBACA,mBACA,oBACA,mBACA,oBACA,mBACA,oBACA,oBACA,cACA,mBACA,mBACA,8BACA,sBACA,4BACA,aACA,gBACA,sBACA,WACA,gBACA,gBACA,uBACA,uBACA,uBACA,4BACA,4BACA,gBACA,gCACA,+BACA,iCACA,6BACA,+BACA,6BACA,kBACA,uBACA,uBACA,iCACA,gCACA,kCACA,8BACA,gCACA,8BACA,2CACA,kDACA,oEACA,2EACA,sDACA,6DACA,+CACA,sDACA,wBACA,+BACA,gCACA,uCACA,iCACA,wCACA,6CACA,oDACA,uBACA,8BACA,mDACA,0DACA,yBACA,gCACA,yDACA,gEACA,wDACA,+DACA,4DACA,mEACA,iCACA,wCACA,8CACA,qDACA,wBACA,+BACA,0CACA,iDACA,qBACA,4BACA,2BACA,kCACA,0BACA,0BACA,6BACA,qBACA,wBACA,iBACA,mBACA,0BACA,yBACA,0BACA,4BACA,iBACA,uBACA,oBACA,2BACA,gCACA,uCACA,yBACA,gCACA,0CACA,4BACA,6BACA,kCACA,uBACA,yBACA,mBACA,qBACA,wBACA,qBACA,qBACA,qBACA,0BACA,0BACA,0BACA,gBACA,oBACA,oBACA,oBACA,oBACA,0BACA,SACA,cACA,cACA,sDACA,wEACA,uEACA,2DACA,sDACA,mDACA,qDACA,8DACA,wDACA,qGACA,8DACA,0FACA,kDACA,4CACA,+DACA,2DACA,+BACA,4DACA,oCACA,yCACA,2DACA,mDACA,oCACA,2CACA,wCACA,sBACA,2BACA,2BACA,sBACA,6BACA,kBACA,aACA,kBACA,kBACA,yBACA,yBACA,yBACA,qBACA,aACA,uBACA,qBACA,qBACA,uBACA,qBACA,qBACA,uBACA,sBACA,uBACA,mBACA,KACA,UACA,UACA,iBACA,0BACA,0BACA,0BACA,+BACA,+BACA,uBACA,uBACA,uBACA,4BACA,4BACA,aACA,aACA,gCACA,qCACA,aACA,+BACA,iCACA,4CACA,qCACA,gDACA,uCACA,8CACA,uCACA,8CACA,qCACA,4CACA,sCACA,6CACA,uCACA,8CACA,4BACA,2BACA,+BACA,4BACA,sCACA,UACA,eACA,eACA,+BACA,+BACA,yBACA,QACA,aACA,aACA,0BACA,kCACA,oBACA,qBACA,yBACA,6BACA,0BACA,0BACA,0BACA,0BACA,2BACH,C,0BC6lBD,OAr9BwC,CACpC,oBAAqB,CACjB,IACA,IACA,IACA,GACH,CACD,oBAAqB,CACjB,IACA,IACH,CACD,mBAAoB,CAChB,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,qBAAsB,CAClB,IACA,GACH,CACD,wBAAyB,CACrB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,uBAAwB,CACpB,GACA,GACA,GACA,GACA,GACH,CACD,YAAa,CACT,IACA,IACH,CACD,IAAO,CACH,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,KAAQ,CACJ,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,yBAA0B,CACtB,IACA,IACH,CACD,iCAAkC,CAC9B,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACH,CACD,iCAAkC,CAC9B,IACA,IACH,CACD,iCAAkC,CAC9B,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,IACA,EACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,GACA,GACA,GACA,GACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,IACA,EACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,iCAAkC,CAC9B,IACA,IACA,GACH,CACD,OAAU,CACN,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,kBAAmB,CACf,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,EACH,CACD,2BAA4B,CACxB,IACA,IACH,CACD,wBAAyB,CACrB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,IAAO,CACH,GACA,GACA,GACA,GACA,GACH,CACD,uBAAwB,CACpB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,cAAe,CACX,IACA,IACH,CACD,0BAA2B,CACvB,IACA,GACH,CACD,qBAAsB,CAClB,IACA,IACA,GACH,CACD,aAAgB,CACZ,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,kBAAmB,CACf,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,uBAAwB,CACpB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,wBAAyB,CACrB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,qBAAsB,CAClB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,aAAc,CACV,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACH,CACD,eAAgB,CACZ,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,CACD,IAAO,CACH,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACH,AACL,ECp9BA,GAAe,CACX,QACA,SACA,OACA,SACA,gBACA,UACA,gBACA,UACA,uBACA,cACA,sBACA,WACA,UACA,UACA,SACA,YACA,UACA,YACA,QACA,aACA,yBACA,WACA,aACA,UACA,eACA,WACA,UACA,UACA,QACA,UACA,SACA,UACA,SACA,cACA,SACA,WACA,UACA,SACA,SACA,0BACA,mCACA,2BACA,QACA,cACA,cACA,eACA,QACA,WACA,QACA,WACA,aACA,OACA,aACA,mBACA,SACA,iBACA,UACA,WACA,UACA,WACA,qBACA,UACA,UACA,UACA,QACA,UACA,QACA,WACA,UACA,OACA,mBACA,aACA,gBACA,SACA,QACA,iBACA,UACA,UACA,WACA,QACA,YACA,YACA,aACA,SACA,oBACA,SACA,YACA,gBACA,SACA,WACA,UACA,QACA,UACA,YACA,UACA,SACA,cACA,QACA,OACA,OACA,UACA,QACA,SACA,UACA,SACA,QACA,QACA,aACA,WACA,WACA,UACA,wBACA,cACA,cACA,SACA,iBACA,aACA,OACA,UACA,cACA,gBACA,YACA,UACA,UACA,YACA,aACA,SACA,QACA,UACA,SACA,UACA,aACA,aACA,mBACA,kBACA,OACA,UACA,WACA,aACA,aACA,QACA,YACA,WACA,SACA,SACA,WACA,aACA,UACA,QACA,iBACA,UACA,YACA,cACA,SACA,QACA,QACA,OACA,cACA,OACA,SACA,OACA,mBACA,cACA,WACA,SACA,mBACA,qBACA,WACA,QACA,WACA,QACA,UACA,SACA,SACA,SACA,eACA,kBACA,aACA,QACA,SACA,YACA,+CACA,WACA,WACA,eACA,aACA,UACA,UACA,WACA,cACA,iCACA,cACA,QACA,WACA,2BACA,OACA,OACA,WACA,aACA,UACA,aACA,eACA,UACA,QACA,SACA,sBACA,SACA,WACA,UACA,SACA,MACA,UACA,aACA,eACA,mCACA,YACA,yBACA,UACA,UACA,QACA,QACA,eACA,SACA,WACA,eACA,cACA,eACA,gBACA,kBACA,gBACA,mBACA,gBACA,eACA,eACA,cACA,aACA,gBACA,eACA,YACA,cACA,gBACA,iBACA,aACA,gBACA,qBACA,gBACA,iBACA,mBACA,gBACA,eACA,gBACA,cACA,qBACA,kBACA,kBACA,gBACA,sBACA,oBACA,YACA,gBACA,cACA,oBACA,oBACA,sBACA,oBACA,iBACA,aACA,YACA,eACA,gBACA,kBACA,qBACA,iBACA,eACA,sBACA,YACA,gCACA,mBACA,yBACA,4BACA,kBACA,2BACA,mBACA,wBACA,oCACA,gCACA,sBACA,kBACA,kBACA,+BACA,iBACA,uBACA,gBACH,C,uHC5LM,SAASigB,GAASC,CAAgB,E,IAAEC,EAAAA,CAAAA,CAAA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"}