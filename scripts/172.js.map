{"version":3,"file":"172.js","sources":["webpack://assets/./src/urban-stats-script/Editor.tsx","webpack://assets/./src/urban-stats-script/StandaloneEditor.tsx","webpack://assets/./src/urban-stats-script/ast.ts","webpack://assets/./src/urban-stats-script/constants/color.ts","webpack://assets/./src/urban-stats-script/constants/insets.ts","webpack://assets/./src/urban-stats-script/constants/scale.ts","webpack://assets/./src/urban-stats-script/context.ts","webpack://assets/./src/urban-stats-script/editor-utils.tsx","webpack://assets/./src/utils/isAMatch.ts","webpack://assets/./src/urban-stats-script/interpreter.ts","webpack://assets/./src/urban-stats-script/lexer.ts","webpack://assets/./src/urban-stats-script/location.ts","webpack://assets/./src/urban-stats-script/parser.ts","webpack://assets/./src/urban-stats-script/types-values.ts","webpack://assets/./src/urban-stats-script/worker.ts","webpack://assets/./src/urban-stats-script/workerManager.ts","webpack://assets/./src/uss-documentation.tsx"],"sourcesContent":["import '@fontsource/inconsolata/500.css'\n\nimport React, { CSSProperties, ReactNode, useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useColors } from '../page_template/colors'\nimport { LongFormDocumentation } from '../uss-documentation'\nimport { TestUtils } from '../utils/TestUtils'\n\nimport { renderCode, getRange, nodeContent, Range, setRange, EditorResult, longMessage, Script, makeScript, getAutocompleteOptions, createAutocompleteMenu, createPlaceholder, createDocumentationPopover } from './editor-utils'\nimport { AnnotatedToken } from './lexer'\nimport { LocInfo } from './location'\nimport { TypeEnvironment, USSDocumentedType } from './types-values'\n\ninterface AutocompleteState {\n    kind: 'autocomplete'\n    location: LocInfo\n    options: string[]\n    element: HTMLElement\n    apply: (optionIdx: number) => void\n}\n\ninterface DocumentationState {\n    kind: 'documentation'\n    location: LocInfo\n    name: string\n    value: USSDocumentedType\n    element: HTMLElement\n}\n\ntype PopoverState = AutocompleteState | DocumentationState | undefined\n\nexport function Editor(\n    { uss, setUss, typeEnvironment, results, placeholder, selection, setSelection, eRef }: {\n        uss: string\n        setUss: (newScript: string) => void\n        typeEnvironment: TypeEnvironment\n        results: EditorResult[]\n        placeholder?: string\n        selection: Range | null\n        setSelection: (newRange: Range | null) => void\n        eRef?: React.MutableRefObject<HTMLPreElement | null>\n    },\n): ReactNode {\n    const setSelectionRef = useRef(setSelection)\n    setSelectionRef.current = setSelection\n\n    const script = useMemo(() => makeScript(uss), [uss])\n\n    const colors = useColors()\n\n    const editorRef = useRef<HTMLPreElement | null>(null)\n\n    const [popoverState, setPopoverState] = useState<PopoverState>(undefined)\n    const [autocompleteSelectionIdx, setAutocompleteSelectionIdx] = useState(0)\n\n    const spanTokenMapRef = useRef<Map<Element, AnnotatedToken>>(new Map())\n\n    const renderScript = useCallback((newScript: Script) => {\n        spanTokenMapRef.current.clear()\n\n        const fragment = renderCode(\n            newScript, colors, results.filter(r => r.kind !== 'success'),\n            (token, content) => {\n                if (popoverState?.location.end.charIdx === token.location.end.charIdx && token.token.type === 'identifier') {\n                    content.push(popoverState.element)\n                }\n                if (placeholder !== undefined && newScript.tokens.every(t => t.token.type === 'operator' && t.token.value === 'EOL') && token.location.end.charIdx === 0) {\n                    content.push(createPlaceholder(colors, placeholder))\n                }\n            },\n            (token, span) => {\n                spanTokenMapRef.current.set(span, token)\n            },\n        )\n\n        const editor = editorRef.current!\n        editor.replaceChildren(...fragment)\n        // Usually you want to set the selection after this, since it has been reset\n    }, [colors, results, popoverState, placeholder])\n\n    const lastRenderScript = useRef<typeof renderScript>(renderScript)\n    const lastScript = useRef<Script | undefined>(undefined)\n\n    useEffect(() => {\n        const editor = editorRef.current!\n\n        // Rerendering when just a selection change happens causes the selection interaction to be interrupted\n        if (script !== lastScript.current || renderScript !== lastRenderScript.current) {\n            renderScript(script)\n        }\n        setRange(editor, selection)\n\n        lastRenderScript.current = renderScript\n        lastScript.current = script\n    }, [renderScript, script, selection])\n\n    const editScript = useCallback((newUss: string, newRange: Range) => {\n        const newScript = makeScript(newUss)\n        renderScript(newScript)\n        setRange(editorRef.current!, newRange)\n        setUss(newScript.uss)\n        setSelection(newRange)\n        setPopoverState(undefined)\n    }, [renderScript, setUss, setSelection])\n\n    useEffect(() => {\n        const listener = (): void => {\n            // These events are often spurious\n\n            const range = getRange(editorRef.current!)\n            setSelectionRef.current(range)\n            // Cancel autocomplete if the selection is no longer at the end\n            setPopoverState(s => s?.kind === 'autocomplete' && (s.location.end.charIdx !== range?.start || s.location.end.charIdx !== range.end) ? undefined : s)\n        }\n        document.addEventListener('selectionchange', listener)\n        return () => {\n            document.removeEventListener('selectionchange', listener)\n        }\n    }, []) // Rebinding can cause problems with multiple editors as they stop listening when one editor changes selection\n\n    useEffect(() => {\n        const editor = editorRef.current!\n        const listener = (): void => {\n            const range = getRange(editor)\n            const newScript = makeScript(nodeContent(editor))\n            const token = range !== null && range.start === range.end\n                ? newScript.tokens.find(t => t.token.type === 'identifier' && t.location.end.charIdx === range.start)\n                : undefined\n            if (token !== undefined) {\n                const tokenValue = token.token.value as string\n                const options = getAutocompleteOptions(typeEnvironment, newScript.tokens, tokenValue)\n                if (options.length === 0) {\n                    setPopoverState(undefined)\n                }\n                else {\n                    setPopoverState({\n                        kind: 'autocomplete',\n                        location: token.location,\n                        options,\n                        element: createAutocompleteMenu(colors),\n                        apply(optionIdx) {\n                            const option = options[optionIdx]\n                            const delta = option.length - tokenValue.length\n                            const editedUss = newScript.uss.slice(0, token.location.start.charIdx) + option + newScript.uss.slice(token.location.end.charIdx)\n                            const editedRange = { start: token.location.end.charIdx + delta, end: token.location.end.charIdx + delta }\n                            editScript(editedUss, editedRange)\n                        },\n                    })\n                    setAutocompleteSelectionIdx(0)\n                }\n            }\n            else {\n                setPopoverState(undefined)\n            }\n            setUss(newScript.uss)\n            setSelection(range)\n        }\n        editor.addEventListener('input', listener)\n        return () => { editor.removeEventListener('input', listener) }\n    }, [typeEnvironment, colors, editScript, setUss, setSelection])\n\n    useEffect(() => {\n        const editor = editorRef.current!\n        const listener = (e: KeyboardEvent): void => {\n            if (popoverState?.kind === 'autocomplete') {\n                switch (e.key) {\n                    case 'Enter':\n                    case 'Tab':\n                        e.preventDefault()\n                        popoverState.apply(autocompleteSelectionIdx)\n                        return\n                    case 'Escape':\n                        e.preventDefault()\n                        setPopoverState(undefined)\n                        return\n                    case 'ArrowDown':\n                    case 'ArrowUp':\n                        e.preventDefault()\n                        if (e.key === 'ArrowDown') {\n                            setAutocompleteSelectionIdx(i => i + 1 >= popoverState.options.length ? 0 : i + 1)\n                        }\n                        else {\n                            setAutocompleteSelectionIdx(i => i - 1 < 0 ? popoverState.options.length - 1 : i - 1)\n                        }\n                        return\n                }\n            }\n\n            if (e.key === 'Tab') {\n                e.preventDefault()\n                const range = getRange(editor)\n                if (range !== null) {\n                    editScript(\n                        `${script.uss.slice(0, range.start)}    ${script.uss.slice(range.end)}`,\n                        { start: range.start + 4, end: range.start + 4 },\n                    )\n                }\n            }\n            else if (e.key === 'Backspace') {\n                const range = getRange(editor)\n                if (range !== null && range.start === range.end && range.start >= 4 && script.uss.slice(range.start - 4, range.start) === '    ') {\n                    e.preventDefault()\n                    editScript(\n                        `${script.uss.slice(0, range.start - 4)}${script.uss.slice(range.start)}`,\n                        { start: range.start - 4, end: range.start - 4 },\n                    )\n                }\n            }\n        }\n        editor.addEventListener('keydown', listener)\n        return () => { editor.removeEventListener('keydown', listener) }\n    }, [script, renderScript, popoverState, autocompleteSelectionIdx, editScript])\n\n    useEffect(() => {\n        const editor = editorRef.current!\n        const listener = (): void => {\n            setPopoverState(undefined)\n        }\n        editor.addEventListener('blur', listener)\n        return () => { editor.removeEventListener('blur', listener) }\n    }, [])\n\n    useEffect(() => {\n        let hoveredToken: AnnotatedToken | undefined\n        const listener = (event: MouseEvent): void => {\n            for (const elem of document.elementsFromPoint(event.clientX, event.clientY)) {\n                let token: AnnotatedToken | undefined, name, value\n                if ((token = spanTokenMapRef.current.get(elem)) !== undefined && token.token.type === 'identifier' && (name = token.token.value) && (value = typeEnvironment.get(name)) !== undefined) {\n                    hoveredToken = token\n                    const opts = {\n                        location: token.location,\n                        name,\n                        value,\n                    }\n                    setTimeout(() => {\n                        if (hoveredToken === token) {\n                            setPopoverState({\n                                kind: 'documentation',\n                                ...opts,\n                                element: createDocumentationPopover(colors),\n                            })\n                        }\n                    }, 500)\n                    return\n                }\n                if (popoverState?.kind === 'documentation' && popoverState.element === elem) {\n                    hoveredToken = undefined\n                    return\n                }\n            }\n            hoveredToken = undefined\n            if (popoverState?.kind === 'documentation') {\n                setPopoverState(undefined)\n            }\n        }\n        document.addEventListener('mousemove', listener)\n        return () => { document.removeEventListener('mousemove', listener) }\n    }, [colors, typeEnvironment, popoverState])\n\n    const borderColor = useResultsColor(colorKey(results))\n\n    return (\n        <div style={{ marginTop: '0.25em' }}>\n            <pre\n                id=\"test-editor-body\"\n                style={{\n                    ...codeStyle,\n                    caretColor: TestUtils.shared.isTesting ? 'transparent' : colors.textMain,\n                    border: `1px solid ${borderColor}`,\n                    borderRadius: TestUtils.shared.isTesting ? 0 : (results.length > 0 ? '5px 5px 0 0' : '5px'),\n                }}\n                ref={(e) => {\n                    editorRef.current = e\n                    if (eRef !== undefined) {\n                        eRef.current = e\n                    }\n                }}\n                contentEditable=\"plaintext-only\"\n                spellCheck=\"false\"\n            />\n            <DisplayResults results={results} editor={true} />\n            {popoverState === undefined\n                ? null\n                : createPortal(\n                    popoverState.kind === 'autocomplete'\n                        ? (\n                                <Autocomplete\n                                    state={popoverState}\n                                    selectionIdx={autocompleteSelectionIdx}\n                                    setSelectionIdx={setAutocompleteSelectionIdx}\n                                    apply={(i) => { popoverState.apply(i) }}\n                                />\n                            )\n                        : <LongFormDocumentation name={popoverState.name} value={popoverState.value} />,\n                    popoverState.element,\n                )}\n        </div>\n    )\n}\n\nexport const codeStyle: CSSProperties = {\n    whiteSpace: 'pre-wrap',\n    fontFamily: 'Inconsolata, monospace',\n    fontWeight: 500,\n    lineHeight: '175%',\n    margin: 0,\n    padding: '1em',\n}\n\nfunction colorKey(results: EditorResult[]): 'r' | 'o' | 'g' | 's' {\n    switch (true) {\n        case results.some(r => r.kind === 'error'):\n            return 'r'\n        case results.some(r => r.kind === 'warning'):\n            return 'o'\n        case results.some(r => r.kind === 'success'):\n            return 'g'\n        default:\n            return 's'\n    }\n}\n\nfunction useResultsColor(cKey: 'r' | 'o' | 'g' | 's'): string {\n    const colors = useColors()\n    switch (cKey) {\n        case 'r':\n            return colors.hueColors.red\n        case 'o':\n            return colors.hueColors.orange\n        case 'g':\n            return colors.hueColors.green\n        case 's':\n            return colors.borderShadow\n    }\n}\n\nexport function DisplayResults(props: { results: EditorResult[], editor: boolean }): ReactNode | undefined {\n    const colors = useColors()\n    const cKey = colorKey(props.results)\n    const color = useResultsColor(cKey)\n    if (props.results.length === 0) {\n        return undefined\n    }\n    const border = `2px solid ${color}`\n    const style = {\n        ...codeStyle,\n        borderRadius: TestUtils.shared.isTesting ? 0 : (props.editor ? '0 0 5px 5px' : '5px'),\n        backgroundColor: colors.slightlyDifferentBackground,\n        color: colors.textMain,\n        borderTop: props.editor ? 'none' : border,\n        borderRight: border,\n        borderBottom: border,\n        borderLeft: border,\n        marginTop: props.editor ? '0' : '0.25em',\n    }\n    return (\n        <div id=\"test-editor-result\" className={`color-${cKey}`}>\n            <pre style={style}>\n                {props.results.map((error, _, errors) => `${errors.length > 1 ? '- ' : ''}${longMessage(error, props.editor)}`).join('\\n')}\n            </pre>\n        </div>\n    )\n}\n\nfunction Autocomplete(props: { state: Exclude<AutocompleteState, undefined>, selectionIdx: number, setSelectionIdx: (idx: number) => void, apply: (idx: number) => void }): ReactNode {\n    return props.state.options.map((option, index) => (\n        <AutocompleteOption\n            key={option}\n            option={option}\n            index={index}\n            selected={index === props.selectionIdx}\n            apply={() => { props.apply(index) }}\n        />\n    ))\n}\n\nfunction AutocompleteOption(props: { option: string, index: number, selected: boolean, apply: () => void }): ReactNode {\n    const colors = useColors()\n    const [hovering, setHovering] = useState(false)\n    const style: CSSProperties = {\n        cursor: 'pointer',\n        backgroundColor: (props.selected || hovering\n            ? colors.slightlyDifferentBackgroundFocused\n            : props.index % 2 === 0 ? colors.background : colors.slightlyDifferentBackground),\n        padding: '0 0.5em',\n    }\n\n    const optionRef = useRef<HTMLDivElement>(null)\n\n    useEffect(() => {\n        optionRef.current?.scrollIntoView({ block: 'nearest' })\n    }, [props.selected])\n\n    return (\n        <div\n            ref={optionRef}\n            style={style}\n            onMouseEnter={() => { setHovering(true) }}\n            onMouseLeave={() => { setHovering(false) }}\n            onClick={props.apply}\n        >\n            {props.option}\n        </div>\n    )\n}\n","/**\n * Typically an Editor is connected to another system (e.g. the mapper) that manages its state.\n * This Editor mostly manages its own state, and presents its own result.\n */\n\nimport React, { ReactNode, useEffect, useRef, useState } from 'react'\n\nimport { Editor } from './Editor'\nimport { defaultConstants } from './constants/constants'\nimport { EditorResult, Range, UndoRedoOptions, useUndoRedo } from './editor-utils'\nimport { parse } from './parser'\nimport { TypeEnvironment } from './types-values'\nimport { executeAsync } from './workerManager'\n\nexport function StandaloneEditor(props: { ident: string, getCode: () => string, onChange?: (code: string) => void }): ReactNode {\n    const editorRef = useRef<HTMLPreElement | null>(null)\n\n    const { uss, setUss, typeEnvironment, results, selection, setSelection, undoRedoUi } = useStandaloneEditorState<Range | null>({\n        ...props,\n        getSelection: () => null,\n        undoRedoOptions: { onlyElement: editorRef },\n    })\n\n    return (\n        <div id=\"test-editor-panel\">\n            <Editor\n                uss={uss}\n                setUss={setUss}\n                typeEnvironment={typeEnvironment}\n                results={results}\n                placeholder=\"Enter Urban Stats Script\"\n                selection={selection}\n                setSelection={setSelection}\n                eRef={editorRef}\n            />\n            {undoRedoUi}\n        </div>\n    )\n}\n\nexport function useStandaloneEditorState<Selection>({ ident, getCode, onChange, getSelection, undoRedoOptions }: {\n    ident: string\n    getCode: () => string\n    onChange?: (code: string) => void\n    getSelection: () => Selection\n    undoRedoOptions: UndoRedoOptions\n}): {\n        uss: string\n        setUss: (newUss: string) => void\n        typeEnvironment: TypeEnvironment\n        results: EditorResult[]\n        selection: Selection\n        setSelection: (newSelection: Selection) => void\n        undoRedoUi: ReactNode\n    } {\n    const [results, setResults] = useState<EditorResult[]>([])\n\n    const [uss, setUss] = useState(getCode)\n    const ussVersion = useRef(0)\n\n    const [selection, setSelection] = useState<Selection>(getSelection)\n\n    const updateUss = async (newScript: string): Promise<void> => {\n        setUss(newScript)\n        const version = ++ussVersion.current\n        onChange?.(newScript)\n\n        const stmts = parse(newScript, { type: 'single', ident })\n\n        if (stmts.type === 'error') {\n            setResults(stmts.errors.map(e => ({ ...e, kind: 'error' })))\n            return\n        }\n\n        const exec = await executeAsync({ descriptor: { kind: 'generic' }, stmts })\n\n        if (version === ussVersion.current) {\n            // avoid race conditions\n            setResults([\n                ...(exec.resultingValue !== undefined ? [{ kind: 'success' as const, result: exec.resultingValue }] : []),\n                ...exec.error,\n            ])\n        }\n    }\n\n    const { addState, updateCurrentSelection, ui: undoRedoUi } = useUndoRedo(\n        uss,\n        selection,\n        updateUss,\n        setSelection,\n        undoRedoOptions,\n    )\n\n    useEffect(\n        () => {\n            void updateUss(getCode())\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps -- run once at beginning\n        [],\n    )\n\n    const typeEnvironment = defaultConstants as TypeEnvironment\n\n    return {\n        uss,\n        setUss: (newUss) => {\n            void updateUss(newUss)\n            addState(newUss, selection)\n        },\n        setSelection: (newSelection) => {\n            setSelection(newSelection)\n            updateCurrentSelection(newSelection)\n        },\n        typeEnvironment,\n        selection,\n        results,\n        undoRedoUi,\n    }\n}\n","import assert from 'assert'\n\nimport { LocInfo } from './location'\nimport { Decorated, ParseError } from './parser'\nimport { USSType } from './types-values'\n\nexport type UrbanStatsASTArg = (\n    { type: 'unnamed', value: UrbanStatsASTExpression } |\n    { type: 'named', name: Decorated<string>, value: UrbanStatsASTExpression })\n\nexport type UrbanStatsASTLHS = (\n    { type: 'identifier', name: Decorated<string> } |\n    { type: 'attribute', expr: UrbanStatsASTExpression, name: Decorated<string> })\n\nexport type UrbanStatsASTExpression = (\n    UrbanStatsASTLHS |\n    { type: 'constant', value: Decorated<{ type: 'number', value: number } | { type: 'string', value: string }> } |\n    { type: 'call', fn: UrbanStatsASTExpression, args: UrbanStatsASTArg[], entireLoc: LocInfo } |\n    { type: 'binaryOperator', operator: Decorated<string>, left: UrbanStatsASTExpression, right: UrbanStatsASTExpression } |\n    { type: 'unaryOperator', operator: Decorated<string>, expr: UrbanStatsASTExpression } |\n    { type: 'objectLiteral', entireLoc: LocInfo, properties: [string, UrbanStatsASTExpression][] } |\n    { type: 'vectorLiteral', entireLoc: LocInfo, elements: UrbanStatsASTExpression[] } |\n    { type: 'if', entireLoc: LocInfo, condition: UrbanStatsASTExpression, then: UrbanStatsASTStatement, else?: UrbanStatsASTStatement } |\n    { type: 'do', entireLoc: LocInfo, statements: UrbanStatsASTStatement[] } |\n    // for internal purposes only\n    { type: 'customNode', entireLoc: LocInfo, expr: UrbanStatsASTStatement, originalCode: string, expectedType?: USSType[] }\n)\n\nexport type UrbanStatsASTStatement = (\n    { type: 'assignment', lhs: UrbanStatsASTLHS, value: UrbanStatsASTExpression } |\n    { type: 'expression', value: UrbanStatsASTExpression } |\n    { type: 'statements', entireLoc: LocInfo, result: UrbanStatsASTStatement[] } |\n    { type: 'condition', entireLoc: LocInfo, condition: UrbanStatsASTExpression, rest: UrbanStatsASTStatement[] } |\n    { type: 'parseError', originalCode: string, errors: ParseError[] })\n\nexport type UrbanStatsAST = UrbanStatsASTArg | UrbanStatsASTExpression | UrbanStatsASTStatement\n\nexport function unify(...locations: LocInfo[]): LocInfo {\n    assert(locations.length > 0, 'At least one location must be provided for unification')\n    const startLine = locations.reduce((min, loc) => Math.min(min, loc.start.lineIdx), Number.MAX_VALUE)\n    const endLine = locations.reduce((max, loc) => Math.max(max, loc.end.lineIdx), -Number.MAX_VALUE)\n    const startCol = locations.reduce((min, loc) => Math.min(min, loc.start.colIdx), Number.MAX_VALUE)\n    const endCol = locations.reduce((max, loc) => Math.max(max, loc.end.colIdx), -Number.MAX_VALUE)\n    const startChar = locations.reduce((min, loc) => Math.min(min, loc.start.charIdx), Number.MAX_VALUE)\n    const endChar = locations.reduce((max, loc) => Math.max(max, loc.end.charIdx), -Number.MAX_VALUE)\n    return {\n        start: { block: locations[0].start.block, lineIdx: startLine, colIdx: startCol, charIdx: startChar },\n        end: { block: locations[0].end.block, lineIdx: endLine, colIdx: endCol, charIdx: endChar },\n    }\n}\n\nexport function locationOf(node: UrbanStatsAST): LocInfo {\n    /* c8 ignore start -- This function doesn't need to be tested in detail, as it is a simple location extractor */\n    switch (node.type) {\n        case 'unnamed':\n            return locationOf(node.value)\n        case 'named':\n            return unify(node.name.location, locationOf(node.value))\n        case 'constant':\n            return node.value.location\n        case 'identifier':\n            return node.name.location\n        case 'attribute':\n            return unify(node.name.location, locationOf(node.expr))\n        case 'call':\n            return node.entireLoc\n        case 'unaryOperator':\n            return unify(node.operator.location, locationOf(node.expr))\n        case 'binaryOperator':\n            return unify(locationOf(node.left), locationOf(node.right), node.operator.location)\n        case 'objectLiteral':\n        case 'vectorLiteral':\n        case 'if':\n        case 'do':\n        case 'condition':\n        case 'statements':\n            return node.entireLoc\n        case 'assignment':\n            return unify(locationOf(node.lhs), locationOf(node.value))\n        case 'expression':\n            return locationOf(node.value)\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        case 'customNode':\n            return node.entireLoc\n    }\n    /* c8 ignore stop */\n}\n\nexport function locationOfLastExpression(node: UrbanStatsAST): LocInfo {\n    switch (node.type) {\n        case 'assignment':\n            return locationOf(node.value)\n        case 'statements':\n            return locationOfLastExpression(node.result[node.result.length - 1])\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        default:\n            return locationOf(node)\n    }\n}\n\nexport function getAllParseErrors(node: UrbanStatsAST): ParseError[] {\n    const errors: ParseError[] = []\n\n    function collectErrors(n: UrbanStatsAST): void {\n        switch (n.type) {\n            case 'unnamed':\n                collectErrors(n.value)\n                break\n            case 'named':\n                collectErrors(n.value)\n                break\n            case 'constant':\n            case 'identifier':\n                // No parse errors in these\n                break\n            case 'attribute':\n                collectErrors(n.expr)\n                break\n            case 'call':\n                collectErrors(n.fn)\n                n.args.forEach(collectErrors)\n                break\n            case 'unaryOperator':\n                collectErrors(n.expr)\n                break\n            case 'binaryOperator':\n                collectErrors(n.left)\n                collectErrors(n.right)\n                break\n            case 'objectLiteral':\n                n.properties.forEach(([, value]) => {\n                    collectErrors(value)\n                })\n                break\n            case 'vectorLiteral':\n                n.elements.forEach(collectErrors)\n                break\n            case 'if':\n                collectErrors(n.condition)\n                collectErrors(n.then)\n                if (n.else) {\n                    collectErrors(n.else)\n                }\n                break\n            case 'do':\n                n.statements.forEach(collectErrors)\n                break\n            case 'assignment':\n                collectErrors(n.lhs)\n                collectErrors(n.value)\n                break\n            case 'expression':\n                collectErrors(n.value)\n                break\n            case 'statements':\n                n.result.forEach(collectErrors)\n                break\n            case 'condition':\n                collectErrors(n.condition)\n                n.rest.forEach(collectErrors)\n                break\n            case 'parseError':\n                errors.push(...n.errors)\n                break\n            case 'customNode':\n                collectErrors(n.expr)\n                break\n        }\n    }\n\n    collectErrors(node)\n    return errors\n}\n\nexport function toStatement(node: UrbanStatsASTExpression | UrbanStatsASTStatement): UrbanStatsASTStatement {\n    switch (node.type) {\n        case 'statements':\n        case 'assignment':\n        case 'expression':\n        case 'condition':\n        case 'parseError':\n            return node\n        default:\n            return { type: 'expression', value: node }\n    }\n}\n","import ColorLib from 'color'\n\nimport hueColors from '../../data/hueColors'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue, createConstantExpression } from '../types-values'\n\nimport { Color, hexToColor } from './color-utils'\nimport { camelToHuman } from './utils'\n\nexport const colorType = { type: 'opaque', name: 'color' } satisfies USSType\n\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError: true): Color | undefined\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number): Color\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (red < 0 || red > 1 || green < 0 || green > 1 || blue < 0 || blue > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`RGB values must be between 0 and 1, got (${red}, ${green}, ${blue}, ${alpha})`)\n    }\n    const r = Math.round(red * 255)\n    const g = Math.round(green * 255)\n    const b = Math.round(blue * 255)\n    const a = Math.round(alpha * 255)\n    return { r, g, b, a }\n}\n\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError: true): Color | undefined\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number): Color\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (hue < 0 || hue > 360 || saturation < 0 || saturation > 1 || value < 0 || value > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`HSV values must be (hue: 0-360, saturation: 0-1, value: 0-1, alpha: 0-1), got (${hue}, ${saturation}, ${value}, ${alpha})`)\n    }\n    const color = ColorLib.hsv(hue, saturation * 100, value * 100)\n    return {\n        r: Math.round(color.red()),\n        g: Math.round(color.green()),\n        b: Math.round(color.blue()),\n        a: Math.round(alpha * 255),\n    }\n}\n\nexport const rgb = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // red\n            { type: 'concrete', value: { type: 'number' } }, // green\n            { type: 'concrete', value: { type: 'number' } }, // blue\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: rgbToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (RGB)',\n        category: 'color',\n        namedArgs: { a: 'Alpha' },\n        longDescription: 'Creates a color using RGB (Red, Green, Blue) values. Each component ranges from 0 to 1, where 0 is no color and 1 is full intensity.',\n    },\n} satisfies USSValue\n\nexport const hsv = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // hue\n            { type: 'concrete', value: { type: 'number' } }, // saturation\n            { type: 'concrete', value: { type: 'number' } }, // value\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: hsvToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (HSV)',\n        category: 'color',\n        longDescription: 'Creates a color using HSV (Hue, Saturation, Value) values. Hue ranges from 0 to 360 degrees, saturation and value range from 0 to 1.',\n    },\n} satisfies USSValue\n\nexport const renderColor = {\n    type: {\n        type: 'function',\n        posArgs: [{ type: 'concrete', value: colorType }],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: { type: 'string' } },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): string => {\n        const color = (posArgs[0] as { type: 'opaque', value: { r: number, g: number, b: number, a: number } }).value\n        return doRender(color)\n    },\n    documentation: {\n        humanReadableName: 'Color to String',\n        category: 'color',\n        longDescription: 'Converts a color object to its hexadecimal string representation (e.g., \"#ff0000\" for red). If the alpha channel is not 255, it will be included in the string, e.g., \"#ff000088\" for red with 50% opacity.',\n    },\n} satisfies USSValue\n\nexport function doRender(color: Color, ignoreAlpha?: boolean): string {\n    const hex = (x: number): string => {\n        x = Math.round(x)\n        const hexValue = x.toString(16)\n        return hexValue.length === 1 ? `0${hexValue}` : hexValue\n    }\n    let h = `#${hex(color.r)}${hex(color.g)}${hex(color.b)}`\n    if (color.a !== 255 && !ignoreAlpha) {\n        h += hex(color.a)\n    }\n    return h\n}\n\nfunction drawFunction(functionName: string, param1: number, param2: number, param3: number, alpha: number, round?: number): string {\n    const format: (num: number) => string = round !== undefined ? num => num.toFixed(round) : num => num.toString()\n    const alphaPart = alpha !== 255 ? `, a=${format(alpha / 255)}` : ''\n    return `${functionName}(${format(param1)}, ${format(param2)}, ${format(param3)}${alphaPart})`\n}\n\nexport function rgbColorExpression(color: Color, { forceAlpha, round }: { forceAlpha?: number, round?: number } = {}): string {\n    return drawFunction('rgb', color.r / 255, color.g / 255, color.b / 255, forceAlpha ?? color.a, round)\n}\n\nexport function hsvColorExpression(color: Color, { forceAlpha, round }: { forceAlpha?: number, round?: number } = {}): string {\n    const c = ColorLib.rgb(color.r, color.g, color.b)\n    return drawFunction('hsv', c.hue(), c.saturationv() / 100, c.value() / 100, forceAlpha ?? color.a, round)\n}\n\nfunction colorConstant(name: string, value: string, isDefault?: boolean): [string, USSValue] {\n    const humanReadableName = camelToHuman(name)\n    const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1)\n    const color = hexToColor(value)\n    return [`color${capitalizedName}`, {\n        type: colorType,\n        value: { type: 'opaque', opaqueType: 'color', value: color },\n        documentation: {\n            humanReadableName,\n            category: 'color',\n            equivalentExpressions: [parseNoErrorAsExpression(rgbColorExpression(color, { round: 3 }), ''), parseNoErrorAsExpression(hsvColorExpression(color, { round: 3 }), '')],\n            isDefault,\n            longDescription: `Predefined color constant representing ${humanReadableName.toLowerCase()}.`,\n            documentationTable: 'predefined-colors',\n            selectorRendering: {\n                kind: 'gradientBackground',\n                ramp: [[0, value], [1, value]],\n            },\n        },\n    }] satisfies [string, USSValue]\n}\n\nexport const colorConstants = [\n    ...Object.entries(hueColors).map(([name, value]) => colorConstant(name, value)),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('white', '#ffffff'),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('black', '#000000', true),\n]\n","import { Inset } from '../../components/map'\nimport insets from '../../data/insets'\nimport { UrbanStatsASTExpression } from '../ast'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue } from '../types-values'\n\nexport const insetType = {\n    type: 'opaque',\n    name: 'inset',\n} satisfies USSType\n\nexport const insetsType = {\n    type: 'opaque',\n    name: 'insets',\n} satisfies USSType\n\nexport const boundsType = {\n    type: 'object',\n    properties: new Map([\n        ['west', { type: 'number' }],\n        ['east', { type: 'number' }],\n        ['north', { type: 'number' }],\n        ['south', { type: 'number' }],\n    ]),\n} satisfies USSType\n\nexport function constructInset(\n    screenBounds: { west: number, east: number, north: number, south: number },\n    mapBounds: { west: number, east: number, north: number, south: number },\n    mainMap: boolean,\n    name?: string,\n): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'inset',\n        value: {\n            bottomLeft: [screenBounds.west, screenBounds.south],\n            topRight: [screenBounds.east, screenBounds.north],\n            coordBox: [mapBounds.west, mapBounds.south, mapBounds.east, mapBounds.north],\n            mainMap,\n            name,\n        } satisfies Inset & { name?: string },\n    }\n}\n\nexport function constructInsets(insetList: Inset[]): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'insets',\n        value: insetList,\n    }\n}\n\nexport const constructInsetValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            screenBounds: { type: { type: 'concrete', value: boundsType } },\n            mapBounds: { type: { type: 'concrete', value: boundsType } },\n            mainMap: { type: { type: 'concrete', value: { type: 'boolean' } } },\n            name: { type: { type: 'concrete', value: { type: 'string' } } },\n        },\n        returnType: { type: 'concrete', value: insetType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const screenBoundsObj = namedArgs.screenBounds as Map<string, USSRawValue>\n        const mapBoundsObj = namedArgs.mapBounds as Map<string, USSRawValue>\n        const mainMap = namedArgs.mainMap as boolean\n        const name = namedArgs.name as string\n        return constructInset(\n            {\n                west: screenBoundsObj.get('west') as number,\n                east: screenBoundsObj.get('east') as number,\n                north: screenBoundsObj.get('north') as number,\n                south: screenBoundsObj.get('south') as number,\n            },\n            {\n                west: mapBoundsObj.get('west') as number,\n                east: mapBoundsObj.get('east') as number,\n                north: mapBoundsObj.get('north') as number,\n                south: mapBoundsObj.get('south') as number,\n            },\n            mainMap,\n            name,\n        )\n    },\n    documentation: {\n        humanReadableName: 'Custom Inset',\n        category: 'inset',\n        longDescription: 'Creates a custom map inset with specified screen bounds (bounding box of the inset on the screen, where bottom left corner has (0, 0) and top right corner has (1, 1)), map bounds (bounding box of the inset on the map, in longitude and latitude), and whether it is the main map (the interactive map).',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructInsetsValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [\n            {\n                type: 'concrete',\n                value: {\n                    type: 'vector',\n                    elementType: insetType,\n                },\n            },\n        ],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: insetsType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const insetsList = posArgs[0] as { type: 'opaque', opaqueType: 'inset', value: Inset }[]\n        return constructInsets(insetsList.map(item => item.value))\n    },\n    documentation: {\n        humanReadableName: 'Custom Insets',\n        category: 'inset',\n        isDefault: true,\n        longDescription: 'Creates a collection of map insets.',\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nfunction computeInsetConstantName(name: string): string {\n    name = name.replace(/[\\s,().-]/g, '')\n    name = name.replaceAll('+', 'Plus')\n    name = `inset${name}`\n    return name\n}\n\nexport function deconstruct(inset: typeof insets[keyof typeof insets][number] | Inset): UrbanStatsASTExpression {\n    const uss = `constructInset(screenBounds={ north: ${inset.topRight[1]}, east: ${inset.topRight[0]}, south: ${inset.bottomLeft[1]}, west: ${inset.bottomLeft[0]} }, mapBounds={ north: ${inset.coordBox[3]}, east: ${inset.coordBox[2]}, south: ${inset.coordBox[1]}, west: ${inset.coordBox[0]} }, mainMap=${inset.mainMap}, name=\"${inset.name}\")`\n    return parseNoErrorAsExpression(uss, '')\n}\n\nexport const insetConsts: [string, USSValue][] = Object.entries(insets).flatMap(([, regionInsets]) =>\n    regionInsets.map((inset) => {\n        const insetName = inset.name\n        const constantName = computeInsetConstantName(insetName)\n\n        return [\n            constantName,\n            {\n                type: insetType,\n                value: {\n                    type: 'opaque',\n                    opaqueType: 'inset',\n                    value: {\n                        bottomLeft: [...inset.bottomLeft] as [number, number],\n                        topRight: [...inset.topRight] as [number, number],\n                        // copy to get rid of readonly\n                        coordBox: [...inset.coordBox] as [number, number, number, number],\n                        mainMap: inset.mainMap,\n                        name: inset.name,\n                    } satisfies Inset,\n                },\n                documentation: {\n                    humanReadableName: insetName,\n                    category: 'inset',\n                    equivalentExpressions: [deconstruct(inset)],\n                    longDescription: `Predefined map inset for the region \"${insetName}\".`,\n                    documentationTable: 'predefined-insets',\n                },\n            } satisfies USSValue,\n        ] as [string, USSValue]\n    }),\n)\n\nexport const insetNameToConstantName = new Map<string, string>(\n    Object.entries(insets).flatMap(([, regionInsets]) =>\n        regionInsets.map((inset) => {\n            const insetName = inset.name\n            return [insetName, computeInsetConstantName(insetName)]\n        }),\n    ),\n)\n","import { USSType, USSValue, createConstantExpression } from '../types-values'\n\n// Functions can't be send over the worker boundary, so instead we must send descriptors\nexport interface LinearScaleDescriptor { kind: 'linear', min: number, max: number }\n\nexport type ScaleDescriptor =\n    LinearScaleDescriptor |\n    { kind: 'log', linearScale: LinearScaleDescriptor }\nexport type Scale = (values: number[], min?: number, max?: number, center?: number) => ScaleDescriptor\n\nexport interface ScaleInstance {\n    forward: (value: number) => number\n    inverse: (value: number) => number\n}\n\nexport const scaleType = {\n    type: 'opaque',\n    name: 'scale',\n} satisfies USSType\n\nexport function instantiate(descriptor: ScaleDescriptor): ScaleInstance {\n    switch (descriptor.kind) {\n        case 'linear':\n            const { min, max } = descriptor\n            if (min === max) {\n                // just arbitrarily map min <=> 0.5\n                return {\n                    forward: x => 0.5 + x - min,\n                    inverse: x => x - 0.5 + min,\n                }\n            }\n            const range = max - min\n\n            return {\n                forward: (value: number) => (value - min) / range,\n                inverse: (value: number) => value * range + min,\n            }\n        case 'log':\n            const { forward, inverse } = instantiate(descriptor.linearScale)\n            return {\n                forward: (value: number) => forward(Math.log(value)),\n                inverse: (value: number) => Math.exp(inverse(value)),\n            }\n    }\n}\n\nconst linearScale: Scale = (values: number[], min?: number, max?: number, center?: number) => {\n    values = values.filter(value => typeof value === 'number' && !isNaN(value) && isFinite(value))\n\n    let computedMin = min ?? Math.min(...values)\n    let computedMax = max ?? Math.max(...values)\n\n    if (center !== undefined) {\n        if (min !== undefined && max !== undefined) {\n            if (Math.abs(center - (min + max) / 2) > 1e-10) {\n                throw new Error(`Inconsistent parameters: center ${center} does not equal (min + max) / 2 = ${min + max} / 2`)\n            }\n        }\n        else if (min !== undefined) {\n            computedMax = 2 * center - min\n        }\n        else if (max !== undefined) {\n            computedMin = 2 * center - max\n        }\n        else {\n            const range = Math.max(computedMax - center, center - computedMin)\n            computedMin = center - range\n            computedMax = center + range\n        }\n    }\n    return {\n        kind: 'linear',\n        min: computedMin,\n        max: computedMax,\n    }\n}\n\nconst logScale: Scale = (values: number[], min?: number, max?: number, center?: number) => {\n    const logVals = values.map(Math.log)\n    const logMin = min !== undefined ? Math.log(min) : undefined\n    const logMax = max !== undefined ? Math.log(max) : undefined\n    const logCenter = center !== undefined ? Math.log(center) : undefined\n    const linearScaleDescriptor = linearScale(logVals, logMin, logMax, logCenter) as LinearScaleDescriptor\n    return {\n        kind: 'log',\n        linearScale: linearScaleDescriptor,\n    }\n}\n\nexport const linearScaleValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            min: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            center: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            max: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n        },\n        returnType: { type: 'concrete', value: scaleType },\n    },\n    value: (ctx, posArgs, namedArgs) => {\n        const min = namedArgs.min as number | null | undefined\n        const max = namedArgs.max as number | null | undefined\n        const center = namedArgs.center as number | null | undefined\n        // Return a scale function that closes over these params\n        return {\n            type: 'opaque',\n            opaqueType: 'scale',\n            value: (values: number[]) => linearScale(values, min ?? undefined, max ?? undefined, center ?? undefined),\n        }\n    },\n    documentation: {\n        humanReadableName: 'Linear Scale',\n        category: 'scale',\n        isDefault: true,\n        longDescription: 'Creates a linear scale that maps numeric values to a range. If min/max are not specified, they are computed from the data. Center parameter can be used to create symmetric ranges.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n    },\n} satisfies USSValue\n\nexport const logScaleValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            min: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            center: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            max: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n        },\n        returnType: { type: 'concrete', value: scaleType },\n    },\n    value: (ctx, posArgs, namedArgs) => {\n        const min = namedArgs.min as number | null | undefined\n        const max = namedArgs.max as number | null | undefined\n        const center = namedArgs.center as number | null | undefined\n        // Return a scale function that closes over these params\n        return {\n            type: 'opaque',\n            opaqueType: 'scale',\n            value: (values: number[]) => logScale(values, min ?? undefined, max ?? undefined, center ?? undefined),\n        }\n    },\n    documentation: {\n        humanReadableName: 'Logarithmic Scale',\n        category: 'scale',\n        longDescription: 'Creates a logarithmic scale that maps numeric values to a range using log transformation. Useful for data with wide ranges or exponential distributions. If min/max are not specified, they are computed from the data. Center parameter can be used to create symmetric ranges.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n    },\n} satisfies USSValue\n","import assert from 'assert'\n\nimport { Effect, InterpretationError } from './interpreter'\nimport { LocInfo } from './location'\nimport { USSValue } from './types-values'\n\nexport class Context {\n    #effect: (eff: Effect) => void\n    #error: (msg: string, location: LocInfo) => InterpretationError\n    #constants: Map<string, USSValue>\n    #variables: Map<string, USSValue>\n\n    constructor(effect: (eff: Effect) => void, error: (msg: string, location: LocInfo) => InterpretationError, constants: Map<string, USSValue>, variables: Map<string, USSValue>) {\n        this.#effect = effect\n        this.#error = error\n        this.#constants = constants\n        this.#variables = variables\n        for (const name of variables.keys()) {\n            assert(!constants.has(name), `Variable name \"${name}\" conflicts with a constant`)\n        }\n    }\n\n    effect(eff: Effect): void {\n        this.#effect(eff)\n    }\n\n    error(msg: string, location: LocInfo): InterpretationError {\n        return this.#error(msg, location)\n    }\n\n    getVariable(name: string): USSValue | undefined {\n        if (this.#constants.has(name)) {\n            return this.#constants.get(name)\n        }\n        return this.#variables.get(name)\n    }\n\n    assignVariable(name: string, value: USSValue): string | undefined {\n        if (this.#constants.has(name)) {\n            return `Cannot assign to constant \"${name}\"`\n        }\n        this.#variables.set(name, value)\n        return undefined\n    }\n\n    variableEntries(): IterableIterator<[string, USSValue]> {\n        return this.#variables.entries()\n    }\n\n    evolveVariables(variables: Map<string, USSValue>): Context {\n        return new Context(\n            this.#effect,\n            this.#error,\n            this.#constants,\n            variables,\n        )\n    }\n}\n","import React, { CSSProperties, ReactNode, useCallback, useEffect, useRef, useState } from 'react'\n\nimport { Colors } from '../page_template/color-themes'\nimport { DefaultMap } from '../utils/DefaultMap'\nimport { TestUtils } from '../utils/TestUtils'\nimport { isAMatch } from '../utils/isAMatch'\nimport { useMobileLayout } from '../utils/responsive'\n\nimport { renderLocInfo } from './interpreter'\nimport { AnnotatedToken, lex } from './lexer'\nimport { ParseError } from './parser'\nimport { renderValue, TypeEnvironment, USSValue } from './types-values'\n\nexport type EditorError = ParseError & { kind: 'error' | 'warning' }\nexport type EditorResult = EditorError | { kind: 'success', result: USSValue }\n\nexport function longMessage(result: EditorResult, includeLocationInfo: boolean): string {\n    switch (result.kind) {\n        case 'error':\n        case 'warning':\n            return includeLocationInfo ? `${result.value} at ${renderLocInfo(result.location)}` : result.value\n        case 'success':\n            return renderValue(result.result)\n    }\n}\n\nexport interface Script { uss: string, tokens: AnnotatedToken[] }\n\nexport function makeScript(uss: string): Script {\n    if (!uss.endsWith('\\n')) {\n        uss = `${uss}\\n`\n    }\n    return { uss, tokens: lex({ type: 'single', ident: 'editor' }, uss) }\n}\n\n// `errors` may not overlap\nexport function renderCode(\n    script: Script,\n    colors: Colors,\n    errors: EditorError[],\n    modfiyTokenContent: (token: AnnotatedToken, content: Node[]) => void,\n    modifyTokenSpan: (token: AnnotatedToken, span: HTMLSpanElement) => void,\n): Node[] {\n    const span = spanFactory(colors)\n\n    const lexSpans: Node[] = []\n    let errorSpans: { error: EditorError, spans: Node[] } | undefined = undefined\n    let charIdx = 0\n    let indexInTokens = 0\n    let indexInErrors = 0\n    while (indexInTokens < script.tokens.length && charIdx < script.uss.length) {\n        if (indexInErrors < errors.length) {\n            const errorLoc = errors[indexInErrors].location\n            if (charIdx >= errorLoc.start.charIdx) {\n                errorSpans = { spans: [], error: errors[indexInErrors] }\n                indexInErrors++\n            }\n        }\n        if (errorSpans !== undefined) {\n            const errorLoc = errorSpans.error.location\n            if (charIdx >= errorLoc.end.charIdx) {\n                lexSpans.push(span(errorSpans.error, errorSpans.spans))\n                errorSpans = undefined\n            }\n        }\n\n        const token = script.tokens[indexInTokens]\n        if (charIdx === token.location.start.charIdx) {\n            const content: Node[] = [document.createTextNode(script.uss.slice(token.location.start.charIdx, token.location.end.charIdx))]\n            modfiyTokenContent(token, content)\n            const tokenSpan = span(token.token, content)\n            modifyTokenSpan(token, tokenSpan);\n            (errorSpans?.spans ?? lexSpans).push(tokenSpan)\n            charIdx = token.location.end.charIdx\n            indexInTokens++\n        }\n        else if (charIdx < token.location.start.charIdx) {\n            (errorSpans?.spans ?? lexSpans).push(document.createTextNode(script.uss.slice(charIdx, token.location.start.charIdx)))\n            charIdx = token.location.start.charIdx\n        }\n        else {\n            throw new Error('invalid state')\n        }\n    }\n\n    if (errorSpans !== undefined) {\n        lexSpans.push(span(errorSpans.error, errorSpans.spans))\n        errorSpans = undefined\n    }\n\n    return lexSpans\n}\n\nexport function nodeContent(node: Node): string {\n    if (node instanceof HTMLElement) {\n        if (!node.isContentEditable) {\n            return ''\n        }\n        return Array.from(node.childNodes).map(nodeContent).join('')\n    }\n    else {\n        return node.textContent ?? ''\n    }\n}\n\nexport interface Range { start: number, end: number }\n\nexport function getRange(editor: HTMLElement): Range | null {\n    const selection = window.getSelection()\n    if (selection?.rangeCount === 1) {\n        const range = selection.getRangeAt(0)\n        if (editor.contains(range.startContainer) && editor.contains(range.endContainer)) {\n            if (editor === range.startContainer || editor === range.endContainer) {\n                return { start: 0, end: 0 }\n            }\n            return { start: positionInEditor(editor, range.startContainer, range.startOffset), end: positionInEditor(editor, range.endContainer, range.endOffset) }\n        }\n    }\n\n    return null\n}\n\n// Traverse up the tree, counting text content of previous siblings along the way\nfunction positionInEditor(editor: Node, node: Node, offset: number): number {\n    while (node !== editor) {\n        let sibling = node.previousSibling\n        while (sibling !== null) {\n            offset += nodeContent(sibling).length\n            sibling = sibling.previousSibling\n        }\n        node = node.parentNode!\n    }\n    return offset\n}\n\nexport function setRange(editor: HTMLElement, newRange: Range | null): void {\n    const currentRange = getRange(editor)\n\n    if (currentRange?.start === newRange?.start && currentRange?.end === newRange?.end) {\n        return\n    }\n\n    const selection = window.getSelection()!\n\n    if (newRange === null) {\n        selection.removeAllRanges()\n        editor.blur()\n        return\n    }\n\n    if (currentRange === null) {\n        editor.focus()\n    }\n\n    const [anchorNode, anchorOffset] = getContainerOffset(editor, newRange.start)\n    const [focusNode, focusOffset] = getContainerOffset(editor, newRange.end)\n\n    selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)\n}\n\n// Inverse of `positionInEditor`\n// Traverse down the tree, always keeping the text content behind us lte position\nexport function getContainerOffset(node: Node, position: number): [Node, number] {\n    let offset = 0\n    while (node.childNodes.length > 0) {\n        node = node.childNodes.item(0)\n        while (offset + nodeContent(node).length < position && node.nextSibling !== null) {\n            offset += nodeContent(node).length\n            node = node.nextSibling\n        }\n    }\n    return [node, position - offset]\n}\n\nfunction spanFactory(colors: Colors): (token: AnnotatedToken['token'] | ParseError, content: (Node | string)[]) => HTMLSpanElement {\n    const brackets = new DefaultMap<string, number>(() => 0)\n\n    const basicConstants = ['true', 'false', 'null']\n\n    return (token, content) => {\n        const style: Record<string, string> = { position: 'relative' }\n        let title: string | undefined\n\n        switch (token.type) {\n            case 'bracket':\n                function levelColor(level: number): string {\n                    switch (level % 3) {\n                        case 0:\n                            return colors.hueColors.yellow\n                        case 1:\n                            return colors.hueColors.pink\n                        case 2:\n                            return colors.hueColors.blue\n                        default:\n                            throw Error()\n                    }\n                }\n\n                if (token.value === '(' || token.value === '[' || token.value === '{') {\n                    const level = Array.from(brackets.values()).reduce((sum, next) => sum + next, 0)\n                    brackets.set(token.value, brackets.get(token.value) + 1)\n                    style.color = levelColor(level)\n                }\n                else {\n                    const openEquivalent = ({\n                        ')': '(',\n                        ']': '[',\n                        '}': '{',\n                    } as const)[token.value]\n                    if (brackets.get(openEquivalent) === 0) {\n                        style.color = colors.hueColors.red\n                    }\n                    else {\n                        brackets.set(openEquivalent, brackets.get(openEquivalent) - 1)\n                        const level = Array.from(brackets.values()).reduce((sum, next) => sum + next, 0)\n                        style.color = levelColor(level)\n                    }\n                }\n                break\n            case 'number':\n                style.color = colors.hueColors.blue\n                break\n            case 'string':\n                style.color = colors.hueColors.green\n                break\n            case 'error':\n                // Safari doesn't support the shorthand 🙄\n                style['text-decoration-color'] = colors.hueColors.red\n                style['text-decoration-style'] = 'wavy'\n                style['text-decoration-line'] = 'underline'\n                style['text-decoration-skip-ink'] = 'none'\n\n                title = token.value\n                break\n            case 'operator':\n                style.color = colors.hueColors.orange\n                break\n            case 'identifier':\n                if (basicConstants.includes(token.value)) {\n                    style.color = colors.hueColors.orange\n                }\n                break\n            case 'keyword':\n                style.color = colors.hueColors.purple\n                break\n        }\n\n        const result = document.createElement('span')\n        result.setAttribute('style', styleToString(style))\n        result.title = title ?? ''\n        result.replaceChildren(...content)\n        return result\n    }\n}\n\nfunction styleToString(style: Record<string, string>): string {\n    return Object.entries(style).map(([key, value]) => `${key}:${value};`).join('')\n}\n\nexport function getAutocompleteOptions(typeEnvironment: TypeEnvironment, tokens: AnnotatedToken[], currentIdentifer: string): string[] {\n    const allIdentifiers = new Set<string>()\n    for (const t of tokens) {\n        if (t.token.type === 'identifier') {\n            allIdentifiers.add(t.token.value)\n        }\n    }\n    for (const [id] of typeEnvironment) {\n        allIdentifiers.add(id)\n    }\n    allIdentifiers.delete(currentIdentifer)\n\n    const sortedIdentifiers = Array.from(allIdentifiers).flatMap((option) => {\n        const match = isAMatch(currentIdentifer.toLowerCase(), option.toLowerCase())\n        if (match === 0) {\n            return []\n        }\n        else {\n            return [{ option, match }]\n        }\n    }).sort((a, b) => {\n        if (a.match !== b.match) {\n            return b.match - a.match\n        }\n        else if (a.option.length !== b.option.length) {\n            return a.option.length - b.option.length\n        }\n        else {\n            return a.option.localeCompare(b.option)\n        }\n    }).map(({ option }) => option)\n\n    return sortedIdentifiers\n}\n\nexport function createAutocompleteMenu(colors: Colors): HTMLElement {\n    const style = {\n        'position': 'absolute',\n        'top': '100%',\n        'left': '100%',\n        'user-select': 'none',\n        'z-index': '3',\n        'overflow': 'scroll',\n        'max-height': `10lh`,\n        'border-radius': TestUtils.shared.isTesting ? '0' : '5px',\n        'border': `1px solid ${colors.borderNonShadow}`,\n        'color': colors.textMain,\n    }\n\n    const result = document.createElement('div')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n\n    return result\n}\n\nexport function createDocumentationPopover(colors: Colors): HTMLElement {\n    const style = {\n        'position': 'absolute',\n        'top': '100%',\n        'left': '0%',\n        'user-select': 'none',\n        'z-index': '3',\n        'overflow': 'scroll',\n        'max-height': `10lh`,\n        'border-radius': TestUtils.shared.isTesting ? '0' : '5px',\n        'border': `1px solid ${colors.borderNonShadow}`,\n        'color': colors.textMain,\n        'background-color': colors.slightlyDifferentBackground,\n        'width': '33vw',\n        'padding': '0 1.33em',\n    }\n\n    const result = document.createElement('div')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n    result.className = 'serif'\n\n    return result\n}\n\nexport function createPlaceholder(colors: Colors, placeholderText: string): HTMLElement {\n    const style = {\n        'position': 'absolute',\n        'user-select': 'none',\n        'white-space': 'pre',\n        'color': colors.hueColors.grey,\n        'pointer-events': 'none',\n    }\n\n    const result = document.createElement('span')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n\n    result.textContent = placeholderText\n\n    return result\n}\n\n// Custom hook interfaces\n\ninterface UndoRedoItem<T, S> {\n    time: number\n    state: T\n    selection: S\n}\n\nexport interface UndoRedoOptions {\n    undoChunking?: number\n    undoHistory?: number\n    onlyElement?: { current: HTMLElement | null }\n}\n\nexport function useUndoRedo<T, S>(\n    initialState: T,\n    initialSelection: S,\n    onStateChange: (state: T) => void,\n    onSelectionChange: (selection: S) => void,\n    { undoChunking = 1000, undoHistory = 100, onlyElement }: UndoRedoOptions = {},\n): {\n        addState: (state: T, selection: S) => void\n        updateCurrentSelection: (selection: S) => void\n        ui: ReactNode\n    } {\n    const undoStack = useRef<UndoRedoItem<T, S>[]>([\n        { time: 0, state: initialState, selection: initialSelection },\n    ])\n    const redoStack = useRef<UndoRedoItem<T, S>[]>([])\n\n    const [canUndo, setCanUndo] = useState(false)\n    const [canRedo, setCanRedo] = useState(false)\n\n    const addState = useCallback((state: T, selection: S): void => {\n        const currentUndoState = undoStack.current[undoStack.current.length - 1]\n\n        if (currentUndoState.time + undoChunking > Date.now()) {\n            // Amend current item rather than making a new one\n            currentUndoState.state = state\n            currentUndoState.selection = selection\n        }\n        else {\n            undoStack.current.push({ time: Date.now(), state, selection })\n            while (undoStack.current.length > undoHistory) {\n                undoStack.current.shift()\n            }\n            setCanUndo(true)\n        }\n        redoStack.current = []\n        setCanRedo(false)\n    }, [undoChunking, undoHistory])\n\n    const updateCurrentSelection = useCallback((selection: S): void => {\n        undoStack.current[undoStack.current.length - 1].selection = selection\n    }, [])\n\n    const doUndo = useCallback((): void => {\n        if (undoStack.current.length >= 2) {\n            const prevState = undoStack.current[undoStack.current.length - 2]\n            // Prev state becomes current state, current state becomes redo state\n            redoStack.current.push(undoStack.current.pop()!)\n            onStateChange(prevState.state)\n            onSelectionChange(prevState.selection)\n            setCanRedo(true)\n            setCanUndo(undoStack.current.length >= 2)\n        }\n    }, [onStateChange, onSelectionChange])\n\n    const doRedo = useCallback((): void => {\n        const futureState = redoStack.current.pop()\n        if (futureState !== undefined) {\n            undoStack.current.push(futureState)\n            onStateChange(futureState.state)\n            onSelectionChange(futureState.selection)\n            setCanUndo(true)\n            setCanRedo(redoStack.current.length >= 1)\n        }\n    }, [onStateChange, onSelectionChange])\n\n    const getIsActive = useCallback(() => {\n        return onlyElement === undefined || (document.activeElement !== null && document.activeElement === onlyElement.current)\n    }, [onlyElement])\n\n    // Set up keyboard shortcuts\n    useEffect(() => {\n        const listener = (e: KeyboardEvent): void => {\n            if (!getIsActive()) {\n                return\n            }\n\n            const isMac = navigator.userAgent.includes('Mac') && !TestUtils.shared.isTesting\n            if (isMac ? e.key.toLowerCase() === 'z' && e.metaKey && !e.shiftKey : e.key.toLowerCase() === 'z' && e.ctrlKey) {\n                e.preventDefault()\n                doUndo()\n            }\n            else if (isMac ? e.key.toLowerCase() === 'z' && e.metaKey && e.shiftKey : e.key.toLowerCase() === 'y' && e.ctrlKey) {\n                e.preventDefault()\n                doRedo()\n            }\n        }\n\n        window.addEventListener('keydown', listener)\n        return () => { window.removeEventListener('keydown', listener) }\n    }, [doUndo, doRedo, getIsActive])\n\n    const [isActive, setIsActive] = useState(getIsActive)\n\n    useEffect(() => {\n        const listener = (): void => {\n            setIsActive(getIsActive())\n        }\n        window.addEventListener('focusin', listener)\n        window.addEventListener('focusout', listener)\n        listener()\n        return () => {\n            window.removeEventListener('focusin', listener)\n            window.removeEventListener('focusout', listener)\n        }\n    }, [getIsActive])\n\n    const ui: ReactNode = isActive ? <UndoRedoControls {...{ doUndo, doRedo, canUndo, canRedo }} /> : null\n\n    return {\n        addState,\n        updateCurrentSelection,\n        ui,\n    }\n}\n\nfunction UndoRedoControls({ doUndo, doRedo, canUndo, canRedo }: { doUndo: () => void, doRedo: () => void, canUndo: boolean, canRedo: boolean }): ReactNode {\n    const outer = useRef<HTMLDivElement>(null)\n    const inner = useRef<HTMLDivElement>(null)\n\n    const width = 150\n    const height = 50\n\n    const padding = 10\n\n    /**\n     * iPhone safari is awful and ignores `position: fixed` when they keyboard is out\n     * So we need to do manual positioning\n     */\n    const positionInner = useCallback(() => {\n        // Get outer's position in the window\n        // Position inner at an offset from outer that matches up with the current scroll position\n        if (outer.current === null || inner.current === null) {\n            return\n        }\n\n        const outerBounds = outer.current.getBoundingClientRect()\n\n        inner.current.style.top = `${(window.visualViewport?.height ?? window.innerHeight) - outerBounds.top - height}px`\n        inner.current.style.left = `${(window.visualViewport?.width ?? window.innerWidth) - outerBounds.left - width}px`\n    }, [])\n\n    useEffect(positionInner)\n\n    useEffect(() => {\n        window.addEventListener('scroll', positionInner)\n        window.addEventListener('resize', positionInner)\n        window.visualViewport?.addEventListener('resize', positionInner)\n        return () => {\n            window.removeEventListener('scroll', positionInner)\n            window.removeEventListener('resize', positionInner)\n            window.visualViewport?.removeEventListener('resize', positionInner)\n        }\n    }, [positionInner])\n\n    const isMobile = useMobileLayout()\n\n    if (!isMobile) {\n        return null\n    }\n\n    const buttonStyle: CSSProperties = { flex: 1, touchAction: 'manipulation', zIndex: 100 }\n\n    return (\n        <div ref={outer} style={{ position: 'absolute' }}>\n            <div\n                ref={inner}\n                style={{\n                    position: 'absolute',\n                    display: 'flex',\n                    width: `${width}px`,\n                    height: `${height}px`,\n                    gap: `${padding}px`,\n                    padding: `${padding}px`,\n                }}\n            >\n                <button\n                    onPointerDown={(e) => {\n                        e.preventDefault()\n                        doUndo()\n                    }}\n                    disabled={!canUndo}\n                    style={buttonStyle}\n                >\n                    Undo\n                </button>\n                <button\n                    onPointerDown={(e) => {\n                        e.preventDefault()\n                        doRedo()\n                    }}\n                    disabled={!canRedo}\n                    style={buttonStyle}\n                >\n                    Redo\n                </button>\n            </div>\n        </div>\n    )\n}\n","/*\n    Check whether a is a substring of b (does not have to be contiguous)\n*/\nexport function isAMatch(a: string, b: string): number {\n    let i = 0\n    let matchCount = 0\n    let prevMatch = true\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of -- b is a string\n    for (let j = 0; j < b.length; j++) {\n        if (a[i] === b[j]) {\n            i++\n            if (prevMatch) {\n                matchCount++\n            }\n            prevMatch = true\n        }\n        else {\n            prevMatch = false\n        }\n        if (i === a.length) {\n            return matchCount + 1\n        }\n    }\n    return 0\n}\n","import { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTStatement, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTArg, locationOf, unify } from './ast'\nimport { Context } from './context'\nimport { addAdditionalDims, broadcastApply, broadcastCall } from './forward-broadcasting'\nimport { LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\nimport { splitMask } from './split-broadcasting'\nimport { renderType, unifyType, USSRawValue, USSType, USSValue, USSVectorType, ValueArg, undocValue, canUnifyTo } from './types-values'\n\nexport interface Effect { type: 'warning', message: string, location: LocInfo }\n\nexport function renderLocInfo(loc: LocInfo): string {\n    if (loc.start.lineIdx === loc.end.lineIdx) {\n        if (loc.start.colIdx + 1 === loc.end.colIdx) {\n            // Single character location\n            return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}`\n        }\n        return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}-${loc.end.colIdx}`\n    }\n    return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1} - ${loc.end.lineIdx + 1}:${loc.end.colIdx}`\n}\n\nexport class InterpretationError extends Error {\n    public value: string\n    constructor(message: string, public location: LocInfo) {\n        super(`${message} at ${renderLocInfo(location)}`)\n        this.name = 'InterpretationError'\n        this.value = message\n        this.location = location\n    }\n}\n\nexport function evaluate(expr: UrbanStatsASTExpression, env: Context): USSValue {\n    switch (expr.type) {\n        case 'constant':\n            const value = expr.value.node\n            if (value.type === 'number') {\n                return undocValue(value.value, { type: 'number' })\n            }\n            return undocValue(value.value satisfies string, { type: 'string' })\n        case 'identifier':\n            const varName = expr.name.node\n            const res = env.getVariable(varName)\n            if (res !== undefined) {\n                return res\n            }\n            throw env.error(`Undefined variable: ${varName}`, expr.name.location)\n        case 'attribute':\n            const obj = evaluate(expr.expr, env)\n            const attr = expr.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, undefined)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(expr))\n            }\n            return lookupResult.value\n        case 'call':\n            const func = evaluate(expr.fn, env)\n            const args = expr.args.map(arg => evaluateArg(arg, env))\n            const broadcastResult = broadcastCall(func, args, env, locationOf(expr))\n            if (broadcastResult.type === 'error') {\n                throw env.error(broadcastResult.message, locationOf(expr))\n            }\n            return broadcastResult.result\n        case 'unaryOperator':\n            const operand = evaluate(expr.expr, env)\n            return evaluateUnaryOperator(operand, expr.operator.node, env, locationOf(expr))\n        case 'binaryOperator':\n            const left = evaluate(expr.left, env)\n            const right = evaluate(expr.right, env)\n            return evaluateBinaryOperator(left, right, expr.operator.node, env, locationOf(expr))\n        case 'vectorLiteral':\n            const elements = expr.elements.map(e => evaluate(e, env))\n            let elementType = { type: 'elementOfEmptyVector' } as USSType | { type: 'elementOfEmptyVector' }\n            for (const e of elements) {\n                elementType = unifyType(elementType, e.type, () => {\n                    assert(elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(e.value)}`)\n                    return env.error(`vector literal contains heterogenous types ${renderType(elementType)} and ${renderType(e.type)}`, locationOf(expr))\n                })\n            }\n            return undocValue(elements.map(e => e.value), { type: 'vector', elementType })\n        case 'objectLiteral':\n            const ts = new Map<string, USSType>()\n            const vs = new Map<string, USSRawValue>()\n            for (const [name, e] of expr.properties) {\n                const v = evaluate(e, env)\n                if (ts.has(name)) {\n                    throw env.error(`Duplicate key ${name} in object literal`, locationOf(e))\n                }\n                ts.set(name, v.type)\n                vs.set(name, v.value)\n            }\n            return undocValue(vs, {\n                type: 'object',\n                properties: ts,\n            })\n        case 'if':\n            const condition = evaluate(expr.condition, env)\n            return splitMask(\n                env,\n                condition,\n                (v: USSValue, subEnv: Context): USSValue => {\n                    if (v.type.type !== 'boolean') {\n                        throw env.error(`Condition in if statement must be a boolean, but got ${renderType(v.type)}`, locationOf(expr.condition))\n                    }\n                    if (v.value) {\n                        return execute(expr.then, subEnv)\n                    }\n                    if (expr.else === undefined) {\n                        return undocValue(null, { type: 'null' })\n                    }\n                    return execute(expr.else, subEnv)\n                },\n                locationOf(expr.condition),\n                locationOf(expr),\n            )\n        case 'do':\n            if (expr.statements.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let doResult: USSValue = execute(expr.statements[0], env)\n            for (const statement of expr.statements.slice(1)) {\n                doResult = execute(statement, env)\n            }\n            return doResult\n        case 'customNode':\n            // This is a custom node for internal purposes, we just evaluate the expression\n            const result = execute(expr.expr, env)\n\n            // Check type if expectedType is provided\n            if (expr.expectedType && !expr.expectedType.some(t => canUnifyTo(result.type, t))) {\n                throw env.error(\n                    `Custom expression expected to return type ${expr.expectedType.map(t => renderType(t)).join(' or ')}, but got ${renderType(result.type)}`,\n                    locationOf(expr),\n                )\n            }\n\n            return result\n    }\n}\n\nexport function execute(expr: UrbanStatsASTStatement, env: Context): USSValue {\n    switch (expr.type) {\n        case 'condition':\n            if (expr.rest.length === 0) {\n                throw env.error('condition(..) must be followed by at least one statement', locationOf(expr))\n            }\n            return evaluate(\n                { type: 'if',\n                    condition: expr.condition,\n                    then: { type: 'statements', result: expr.rest, entireLoc: unify(...expr.rest.map(locationOf)) },\n                    entireLoc: expr.entireLoc,\n                },\n                env,\n            )\n        case 'assignment':\n            const value = evaluate(expr.value, env)\n            evaluateLHS(expr.lhs, value, env)\n            return value\n        case 'expression':\n            return evaluate(expr.value, env)\n        case 'statements':\n            if (expr.result.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let result: USSValue = execute(expr.result[0], env)\n            for (const statement of expr.result.slice(1)) {\n                result = execute(statement, env)\n            }\n            return result\n        case 'parseError':\n            assert(expr.errors.length > 0, 'parseError node must have at least one error')\n            throw env.error(\n                `Parse error: ${expr.errors.map(e => e.value).join(', ')}`,\n                expr.errors[0].location,\n            )\n    }\n}\n\nexport function evaluateLHS(lhs: UrbanStatsASTLHS, value: USSValue, env: Context): void {\n    switch (lhs.type) {\n        case 'identifier':\n            const varName = lhs.name.node\n            const err = env.assignVariable(varName, value)\n            if (err !== undefined) {\n                throw env.error(err, locationOf(lhs))\n            }\n            return\n        case 'attribute':\n            const obj = evaluate(lhs.expr, env)\n            const attr = lhs.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, value)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(lhs))\n            }\n            return\n    }\n}\n\nfunction evaluateArg(arg: UrbanStatsASTArg, env: Context): ValueArg {\n    switch (arg.type) {\n        case 'named':\n            return {\n                type: 'named',\n                name: arg.name.node,\n                value: evaluate(arg.value, env),\n            }\n        case 'unnamed':\n            return {\n                type: 'unnamed',\n                value: evaluate(arg.value, env),\n            }\n    }\n}\n\nfunction attrLookupOrSet(\n    obj: USSValue,\n    attr: string,\n    orSet: USSValue | undefined,\n): { type: 'success', value: USSValue } | { type: 'error', message: string } {\n    const type = obj.type\n    if (type.type === 'object') {\n        const val = obj.value\n        assert(val instanceof Map, `Expected object type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        const aT = type.properties.get(attr)\n        if (aT === undefined) {\n            return {\n                type: 'error',\n                message: `Attribute ${attr} not found in object of type ${renderType(type)}`,\n            }\n        }\n        if (orSet !== undefined) {\n            if (renderType(aT) !== renderType(orSet.type)) {\n                return {\n                    type: 'error',\n                    message: `Type mismatch: expected ${renderType(aT)} but got ${renderType(orSet.type)} for attribute ${attr} in object of type ${renderType(type)}`,\n                }\n            }\n            // If orSet is provided, we set the attribute to the value\n            val.set(attr, orSet.value)\n            return {\n                type: 'success',\n                value: undocValue(orSet.value, aT),\n            }\n        }\n        const content = val.get(attr)\n        assert(content !== undefined, `Expected attribute ${attr} to be defined in object, but got undefined at ${JSON.stringify(obj.value)}`)\n        return {\n            type: 'success',\n            value: undocValue(val.get(attr)!, aT),\n        }\n    }\n    if (type.type === 'vector') {\n        const val = obj.value\n        assert(val instanceof Array, `Expected vector type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        let orSetLookp: (idx: number) => USSValue | undefined = () => undefined\n        if (orSet !== undefined) {\n            if (orSet.type.type !== 'vector') {\n                orSet = undocValue(addAdditionalDims([val.length], orSet.value), { type: 'vector', elementType: orSet.type })\n            }\n            assert(Array.isArray(orSet.value), `It should be an array at this point`)\n            if (orSet.value.length !== val.length) {\n                return { type: 'error', message: `Expected vector of length ${val.length} but got ${orSet.value.length} for attribute ${attr} in object of type ${renderType(type)}` }\n            }\n            const v = orSet.value\n            const t = (orSet.type as USSVectorType).elementType\n            assert(t.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(orSet.value)}`)\n            orSetLookp = (idx: number) => {\n                return undocValue(v[idx], t)\n            }\n        }\n        const resultsOrErr = val.map((x, i) => {\n            assert(type.elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(obj.value)}`)\n            return attrLookupOrSet(undocValue(x, type.elementType), attr, orSetLookp(i))\n        })\n        if (resultsOrErr.some(r => r.type === 'error')) {\n            return { type: 'error', message: resultsOrErr.filter(r => r.type === 'error').map(r => (r as { type: 'error', message: string }).message)[0] }\n        }\n        const results = resultsOrErr.map(r => (r as { type: 'success', value: USSValue }).value)\n        const rawValue = results.map(r => r.value)\n        const typ = results[0].type\n        return {\n            type: 'success',\n            value: undocValue(rawValue, { type: 'vector', elementType: typ }),\n        }\n    }\n    return { type: 'error', message: `Cannot access attribute of type ${renderType(type)}. Only objects and vectors support attributes.` }\n}\n\nfunction evaluateUnaryOperator(operand: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.unary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.unary(operator, errLoc),\n        [operand],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n\nfunction evaluateBinaryOperator(left: USSValue, right: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.binary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.binary(operator, errLoc),\n        [left, right],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n","import { assert } from '../utils/defensive'\n\nimport { Block, LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\n\nconst nonExpressionOperators = ['=', ',', ';', '.', ':']\nconst operatorCharacters = '!@$%^&*-+=~`<>/?:|,;.'\n\nconst keywords = ['if', 'do', 'else', 'customNode', 'condition']\nexport type Keyword = (typeof keywords)[number]\n\ninterface NumericToken { type: 'number', value: number }\ninterface IdentifierToken { type: 'identifier', value: string }\ninterface KeywordToken { type: 'keyword', value: Keyword }\ninterface StringToken { type: 'string', value: string }\ninterface OperatorToken { type: 'operator', value: string }\ninterface BracketToken { type: 'bracket', value: '(' | ')' | '{' | '}' | '[' | ']' }\ninterface ErrorToken { type: 'error', value: string }\ntype NonErrorToken = NumericToken | IdentifierToken | KeywordToken | StringToken | OperatorToken | BracketToken\ntype Token = NonErrorToken | ErrorToken\n\nexport interface AnnotatedToken {\n    token: Token\n    location: LocInfo\n}\n\nexport type AnnotatedTokenWithValue = AnnotatedToken & { token: NonErrorToken }\n\ninterface GenericLexer {\n    firstToken: (ch: string) => boolean\n    innerToken: (ch: string) => boolean\n    parse: (string: string) => Token\n}\n\nfunction isDigit(ch: string): boolean {\n    return ch >= '0' && ch <= '9'\n}\nfunction isAlpha(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_'\n}\n\nexport function emptyLocation(ident: string): LocInfo {\n    return {\n        start: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n        end: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n    }\n}\n\nexport function parseNumber(input: string): number | undefined {\n    if (/^-?\\d*(\\.\\d+)?([eE][+-]?\\d+)?$/i.test(input)) {\n        // normal number format\n        const value = parseFloat(input)\n        if (isNaN(value)) {\n            return\n        }\n        return value\n    }\n    if (input.endsWith('k')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000\n    }\n    if (input.endsWith('m')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000000\n    }\n    return\n}\n\nconst identifierLexer: GenericLexer = {\n    firstToken: isAlpha,\n    innerToken: (ch: string): boolean => isAlpha(ch) || isDigit(ch),\n    parse: (string: string): Token => { return { type: keywords.includes(string) ? 'keyword' : 'identifier', value: string } },\n}\n\nfunction isOperator(string: string): boolean {\n    return nonExpressionOperators.includes(string) || expressionOperatorMap.has(string)\n}\n\nconst operatorLexer: GenericLexer = {\n    firstToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    innerToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    parse: (string: string): Token => {\n        if (isOperator(string)) {\n            return { type: 'operator', value: string }\n        }\n        return { type: 'error', value: `Invalid operator: ${string}` }\n    },\n}\n\nfunction lexLine(input: string, block: Block, lineNo: number, charIdxOffset: number): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    // one line\n    assert(!input.includes('\\n'), 'Input contains new line characters')\n    let idx = 0\n    lex: while (idx < input.length) {\n        const char = input[idx]\n        if (char === ' ') {\n            idx++\n            continue\n        }\n        if (char === '(' || char === ')' || char === '{' || char === '}' || char === '[' || char === ']') {\n            const token: AnnotatedToken = {\n                token: { type: 'bracket', value: char },\n                location: {\n                    start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                    end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n                },\n            }\n            tokens.push(token)\n            idx++\n            continue\n        }\n        if (isDigit(char)) {\n            let token\n            [idx, token] = lexNumber(input, idx, block, lineNo, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue\n            }\n        }\n        for (const lexer of [identifierLexer, operatorLexer]) {\n            let token\n            [idx, token] = lexGeneric(input, idx, block, lineNo, lexer, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue lex\n            }\n        }\n        let token\n        [idx, token] = lexString(input, idx, block, lineNo, charIdxOffset)\n        if (token !== undefined) {\n            tokens.push(token)\n            continue\n        }\n        tokens.push({\n            token: { type: 'error', value: `Unexpected character: ${char}` },\n            location: {\n                start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n            },\n        })\n        idx++\n    }\n    return tokens\n}\n\nexport function lex(block: Block, input: string): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    const lines = input.split('\\n')\n    let charIdx = 0\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i]\n        const lineTokens = lexLine(line, block, i, charIdx)\n        tokens.push(...lineTokens)\n        charIdx += line.length\n        tokens.push({\n            token: { type: 'operator', value: 'EOL' },\n            location: {\n                start: { block, lineIdx: i, colIdx: line.length, charIdx },\n                end: { block, lineIdx: i, colIdx: line.length, charIdx },\n            },\n        })\n        charIdx += 1 // newline\n    }\n    return tokens\n}\n\nfunction lexGeneric(\n    input: string,\n    idx: number,\n    block: Block,\n    lineNo: number,\n    lexer: GenericLexer,\n    charIdxOffset: number,\n): [number, AnnotatedToken | undefined] {\n    if (!lexer.firstToken(input[idx])) {\n        return [idx, undefined]\n    }\n\n    const start = idx\n    while (idx < input.length && lexer.innerToken(input[idx])) {\n        idx++\n    }\n    const token: AnnotatedToken = {\n        token: lexer.parse(input.slice(start, idx)),\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexString(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    if (input[idx] !== '\"') {\n        return [idx, undefined]\n    }\n    const start = idx\n    idx++\n    while (true) {\n        if (idx >= input.length) {\n            return [idx, { token: { type: 'error', value: 'Unterminated string' }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + start } } }]\n        }\n        if (input[idx] === '\"') {\n            idx++\n            break\n        }\n        if (input[idx] === '\\\\') {\n            idx += 2\n            continue\n        }\n        idx++\n    }\n    let result: string\n    try {\n        const resultObj: unknown = JSON.parse(input.slice(start, idx))\n        assert(typeof resultObj === 'string', `Invalid string: ${input.slice(start, idx)}`)\n        result = resultObj\n    }\n    catch (e) {\n        return [idx, { token: { type: 'error', value: `Invalid string: ${input.slice(start, idx)}: ${e}` }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'string', value: result },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexNumber(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    const numberFormat = /^\\d+(\\.\\d+)?([eE][+-]?\\d+|k|m)?/i\n    const match = numberFormat.exec(input.slice(idx))\n    if (!match) {\n        return [idx, undefined]\n    }\n    const numberStr = match[0]\n    const number = parseNumber(numberStr)\n    if (number === undefined) {\n        return [idx + numberStr.length, { token: { type: 'error', value: `Invalid number format: ${numberStr}` }, location: { start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx }, end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'number', value: number },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n            end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length },\n        },\n    }\n    return [idx + numberStr.length, token]\n}\n","export type Block = { type: 'single', ident: string } | { type: 'multi' }\n\nexport interface SingleLocationWithinBlock {\n    lineIdx: number\n    colIdx: number\n    charIdx: number\n}\nexport type SingleLocation = SingleLocationWithinBlock & { block: Block }\n\nexport interface LocInfo {\n    start: SingleLocation\n    end: SingleLocation\n}\n\nexport const noLocation = { start: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 }, end: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 } } satisfies LocInfo\n\nexport function extendBlockIdPositionalArg(blockIdent: string, position: number): string {\n    return `${blockIdent}_pos_${position}`\n}\n\nexport function extendBlockIdKwarg(blockIdent: string, argName: string): string {\n    return `${blockIdent}_${argName}`\n}\n\nexport function extendBlockIdVectorElement(blockIdent: string, index: number): string {\n    return `${blockIdent}_el_${index}`\n}\n\nexport function extendBlockIdObjectProperty(blockIdent: string, property: string): string {\n    return `${blockIdent}_prop_${property}`\n}\n","import { assert } from '../utils/defensive'\n\nimport { locationOf, unify, UrbanStatsAST, UrbanStatsASTArg, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTStatement } from './ast'\nimport { Context } from './context'\nimport { AnnotatedToken, AnnotatedTokenWithValue, lex, Keyword, emptyLocation } from './lexer'\nimport { noLocation, LocInfo, Block } from './location'\nimport { expressionOperatorMap, infixOperators, unaryOperators } from './operators'\nimport { USSType } from './types-values'\n\nexport interface Decorated<T> {\n    node: T\n    location: LocInfo\n}\n\nexport interface ParseError { type: 'error', value: string, location: LocInfo }\n\ntype USSInfixSequenceElement = { type: 'operator', operatorType: 'unary' | 'binary', value: Decorated<string> } | UrbanStatsASTExpression\n\nexport function toSExp(node: UrbanStatsAST): string {\n    /**\n     * For testing purposes, we convert the AST to a simple S-expression format.\n     */\n    switch (node.type) {\n        case 'unnamed':\n            return toSExp(node.value)\n        case 'named':\n            return `(named ${node.name.node} ${toSExp(node.value)})`\n        case 'constant':\n            return `(const ${node.value.node.value})`\n        case 'identifier':\n            return `(id ${node.name.node})`\n        case 'attribute':\n            return `(attr ${toSExp(node.expr)} ${node.name.node})`\n        case 'call':\n            return `(fn ${[node.fn, ...node.args].map(toSExp).join(' ')})`\n        case 'unaryOperator':\n            return `(${node.operator.node} ${toSExp(node.expr)})`\n        case 'binaryOperator':\n            return `(${node.operator.node} ${toSExp(node.left)} ${toSExp(node.right)})`\n        case 'vectorLiteral':\n            return `(vector ${node.elements.map(toSExp).join(' ')})`\n        case 'objectLiteral':\n            return `(object ${node.properties.map(([key, value]) => `(${key} ${toSExp(value)})`).join(' ')})`\n        case 'assignment':\n            return `(assign ${toSExp(node.lhs)} ${toSExp(node.value)})`\n        case 'expression':\n            return `(expr ${toSExp(node.value)})`\n        case 'statements':\n            return `(statements ${node.result.map(toSExp).join(' ')})`\n        case 'if':\n            return `(if ${toSExp(node.condition)} ${toSExp(node.then)}${node.else ? ` ${toSExp(node.else)}` : ''})`\n        case 'do':\n            return `(do ${node.statements.map(toSExp).join(' ')})`\n        case 'condition':\n            return `(condition ${toSExp(node.condition)} ${node.rest.map(toSExp).join(' ')})`\n        case 'parseError':\n            return `(parseError ${JSON.stringify(node.originalCode)} ${JSON.stringify(node.errors)})`\n        case 'customNode':\n            return `(customNode ${toSExp(node.expr)} ${JSON.stringify(node.originalCode)})`\n    }\n}\n\nclass ParseState {\n    tokens: AnnotatedTokenWithValue[]\n    index: number\n    constructor(tokens: AnnotatedTokenWithValue[]) {\n        this.tokens = tokens\n        this.index = 0\n    }\n\n    skipEOL(): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === 'operator' && token.token.value === 'EOL') {\n            this.index++\n            return true\n        }\n        return false\n    }\n\n    consumeTokenOfType(type: string, ...values: (string | number)[]): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === type && (values.length === 0 || values.includes(token.token.value))) {\n            this.index++\n            return true\n        }\n        if (this.skipEOL()) {\n            if (this.consumeTokenOfType(type, ...values)) {\n                return true\n            }\n            this.index-- // backtrack\n        }\n        return false\n    }\n\n    consumeOperator(...oneOfOps: string[]): boolean {\n        return this.consumeTokenOfType('operator', ...oneOfOps)\n    }\n\n    consumeBracket(...oneOfBrackets: string[]): boolean {\n        return this.consumeTokenOfType('bracket', ...oneOfBrackets)\n    }\n\n    consumeIdentifier(): boolean {\n        return this.consumeTokenOfType('identifier')\n    }\n\n    consumeKeyword(...oneOfKeywords: Keyword[]): boolean {\n        return this.consumeTokenOfType('keyword', ...oneOfKeywords)\n    }\n\n    maybeLastNonEOLToken(offset: number): AnnotatedTokenWithValue {\n        for (let i = this.index + offset; i >= 0; i--) {\n            const token = this.tokens[i]\n            if (token.token.type !== 'operator' || token.token.value !== 'EOL') {\n                return token\n            }\n        }\n        return this.tokens[this.index + offset]\n    }\n\n    parseSingleExpression(): UrbanStatsASTExpression | ParseError {\n        while (this.skipEOL()) { }\n        if (this.index >= this.tokens.length) {\n            return { type: 'error', value: 'Unexpected end of input', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const token = this.tokens[this.index]\n        switch (token.token.type) {\n            case 'number':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'number', value: token.token.value }, location: token.location } }\n            case 'string':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'string', value: token.token.value }, location: token.location } }\n            case 'identifier':\n                this.index++\n                return { type: 'identifier', name: { node: token.token.value, location: token.location } }\n            case 'keyword':\n                throw new Error(`Unexpected keyword ${token.token.value}`)\n            case 'bracket':\n                switch (token.token.value) {\n                    case '(':\n                        this.index++\n                        const expr = this.parseExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        if (!this.consumeBracket(')')) {\n                            return { type: 'error', value: 'Expected closing bracket ) to match this one', location: token.location }\n                        }\n                        return expr\n                    case '{':\n                        this.index++\n                        const startLoc = token.location\n                        const properties: [string, UrbanStatsASTExpression][] = []\n                        while (!this.consumeBracket('}')) {\n                            if (properties.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: `Expected comma , or closing bracket } after object field name; instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n                            }\n                            if (!this.consumeIdentifier()) {\n                                return { type: 'error', value: 'Expected identifier for object field name', location: this.maybeLastNonEOLToken(-1).location }\n                            }\n                            const keyToken = this.tokens[this.index - 1]\n                            assert(keyToken.token.type === 'identifier', `Expected identifier token, but got ${keyToken.token.type}`)\n                            if (!this.consumeOperator(':')) {\n                                return { type: 'error', value: `Expected : token after object field name`, location: keyToken.location }\n                            }\n                            const value = this.parseExpression()\n                            if (value.type === 'error') {\n                                return value\n                            }\n                            properties.push([keyToken.token.value, value])\n                        }\n                        const endLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'objectLiteral',\n                            entireLoc: unify(startLoc, endLoc),\n                            properties,\n                        }\n                    case '[':\n                        this.index++\n                        const vectorStartLoc = token.location\n                        const elements: UrbanStatsASTExpression[] = []\n                        while (!this.consumeBracket(']')) {\n                            if (elements.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: 'Expected comma , or closing bracket ] after vector element', location: this.maybeLastNonEOLToken(0).location }\n                            }\n                            const element = this.parseExpression()\n                            if (element.type === 'error') {\n                                return element\n                            }\n                            elements.push(element)\n                        }\n                        const vectorEndLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'vectorLiteral',\n                            entireLoc: unify(vectorStartLoc, vectorEndLoc),\n                            elements,\n                        }\n                }\n                return { type: 'error', value: `Unexpected bracket ${token.token.value}`, location: token.location }\n            case 'operator':\n                return { type: 'error', value: `Unexpected operator ${token.token.value}`, location: token.location }\n        }\n    }\n\n    parseArg(): UrbanStatsASTArg | ParseError {\n        const exprOrName = this.parseExpression()\n        if (exprOrName.type === 'error') {\n            return exprOrName\n        }\n        if (!this.consumeOperator('=')) {\n            return { type: 'unnamed', value: exprOrName }\n        }\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (exprOrName.type !== 'identifier') {\n            return { type: 'error', value: 'Expected identifier for named argument', location: locationOf(exprOrName) }\n        }\n        return {\n            type: 'named',\n            name: { node: exprOrName.name.node, location: exprOrName.name.location },\n            value: expr,\n        }\n    }\n\n    parseParenthesizedArgs(): { type: 'args', args: [UrbanStatsASTArg[], LocInfo] } | ParseError | undefined {\n        if (!this.consumeBracket('(')) {\n            return undefined\n        }\n        const startLoc = this.tokens[this.index - 1].location\n        const args: UrbanStatsASTArg[] = []\n        while (true) {\n            if (this.consumeBracket(')')) {\n                const endLoc = this.tokens[this.index - 1].location\n                return { type: 'args', args: [args, unify(startLoc, endLoc)] }\n            }\n            if (args.length > 0 && !this.consumeOperator(',')) {\n                return { type: 'error', value: `Expected comma , or closing bracket ); instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n            }\n            const arg = this.parseArg()\n            if (arg.type === 'error') {\n                return arg\n            }\n            args.push(arg)\n        }\n    }\n\n    parseFunctionalExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('customNode')) {\n            return this.parseCustomNodeExpression()\n        }\n\n        let fn = this.parseSingleExpression()\n        if (fn.type === 'error') {\n            return fn\n        }\n        while (true) {\n            let done = true\n            const args = this.parseParenthesizedArgs()\n            if (args !== undefined) {\n                done = false\n                if (args.type === 'error') {\n                    return args\n                }\n                fn = {\n                    type: 'call',\n                    fn,\n                    entireLoc: unify(locationOf(fn), args.args[1]),\n                    args: args.args[0],\n                }\n            }\n            if (this.consumeOperator('.')) {\n                done = false\n                if (!this.consumeIdentifier()) {\n                    return { type: 'error', value: 'Expected identifier after the dot', location: this.maybeLastNonEOLToken(-1).location }\n                }\n                const token = this.tokens[this.index - 1]\n                assert(token.token.type === 'identifier', `Expected identifier token, but got ${token.token.type}`)\n                fn = {\n                    type: 'attribute',\n                    expr: fn,\n                    name: { node: token.token.value, location: token.location },\n                }\n            }\n            if (done) {\n                break\n            }\n        }\n        return fn\n    }\n\n    parseExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('if')) {\n            return this.parseIfExpression()\n        }\n\n        if (this.consumeKeyword('do')) {\n            return this.parseDoExpression()\n        }\n\n        const operatorExpSequence: USSInfixSequenceElement[] = []\n        // State Machine with states expressionOrUnaryOperator; binaryOperator\n        let state: 'expressionOrUnaryOperator' | 'binaryOperator' = 'expressionOrUnaryOperator'\n        loop: while (true) {\n            switch (state) {\n                case 'expressionOrUnaryOperator': {\n                    if (this.consumeOperator(...unaryOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'unary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        continue\n                    }\n                    else {\n                        const expr = this.parseFunctionalExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        operatorExpSequence.push(expr)\n                        state = 'binaryOperator'\n                    }\n                }\n                    break\n                case 'binaryOperator': {\n                    if (this.consumeOperator(...infixOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'binary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        state = 'expressionOrUnaryOperator'\n                    }\n                    else {\n                        break loop\n                    }\n                }\n            }\n        }\n        return this.parseInfixSequence(operatorExpSequence)\n    }\n\n    parseInfixSequence(operatorExpSequence: USSInfixSequenceElement[]): UrbanStatsASTExpression | ParseError {\n        assert(operatorExpSequence.length !== 0, 'Expected expression')\n        if (operatorExpSequence.length === 1) {\n            assert(operatorExpSequence[0].type !== 'operator', `Unexpected operator ${JSON.stringify(operatorExpSequence[0])} at beginning of infix sequence`)\n            return operatorExpSequence[0]\n        }\n        // Get the highest precedence operator\n        const precedences = operatorExpSequence.map(x => x.type === 'operator' ? expressionOperatorMap.get(x.value.node)?.precedence ?? 0 : 0)\n        const maxPrecedence = Math.max(...precedences)\n        assert(maxPrecedence > 0, 'No valid operator found in infix sequence')\n        const index = precedences.findIndex(p => p === maxPrecedence)\n        assert(index > -1, 'No operator found with maximum precedence; this should not happen')\n        return this.parseInfixSequence(this.resolveOperator(operatorExpSequence, index))\n    }\n\n    resolveOperator(operatorExpSequence: USSInfixSequenceElement[], index: number): USSInfixSequenceElement[] {\n        assert(operatorExpSequence[index].type === 'operator', `Expected operator at index ${index}, but found expression: ${JSON.stringify(operatorExpSequence[index])}`)\n        const next = operatorExpSequence[index + 1]\n        if (next.type === 'operator') {\n            return this.resolveOperator(operatorExpSequence, index + 1)\n        }\n        switch (operatorExpSequence[index].operatorType) {\n            case 'unary': {\n                return [\n                    ...operatorExpSequence.slice(0, index),\n                    { type: 'unaryOperator', operator: operatorExpSequence[index].value, expr: next },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n            case 'binary': {\n                // Split the sequence into left and right parts\n                const left = operatorExpSequence[index - 1]\n                const right = operatorExpSequence[index + 1]\n                assert(left.type !== 'operator' && right.type !== 'operator', 'unreachable: left or right should not be an operator')\n                return [\n                    ...operatorExpSequence.slice(0, index - 1),\n                    { type: 'binaryOperator', operator: operatorExpSequence[index].value, left, right },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n        }\n    }\n\n    checkLHS(expr: UrbanStatsASTExpression): UrbanStatsASTLHS | ParseError {\n        switch (expr.type) {\n            case 'identifier':\n            case 'attribute':\n                return expr\n            case 'constant':\n            case 'call':\n            case 'unaryOperator':\n            case 'binaryOperator':\n            case 'vectorLiteral':\n            case 'objectLiteral':\n            case 'if':\n            case 'do':\n            case 'customNode':\n                return { type: 'error', value: 'Cannot assign to this expression', location: locationOf(expr) }\n        }\n    }\n\n    parseStatement(): UrbanStatsASTStatement | ParseError {\n        if (this.consumeKeyword('condition')) {\n            return this.parseConditionStatement()\n        }\n\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (this.consumeOperator('=')) {\n            const value = this.parseExpression()\n            if (value.type === 'error') {\n                return value\n            }\n            const lhs = this.checkLHS(expr)\n            if (lhs.type === 'error') {\n                return lhs\n            }\n            return { type: 'assignment', lhs, value }\n        }\n        return { type: 'expression', value: expr }\n    }\n\n    parseIfExpression(): UrbanStatsASTExpression | ParseError {\n        const ifToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after if', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const then = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after if block')\n        if (then.type === 'error') {\n            return then\n        }\n        let elseBranch: UrbanStatsASTStatement | undefined = undefined\n        if (this.consumeKeyword('else')) {\n            if (!this.consumeBracket('{')) {\n                return { type: 'error', value: 'Expected opening bracket { after else', location: this.maybeLastNonEOLToken(-1).location }\n            }\n            const eb = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after else block')\n            if (eb.type === 'error') {\n                return eb\n            }\n            elseBranch = eb\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'if',\n            entireLoc: unify(ifToken.location, lastToken.location),\n            condition,\n            then,\n            else: elseBranch,\n        }\n    }\n\n    parseDoExpression(): UrbanStatsASTExpression | ParseError {\n        const doToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after do', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const statements = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after do block')\n        if (statements.type === 'error') {\n            return statements\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'do',\n            entireLoc: unify(doToken.location, lastToken.location),\n            statements: statements.type === 'statements' ? statements.result : [statements],\n        }\n    }\n\n    parseConditionStatement(): UrbanStatsASTStatement | ParseError {\n        const conditionToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return {\n            type: 'condition',\n            entireLoc: unify(conditionToken.location, this.tokens[this.index - 1].location),\n            condition,\n            rest: [],\n        }\n    }\n\n    parseStatements(canEnd: boolean = false, end: () => boolean = () => false, errMsg: string = 'Expected end of line or ; after'): UrbanStatsASTStatement | ParseError {\n        const statements: UrbanStatsASTStatement[] = []\n        while (this.index < this.tokens.length) {\n            if (end()) {\n                break\n            }\n            while (this.skipEOL()) { }\n            if (this.index >= this.tokens.length) {\n                break\n            }\n            const statement = this.parseStatement()\n            if (statement.type === 'error') {\n                return statement\n            }\n            statements.push(statement)\n            if (end()) {\n                break\n            }\n            if (!this.consumeOperator('EOL', ';')) {\n                return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n            }\n            while (this.skipEOL()) { }\n        }\n        if (this.index === this.tokens.length && canEnd) {\n            return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return mergeStatements(\n            statements,\n            this.index > 0\n                ? this.tokens[this.index - 1].location\n                /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n                : undefined,\n        )\n    }\n\n    parseCustomNodeExpression(): UrbanStatsASTExpression | ParseError {\n        const argsRes = this.parseParenthesizedArgs()\n\n        if (argsRes === undefined) {\n            return { type: 'error', value: 'Expected arguments for customNode', location: this.maybeLastNonEOLToken(-1).location }\n        }\n\n        if (argsRes.type === 'error') {\n            return argsRes\n        }\n\n        const [args, locArg] = argsRes.args\n\n        const code = args[0]\n\n        if (args.length !== 1 || code.type !== 'unnamed') {\n            return { type: 'error', value: 'Incorrect arguments for customNode, expected 1 unnamed argument', location: argsRes.args[1] }\n        }\n\n        if (code.value.type !== 'constant' || code.value.value.node.type !== 'string') {\n            return { type: 'error', value: 'Expected string constant as argument to customNode', location: locationOf(code) }\n        }\n\n        const parseResult = parse(code.value.value.node.value, code.value.value.location.start.block)\n\n        if (parseResult.type === 'error') {\n            return {\n                type: 'customNode',\n                expr: {\n                    type: 'parseError',\n                    errors: parseResult.errors,\n                    originalCode: code.value.value.node.value,\n                },\n                originalCode: code.value.value.node.value,\n                entireLoc: locArg,\n            }\n        }\n\n        return {\n            type: 'customNode',\n            expr: parseResult,\n            originalCode: code.value.value.node.value,\n            entireLoc: locArg,\n        }\n    }\n}\n\nexport function mergeStatements(statements: UrbanStatsASTStatement[], fallbackLocation?: LocInfo): UrbanStatsASTStatement {\n    statements = gulpRestForConditions(statements)\n    if (statements.length === 1) {\n        return statements[0]\n    }\n    const entireLoc: LocInfo = statements.length > 0\n        ? unify(...statements.map(locationOf))\n        : fallbackLocation\n        /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n        ?? noLocation\n    return { type: 'statements', result: statements, entireLoc }\n}\n\nfunction gulpRestForConditions(statements: UrbanStatsASTStatement[]): UrbanStatsASTStatement[] {\n    /**\n     * Handle condition statements by gulping the next statement into the condition's rest.\n     */\n    const result: UrbanStatsASTStatement[] = []\n    for (let i = 0; i < statements.length; i++) {\n        const stmt = statements[i]\n        if (stmt.type === 'condition') {\n            stmt.rest.push(...gulpRestForConditions(statements.slice(i + 1)))\n            result.push(stmt)\n            break\n        }\n        result.push(stmt)\n    }\n    return result\n}\n\nexport function parse(code: string, block?: Block, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const tokens = lex(block ?? { type: 'multi' }, code)\n    return parseTokens(tokens, code, returnParseErrorNode)\n}\n\nexport function parseTokens(tokens: AnnotatedToken[], originalCode: string, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const lexErrors = tokens.filter(token => token.token.type === 'error')\n    if (lexErrors.length > 0) {\n        const errors: ParseError[] = lexErrors.map(token => ({ type: 'error' as const, value: `Unrecognized token: ${token.token.value}`, location: token.location }))\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors }\n        }\n        return { type: 'error', errors }\n    }\n    const state = new ParseState(tokens as AnnotatedTokenWithValue[]) // we checked for errors above, so this cast is safe\n    const stmts = state.parseStatements()\n    if (stmts.type === 'error') {\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors: [stmts] }\n        }\n        return { type: 'error', errors: [stmts] }\n    }\n    assert(state.index === state.tokens.length, `Parser did not consume all tokens: ${state.index} < ${state.tokens.length}`)\n    return stmts\n}\n\nfunction allExpressions(node: UrbanStatsASTStatement | UrbanStatsASTExpression): UrbanStatsASTExpression[] {\n    const expressions: UrbanStatsASTExpression[] = []\n    function helper(n: UrbanStatsASTStatement | UrbanStatsASTExpression | UrbanStatsASTArg): boolean {\n        switch (n.type) {\n            case 'unnamed':\n                helper(n.value)\n                return true\n            case 'named':\n                expressions.push(n.value)\n                helper(n.value)\n                return true\n            case 'constant':\n            case 'identifier':\n                expressions.push(n)\n                return true\n            case 'attribute':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'call':\n                expressions.push(n)\n                helper(n.fn)\n                n.args.forEach(helper)\n                return true\n            case 'unaryOperator':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'binaryOperator':\n                expressions.push(n)\n                helper(n.left)\n                helper(n.right)\n                return true\n            case 'objectLiteral':\n                expressions.push(n)\n                n.properties.forEach(([key, value]) => {\n                    expressions.push({ type: 'constant', value: { node: { type: 'string', value: key }, location: n.entireLoc } })\n                    helper(value)\n                })\n                return true\n            case 'vectorLiteral':\n                expressions.push(n)\n                n.elements.forEach(helper)\n                return true\n            case 'assignment':\n                helper(n.lhs)\n                helper(n.value)\n                return true\n            case 'expression':\n                helper(n.value)\n                return true\n            case 'statements':\n                n.result.forEach(helper)\n                return true\n            case 'if':\n                helper(n.condition)\n                helper(n.then)\n                if (n.else) {\n                    helper(n.else)\n                }\n                return true\n            case 'do':\n                n.statements.forEach(helper)\n                return true\n            case 'condition':\n                helper(n.condition)\n                n.rest.forEach(helper)\n                return true\n            case 'parseError':\n                return true\n            case 'customNode':\n                // do not actually put this in the expressions list, as is for internal use only\n                helper(n.expr)\n                return true\n        }\n    }\n    helper(node)\n    return expressions\n}\n\nfunction identifiersInExpr(node: UrbanStatsASTStatement | UrbanStatsASTExpression): Set<string> {\n    const identifiers = new Set<string>()\n    allExpressions(node).forEach((expr) => {\n        if (expr.type === 'identifier') {\n            identifiers.add(expr.name.node)\n        }\n    })\n    return identifiers\n}\n\nexport function allIdentifiers(node: UrbanStatsASTStatement | UrbanStatsASTExpression, ctx: Context): Set<string> {\n    const identifiers = identifiersInExpr(node)\n    while (true) {\n        // make sure to include identifiers from default values of function arguments pulled in by the identifiers\n        const newIdentifiers = new Set<string>()\n        identifiers.forEach((id) => {\n            const t = ctx.getVariable(id)?.type\n            if (t === undefined || t.type !== 'function') {\n                return\n            }\n            Object.entries(t.namedArgs).forEach(([, arg]) => {\n                const dv = arg.defaultValue\n                if (dv === undefined) {\n                    return\n                }\n                identifiersInExpr(dv).forEach((newId) => {\n                    if (!identifiers.has(newId)) {\n                        newIdentifiers.add(newId)\n                    }\n                })\n            })\n        })\n        if (newIdentifiers.size === 0) {\n            break\n        }\n        newIdentifiers.forEach(id => identifiers.add(id))\n    }\n    return identifiers\n}\n\nexport function unparse(node: UrbanStatsASTStatement | UrbanStatsASTExpression, opts: { indent?: number, inline?: boolean, simplify?: boolean, expressionalContext?: boolean } = {}): string {\n    if (opts.inline) {\n        assert(opts.expressionalContext ?? false, 'inline must be true if expressionalContext is true')\n    }\n    opts.indent = opts.indent ?? 0\n    function isSimpleExpression(expr: UrbanStatsASTExpression): boolean {\n        return expr.type === 'identifier' || expr.type === 'vectorLiteral' || expr.type === 'constant' || expr.type === 'customNode'\n    }\n    function indentSpaces(level: number): string {\n        return '    '.repeat(level)\n    }\n    switch (node.type) {\n        case 'customNode':\n            if (!opts.simplify) {\n                return `customNode(${JSON.stringify(node.originalCode.trim())})`\n            }\n            if (opts.expressionalContext && node.expr.type !== 'expression') {\n                return unparse({ type: 'do', statements: [node.expr], entireLoc: locationOf(node.expr) }, { ...opts, inline: true })\n            }\n            else {\n                return node.originalCode.trim()\n            }\n        case 'parseError':\n            return node.originalCode\n        case 'constant':\n            if (node.value.node.type === 'string') {\n                return `\"${node.value.node.value}\"`\n            }\n            else {\n                return node.value.node.value.toString()\n            }\n        case 'identifier':\n            return node.name.node\n        case 'attribute':\n            const exprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            return `${exprStr}.${node.name.node}`\n        case 'call':\n            const fnStr = unparse(node.fn, { ...opts, inline: true, expressionalContext: true })\n            const argsStr = node.args.map((arg) => {\n                switch (arg.type) {\n                    case 'unnamed':\n                        return unparse(arg.value, { ...opts, inline: true, expressionalContext: true })\n                    case 'named':\n                        return `${arg.name.node}=${unparse(arg.value, { ...opts, inline: true, expressionalContext: true })}`\n                }\n            })\n            const fnNeedsParens = !isSimpleExpression(node.fn)\n            const fnWithParens = fnNeedsParens ? `(${fnStr})` : fnStr\n            return `${fnWithParens}(${argsStr.join(', ')})`\n        case 'unaryOperator':\n            const unaryExprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            const needsParens = !isSimpleExpression(node.expr)\n            const exprWithParens = needsParens ? `(${unaryExprStr})` : unaryExprStr\n            return `${node.operator.node}${exprWithParens}`\n        case 'binaryOperator':\n            const leftStr = unparse(node.left, { ...opts, inline: true, expressionalContext: true })\n            const rightStr = unparse(node.right, { ...opts, inline: true, expressionalContext: true })\n            const opPrecedence = expressionOperatorMap.get(node.operator.node)?.precedence ?? 0\n            let leftWithParens = leftStr\n            if (node.left.type === 'binaryOperator') {\n                const leftOpPrecedence = expressionOperatorMap.get(node.left.operator.node)?.precedence ?? 0\n                if (leftOpPrecedence < opPrecedence) {\n                    leftWithParens = `(${leftStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.left)) {\n                leftWithParens = `(${leftStr})`\n            }\n            let rightWithParens = rightStr\n            if (node.right.type === 'binaryOperator') {\n                const rightOpPrecedence = expressionOperatorMap.get(node.right.operator.node)?.precedence ?? 0\n                if (rightOpPrecedence <= opPrecedence) {\n                    rightWithParens = `(${rightStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.right)) {\n                rightWithParens = `(${rightStr})`\n            }\n            return `${leftWithParens} ${node.operator.node} ${rightWithParens}`\n        case 'vectorLiteral':\n            const elementsStr = node.elements.map(elem => unparse(elem, { ...opts, inline: true, expressionalContext: true }))\n            return `[${elementsStr.join(', ')}]`\n        case 'objectLiteral':\n            const propertiesStr = node.properties.map(([key, value]) => {\n                const valueStr = unparse(value, { ...opts, inline: true, expressionalContext: true })\n                return `${key}: ${valueStr}`\n            })\n            return `{${propertiesStr.join(', ')}}`\n        case 'assignment':\n            const lhsStr = unparse(node.lhs, { ...opts, expressionalContext: true })\n            const valueStr = unparse(node.value, { ...opts, expressionalContext: true })\n            return opts.inline ? `${lhsStr} = ${valueStr}` : `${indentSpaces(opts.indent)}${lhsStr} = ${valueStr}`\n        case 'expression':\n            // despite being an expression, it is not in an expressional context if its parent is not\n            return opts.inline ? unparse(node.value, opts) : `${indentSpaces(opts.indent)}${unparse(node.value, opts)}`\n        case 'statements':\n            const statementsStr = node.result\n                .map(stmt => unparse(stmt, opts))\n                .filter(s => s !== '' && s !== 'do {  }')\n            return statementsStr.join(opts.inline ? '; ' : ';\\n')\n        case 'if':\n            const conditionStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const thenStr = unparse(node.then, { ...opts, indent: opts.indent + 1 })\n            let ifStr = opts.inline\n                ? `if (${conditionStr}) { ${thenStr} }`\n                : `if (${conditionStr}) {\\n${thenStr}\\n${indentSpaces(opts.indent)}}`\n            if (node.else) {\n                const elseStr = unparse(node.else, { ...opts, indent: opts.indent + 1 })\n                ifStr += opts.inline\n                    ? ` else { ${elseStr} }`\n                    : ` else {\\n${elseStr}\\n${indentSpaces(opts.indent)}}`\n            }\n            return ifStr\n        case 'do':\n            const doStatements = { type: 'statements' as const, result: node.statements, entireLoc: node.entireLoc }\n            const doStr = unparse(doStatements, { ...opts, indent: opts.indent + 1 })\n            return opts.inline\n                ? `do { ${doStr} }`\n                : `do {\\n${doStr}\\n${indentSpaces(opts.indent)}}`\n        case 'condition':\n            const condStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const restStatements = { type: 'statements' as const, result: node.rest, entireLoc: node.entireLoc }\n            const restStr = unparse(restStatements, opts)\n            // If condition is literal \"true\", elide it\n            if (opts.simplify && node.condition.type === 'identifier' && node.condition.name.node === 'true') {\n                return restStr\n            }\n            return `${indentSpaces(opts.indent)}condition (${condStr})\\n${restStr}`\n    }\n}\n\nexport function parseNoError(uss: string, blockId: string): UrbanStatsASTStatement {\n    const result = parse(uss, { type: 'single', ident: blockId }, true)\n    assert(result.type !== 'error', `Should not have an error`)\n    return result\n}\n\nexport function parseNoErrorAsCustomNode(uss: string, blockId: string, expectedType?: USSType[]): Extract<UrbanStatsASTExpression, { type: 'customNode' }> {\n    assert(!blockId.startsWith('undefined'), 'blockId must not start with \"undefined\"')\n    const result = parseNoError(uss, blockId)\n    return {\n        type: 'customNode',\n        expr: result,\n        originalCode: uss,\n        expectedType,\n        entireLoc: emptyLocation(blockId),\n    }\n}\n\nexport function parseNoErrorAsExpression(uss: string, blockId: string): UrbanStatsASTExpression {\n    const result = parseNoError(uss, blockId)\n    assert(result.type === 'expression', 'Must be expression')\n    return result.value\n}\n","import { Basemap } from '../mapper/settings/utils'\nimport { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTExpression } from './ast'\nimport { Color, hexToColor } from './constants/color-utils'\nimport { CMap, CMapRGB, Outline, PMap } from './constants/map'\nimport { RampT } from './constants/ramp'\nimport { Scale } from './constants/scale'\nimport { Context } from './context'\nimport { noLocation } from './location'\nimport { unparse } from './parser'\n\n// Define Inset and Insets types locally to avoid import issues\ninterface Inset { bottomLeft: [number, number], topRight: [number, number], coordBox?: [number, number, number, number], mainMap: boolean, name?: string }\ntype Insets = Inset[]\n\n// Define the tagged union for opaque values\nexport type USSOpaqueValue =\n    | { type: 'opaque', opaqueType: 'color', value: Color }\n    | { type: 'opaque', opaqueType: 'scale', value: Scale }\n    | { type: 'opaque', opaqueType: 'inset', value: Inset }\n    | { type: 'opaque', opaqueType: 'insets', value: Insets }\n    | { type: 'opaque', opaqueType: 'cMap', value: CMap }\n    | { type: 'opaque', opaqueType: 'cMapRGB', value: CMapRGB }\n    | { type: 'opaque', opaqueType: 'pMap', value: PMap }\n    | { type: 'opaque', opaqueType: 'outline', value: Outline }\n    | { type: 'opaque', opaqueType: 'unit', value: { unit: string } }\n    | { type: 'opaque', opaqueType: 'ramp', value: RampT }\n    | { type: 'opaque', opaqueType: 'basemap', value: Basemap }\n    | { type: 'opaque', opaqueType: 'geoFeatureHandle', value: string }\n    | { type: 'opaque', opaqueType: 'geoCentroidHandle', value: string }\n\ninterface USSNumberType {\n    type: 'number'\n}\n\ninterface USSStringType {\n    type: 'string'\n}\ninterface USSBooleanType {\n    type: 'boolean'\n}\n\ninterface USSNullType {\n    type: 'null'\n}\n\nexport interface USSOpaqueType {\n    type: 'opaque'\n    name: string\n    allowCustomExpression?: boolean\n}\n\nexport interface USSVectorType {\n    type: 'vector'\n    elementType: USSType | { type: 'elementOfEmptyVector' }\n}\n\nexport interface USSObjectType {\n    type: 'object'\n    properties: Map<string, USSType>\n}\n\nexport type USSFunctionArgType = { type: 'concrete', value: USSType } | { type: 'anyPrimitive' }\nexport type USSFunctionReturnType = { type: 'concrete', value: USSType } | { type: 'inferFromPrimitive' }\n\nexport interface NamedFunctionArgumentWithDocumentation {\n    type: USSFunctionArgType\n    defaultValue?: UrbanStatsASTExpression\n    documentation?: NamedFunctionArgumentDocumentation\n}\n\nexport interface USSFunctionType {\n    type: 'function'\n    posArgs: USSFunctionArgType[]\n    namedArgs: Record<string, NamedFunctionArgumentWithDocumentation>\n    returnType: USSFunctionReturnType\n}\n\ninterface NamedFunctionArgumentDocumentation {\n    hide?: boolean\n}\n\nexport type USSType = (\n    USSNumberType\n    | USSStringType\n    | USSBooleanType\n    | USSNullType\n    | USSOpaqueType\n    | USSObjectType\n    | USSVectorType\n    | USSFunctionType\n)\n\nexport type USSPrimitiveRawValue = (\n    number |\n    string |\n    boolean |\n    null\n)\n\nexport interface OriginalFunctionArgs {\n    posArgs: USSValue[]\n    namedArgs: Record<string, USSValue>\n}\n\nexport type USSRawValue = (\n    USSPrimitiveRawValue |\n    USSRawValue[] |\n    Map<string, USSRawValue> |\n    (\n        (\n            ctx: Context,\n            posArgs: USSRawValue[],\n            namedArgs: Record<string, USSRawValue>,\n            // only used occasionally, for functions that need to access the original arguments\n            // to e.g., access their documentation\n            originalArgs: OriginalFunctionArgs\n        ) => USSRawValue\n    ) |\n    USSOpaqueValue\n)\n\nexport const constantCategories = ['basic', 'color', 'math', 'regression', 'mapper', 'logic', 'map', 'scale', 'ramp', 'unit', 'inset'] as const\n\nexport type ConstantCategory = typeof constantCategories[number]\n\nexport type DocumentationTable = 'mapper-data-variables' | 'predefined-colors' | 'unit-types' | 'predefined-ramps' | 'predefined-insets' | 'logarithm-functions' | 'trigonometric-functions'\n\nexport type SelectorRendering = { kind: 'subtitleLongDescription' } | { kind: 'gradientBackground', ramp: RampT }\nexport interface Documentation {\n    humanReadableName: string\n    priority?: number\n    /**\n     * True if this is the canonical default value for its type (e.g., the default ramp or scale).\n     */\n    isDefault?: boolean\n    /**\n     * Human-readable names for named arguments. Maps argument name to display name.\n     */\n    namedArgs?: Record<string, string>\n    /**\n     * Should be included when a constant should be deconstructed into an expression for user editing\n     */\n    equivalentExpressions?: UrbanStatsASTExpression[]\n    /**\n     * Included for all bulit-in constants.\n     */\n    category?: ConstantCategory\n    /**\n     * Whether the constant should be grouped with other constants in a table in the documentation.\n     * If present, this field groups the constant with other similar ones.\n     */\n    documentationTable?: DocumentationTable\n    /**\n     * Included for all bulit-in constants. Will be displayed in the documentation.\n     */\n    longDescription?: string\n    /**\n     * Used when displaying this value in a selector\n     */\n    selectorRendering?: SelectorRendering\n    /**\n     * True if this is a custom constructor that should invoke edit icons elsewhere\n     */\n    customConstructor?: boolean\n    /**\n     * True if the constant is derived from a statistic column. These should all have type number[]\n     */\n    fromStatisticColumn?: boolean\n    /**\n     * True if this should be outputted in the context returned by the worker. If this is true, the value\n     * should also be serializable to JSON.\n     */\n    includedInOutputContext?: boolean\n}\n\nexport interface USSDocumentedType {\n    type: USSType\n    documentation?: Documentation\n\n}\n\nexport type TypeEnvironment = Map<string, USSDocumentedType>\n\nexport type USSValue = { value: USSRawValue } & USSDocumentedType\n\nexport function undocValue(value: USSRawValue, type: USSType): USSValue {\n    return {\n        type,\n        value,\n        documentation: undefined,\n    }\n}\n\nexport function createConstantExpression(value: number | string | boolean | null): UrbanStatsASTExpression {\n    // Create a simple constant expression for primitive values\n    if (typeof value === 'number') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'number', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'string') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'string', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'boolean') {\n        // For booleans, use identifier expressions that reference the predefined constants\n        return {\n            type: 'identifier',\n            name: { node: value.toString(), location: noLocation },\n        }\n    }\n    else {\n        // For null, use identifier expression that references the predefined null constant\n        return {\n            type: 'identifier',\n            name: { node: 'null', location: noLocation },\n        }\n    }\n}\n\nexport function unifyFunctionType(param: USSFunctionArgType, arg: USSType): boolean {\n    if (param.type === 'concrete') {\n        return renderType(param.value) === renderType(arg)\n    }\n    return arg.type === 'number' || arg.type === 'string' || arg.type === 'boolean' || arg.type === 'null'\n}\n\nexport function renderType(type: USSType): string {\n    if (type.type === 'number') {\n        return 'number'\n    }\n    if (type.type === 'string') {\n        return 'string'\n    }\n    if (type.type === 'boolean') {\n        return 'boolean'\n    }\n    if (type.type === 'vector') {\n        return `[${type.elementType.type === 'elementOfEmptyVector' ? '' : renderType(type.elementType)}]`\n    }\n    if (type.type === 'object') {\n        assert(type.properties instanceof Map, `Expected properties to be a Map, got ${typeof type.properties}`)\n        return `{${[...type.properties.entries()].sort().map(([k, v]) => `${k}: ${renderType(v)}`).join(', ')}}`\n    }\n    if (type.type === 'null') {\n        return 'null'\n    }\n    if (type.type === 'opaque') {\n        return type.name\n    }\n    return `(${type.posArgs.map(renderArgumentType).join(', ')}; ${Object.entries(type.namedArgs).map(([k, v]) => `${k}: ${renderKwargType(v)}`).join(', ')}) -> ${renderReturnType(type.returnType)}`\n}\n\nexport function renderArgumentType(arg: USSFunctionArgType): string {\n    if (arg.type === 'concrete') {\n        return renderType(arg.value)\n    }\n    return 'any'\n}\n\nexport function renderKwargType(arg: { type: USSFunctionArgType, defaultValue?: UrbanStatsASTExpression }): string {\n    const type = renderArgumentType(arg.type)\n    if (arg.defaultValue !== undefined) {\n        return `${type} = ${unparse(arg.defaultValue)}`\n    }\n    return type\n}\n\nfunction renderReturnType(ret: USSFunctionReturnType): string {\n    if (ret.type === 'concrete') {\n        return renderType(ret.value)\n    }\n    return 'any'\n}\n\nexport type ValueArg = (\n    { type: 'unnamed', value: USSValue } |\n    { type: 'named', name: string, value: USSValue }\n)\n\nexport function getPrimitiveType(value: USSRawValue, depth: number = 0): USSType {\n    if (depth === 0) {\n        if (typeof value === 'number') {\n            return { type: 'number' }\n        }\n        if (typeof value === 'string') {\n            return { type: 'string' }\n        }\n        if (typeof value === 'boolean') {\n            return { type: 'boolean' }\n        }\n        if (value === null) {\n            return { type: 'null' }\n        }\n    }\n    assert(Array.isArray(value), `Expected a primitive value, but got ${typeof value}`)\n    return getPrimitiveType(value[0], depth - 1)\n}\n\nexport function unifyType(\n    a: USSType | { type: 'elementOfEmptyVector' },\n    b: USSType | { type: 'elementOfEmptyVector' },\n    error: () => Error,\n): USSType | { type: 'elementOfEmptyVector' } {\n    if (a.type === 'elementOfEmptyVector') {\n        return b\n    }\n    if (b.type === 'elementOfEmptyVector') {\n        return a\n    }\n    if (renderType(a) === renderType(b)) {\n        return a\n    }\n    if (a.type === 'vector' && b.type === 'vector') {\n        return {\n            type: 'vector',\n            elementType: unifyType(a.elementType, b.elementType, error),\n        }\n    }\n    if (a.type === 'object' && b.type === 'object') {\n        if (JSON.stringify([...a.properties.keys()].sort()) !== JSON.stringify([...b.properties.keys()].sort())) {\n            throw error()\n        }\n        const properties = new Map<string, USSType>()\n        for (const [key, type] of a.properties) {\n            properties.set(key, type)\n        }\n        for (const [key, type] of b.properties) {\n            const res = unifyType(properties.get(key)!, type, error)\n            assert(res.type !== 'elementOfEmptyVector', `Unreachable`)\n            properties.set(key, res)\n        }\n        return {\n            type: 'object',\n            properties,\n        }\n    }\n    throw error()\n}\n\nexport function renderValue(input: USSValue): string {\n    function helper(value: USSValue, indent: string): string {\n        const type = value.type\n        switch (type.type) {\n            case 'boolean':\n            case 'null':\n            case 'number':\n                return `${value.value}`\n            case 'string':\n                return `\"${value.value}\"`\n            case 'opaque':\n                const opaqueValue = value.value as USSOpaqueValue\n                switch (opaqueValue.opaqueType) {\n                    case 'scale':\n                    case 'pMap':\n                    case 'cMap':\n                    case 'cMapRGB':\n                    case 'basemap':\n                    case 'inset':\n                    case 'insets':\n                    case 'geoFeatureHandle':\n                    case 'geoCentroidHandle':\n                    case 'unit':\n                        return `[${opaqueValue.opaqueType} object]`\n                    case 'color':\n                        const colorValue = opaqueValue.value as { r: number, g: number, b: number, a: number }\n                        if (colorValue.a === 255) {\n                            return `rgb(${colorValue.r / 255}, ${colorValue.g / 255}, ${colorValue.b / 255})`\n                        }\n                        else {\n                            return `rgb(${colorValue.r / 255}, ${colorValue.g / 255}, ${colorValue.b / 255}, a=${colorValue.a / 255})`\n                        }\n                    case 'outline':\n                        const outline = opaqueValue.value as { color: { r: number, g: number, b: number, a: number }, weight: number }\n                        const outlineColor = outline.color\n                        if (outlineColor.a === 255) {\n                            return `constructOutline(color=rgb(${outlineColor.r / 255}, ${outlineColor.g / 255}, ${outlineColor.b / 255}), weight=${outline.weight})`\n                        }\n                        else {\n                            return `constructOutline(color=rgb(${outlineColor.r / 255}, ${outlineColor.g / 255}, ${outlineColor.b / 255}, a=${outlineColor.a / 255}), weight=${outline.weight})`\n                        }\n                    case 'ramp':\n                        const ramp = opaqueValue.value\n                        const rampValue = ramp.map(\n                            ([position, color]) => {\n                                const contents: [string, USSRawValue][] = [\n                                        ['value', position] satisfies [string, USSRawValue],\n                                        ['color', { type: 'opaque', opaqueType: 'color', value: hexToColor(color) }] satisfies [string, USSRawValue],\n                                ] satisfies [string, USSRawValue][]\n                                return new Map(contents) satisfies Map<string, USSRawValue>\n                            },\n                        )\n                        const interior = undocValue(rampValue,\n                            {\n                                type: 'vector',\n                                elementType: {\n                                    type: 'object',\n                                    properties: new Map([\n                                        ['value', { type: 'number' }],\n                                        ['color', { type: 'opaque', name: 'color' }],\n                                    ]),\n                                },\n                            },\n                        )\n                        return `[ramp ${renderValue(interior)}]`\n                }\n            case 'vector':\n                const vector = value.value as USSRawValue[]\n                if (vector.length === 0) {\n                    return `[]`\n                }\n                // USSType assertion is OK since we handle zero-length vectors above\n                return `[\n${vector.map(element => `${indent}    ${helper(undocValue(element, type.elementType as USSType), `${indent}    `)}`).join(',\\n')}\n${indent}]`\n            case 'object':\n                const map = value.value as Map<string, USSRawValue>\n                if (map.size === 0) {\n                    return `{}`\n                }\n                return `{\n${Array.from(map.entries()).map(([key, element]) => `${indent}    ${key}: ${helper(undocValue(element, type.properties.get(key)!), `${indent}    `)}`).join(',\\n')}\n${indent}}`\n            case 'function':\n                return renderType(type)\n        }\n    }\n    return helper(input, '')\n}\n\nexport function canUnifyTo(a: USSType, b: USSType): boolean {\n    // returns true iff a can be used in a context where b is expected\n    if (renderType(a) === renderType(b)) {\n        return true\n    }\n    // at this point, the types are different\n    switch (b.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'null':\n        case 'opaque':\n            // these are all primitive types, so no way to substitute them\n            return false\n        case 'vector':\n            assert(b.elementType.type !== 'elementOfEmptyVector', `Unreachable`)\n            return canUnifyTo(a, b.elementType)\n        case 'object':\n            if (a.type !== 'object') {\n                return false\n            }\n            if (a.properties.size !== b.properties.size) {\n                return false\n            }\n            if (![...a.properties.keys()].every(key => b.properties.has(key))) {\n                return false\n            }\n            return [...a.properties.keys()].every(key => canUnifyTo(a.properties.get(key)!, b.properties.get(key)!))\n        case 'function':\n            return false\n    }\n}\n","import { emptyContext } from '../../unit/urban-stats-script-utils'\nimport { Inset, Insets } from '../components/map'\nimport insets from '../data/insets'\nimport validGeographies from '../data/mapper/used_geographies'\nimport statistic_path_list from '../data/statistic_path_list'\nimport statistic_variables_info from '../data/statistic_variables_info'\nimport { loadOrderingDataProtobuf, loadProtobuf } from '../load_json'\nimport { mapperContext, defaultTypeEnvironment } from '../mapper/context'\nimport { indexLink } from '../navigation/links'\nimport { Universe } from '../universe'\nimport { assert } from '../utils/defensive'\n\nimport { locationOfLastExpression, UrbanStatsASTExpression } from './ast'\nimport { insetNameToConstantName } from './constants/insets'\nimport { Context } from './context'\nimport { EditorError } from './editor-utils'\nimport { Effect, execute, InterpretationError } from './interpreter'\nimport { noLocation } from './location'\nimport { renderType, USSRawValue, USSValue } from './types-values'\nimport { USSExecutionRequest, USSExecutionResult } from './workerManager'\n\nlet mapperCache: {\n    universe: Universe\n    geographyKind: typeof validGeographies[number]\n    longnames: string[]\n    dataCache: Map<string, number[]>\n} | undefined\n\nasync function executeRequest(request: USSExecutionRequest): Promise<USSExecutionResult> {\n    let context, getWarnings\n    try {\n        ([context, getWarnings] = await contextForRequest(request))\n        const result = execute(request.stmts, context)\n\n        switch (request.descriptor.kind) {\n            case 'generic': {\n                break\n            }\n            case 'mapper': {\n                // no idea why we need this, but it's obviously correct from the switch\n                if (renderType(result.type) !== 'cMap' && renderType(result.type) !== 'cMapRGB' && renderType(result.type) !== 'pMap') {\n                    throw new InterpretationError(`USS expression did not return a cMap, cMapRGB, or pMap type, got: ${renderType(result.type)}`, locationOfLastExpression(request.stmts))\n                }\n                break\n            }\n        }\n        return {\n            resultingValue: { type: result.type, value: removeFunctions(result.value) },\n            error: getWarnings(),\n            context: new Map([...context.variableEntries()].filter(([,v]) => v.documentation?.includedInOutputContext)),\n        }\n    }\n    catch (error) {\n        let interpretationError: InterpretationError\n        if (error instanceof InterpretationError) {\n            interpretationError = error\n        }\n        else {\n            console.error('Unknown interpretation error', error)\n            interpretationError = new InterpretationError('Unknown interpretation error', noLocation)\n        }\n        return {\n            error: [{ type: 'error', value: interpretationError.value, location: interpretationError.location, kind: 'error' }, ...(getWarnings?.() ?? [])],\n            context: new Map(),\n        }\n    }\n}\n\nasync function contextForRequest(request: USSExecutionRequest): Promise<[Context, () => EditorError[]]> {\n    const effects: Effect[] = []\n    const getWarnings = (): EditorError[] => {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- just so if there's additonal types, we're safe\n        return effects.filter(eff => eff.type === 'warning').map(eff => ({\n            type: 'error',\n            value: eff.message,\n            location: eff.location,\n            kind: 'warning',\n        }))\n    }\n    switch (request.descriptor.kind) {\n        case 'generic':\n            return [emptyContext(effects), getWarnings]\n        case 'mapper':\n            return [await mapperContextForRequest(request as USSExecutionRequest & { descriptor: { kind: 'mapper' } }, effects), getWarnings]\n    }\n}\n\nasync function mapperContextForRequest(request: USSExecutionRequest & { descriptor: { kind: 'mapper' } }, effects: Effect[]): Promise<Context> {\n    const geographyKind = request.descriptor.geographyKind\n    const universe = request.descriptor.universe\n    const dte = defaultTypeEnvironment(universe)\n    if (!validGeographies.includes(geographyKind)) {\n        throw new Error('invalid geography')\n    }\n\n    // Load geography names and set up cache\n    let longnames: string[]\n\n    if (mapperCache?.geographyKind === geographyKind && mapperCache.universe === universe) {\n        longnames = mapperCache.longnames\n    }\n    else {\n        // Load geography names from index\n        const indexData = await loadProtobuf(indexLink(universe, geographyKind), 'ArticleOrderingList')\n        longnames = indexData.longnames\n        mapperCache = {\n            universe,\n            geographyKind,\n            longnames,\n            dataCache: new Map(),\n        }\n    }\n\n    const annotateType = (name: string, val: USSRawValue): USSValue => {\n        const typeInfo = dte.get(name)\n        assert(typeInfo !== undefined, `Type info for ${name} not found`)\n        return {\n            type: typeInfo.type,\n            documentation: typeInfo.documentation,\n            value: val,\n        }\n    }\n\n    const getVariable = async (name: string): Promise<USSValue | undefined> => {\n        assert(mapperCache !== undefined, 'mapperCache was initialized above and is never undefined after that')\n        if (name === 'geoName') {\n            return annotateType('geoName', longnames)\n        }\n        if (name === 'geo') {\n            return annotateType('geo', longnames.map(longname => ({ type: 'opaque', opaqueType: 'geoFeatureHandle', value: longname })))\n        }\n        if (name === 'geoCentroid') {\n            return annotateType('geoCentroid', longnames.map(longname => ({ type: 'opaque', opaqueType: 'geoCentroidHandle', value: longname })))\n        }\n        if (name === 'defaultInsets') {\n            return annotateType('defaultInsets', { type: 'opaque', opaqueType: 'insets', value: loadInset(request.descriptor.universe) })\n        }\n        const variableInfo = statistic_variables_info.variableNames.find(v => v.varName === name)\n        if (!variableInfo) {\n            return undefined\n        }\n        const index = variableInfo.index\n\n        // Check cache first\n        const existing = mapperCache.dataCache.get(name)\n        if (existing !== undefined) {\n            return annotateType(name, existing)\n        }\n\n        const statpath = statistic_path_list[index]\n\n        const variableData = await loadOrderingDataProtobuf(universe, statpath, geographyKind)\n        assert(Array.isArray(variableData.value), `Expected variable data for ${name} to be an array`)\n        mapperCache.dataCache.set(name, variableData.value)\n        return annotateType(name, variableData.value)\n    }\n\n    const context = await mapperContext(request.stmts, getVariable, effects, universe)\n    return context\n}\n\nfunction removeFunctions(value: USSRawValue): USSRawValue {\n    if (value instanceof Function) {\n        return null\n    }\n    else if (Array.isArray(value)) {\n        return value.map(removeFunctions)\n    }\n    else if (value instanceof Map) {\n        return new Map(Array.from(value.entries()).map(([k, v]) => [k, removeFunctions(v)]))\n    }\n    else if (value instanceof Object && value.value instanceof Function) {\n        assert(value.opaqueType === 'scale', 'only scales can have functions in their value')\n        return null\n    }\n    return value\n}\n\nonmessage = async (message: MessageEvent<{ request: USSExecutionRequest, id: number }>) => {\n    if (!('request' in message.data)) {\n        // Some other message (e.g. from React devtools)\n        return\n    }\n    const result = await executeRequest(message.data.request)\n    postMessage({ result, id: message.data.id })\n}\n\nexport function loadInset(universe: Universe): Insets {\n    const insetsU = insets[universe]\n    assert(insetsU.length > 0, `No insets for universe ${universe}`)\n    assert(insetsU[0].mainMap, `No main map for universe ${universe}`)\n    const insetsProc = insetsU.map((inset) => {\n        return {\n            bottomLeft: [inset.bottomLeft[0], inset.bottomLeft[1]],\n            topRight: [inset.topRight[0], inset.topRight[1]],\n            // copy to get rid of readonly\n            coordBox: [...inset.coordBox],\n            mainMap: inset.mainMap,\n        } satisfies Inset\n    })\n    return insetsProc\n}\n\nexport function loadInsetExpression(universe: Universe): UrbanStatsASTExpression {\n    const insetsU = insets[universe]\n    const names = insetsU.map(x => x.name)\n\n    const exprs = names.map((name) => {\n        const expr = insetNameToConstantName.get(name)\n        assert(expr !== undefined, `No inset constant for ${name}`)\n        return { type: 'identifier', name: { node: expr, location: noLocation } } satisfies UrbanStatsASTExpression\n    })\n\n    return {\n        type: 'call',\n        fn: { type: 'identifier', name: { node: 'constructInsets', location: noLocation } },\n        args: [{\n            type: 'unnamed',\n            value: {\n                type: 'vectorLiteral',\n                elements: exprs,\n                entireLoc: noLocation,\n            } satisfies UrbanStatsASTExpression,\n        }],\n        entireLoc: noLocation,\n    } satisfies UrbanStatsASTExpression\n}\n","import validGeographies from '../data/mapper/used_geographies'\nimport { Universe } from '../universe'\n\nimport { UrbanStatsASTStatement } from './ast'\nimport { EditorError } from './editor-utils'\nimport { USSOpaqueType, USSOpaqueValue, USSValue } from './types-values'\n\nexport type USSExecutionDescriptor = { kind: 'generic' } | { kind: 'mapper', geographyKind: typeof validGeographies[number], universe: Universe }\nexport interface USSExecutionRequest { descriptor: USSExecutionDescriptor, stmts: UrbanStatsASTStatement }\nexport type AsyncInterpretationError = EditorError[]\n\nexport interface USSExecutionResult<Value extends USSValue = USSValue> {\n    resultingValue?: Value\n    error: AsyncInterpretationError\n    context: Map<string, USSValue>\n}\n\nexport function executeAsync(request: { descriptor: { kind: 'mapper', geographyKind: typeof validGeographies[number], universe: Universe }, stmts: UrbanStatsASTStatement }): Promise<USSExecutionResult<{ type: USSOpaqueType, value: USSOpaqueValue & { opaqueType: 'cMap' | 'cMapRGB' | 'pMap' } }>>\nexport function executeAsync(request: USSExecutionRequest): Promise<USSExecutionResult>\nexport async function executeAsync(request: USSExecutionRequest): Promise<USSExecutionResult> {\n    if (sharedUSSWorker === undefined) {\n        sharedUSSWorker = createUSSWorker()\n    }\n    return await sharedUSSWorker(request)\n}\n\ntype USSWorker = (params: USSExecutionRequest) => Promise<USSExecutionResult>\n\nlet sharedUSSWorker: USSWorker | undefined\n\nconst terminationDelay = 10_000\n\nfunction createUSSWorker(): USSWorker {\n    const worker = new Worker(new URL('./worker', import.meta.url), { name: 'sharedUSSWorker' })\n    // The worker may return responses out of order, so we need to give them identifiers\n    const messageQueue = new Map<number, (result: USSExecutionResult) => void>()\n    worker.addEventListener('message', (message: MessageEvent<{ result: USSExecutionResult, id: number }>) => {\n        messageQueue.get(message.data.id)!(message.data.result)\n        messageQueue.delete(message.data.id)\n    })\n\n    // worker should terminate if not used\n    let terminationTimer: ReturnType<typeof setTimeout> | undefined\n    function resetTerminationTimer(): void {\n        clearTimeout(terminationTimer)\n        terminationTimer = setTimeout(() => {\n            if (messageQueue.size > 0) {\n                resetTerminationTimer()\n            }\n            else {\n                worker.terminate()\n                sharedUSSWorker = undefined\n            }\n        }, terminationDelay)\n    }\n    resetTerminationTimer()\n\n    let counter = 0\n    const result: USSWorker = (request) => {\n        resetTerminationTimer()\n        const id = ++counter\n        worker.postMessage({ request, id })\n        return new Promise((resolve) => {\n            messageQueue.set(id, resolve)\n        })\n    }\n\n    return result\n}\n","import { MathJaxContext } from 'better-react-mathjax'\nimport React, { ReactNode, useState } from 'react'\nimport { Footnotes, FootnotesProvider } from 'react-a11y-footnotes'\n\nimport './style.css'\nimport './common.css'\nimport { defaultTypeEnvironment } from './mapper/context'\nimport { useColors } from './page_template/colors'\nimport { PageTemplate } from './page_template/template'\nimport { StandaloneEditor } from './urban-stats-script/StandaloneEditor'\nimport { defaultConstants } from './urban-stats-script/constants/constants'\nimport { expressionOperatorMap } from './urban-stats-script/operators'\nimport { constantCategories, ConstantCategory, DocumentationTable, renderType, USSDocumentedType, USSValue } from './urban-stats-script/types-values'\nimport { assert } from './utils/defensive'\nimport { useHeaderTextClass } from './utils/responsive'\n\nexport function USSDocumentationPanel(): ReactNode {\n    const textHeaderClass = useHeaderTextClass()\n\n    return (\n        <MathJaxContext>\n            <PageTemplate>\n                <FootnotesProvider>\n                    <div className=\"serif\">\n                        <div className={textHeaderClass}>USS Documentation</div>\n\n                        <Header title=\"Urban Stats Script (USS)\" header=\"h1\" ident=\"uss-title\">\n                            <p>\n                                Urban Stats Script (USS) is a scripting language for describing operations on\n                                data. It is designed to allow users to describe programs as if they refer to a\n                                single row of data, while simultaneously allowing global operations like regression.\n                            </p>\n                            <p>\n                                The basic syntax of USS should be familiar to any programmer. Arithmetic operations are\n                                written as you would expect. Feel free to edit the code below to see how the result changes:\n                            </p>\n                            <StandaloneEditor ident=\"aritmetic\" getCode={() => 'x = 2 ** 3 + 3 * 4' + '\\n' + 'y = x + 2' + '\\n' + 'y'} />\n                            <p>\n                                A full list of operators is available\n                                {' '}\n                                <a href=\"#all-operators\">here</a>\n                                .\n                            </p>\n                            <Header title=\"Lists\" header=\"h2\" ident=\"lists\">\n                                <p>\n                                    The language also supports lists, which are denoted by square brackets. You can use operators on these as well:\n                                </p>\n                                <StandaloneEditor ident=\"lists\" getCode={() => 'x = [1, 2, 3]' + '\\n' + 'y = x + [4, 5, 6]' + '\\n' + 'y'} />\n                                <p>\n                                    For details on broadcasting, see the\n                                    {' '}\n                                    <a href=\"#broadcasting\">broadcasting</a>\n                                    {' '}\n                                    section.\n                                </p>\n                            </Header>\n                            <Header title=\"Objects\" header=\"h2\" ident=\"objects\">\n                                <p>\n                                    The language also supports objects, which are denoted by curly braces. You can use operators on these as well:\n                                </p>\n                                <StandaloneEditor ident=\"objects\" getCode={() => 'x = {a: 1, b: 2}' + '\\n' + 'y = x.a + x.b' + '\\n' + 'y'} />\n                            </Header>\n                            <Header title=\"Opaque Types\" header=\"h2\" ident=\"opaque-types\">\n                                <p>\n                                    USS has several opaque types, which are types that you can only interact with via functions.\n                                    For example, colors are opaque types, and you can only create them using functions like\n                                    {' '}\n                                    <code>rgb()</code>\n                                    {', '}\n                                    <code>hsv()</code>\n                                    , or one of the predefined colors.\n                                </p>\n                                <StandaloneEditor ident=\"opaque-types\" getCode={() => 'x = rgb(0, 0, 1)' + '\\n' + 'y = hsv(0, 1, 1)' + '\\n' + '[x, y, colorRed]'} />\n                                <p>\n                                    And you can only interact with them using functions like\n                                    {' '}\n                                    <code>renderColor()</code>\n                                    {' '}\n                                    or in other contexts that use color objects.\n                                </p>\n                                <StandaloneEditor ident=\"opaque-types\" getCode={() => 'x = rgb(0, 0, 1)' + '\\n' + 'y = hsv(0, 1, 1)' + '\\n' + 'renderColor([x, y, colorRed])'} />\n                            </Header>\n                            <Header title=\"Regressions\" header=\"h2\" ident=\"regressions\">\n                                <p>\n                                    USS supports linear regression via the\n                                    {' '}\n                                    <code>regress(y, x1, x2, ..., weight)</code>\n                                    {' '}\n                                    function, which returns an object with several properties:\n                                </p>\n                                <ul>\n                                    <li>\n                                        <code>b</code>\n                                        : The intercept of the regression line.\n                                    </li>\n                                    <li>\n                                        <code>m1, m2, m3...</code>\n                                        : The coefficients for each independent variable.\n                                    </li>\n                                    <li>\n                                        <code>r2</code>\n                                        : The R-squared value of the regression.\n                                    </li>\n                                    <li>\n                                        <code>residuals</code>\n                                        : The residuals of the regression.\n                                    </li>\n                                </ul>\n                                <p>\n                                    For example, to perform a regression of y on x1 and x2, with the last point weighted more heavily, you could do:\n                                </p>\n                                <StandaloneEditor\n                                    ident=\"regression\"\n                                    getCode={\n                                        () =>\n                                            'x1 = [1, 2, 3, 4, 5]' + '\\n'\n                                            + 'x2 = [2, 3, 2, 3, 2]' + '\\n'\n                                            + 'y = [2.2, 2.8, 3.6, 4.5, 5.1]' + '\\n'\n                                            + 'w = [1, 1, 1, 1, 10]' + '\\n'\n                                            + 'model = regression(y=y, x1=x1, x2=x2, weight=w)' + '\\n'\n                                            + 'model'\n                                    }\n                                />\n                                <p>\n                                    Note that the inputs are all named arguments and the weight is optional.\n                                </p>\n                            </Header>\n                            <Header title=\"Aggregation\" header=\"h2\" ident=\"aggregation\">\n                                <p>\n                                    USS provides several functions for aggregating data, including mean, median, quantile, percentile,\n                                    min, max, sum, and more.\n                                </p>\n                                <p>\n                                    For example, to calculate the mean of a vector, you can do:\n                                </p>\n                                <StandaloneEditor ident=\"aggregation\" getCode={() => 'mean([1, 2, 3, 4, 50])'} />\n                                <p>\n                                    We can also weight the mean, for example:\n                                </p>\n                                <StandaloneEditor ident=\"aggregation\" getCode={() => 'mean([1, 2, 3, 4, 50], weights=[1, 1, 1, 1, 10])'} />\n                                <p>\n                                    The same works for median, quantile, and percentile.\n                                </p>\n                                <StandaloneEditor ident=\"aggregation\" getCode={() => 'percentile([1, 2, 3, 4, 50], 10, weights=[1, 1, 1, 1, 10])'} />\n                                <p>\n                                    On the other hand, min, max, and sum do not support weights.\n                                </p>\n                                <StandaloneEditor ident=\"aggregation\" getCode={() => 'min([1, 2, 3, 4, 50])'} />\n                            </Header>\n                            <Header title=\"Broadcasting\" header=\"h2\" ident=\"broadcasting\">\n                                <p>\n                                    Broadcasting is a feature of USS that allows you to operate on lists of values.\n                                </p>\n                                <Header title=\"Forward Broadcasting\" header=\"h3\" ident=\"forward-broadcasting\">\n                                    <p>\n                                        The main kind of broadcasting is\n                                        forward broadcasting, where you can apply operations to lists of elements. For example, if you have a list of numbers\n                                        and you want to add 1 to each of them, you can do:\n                                    </p>\n                                    <StandaloneEditor ident=\"broadcasting\" getCode={() => 'x = [1, 2, 3]' + '\\n' + 'y = x + 1' + '\\n' + 'y'} />\n                                    <p>\n                                        This will result in a list of numbers, where each element is 1 greater than the corresponding element in the original list.\n                                    </p>\n                                    <p>\n                                        This also works with function calls, for example:\n                                    </p>\n                                    <StandaloneEditor ident=\"broadcasting-function\" getCode={() => 'x = [1, 2, 3]' + '\\n' + 'y = sin(x)' + '\\n' + 'y'} />\n                                    <p>\n                                        Even when the list is of functions:\n                                    </p>\n                                    <StandaloneEditor ident=\"broadcasting-function-list\" getCode={() => 'x = [sin, cos, tan]' + '\\n' + 'y = x(pi)' + '\\n' + 'y'} />\n                                    <p>\n                                        You can also apply broadcasting to objects, for example:\n                                    </p>\n                                    <StandaloneEditor ident=\"broadcasting-object\" getCode={() => 'x = [{a: 1, b: 2}, {a: 3, b: 4}, {a: 5, b: 6}]' + '\\n' + 'y = x.a' + '\\n' + 'y'} />\n                                    <p>\n                                        And even assigning to a property:\n                                    </p>\n                                    <StandaloneEditor ident=\"broadcasting-object-property\" getCode={() => 'x = [{a: 1, b: 2}, {a: 3, b: 4}, {a: 5, b: 6}]' + '\\n' + 'x.a = [10, 20, 30]' + '\\n' + 'x'} />\n                                </Header>\n                                <Header title=\"Split Broadcasting\" header=\"h3\" ident=\"backward-broadcasting\">\n                                    There is also split broadcasting, which is what happens when you use an if statement.\n                                    For example, in the following code, the if statement is split into two branches, one for when y is greater than 65 and one for when it is not.\n                                    <StandaloneEditor ident=\"broadcasting\" getCode={() => 'x = [1, 2, 3]' + '\\n' + 'y = [50, 61, 70]' + '\\n' + 'if (y > 65) { x = x * 10 } else { x = x + 1 }' + '\\n' + 'x'} />\n                                    <p>\n                                        The if statement is split into two branches, one for when y is greater than 65 and one for when it is not.\n                                    </p>\n                                    <p>\n                                        Keep in mind that this is exactly two cases, rather than one for each element. Using mean() reveals this:\n                                    </p>\n                                    <StandaloneEditor ident=\"broadcasting\" getCode={() => 'x = [1, 2, 3]' + '\\n' + 'y = [50, 61, 70]' + '\\n' + 'if (y > 65) { x = mean(x) } else { x = mean(x) }' + '\\n' + 'x'} />\n                                </Header>\n                            </Header>\n                            <Header title=\"Detailed Tables\" header=\"h2\" ident=\"detailed-tables\">\n                                <Header title=\"All Operators\" header=\"h3\" ident=\"all-operators\">\n                                    <p>\n                                        The following is a list of all operators that are available in USS.\n                                    </p>\n                                    <OperatorTable />\n                                </Header>\n                            </Header>\n                            <Header title=\"Constants and Functions\" header=\"h2\" ident=\"constants\">\n                                <p>\n                                    USS provides several built-in constants and functions for mathematical operations,\n                                    data visualization, and data analysis. These are organized by category below.\n                                </p>\n                                <ConstantsDocumentation />\n                            </Header>\n                        </Header>\n                    </div>\n                    <Footnotes />\n                </FootnotesProvider>\n            </PageTemplate>\n        </MathJaxContext>\n    )\n}\n\nfunction createTable(colors: ReturnType<typeof useColors>, headers: string[], cells: ReactNode[][]): ReactNode {\n    const tableStyles = {\n        table: {\n            width: '100%',\n            borderCollapse: 'collapse' as const,\n            margin: '20px 0',\n            fontSize: '14px',\n            color: colors.textMain,\n        },\n        header: {\n            border: `1px solid ${colors.borderNonShadow}`,\n            padding: '12px',\n            textAlign: 'left' as const,\n            verticalAlign: 'top' as const,\n            backgroundColor: colors.background,\n            fontWeight: 'bold' as const,\n        },\n        cell: {\n            border: `1px solid ${colors.borderNonShadow}`,\n            padding: '12px',\n            textAlign: 'left' as const,\n            verticalAlign: 'top' as const,\n        },\n        code: {\n            backgroundColor: colors.slightlyDifferentBackground,\n            padding: '2px 4px',\n            borderRadius: '3px',\n            fontFamily: '\\'Courier New\\', monospace',\n            fontSize: '13px',\n        },\n        rowColors: {\n            even: colors.slightlyDifferentBackground,\n            odd: colors.background,\n        },\n    }\n\n    return (\n        <table style={tableStyles.table}>\n            <thead>\n                <tr>\n                    {headers.map((header, index) => (\n                        <th key={index} style={tableStyles.header}>\n                            {header}\n                        </th>\n                    ))}\n                </tr>\n            </thead>\n            <tbody>\n                {cells.map((row, rowIndex) => (\n                    <tr\n                        key={rowIndex}\n                        style={{\n                            backgroundColor: rowIndex % 2 === 0 ? tableStyles.rowColors.even : tableStyles.rowColors.odd,\n                        }}\n                    >\n                        {row.map((cell, cellIndex) => (\n                            <td key={cellIndex} style={tableStyles.cell}>\n                                {cell}\n                            </td>\n                        ))}\n                    </tr>\n                ))}\n            </tbody>\n        </table>\n    )\n}\n\nfunction OperatorTable(): ReactNode {\n    const colors = useColors()\n\n    const headers = ['Operator', 'Type', 'Precedence', 'Description', 'Example']\n    const cells = Array.from(expressionOperatorMap.entries()).map(([operator, info]) => [\n        <code key=\"operator\" style={{ backgroundColor: colors.slightlyDifferentBackground, padding: '2px 4px', borderRadius: '3px', fontFamily: '\\'Courier New\\', monospace', fontSize: '13px' }}>\n            {operator}\n        </code>,\n        info.unary && info.binary\n            ? 'Unary/Binary'\n            : info.unary\n                ? 'Unary'\n                : info.binary\n                    ? 'Binary'\n                    : 'Unknown',\n        info.precedence,\n        info.description,\n        info.examples.map((example, exampleIndex) => (\n            <span key={exampleIndex}>\n                <code style={{ backgroundColor: colors.slightlyDifferentBackground, padding: '2px 4px', borderRadius: '3px', fontFamily: '\\'Courier New\\', monospace', fontSize: '13px' }}>\n                    {example}\n                </code>\n                {exampleIndex < info.examples.length - 1 && ', '}\n            </span>\n        )),\n    ])\n\n    return createTable(colors, headers, cells)\n}\n\nfunction ConstantsDocumentation(): ReactNode {\n    const [collapsedCategories, setCollapsedCategories] = useState<Set<string>>(new Set(constantCategories))\n\n    const mapperContext = defaultTypeEnvironment('world')\n\n    // Group constants by category\n    const constantsByCategory = new Map<ConstantCategory, [string, USSDocumentedType][]>()\n\n    // Add default constants\n    for (const [name, value] of defaultConstants) {\n        const category = value.documentation?.category\n        assert(category !== undefined, `Constant ${name} does not have a category defined.`)\n        let cat = constantsByCategory.get(category)\n        if (cat === undefined) {\n            cat = []\n            constantsByCategory.set(category, cat)\n        }\n        cat.push([name, value])\n    }\n\n    // Add mapper context elements\n    for (const [name, value] of mapperContext) {\n        // Skip if already added from default constants\n        if (defaultConstants.has(name)) continue\n\n        const category = value.documentation?.category\n        assert(category !== undefined, `Constant ${name} does not have a category defined.`)\n        if (constantCategories.includes(category)) {\n            let cat = constantsByCategory.get(category)\n            if (cat === undefined) {\n                cat = []\n                constantsByCategory.set(category, cat)\n            }\n            cat.push([name, value])\n        }\n    }\n\n    // Group constants by documentationTable for table display\n    const constantsByTable = new Map<DocumentationTable, [string, USSValue][]>()\n    for (const [name, value] of defaultConstants) {\n        const tableName = value.documentation?.documentationTable\n        if (tableName !== undefined) {\n            let cat = constantsByTable.get(tableName)\n            if (cat === undefined) {\n                cat = []\n                constantsByTable.set(tableName, cat)\n            }\n            cat.push([name, value])\n        }\n    }\n\n    // Sort categories for consistent display\n    const categoryOrder = constantCategories\n    const sortedCategories = Array.from(constantsByCategory.entries()).sort((a, b) => {\n        const aIndex = categoryOrder.indexOf(a[0])\n        const bIndex = categoryOrder.indexOf(b[0])\n        return aIndex - bIndex\n    })\n\n    const toggleCategory = (category: ConstantCategory): void => {\n        setCollapsedCategories((prev) => {\n            const newSet = new Set(prev)\n            if (newSet.has(category)) {\n                newSet.delete(category)\n            }\n            else {\n                newSet.add(category)\n            }\n            return newSet\n        })\n    }\n\n    return (\n        <div>\n            {sortedCategories.map(([category, constants]) => {\n                const isCollapsed = collapsedCategories.has(category)\n                return (\n                    <div key={category}>\n                        <div\n                            style={{\n                                cursor: 'pointer',\n                                display: 'flex',\n                                alignItems: 'center',\n                                gap: '10px',\n                                marginBottom: '10px',\n                            }}\n                            onClick={() => { toggleCategory(category) }}\n                        >\n                            <span style={{\n                                fontSize: '16px',\n                                transition: 'transform 0.2s',\n                                transform: isCollapsed ? 'rotate(0deg)' : 'rotate(90deg)',\n                            }}\n                            >\n                                ▶\n                            </span>\n                            <h3 id={`constants-${category}`} style={{ margin: 0 }}>\n                                {getCategoryTitle(category)}\n                            </h3>\n                        </div>\n                        {!isCollapsed && (<DocumentationForCategory category={category} constants={constants} />)}\n                    </div>\n                )\n            })}\n\n        </div>\n    )\n}\n\nfunction DocumentationForCategory(props: { category: ConstantCategory, constants: [string, USSDocumentedType][] }): ReactNode {\n    const withoutTable: [string, USSDocumentedType][] = []\n    const categoryTables = new Map<DocumentationTable, [string, USSDocumentedType][]>()\n    for (const [name, value] of props.constants) {\n        const tableName = value.documentation?.documentationTable\n        if (tableName !== undefined) {\n            let cat = categoryTables.get(tableName)\n            if (cat === undefined) {\n                cat = []\n                categoryTables.set(tableName, cat)\n            }\n            cat.push([name, value])\n        }\n        else {\n            withoutTable.push([name, value])\n        }\n    }\n\n    return (\n        <>\n            <p style={{ marginLeft: '20px' }}>{getCategoryDescription(props.category)}</p>\n            {withoutTable.map(([name, value]) => (\n                <LongFormDocumentation key={name} name={name} value={value} />\n            ))}\n\n            {/* Add tables for constants with documentationTable */}\n            {(() => {\n                return Array.from(categoryTables.entries()).map(([tableName, tableConstants]) =>\n                    <ShortFormTableDocumentation key={tableName} tableName={tableName} tableConstants={tableConstants} />,\n                )\n            })()}\n        </>\n    )\n}\n\nexport function LongFormDocumentation(props: { name: string, value: USSDocumentedType }): ReactNode {\n    const colors = useColors()\n    return (\n        <Header key={props.name} title={props.name} header=\"h4\" ident={`constant-${props.name}`}>\n            <div style={{ marginBottom: '20px', marginLeft: '20px' }}>\n                <div style={{ marginBottom: '10px' }}>\n                    Type:\n                    <code style={{\n                        backgroundColor: colors.slightlyDifferentBackground,\n                        padding: '4px 8px',\n                        borderRadius: '3px',\n                        fontFamily: '\\'Courier New\\', monospace',\n                        fontSize: '13px',\n                        marginLeft: '10px',\n                    }}\n                    >\n                        {renderType(props.value.type)}\n                    </code>\n                </div>\n                <div style={{ marginBottom: '10px' }}>\n                    {props.value.documentation?.longDescription ?? 'No description available.'}\n                </div>\n                {props.value.documentation?.namedArgs && Object.keys(props.value.documentation.namedArgs).length > 0 && (\n                    <div style={{ marginBottom: '10px' }}>\n                        <strong>Named Arguments:</strong>\n                        <ul style={{ margin: '5px 0 0 20px' }}>\n                            {Object.entries(props.value.documentation.namedArgs).map(([argName, argDesc]) => (\n                                <li key={argName}>\n                                    <code style={{\n                                        backgroundColor: colors.slightlyDifferentBackground,\n                                        padding: '2px 4px',\n                                        borderRadius: '3px',\n                                        fontFamily: '\\'Courier New\\', monospace',\n                                        fontSize: '12px',\n                                    }}\n                                    >\n                                        {argName}\n                                    </code>\n                                    :\n                                    {' '}\n                                    {argDesc}\n                                </li>\n                            ))}\n                        </ul>\n                    </div>\n                )}\n                {props.value.documentation?.isDefault && (\n                    <div\n                        style={{\n                            marginBottom: '10px',\n                            color: colors.textMain,\n                            fontStyle: 'italic',\n                        }}\n                    >\n                        Default value for this type\n                    </div>\n                )}\n            </div>\n        </Header>\n    )\n}\n\nfunction ShortFormTableDocumentation(props: { tableName: DocumentationTable, tableConstants: [string, USSDocumentedType][] }): ReactNode {\n    const colors = useColors()\n    const headers = ['Name', 'Type', 'Description']\n    const cells = props.tableConstants.map(([name, value]) => [\n        <span key=\"name\" style={{ fontFamily: '\\'Courier New\\', monospace' }}>{name}</span>,\n        <code\n            key=\"type\"\n            style={{\n                backgroundColor: colors.slightlyDifferentBackground,\n                padding: '2px 4px',\n                borderRadius: '3px',\n                fontFamily: '\\'Courier New\\', monospace',\n                fontSize: '12px',\n            }}\n        >\n            {renderType(value.type)}\n        </code>,\n        <span key=\"description\">\n            {value.documentation?.longDescription ?? 'No description available.'}\n            {value.documentation?.isDefault && (\n                <span key=\"default-indicator\" style={{ fontStyle: 'italic', color: colors.textMain }}>\n                    {' '}\n                    (default)\n                </span>\n            )}\n        </span>,\n    ])\n\n    return (\n        <div key={props.tableName} style={{ marginTop: '20px', marginLeft: '20px' }}>\n            <h4 style={{ marginBottom: '15px' }}>{getTableTitle(props.tableName)}</h4>\n            <p style={{ marginBottom: '15px' }}>{getTableDescription(props.tableName)}</p>\n            {createTable(colors, headers, cells)}\n        </div>\n    )\n}\n\nfunction getCategoryTitle(category: ConstantCategory): string {\n    switch (category) {\n        case 'logic':\n            return 'Logic and Control'\n        case 'math':\n            return 'Mathematical Functions'\n        case 'color':\n            return 'Color Functions'\n        case 'unit':\n            return 'Unit Types'\n        case 'map':\n            return 'Map and Visualization'\n        case 'scale':\n            return 'Scaling Functions'\n        case 'ramp':\n            return 'Color Ramps'\n        case 'inset':\n            return 'Map Insets'\n        case 'regression':\n            return 'Statistical Analysis'\n        case 'basic':\n            return 'Basic Functions'\n        case 'mapper':\n            return 'Mapper Data Variables'\n    }\n}\n\nfunction getCategoryDescription(category: ConstantCategory): string {\n    switch (category) {\n        case 'logic':\n            return 'Boolean values and control flow constants.'\n        case 'math':\n            return 'Mathematical functions for arithmetic, trigonometry, and statistical operations.'\n        case 'color':\n            return 'Functions for creating and manipulating colors using RGB, HSV, and predefined color palettes.'\n        case 'unit':\n            return 'Unit type constants for specifying measurement units in data visualization.'\n        case 'map':\n            return 'Functions for creating choropleth maps, point maps, and map styling.'\n        case 'scale':\n            return 'Functions for scaling numeric data to visualization ranges.'\n        case 'ramp':\n            return 'Functions for creating and manipulating color ramps for data visualization.'\n        case 'inset':\n            return 'Functions for creating map insets and managing multiple map views.'\n        case 'regression':\n            return 'Statistical analysis functions for linear regression.'\n        case 'basic':\n            return 'Basic utility functions for type conversion and common operations.'\n        case 'mapper':\n            return 'The mapper provides several variables relevant to the current universe and set of geographic features.'\n    }\n}\n\nfunction getTableTitle(tableName: DocumentationTable): string {\n    switch (tableName) {\n        case 'predefined-colors':\n            return 'Predefined Color Constants'\n        case 'unit-types':\n            return 'Unit Type Constants'\n        case 'predefined-ramps':\n            return 'Predefined Color Ramps'\n        case 'predefined-insets':\n            return 'Predefined Map Insets'\n        case 'logarithm-functions':\n            return 'Logarithm Functions'\n        case 'trigonometric-functions':\n            return 'Trigonometric Functions'\n        case 'mapper-data-variables':\n            return 'Mapper Data Variables'\n    }\n}\n\nfunction getTableDescription(tableName: DocumentationTable): string {\n    switch (tableName) {\n        case 'predefined-colors':\n            return 'Built-in color constants for common colors like red, blue, green, etc. Each color can be used directly in USS expressions.'\n        case 'unit-types':\n            return 'Unit type constants for specifying measurement units in data visualization and analysis.'\n        case 'predefined-ramps':\n            return 'Predefined color ramps for mapping numeric values to colors in data visualizations.'\n        case 'predefined-insets':\n            return 'Predefined map inset configurations for common geographic regions and territories.'\n        case 'logarithm-functions':\n            return 'Mathematical functions for computing logarithms with different bases (natural, base-10, base-2).'\n        case 'trigonometric-functions':\n            return 'Mathematical functions for trigonometric calculations (sine, cosine, arccosine, etc.).'\n        case 'mapper-data-variables':\n            return 'Variables used in the mapper.'\n    }\n}\n\nfunction Header(props: { title: string, header: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6', ident: string, children: ReactNode }): ReactNode {\n    return (\n        <>\n            <props.header id={props.ident}>\n                {props.title}\n            </props.header>\n            {props.children}\n        </>\n    )\n}\n"],"names":["Editor","param","uss","setUss","typeEnvironment","results","placeholder","selection","setSelection","eRef","setSelectionRef","useRef","script","useMemo","makeScript","colors","useColors","editorRef","_useState","undefined","popoverState","setPopoverState","_useState1","autocompleteSelectionIdx","setAutocompleteSelectionIdx","spanTokenMapRef","Map","renderScript","useCallback","newScript","fragment","renderCode","r","token","content","t","createPlaceholder","span","editor","_editor","lastRenderScript","lastScript","useEffect","setRange","editScript","newUss","newRange","listener","range","getRange","s","document","nodeContent","tokenValue","options","getAutocompleteOptions","createAutocompleteMenu","apply","optionIdx","option","delta","e","i","range1","hoveredToken","event","_iteratorError","elem","name","value","opts","setTimeout","createDocumentationPopover","borderColor","useResultsColor","colorKey","codeStyle","TestUtils","DisplayResults","createPortal","Autocomplete","LongFormDocumentation","cKey","props","color","border","style","error","_","errors","longMessage","index","AutocompleteOption","hovering","setHovering","optionRef","_optionRef_current","StandaloneEditor","_useStandaloneEditorState","undoRedoUi","useStandaloneEditorState","ident","getCode","onChange","getSelection","undoRedoOptions","setResults","ussVersion","_useState2","updateUss","version","stmts","exec","parse","executeAsync","_useUndoRedo","addState","updateCurrentSelection","newSelection","defaultConstants","locationOfLastExpression","node","locationOf","assert","unify","_key","locations","startLine","min","loc","Math","Number","endLine","max","startCol","endCol","startChar","endChar","getAllParseErrors","collectErrors","n","_errors","toStatement","colorType","rgbToColor","red","green","blue","alpha","tolerateError","Error","g","b","a","hsvToColor","hue","saturation","ColorLib","rgb","createConstantExpression","ctx","posArgs","namedArgs","hsv","renderColor","doRender","ignoreAlpha","hex","x","hexValue","h","drawFunction","functionName","param1","param2","param3","round","format","num","alphaPart","rgbColorExpression","_ref","forceAlpha","hsvColorExpression","c","colorConstant","isDefault","humanReadableName","camelToHuman","capitalizedName","hexToColor","parseNoErrorAsExpression","colorConstants","Object","hueColors","insetType","insetsType","boundsType","constructInsetValue","screenBounds","mapBounds","screenBoundsObj","mapBoundsObj","mainMap","constructInsetsValue","insetsList","item","computeInsetConstantName","deconstruct","inset","insetConsts","insets","regionInsets","insetName","insetNameToConstantName","instantiate","descriptor","_instantiate","forward","inverse","scaleType","linearScale","values","center","isNaN","isFinite","_Math","_Math1","computedMin","computedMax","linearScaleValue","logScaleValue","_effect","_error","_constants","_variables","Context","effect","constants","variables","eff","msg","location","getVariable","assignVariable","variableEntries","evolveVariables","result","includeLocationInfo","renderLocInfo","renderValue","lex","modfiyTokenContent","modifyTokenSpan","brackets","DefaultMap","basicConstants","title","levelColor","level","Array","sum","next","openEquivalent","styleToString","_result","lexSpans","errorSpans","charIdx","indexInTokens","indexInErrors","errorLoc","errorLoc1","_errorSpans_spans1","_errorSpans_spans","tokenSpan","_node_textContent","HTMLElement","window","positionInEditor","offset","sibling","currentRange","_getContainerOffset","anchorNode","anchorOffset","_getContainerOffset1","focusNode","focusOffset","getContainerOffset","position","key","tokens","currentIdentifer","allIdentifiers","Set","_iteratorError1","id","match","isAMatch","matchCount","prevMatch","j","placeholderText","useUndoRedo","initialState","initialSelection","onStateChange","onSelectionChange","undoChunking","undoHistory","onlyElement","undoStack","redoStack","canUndo","setCanUndo","canRedo","setCanRedo","state","currentUndoState","Date","doUndo","prevState","doRedo","futureState","getIsActive","isMac","navigator","isActive","setIsActive","ui","UndoRedoControls","outer","inner","positionInner","_window_visualViewport_height","_window_visualViewport_width","outerBounds","_window_visualViewport","useMobileLayout","buttonStyle","InterpretationError","message","p","evaluate","expr","env","undocValue","varName","res","lookupResult","attrLookupOrSet","func","args","arg","broadcastResult","broadcastCall","evaluateUnaryOperator","operand","operator","errLoc","operatorObj","expressionOperatorMap","broadcastApply","evaluateBinaryOperator","left","right","elements","elementType","unifyType","JSON","renderType","ts","vs","v","condition","splitMask","subEnv","execute","doResult","_iteratorError2","statement","canUnifyTo","evaluateLHS","lhs","err","obj","attr","orSet","type","val","_instanceof","_type_of","aT","val1","orSetLookp","addAdditionalDims","idx","resultsOrErr","rawValue","typ","nonExpressionOperators","operatorCharacters","keywords","isDigit","ch","isAlpha","emptyLocation","parseNumber","input","parseFloat","component","component1","identifierLexer","string","operatorLexer","block","lines","line","lineTokens","lexLine","lineNo","charIdxOffset","char","token1","lexNumber","numberFormat","numberStr","number","_iter","lexer","token2","lexGeneric","start","token3","lexString","resultObj","_tokens","noLocation","extendBlockIdPositionalArg","blockIdent","extendBlockIdKwarg","argName","extendBlockIdVectorElement","extendBlockIdObjectProperty","property","unparse","isSimpleExpression","indentSpaces","_opts_expressionalContext","_opts_indent","exprStr","fnStr","argsStr","fnNeedsParens","unaryExprStr","needsParens","exprWithParens","_expressionOperatorMap_get_precedence","_expressionOperatorMap_get_precedence1","_expressionOperatorMap_get_precedence2","leftStr","rightStr","opPrecedence","leftWithParens","leftOpPrecedence","rightWithParens","rightOpPrecedence","elementsStr","propertiesStr","valueStr","lhsStr","statementsStr","stmt","conditionStr","thenStr","ifStr","elseStr","doStr","condStr","restStr","ParseState","skipEOL","consumeTokenOfType","consumeOperator","oneOfOps","consumeBracket","oneOfBrackets","consumeIdentifier","consumeKeyword","oneOfKeywords","maybeLastNonEOLToken","parseSingleExpression","startLoc","properties","keyToken","endLoc","vectorStartLoc","element","vectorEndLoc","parseArg","exprOrName","parseParenthesizedArgs","parseFunctionalExpression","fn","done","parseExpression","operatorExpSequence","loop","unaryOperators","infixOperators","operator1","parseInfixSequence","precedences","maxPrecedence","resolveOperator","checkLHS","parseStatement","parseIfExpression","ifToken","then","elseBranch","eb","lastToken","parseDoExpression","doToken","statements","parseConditionStatement","conditionToken","parseStatements","canEnd","end","errMsg","mergeStatements","fallbackLocation","gulpRestForConditions","_stmt_rest","entireLoc","parseCustomNodeExpression","argsRes","_argsRes_args","locArg","code","parseResult","returnParseErrorNode","parseTokens","originalCode","lexErrors","identifiersInExpr","expressions","identifiers","allExpressions","helper","newIdentifiers","_ctx_getVariable","dv","newId","parseNoError","blockId","parseNoErrorAsCustomNode","expectedType","getPrimitiveType","depth","indent","opaqueValue","colorValue","outline","outlineColor","interior","ramp","vector","map","key1","type1","constantCategories","unifyFunctionType","ret","k","renderArgumentType","renderReturnType","renderKwargType","mapperCache","loadInset","universe","insetsU","loadInsetExpression","exprs","names","onmessage","request","context","getWarnings","interpretationError","_getWarnings","effects","emptyContext","geographyKind","dte","longnames","annotateType","defaultTypeEnvironment","validGeographies","loadProtobuf","indexLink","indexData","typeInfo","variableInfo","existing","statpath","variableData","longname","statistic_variables_info","statistic_path_list","loadOrderingDataProtobuf","mapperContext","removeFunctions","Function","_v_documentation","console","postMessage","sharedUSSWorker","createUSSWorker","terminationTimer","worker","Worker","URL","messageQueue","resetTerminationTimer","clearTimeout","counter","Promise","resolve","USSDocumentationPanel","textHeaderClass","useHeaderTextClass","MathJaxContext","PageTemplate","FootnotesProvider","Header","OperatorTable","ConstantsDocumentation","Footnotes","createTable","headers","cells","tableStyles","header","row","rowIndex","cell","cellIndex","info","example","exampleIndex","collapsedCategories","setCollapsedCategories","constantsByCategory","_value_documentation","category","cat","_value_documentation1","name1","value1","category1","cat1","constantsByTable","_value_documentation2","name2","value2","tableName","cat2","categoryOrder","sortedCategories","aIndex","toggleCategory","prev","newSet","isCollapsed","getCategoryTitle","DocumentationForCategory","withoutTable","categoryTables","getCategoryDescription","tableConstants","ShortFormTableDocumentation","_props_value_documentation_longDescription","_props_value_documentation1","_props_value_documentation2","argDesc","_value_documentation_longDescription","getTableTitle","getTableDescription"],"mappings":"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"}