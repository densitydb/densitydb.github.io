{"version":3,"file":"934.js","sources":["webpack://assets/./src/urban-stats-script/Editor.tsx","webpack://assets/./src/urban-stats-script/ast.ts","webpack://assets/./src/urban-stats-script/constants/color.ts","webpack://assets/./src/urban-stats-script/constants/insets.ts","webpack://assets/./src/urban-stats-script/constants/scale.ts","webpack://assets/./src/urban-stats-script/editor-utils.ts","webpack://assets/./src/utils/isAMatch.ts","webpack://assets/./src/urban-stats-script/interpreter.ts","webpack://assets/./src/urban-stats-script/lexer.ts","webpack://assets/./src/urban-stats-script/location.ts","webpack://assets/./src/urban-stats-script/parser.ts","webpack://assets/./src/urban-stats-script/types-values.ts","webpack://assets/./src/urban-stats-script/workerManager.ts"],"sourcesContent":["import '@fontsource/inconsolata/500.css'\n\nimport React, { CSSProperties, ReactNode, useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useColors } from '../page_template/colors'\nimport { TestUtils } from '../utils/TestUtils'\n\nimport { renderCode, getRange, nodeContent, Range, setRange, EditorResult, longMessage, Script, makeScript, getAutocompleteOptions, createAutocompleteMenu, AutocompleteState, createPlaceholder } from './editor-utils'\nimport { USSDocumentedType } from './types-values'\n\nexport function Editor(\n    { uss, setUss, typeEnvironment, results, placeholder, selection, setSelection, eRef }: {\n        uss: string\n        setUss: (newScript: string) => void\n        typeEnvironment: Map<string, USSDocumentedType>\n        results: EditorResult[]\n        placeholder?: string\n        selection: Range | null\n        setSelection: (newRange: Range | null) => void\n        eRef?: React.MutableRefObject<HTMLPreElement | null>\n    },\n): ReactNode {\n    const setSelectionRef = useRef(setSelection)\n    setSelectionRef.current = setSelection\n\n    const script = useMemo(() => makeScript(uss), [uss])\n\n    const colors = useColors()\n\n    const editorRef = useRef<HTMLPreElement | null>(null)\n\n    const [autocompleteState, setAutocompleteState] = useState<AutocompleteState>(undefined)\n    const [autocompleteSelectionIdx, setAutocompleteSelectionIdx] = useState(0)\n\n    const renderScript = useCallback((newScript: Script) => {\n        const fragment = renderCode(newScript, colors, results.filter(r => r.kind !== 'success'), (token, content) => {\n            if (autocompleteState?.location.end.charIdx === token.location.end.charIdx && token.token.type === 'identifier') {\n                content.push(autocompleteState.element)\n            }\n            if (placeholder !== undefined && newScript.tokens.every(t => t.token.type === 'operator' && t.token.value === 'EOL') && token.location.end.charIdx === 0) {\n                content.push(createPlaceholder(colors, placeholder))\n            }\n        })\n\n        const editor = editorRef.current!\n        editor.replaceChildren(...fragment)\n        // Usually you want to set the selection after this, since it has been reset\n    }, [colors, results, autocompleteState, placeholder])\n\n    const lastRenderScript = useRef<typeof renderScript>(renderScript)\n    const lastScript = useRef<Script | undefined>(undefined)\n\n    useEffect(() => {\n        const editor = editorRef.current!\n\n        // Rerendering when just a selection change happens causes the selection interaction to be interrupted\n        if (script !== lastScript.current || renderScript !== lastRenderScript.current) {\n            renderScript(script)\n        }\n        setRange(editor, selection)\n\n        lastRenderScript.current = renderScript\n        lastScript.current = script\n    }, [renderScript, script, selection])\n\n    const editScript = useCallback((newUss: string, newRange: Range) => {\n        const newScript = makeScript(newUss)\n        renderScript(newScript)\n        setRange(editorRef.current!, newRange)\n        setUss(newScript.uss)\n        setSelection(newRange)\n        setAutocompleteState(undefined)\n    }, [renderScript, setUss, setSelection])\n\n    useEffect(() => {\n        const listener = (): void => {\n            // These events are often spurious\n\n            const range = getRange(editorRef.current!)\n            setSelectionRef.current(range)\n            // Cancel autocomplete if the selection is no longer at the end\n            setAutocompleteState(s => s?.location.end.charIdx !== range?.start || s?.location.end.charIdx !== range?.end ? undefined : s)\n        }\n        document.addEventListener('selectionchange', listener)\n        return () => {\n            document.removeEventListener('selectionchange', listener)\n        }\n    }, []) // Rebinding can cause problems with multiple editors as they stop listening when one editor changes selection\n\n    useEffect(() => {\n        const editor = editorRef.current!\n        const listener = (): void => {\n            const range = getRange(editor)\n            const newScript = makeScript(nodeContent(editor))\n            const token = range !== null && range.start === range.end\n                ? newScript.tokens.find(t => t.token.type === 'identifier' && t.location.end.charIdx === range.start)\n                : undefined\n            if (token !== undefined) {\n                const tokenValue = token.token.value as string\n                const options = getAutocompleteOptions(typeEnvironment, newScript.tokens, tokenValue)\n                if (options.length === 0) {\n                    setAutocompleteState(undefined)\n                }\n                else {\n                    setAutocompleteState({\n                        location: token.location,\n                        options,\n                        element: createAutocompleteMenu(colors),\n                        apply(optionIdx) {\n                            const option = options[optionIdx]\n                            const delta = option.length - tokenValue.length\n                            const editedUss = newScript.uss.slice(0, token.location.start.charIdx) + option + newScript.uss.slice(token.location.end.charIdx)\n                            const editedRange = { start: token.location.end.charIdx + delta, end: token.location.end.charIdx + delta }\n                            editScript(editedUss, editedRange)\n                        },\n                    })\n                    setAutocompleteSelectionIdx(0)\n                }\n            }\n            else {\n                setAutocompleteState(undefined)\n            }\n            setUss(newScript.uss)\n            setSelection(range)\n        }\n        editor.addEventListener('input', listener)\n        return () => { editor.removeEventListener('input', listener) }\n    }, [typeEnvironment, colors, editScript, setUss, setSelection])\n\n    useEffect(() => {\n        const editor = editorRef.current!\n        const listener = (e: KeyboardEvent): void => {\n            if (autocompleteState !== undefined) {\n                switch (e.key) {\n                    case 'Enter':\n                    case 'Tab':\n                        e.preventDefault()\n                        autocompleteState.apply(autocompleteSelectionIdx)\n                        return\n                    case 'Escape':\n                        e.preventDefault()\n                        setAutocompleteState(undefined)\n                        return\n                    case 'ArrowDown':\n                    case 'ArrowUp':\n                        e.preventDefault()\n                        if (e.key === 'ArrowDown') {\n                            setAutocompleteSelectionIdx(i => i + 1 >= autocompleteState.options.length ? 0 : i + 1)\n                        }\n                        else {\n                            setAutocompleteSelectionIdx(i => i - 1 < 0 ? autocompleteState.options.length - 1 : i - 1)\n                        }\n                        return\n                }\n            }\n\n            if (e.key === 'Tab') {\n                e.preventDefault()\n                const range = getRange(editor)\n                if (range !== null) {\n                    editScript(\n                        `${script.uss.slice(0, range.start)}    ${script.uss.slice(range.end)}`,\n                        { start: range.start + 4, end: range.start + 4 },\n                    )\n                }\n            }\n            else if (e.key === 'Backspace') {\n                const range = getRange(editor)\n                if (range !== null && range.start === range.end && range.start >= 4 && script.uss.slice(range.start - 4, range.start) === '    ') {\n                    e.preventDefault()\n                    editScript(\n                        `${script.uss.slice(0, range.start - 4)}${script.uss.slice(range.start)}`,\n                        { start: range.start - 4, end: range.start - 4 },\n                    )\n                }\n            }\n        }\n        editor.addEventListener('keydown', listener)\n        return () => { editor.removeEventListener('keydown', listener) }\n    }, [script, renderScript, autocompleteState, autocompleteSelectionIdx, editScript])\n\n    useEffect(() => {\n        const editor = editorRef.current!\n        const listener = (): void => {\n            setAutocompleteState(undefined)\n        }\n        editor.addEventListener('blur', listener)\n        return () => { editor.removeEventListener('blur', listener) }\n    }, [])\n\n    const borderColor = useResultsColor(colorKey(results))\n\n    return (\n        <div style={{ marginTop: '0.25em' }}>\n            <pre\n                id=\"test-editor-body\"\n                style={{\n                    ...codeStyle,\n                    caretColor: TestUtils.shared.isTesting ? 'transparent' : colors.textMain,\n                    border: `1px solid ${borderColor}`,\n                    borderRadius: TestUtils.shared.isTesting ? 0 : (results.length > 0 ? '5px 5px 0 0' : '5px'),\n                }}\n                ref={(e) => {\n                    editorRef.current = e\n                    if (eRef !== undefined) {\n                        eRef.current = e\n                    }\n                }}\n                contentEditable=\"plaintext-only\"\n                spellCheck=\"false\"\n            />\n            <DisplayResults results={results} editor={true} />\n            {autocompleteState === undefined\n                ? null\n                : createPortal(\n                    <Autocomplete\n                        state={autocompleteState}\n                        selectionIdx={autocompleteSelectionIdx}\n                        setSelectionIdx={setAutocompleteSelectionIdx}\n                        apply={(i) => { autocompleteState.apply(i) }}\n                    />,\n                    autocompleteState.element,\n                )}\n        </div>\n    )\n}\n\nexport const codeStyle: CSSProperties = {\n    whiteSpace: 'pre-wrap',\n    fontFamily: 'Inconsolata, monospace',\n    fontWeight: 500,\n    lineHeight: '175%',\n    margin: 0,\n    padding: '1em',\n}\n\nfunction colorKey(results: EditorResult[]): 'r' | 'o' | 'g' | 's' {\n    switch (true) {\n        case results.some(r => r.kind === 'error'):\n            return 'r'\n        case results.some(r => r.kind === 'warning'):\n            return 'o'\n        case results.some(r => r.kind === 'success'):\n            return 'g'\n        default:\n            return 's'\n    }\n}\n\nfunction useResultsColor(cKey: 'r' | 'o' | 'g' | 's'): string {\n    const colors = useColors()\n    switch (cKey) {\n        case 'r':\n            return colors.hueColors.red\n        case 'o':\n            return colors.hueColors.orange\n        case 'g':\n            return colors.hueColors.green\n        case 's':\n            return colors.borderShadow\n    }\n}\n\nexport function DisplayResults(props: { results: EditorResult[], editor: boolean }): ReactNode | undefined {\n    const colors = useColors()\n    const cKey = colorKey(props.results)\n    const color = useResultsColor(cKey)\n    if (props.results.length === 0) {\n        return undefined\n    }\n    const border = `2px solid ${color}`\n    const style = {\n        ...codeStyle,\n        borderRadius: TestUtils.shared.isTesting ? 0 : (props.editor ? '0 0 5px 5px' : '5px'),\n        backgroundColor: colors.slightlyDifferentBackground,\n        color: colors.textMain,\n        borderTop: props.editor ? 'none' : border,\n        borderRight: border,\n        borderBottom: border,\n        borderLeft: border,\n        marginTop: props.editor ? '0' : '0.25em',\n    }\n    return (\n        <div id=\"test-editor-result\" className={`color-${cKey}`}>\n            <pre style={style}>\n                {props.results.map((error, _, errors) => `${errors.length > 1 ? '- ' : ''}${longMessage(error, props.editor)}`).join('\\n')}\n            </pre>\n        </div>\n    )\n}\n\nfunction Autocomplete(props: { state: Exclude<AutocompleteState, undefined>, selectionIdx: number, setSelectionIdx: (idx: number) => void, apply: (idx: number) => void }): ReactNode {\n    return props.state.options.map((option, index) => (\n        <AutocompleteOption\n            key={option}\n            option={option}\n            index={index}\n            selected={index === props.selectionIdx}\n            apply={() => { props.apply(index) }}\n        />\n    ))\n}\n\nfunction AutocompleteOption(props: { option: string, index: number, selected: boolean, apply: () => void }): ReactNode {\n    const colors = useColors()\n    const [hovering, setHovering] = useState(false)\n    const style: CSSProperties = {\n        cursor: 'pointer',\n        backgroundColor: (props.selected || hovering\n            ? colors.slightlyDifferentBackgroundFocused\n            : props.index % 2 === 0 ? colors.background : colors.slightlyDifferentBackground),\n        padding: '0 0.5em',\n    }\n\n    const optionRef = useRef<HTMLDivElement>(null)\n\n    useEffect(() => {\n        optionRef.current?.scrollIntoView({ block: 'nearest' })\n    }, [props.selected])\n\n    return (\n        <div\n            ref={optionRef}\n            style={style}\n            onMouseEnter={() => { setHovering(true) }}\n            onMouseLeave={() => { setHovering(false) }}\n            onClick={props.apply}\n        >\n            {props.option}\n        </div>\n    )\n}\n","import assert from 'assert'\n\nimport { LocInfo } from './location'\nimport { Decorated, ParseError } from './parser'\nimport { USSType } from './types-values'\n\nexport type UrbanStatsASTArg = (\n    { type: 'unnamed', value: UrbanStatsASTExpression } |\n    { type: 'named', name: Decorated<string>, value: UrbanStatsASTExpression })\n\nexport type UrbanStatsASTLHS = (\n    { type: 'identifier', name: Decorated<string> } |\n    { type: 'attribute', expr: UrbanStatsASTExpression, name: Decorated<string> })\n\nexport type UrbanStatsASTExpression = (\n    UrbanStatsASTLHS |\n    { type: 'constant', value: Decorated<{ type: 'number', value: number } | { type: 'string', value: string }> } |\n    { type: 'call', fn: UrbanStatsASTExpression, args: UrbanStatsASTArg[], entireLoc: LocInfo } |\n    { type: 'binaryOperator', operator: Decorated<string>, left: UrbanStatsASTExpression, right: UrbanStatsASTExpression } |\n    { type: 'unaryOperator', operator: Decorated<string>, expr: UrbanStatsASTExpression } |\n    { type: 'objectLiteral', entireLoc: LocInfo, properties: [string, UrbanStatsASTExpression][] } |\n    { type: 'vectorLiteral', entireLoc: LocInfo, elements: UrbanStatsASTExpression[] } |\n    { type: 'if', entireLoc: LocInfo, condition: UrbanStatsASTExpression, then: UrbanStatsASTStatement, else?: UrbanStatsASTStatement } |\n    { type: 'do', entireLoc: LocInfo, statements: UrbanStatsASTStatement[] } |\n    // for internal purposes only\n    { type: 'customNode', entireLoc: LocInfo, expr: UrbanStatsASTStatement, originalCode: string, expectedType?: USSType[] }\n)\n\nexport type UrbanStatsASTStatement = (\n    { type: 'assignment', lhs: UrbanStatsASTLHS, value: UrbanStatsASTExpression } |\n    { type: 'expression', value: UrbanStatsASTExpression } |\n    { type: 'statements', entireLoc: LocInfo, result: UrbanStatsASTStatement[] } |\n    { type: 'condition', entireLoc: LocInfo, condition: UrbanStatsASTExpression, rest: UrbanStatsASTStatement[] } |\n    { type: 'parseError', originalCode: string, errors: ParseError[] })\n\nexport type UrbanStatsAST = UrbanStatsASTArg | UrbanStatsASTExpression | UrbanStatsASTStatement\n\nexport function unify(...locations: LocInfo[]): LocInfo {\n    assert(locations.length > 0, 'At least one location must be provided for unification')\n    const startLine = locations.reduce((min, loc) => Math.min(min, loc.start.lineIdx), Number.MAX_VALUE)\n    const endLine = locations.reduce((max, loc) => Math.max(max, loc.end.lineIdx), -Number.MAX_VALUE)\n    const startCol = locations.reduce((min, loc) => Math.min(min, loc.start.colIdx), Number.MAX_VALUE)\n    const endCol = locations.reduce((max, loc) => Math.max(max, loc.end.colIdx), -Number.MAX_VALUE)\n    const startChar = locations.reduce((min, loc) => Math.min(min, loc.start.charIdx), Number.MAX_VALUE)\n    const endChar = locations.reduce((max, loc) => Math.max(max, loc.end.charIdx), -Number.MAX_VALUE)\n    return {\n        start: { block: locations[0].start.block, lineIdx: startLine, colIdx: startCol, charIdx: startChar },\n        end: { block: locations[0].end.block, lineIdx: endLine, colIdx: endCol, charIdx: endChar },\n    }\n}\n\nexport function locationOf(node: UrbanStatsAST): LocInfo {\n    /* c8 ignore start -- This function doesn't need to be tested in detail, as it is a simple location extractor */\n    switch (node.type) {\n        case 'unnamed':\n            return locationOf(node.value)\n        case 'named':\n            return unify(node.name.location, locationOf(node.value))\n        case 'constant':\n            return node.value.location\n        case 'identifier':\n            return node.name.location\n        case 'attribute':\n            return unify(node.name.location, locationOf(node.expr))\n        case 'call':\n            return node.entireLoc\n        case 'unaryOperator':\n            return unify(node.operator.location, locationOf(node.expr))\n        case 'binaryOperator':\n            return unify(locationOf(node.left), locationOf(node.right), node.operator.location)\n        case 'objectLiteral':\n        case 'vectorLiteral':\n        case 'if':\n        case 'do':\n        case 'condition':\n        case 'statements':\n            return node.entireLoc\n        case 'assignment':\n            return unify(locationOf(node.lhs), locationOf(node.value))\n        case 'expression':\n            return locationOf(node.value)\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        case 'customNode':\n            return node.entireLoc\n    }\n    /* c8 ignore stop */\n}\n\nexport function locationOfLastExpression(node: UrbanStatsAST): LocInfo {\n    switch (node.type) {\n        case 'assignment':\n            return locationOf(node.value)\n        case 'statements':\n            return locationOfLastExpression(node.result[node.result.length - 1])\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        default:\n            return locationOf(node)\n    }\n}\n\nexport function getAllParseErrors(node: UrbanStatsAST): ParseError[] {\n    const errors: ParseError[] = []\n\n    function collectErrors(n: UrbanStatsAST): void {\n        switch (n.type) {\n            case 'unnamed':\n                collectErrors(n.value)\n                break\n            case 'named':\n                collectErrors(n.value)\n                break\n            case 'constant':\n            case 'identifier':\n                // No parse errors in these\n                break\n            case 'attribute':\n                collectErrors(n.expr)\n                break\n            case 'call':\n                collectErrors(n.fn)\n                n.args.forEach(collectErrors)\n                break\n            case 'unaryOperator':\n                collectErrors(n.expr)\n                break\n            case 'binaryOperator':\n                collectErrors(n.left)\n                collectErrors(n.right)\n                break\n            case 'objectLiteral':\n                n.properties.forEach(([, value]) => {\n                    collectErrors(value)\n                })\n                break\n            case 'vectorLiteral':\n                n.elements.forEach(collectErrors)\n                break\n            case 'if':\n                collectErrors(n.condition)\n                collectErrors(n.then)\n                if (n.else) {\n                    collectErrors(n.else)\n                }\n                break\n            case 'do':\n                n.statements.forEach(collectErrors)\n                break\n            case 'assignment':\n                collectErrors(n.lhs)\n                collectErrors(n.value)\n                break\n            case 'expression':\n                collectErrors(n.value)\n                break\n            case 'statements':\n                n.result.forEach(collectErrors)\n                break\n            case 'condition':\n                collectErrors(n.condition)\n                n.rest.forEach(collectErrors)\n                break\n            case 'parseError':\n                errors.push(...n.errors)\n                break\n            case 'customNode':\n                collectErrors(n.expr)\n                break\n        }\n    }\n\n    collectErrors(node)\n    return errors\n}\n\nexport function toStatement(node: UrbanStatsASTExpression | UrbanStatsASTStatement): UrbanStatsASTStatement {\n    switch (node.type) {\n        case 'statements':\n        case 'assignment':\n        case 'expression':\n        case 'condition':\n        case 'parseError':\n            return node\n        default:\n            return { type: 'expression', value: node }\n    }\n}\n","import ColorLib from 'color'\n\nimport hueColors from '../../data/hueColors'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue, createConstantExpression } from '../types-values'\n\nimport { Color, hexToColor } from './color-utils'\nimport { camelToHuman } from './utils'\n\nexport const colorType = { type: 'opaque', name: 'color' } satisfies USSType\n\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError: true): Color | undefined\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number): Color\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (red < 0 || red > 1 || green < 0 || green > 1 || blue < 0 || blue > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`RGB values must be between 0 and 1, got (${red}, ${green}, ${blue}, ${alpha})`)\n    }\n    const r = Math.round(red * 255)\n    const g = Math.round(green * 255)\n    const b = Math.round(blue * 255)\n    const a = Math.round(alpha * 255)\n    return { r, g, b, a }\n}\n\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError: true): Color | undefined\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number): Color\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (hue < 0 || hue > 360 || saturation < 0 || saturation > 1 || value < 0 || value > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`HSV values must be (hue: 0-360, saturation: 0-1, value: 0-1, alpha: 0-1), got (${hue}, ${saturation}, ${value}, ${alpha})`)\n    }\n    const color = ColorLib.hsv(hue, saturation * 100, value * 100)\n    return {\n        r: Math.round(color.red()),\n        g: Math.round(color.green()),\n        b: Math.round(color.blue()),\n        a: Math.round(alpha * 255),\n    }\n}\n\nexport const rgb = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // red\n            { type: 'concrete', value: { type: 'number' } }, // green\n            { type: 'concrete', value: { type: 'number' } }, // blue\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: rgbToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (RGB)',\n        category: 'color',\n        namedArgs: { a: 'Alpha' },\n        longDescription: 'Creates a color using RGB (Red, Green, Blue) values. Each component ranges from 0 to 1, where 0 is no color and 1 is full intensity.',\n    },\n} satisfies USSValue\n\nexport const hsv = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // hue\n            { type: 'concrete', value: { type: 'number' } }, // saturation\n            { type: 'concrete', value: { type: 'number' } }, // value\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: hsvToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (HSV)',\n        category: 'color',\n        longDescription: 'Creates a color using HSV (Hue, Saturation, Value) values. Hue ranges from 0 to 360 degrees, saturation and value range from 0 to 1.',\n    },\n} satisfies USSValue\n\nexport const renderColor = {\n    type: {\n        type: 'function',\n        posArgs: [{ type: 'concrete', value: colorType }],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: { type: 'string' } },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): string => {\n        const color = (posArgs[0] as { type: 'opaque', value: { r: number, g: number, b: number, a: number } }).value\n        return doRender(color)\n    },\n    documentation: {\n        humanReadableName: 'Color to String',\n        category: 'color',\n        longDescription: 'Converts a color object to its hexadecimal string representation (e.g., \"#ff0000\" for red). If the alpha channel is not 255, it will be included in the string, e.g., \"#ff000088\" for red with 50% opacity.',\n    },\n} satisfies USSValue\n\nexport function doRender(color: Color, ignoreAlpha?: boolean): string {\n    const hex = (x: number): string => {\n        const hexValue = x.toString(16)\n        return hexValue.length === 1 ? `0${hexValue}` : hexValue\n    }\n    let h = `#${hex(color.r)}${hex(color.g)}${hex(color.b)}`\n    if (color.a !== 255 && !ignoreAlpha) {\n        h += hex(color.a)\n    }\n    return h\n}\n\nfunction drawFunction(functionName: string, param1: number, param2: number, param3: number, alpha: number, round?: number): string {\n    const format: (num: number) => string = round !== undefined ? num => num.toFixed(round) : num => num.toString()\n    const alphaPart = alpha !== 255 ? `, a=${format(alpha / 255)}` : ''\n    return `${functionName}(${format(param1)}, ${format(param2)}, ${format(param3)}${alphaPart})`\n}\n\nexport function rgbColorExpression(color: Color, { forceAlpha, round }: { forceAlpha?: number, round?: number } = {}): string {\n    return drawFunction('rgb', color.r / 255, color.g / 255, color.b / 255, forceAlpha ?? color.a, round)\n}\n\nexport function hsvColorExpression(color: Color, { forceAlpha, round }: { forceAlpha?: number, round?: number } = {}): string {\n    const c = ColorLib.rgb(color.r, color.g, color.b)\n    return drawFunction('hsv', c.hue(), c.saturationv() / 100, c.value() / 100, forceAlpha ?? color.a, round)\n}\n\nfunction colorConstant(name: string, value: string, isDefault?: boolean): [string, USSValue] {\n    const humanReadableName = camelToHuman(name)\n    const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1)\n    const color = hexToColor(value)\n    return [`color${capitalizedName}`, {\n        type: colorType,\n        value: { type: 'opaque', opaqueType: 'color', value: color },\n        documentation: {\n            humanReadableName,\n            category: 'color',\n            equivalentExpressions: [parseNoErrorAsExpression(rgbColorExpression(color, { round: 3 }), ''), parseNoErrorAsExpression(hsvColorExpression(color, { round: 3 }), '')],\n            isDefault,\n            longDescription: `Predefined color constant representing ${humanReadableName.toLowerCase()}.`,\n            documentationTable: 'predefined-colors',\n        },\n    }] satisfies [string, USSValue]\n}\n\nexport const colorConstants = [\n    ...Object.entries(hueColors).map(([name, value]) => colorConstant(name, value)),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('white', '#ffffff'),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('black', '#000000', true),\n]\n","import { Inset } from '../../components/map'\nimport insets from '../../data/insets'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue } from '../types-values'\n\nexport const insetType = {\n    type: 'opaque',\n    name: 'inset',\n} satisfies USSType\n\nexport const insetsType = {\n    type: 'opaque',\n    name: 'insets',\n} satisfies USSType\n\nexport const boundsType = {\n    type: 'object',\n    properties: new Map([\n        ['west', { type: 'number' }],\n        ['east', { type: 'number' }],\n        ['north', { type: 'number' }],\n        ['south', { type: 'number' }],\n    ]),\n} satisfies USSType\n\nexport function constructInset(\n    screenBounds: { west: number, east: number, north: number, south: number },\n    mapBounds: { west: number, east: number, north: number, south: number },\n    mainMap: boolean,\n    name?: string,\n): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'inset',\n        value: {\n            bottomLeft: [screenBounds.west, screenBounds.south],\n            topRight: [screenBounds.east, screenBounds.north],\n            coordBox: [mapBounds.west, mapBounds.south, mapBounds.east, mapBounds.north],\n            mainMap,\n            name,\n        } satisfies Inset & { name?: string },\n    }\n}\n\nexport function constructInsets(insetList: Inset[]): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'insets',\n        value: insetList,\n    }\n}\n\nexport const constructInsetValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            screenBounds: { type: { type: 'concrete', value: boundsType } },\n            mapBounds: { type: { type: 'concrete', value: boundsType } },\n            mainMap: { type: { type: 'concrete', value: { type: 'boolean' } } },\n            name: { type: { type: 'concrete', value: { type: 'string' } } },\n        },\n        returnType: { type: 'concrete', value: insetType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const screenBoundsObj = namedArgs.screenBounds as Map<string, USSRawValue>\n        const mapBoundsObj = namedArgs.mapBounds as Map<string, USSRawValue>\n        const mainMap = namedArgs.mainMap as boolean\n        const name = namedArgs.name as string\n        return constructInset(\n            {\n                west: screenBoundsObj.get('west') as number,\n                east: screenBoundsObj.get('east') as number,\n                north: screenBoundsObj.get('north') as number,\n                south: screenBoundsObj.get('south') as number,\n            },\n            {\n                west: mapBoundsObj.get('west') as number,\n                east: mapBoundsObj.get('east') as number,\n                north: mapBoundsObj.get('north') as number,\n                south: mapBoundsObj.get('south') as number,\n            },\n            mainMap,\n            name,\n        )\n    },\n    documentation: {\n        humanReadableName: 'Custom Inset',\n        category: 'inset',\n        longDescription: 'Creates a custom map inset with specified screen bounds (bounding box of the inset on the screen, where bottom left corner has (0, 0) and top right corner has (1, 1)), map bounds (bounding box of the inset on the map, in longitude and latitude), and whether it is the main map (the interactive map).',\n    },\n} satisfies USSValue\n\nexport const constructInsetsValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [\n            {\n                type: 'concrete',\n                value: {\n                    type: 'vector',\n                    elementType: insetType,\n                },\n            },\n        ],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: insetsType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const insetsList = posArgs[0] as { type: 'opaque', opaqueType: 'inset', value: Inset }[]\n        return constructInsets(insetsList.map(item => item.value))\n    },\n    documentation: {\n        humanReadableName: 'Custom Insets',\n        category: 'inset',\n        isDefault: true,\n        longDescription: 'Creates a collection of map insets.',\n    },\n} satisfies USSValue\n\nfunction computeInsetConstantName(name: string): string {\n    name = name.replace(/[\\s,().-]/g, '')\n    name = name.replaceAll('+', 'Plus')\n    name = `inset${name}`\n    return name\n}\n\nexport const insetConsts: [string, USSValue][] = Object.entries(insets).flatMap(([, regionInsets]) =>\n    regionInsets.map((inset) => {\n        const insetName = inset.name\n        const constantName = computeInsetConstantName(insetName)\n\n        const uss = `constructInset(screenBounds={ north: ${inset.topRight[1]}, east: ${inset.topRight[0]}, south: ${inset.bottomLeft[1]}, west: ${inset.bottomLeft[0]} }, mapBounds={ north: ${inset.coordBox[3]}, east: ${inset.coordBox[2]}, south: ${inset.coordBox[1]}, west: ${inset.coordBox[0]} }, mainMap=${inset.mainMap}, name=\"${inset.name}\")`\n        const expr = parseNoErrorAsExpression(uss, '')\n\n        return [\n            constantName,\n            {\n                type: insetType,\n                value: {\n                    type: 'opaque',\n                    opaqueType: 'inset',\n                    value: {\n                        bottomLeft: [...inset.bottomLeft] as [number, number],\n                        topRight: [...inset.topRight] as [number, number],\n                        // copy to get rid of readonly\n                        coordBox: [...inset.coordBox] as [number, number, number, number],\n                        mainMap: inset.mainMap,\n                        name: inset.name,\n                    } satisfies Inset,\n                },\n                documentation: {\n                    humanReadableName: insetName,\n                    category: 'inset',\n                    equivalentExpressions: [expr],\n                    longDescription: `Predefined map inset for the region \"${insetName}\".`,\n                    documentationTable: 'predefined-insets',\n                },\n            } satisfies USSValue,\n        ] as [string, USSValue]\n    }),\n)\n\nexport const insetNameToConstantName = new Map<string, string>(\n    Object.entries(insets).flatMap(([, regionInsets]) =>\n        regionInsets.map((inset) => {\n            const insetName = inset.name\n            return [insetName, computeInsetConstantName(insetName)]\n        }),\n    ),\n)\n","import { USSType, USSValue, createConstantExpression } from '../types-values'\n\n// Functions can't be send over the worker boundary, so instead we must send descriptors\nexport interface LinearScaleDescriptor { kind: 'linear', min: number, max: number }\n\nexport type ScaleDescriptor =\n    LinearScaleDescriptor |\n    { kind: 'log', linearScale: LinearScaleDescriptor }\nexport type Scale = (values: number[], min?: number, max?: number, center?: number) => ScaleDescriptor\n\nexport interface ScaleInstance {\n    forward: (value: number) => number\n    inverse: (value: number) => number\n}\n\nexport const scaleType = {\n    type: 'opaque',\n    name: 'scale',\n} satisfies USSType\n\nexport function instantiate(descriptor: ScaleDescriptor): ScaleInstance {\n    switch (descriptor.kind) {\n        case 'linear':\n            const { min, max } = descriptor\n            if (min === max) {\n                // just arbitrarily map min <=> 0.5\n                return {\n                    forward: x => 0.5 + x - min,\n                    inverse: x => x - 0.5 + min,\n                }\n            }\n            const range = max - min\n\n            return {\n                forward: (value: number) => (value - min) / range,\n                inverse: (value: number) => value * range + min,\n            }\n        case 'log':\n            const { forward, inverse } = instantiate(descriptor.linearScale)\n            return {\n                forward: (value: number) => forward(Math.log(value)),\n                inverse: (value: number) => Math.exp(inverse(value)),\n            }\n    }\n}\n\nconst linearScale: Scale = (values: number[], min?: number, max?: number, center?: number) => {\n    values = values.filter(value => typeof value === 'number' && !isNaN(value) && isFinite(value))\n\n    let computedMin = min ?? Math.min(...values)\n    let computedMax = max ?? Math.max(...values)\n\n    if (center !== undefined) {\n        if (min !== undefined && max !== undefined) {\n            if (Math.abs(center - (min + max) / 2) > 1e-10) {\n                throw new Error(`Inconsistent parameters: center ${center} does not equal (min + max) / 2 = ${min + max} / 2`)\n            }\n        }\n        else if (min !== undefined) {\n            computedMax = 2 * center - min\n        }\n        else if (max !== undefined) {\n            computedMin = 2 * center - max\n        }\n        else {\n            const range = Math.max(computedMax - center, center - computedMin)\n            computedMin = center - range\n            computedMax = center + range\n        }\n    }\n    return {\n        kind: 'linear',\n        min: computedMin,\n        max: computedMax,\n    }\n}\n\nconst logScale: Scale = (values: number[], min?: number, max?: number, center?: number) => {\n    const logVals = values.map(Math.log)\n    const logMin = min !== undefined ? Math.log(min) : undefined\n    const logMax = max !== undefined ? Math.log(max) : undefined\n    const logCenter = center !== undefined ? Math.log(center) : undefined\n    const linearScaleDescriptor = linearScale(logVals, logMin, logMax, logCenter) as LinearScaleDescriptor\n    return {\n        kind: 'log',\n        linearScale: linearScaleDescriptor,\n    }\n}\n\nexport const linearScaleValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            min: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            center: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            max: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n        },\n        returnType: { type: 'concrete', value: scaleType },\n    },\n    value: (ctx, posArgs, namedArgs) => {\n        const min = namedArgs.min as number | null | undefined\n        const max = namedArgs.max as number | null | undefined\n        const center = namedArgs.center as number | null | undefined\n        // Return a scale function that closes over these params\n        return {\n            type: 'opaque',\n            opaqueType: 'scale',\n            value: (values: number[]) => linearScale(values, min ?? undefined, max ?? undefined, center ?? undefined),\n        }\n    },\n    documentation: {\n        humanReadableName: 'Linear Scale',\n        category: 'scale',\n        isDefault: true,\n        longDescription: 'Creates a linear scale that maps numeric values to a range. If min/max are not specified, they are computed from the data. Center parameter can be used to create symmetric ranges.',\n    },\n} satisfies USSValue\n\nexport const logScaleValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            min: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            center: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n            max: {\n                type: { type: 'concrete', value: { type: 'number' } },\n                defaultValue: createConstantExpression(null),\n            },\n        },\n        returnType: { type: 'concrete', value: scaleType },\n    },\n    value: (ctx, posArgs, namedArgs) => {\n        const min = namedArgs.min as number | null | undefined\n        const max = namedArgs.max as number | null | undefined\n        const center = namedArgs.center as number | null | undefined\n        // Return a scale function that closes over these params\n        return {\n            type: 'opaque',\n            opaqueType: 'scale',\n            value: (values: number[]) => logScale(values, min ?? undefined, max ?? undefined, center ?? undefined),\n        }\n    },\n    documentation: {\n        humanReadableName: 'Logarithmic Scale',\n        category: 'scale',\n        longDescription: 'Creates a logarithmic scale that maps numeric values to a range using log transformation. Useful for data with wide ranges or exponential distributions. If min/max are not specified, they are computed from the data. Center parameter can be used to create symmetric ranges.',\n    },\n} satisfies USSValue\n","import { useCallback, useEffect, useRef } from 'react'\n\nimport { Colors } from '../page_template/color-themes'\nimport { DefaultMap } from '../utils/DefaultMap'\nimport { TestUtils } from '../utils/TestUtils'\nimport { isAMatch } from '../utils/isAMatch'\n\nimport { renderLocInfo } from './interpreter'\nimport { AnnotatedToken, lex } from './lexer'\nimport { LocInfo } from './location'\nimport { ParseError } from './parser'\nimport { renderValue, USSDocumentedType, USSValue } from './types-values'\n\nexport type EditorError = ParseError & { kind: 'error' | 'warning' }\nexport type EditorResult = EditorError | { kind: 'success', result: USSValue }\n\nexport function longMessage(result: EditorResult, includeLocationInfo: boolean): string {\n    switch (result.kind) {\n        case 'error':\n        case 'warning':\n            return includeLocationInfo ? `${result.value} at ${renderLocInfo(result.location)}` : result.value\n        case 'success':\n            return renderValue(result.result)\n    }\n}\n\nexport interface Script { uss: string, tokens: AnnotatedToken[] }\n\nexport function makeScript(uss: string): Script {\n    if (!uss.endsWith('\\n')) {\n        uss = `${uss}\\n`\n    }\n    return { uss, tokens: lex({ type: 'single', ident: 'editor' }, uss) }\n}\n\nexport type AutocompleteState = {\n    location: LocInfo\n    options: string[]\n    element: HTMLElement\n    apply: (optionIdx: number) => void\n} | undefined\n\n// `errors` may not overlap\nexport function renderCode(script: Script, colors: Colors, errors: EditorError[], modfiyTokenContent: (token: AnnotatedToken, content: Node[]) => void): Node[] {\n    const span = spanFactory(colors)\n\n    const lexSpans: Node[] = []\n    let errorSpans: { error: EditorError, spans: Node[] } | undefined = undefined\n    let charIdx = 0\n    let indexInTokens = 0\n    let indexInErrors = 0\n    while (indexInTokens < script.tokens.length && charIdx < script.uss.length) {\n        if (indexInErrors < errors.length) {\n            const errorLoc = errors[indexInErrors].location\n            if (charIdx >= errorLoc.start.charIdx) {\n                errorSpans = { spans: [], error: errors[indexInErrors] }\n                indexInErrors++\n            }\n        }\n        if (errorSpans !== undefined) {\n            const errorLoc = errorSpans.error.location\n            if (charIdx >= errorLoc.end.charIdx) {\n                lexSpans.push(span(errorSpans.error, errorSpans.spans))\n                errorSpans = undefined\n            }\n        }\n\n        const token = script.tokens[indexInTokens]\n        if (charIdx === token.location.start.charIdx) {\n            const content: Node[] = [document.createTextNode(script.uss.slice(token.location.start.charIdx, token.location.end.charIdx))]\n            modfiyTokenContent(token, content);\n            (errorSpans?.spans ?? lexSpans).push(span(token.token, content))\n            charIdx = token.location.end.charIdx\n            indexInTokens++\n        }\n        else if (charIdx < token.location.start.charIdx) {\n            (errorSpans?.spans ?? lexSpans).push(document.createTextNode(script.uss.slice(charIdx, token.location.start.charIdx)))\n            charIdx = token.location.start.charIdx\n        }\n        else {\n            throw new Error('invalid state')\n        }\n    }\n\n    if (errorSpans !== undefined) {\n        lexSpans.push(span(errorSpans.error, errorSpans.spans))\n        errorSpans = undefined\n    }\n\n    return lexSpans\n}\n\nexport function nodeContent(node: Node): string {\n    if (node instanceof HTMLElement) {\n        if (!node.isContentEditable) {\n            return ''\n        }\n        return Array.from(node.childNodes).map(nodeContent).join('')\n    }\n    else {\n        return node.textContent ?? ''\n    }\n}\n\nexport interface Range { start: number, end: number }\n\nexport function getRange(editor: HTMLElement): Range | null {\n    const selection = window.getSelection()\n    if (selection?.rangeCount === 1) {\n        const range = selection.getRangeAt(0)\n        if (editor.contains(range.startContainer) && editor.contains(range.endContainer)) {\n            if (editor === range.startContainer || editor === range.endContainer) {\n                return { start: 0, end: 0 }\n            }\n            return { start: positionInEditor(editor, range.startContainer, range.startOffset), end: positionInEditor(editor, range.endContainer, range.endOffset) }\n        }\n    }\n\n    return null\n}\n\n// Traverse up the tree, counting text content of previous siblings along the way\nfunction positionInEditor(editor: Node, node: Node, offset: number): number {\n    while (node !== editor) {\n        let sibling = node.previousSibling\n        while (sibling !== null) {\n            offset += nodeContent(sibling).length\n            sibling = sibling.previousSibling\n        }\n        node = node.parentNode!\n    }\n    return offset\n}\n\nexport function setRange(editor: HTMLElement, newRange: Range | null): void {\n    const currentRange = getRange(editor)\n\n    if (currentRange?.start === newRange?.start && currentRange?.end === newRange?.end) {\n        return\n    }\n\n    const selection = window.getSelection()!\n\n    if (newRange === null) {\n        selection.removeAllRanges()\n        editor.blur()\n        return\n    }\n\n    if (currentRange === null) {\n        editor.focus()\n    }\n\n    const [anchorNode, anchorOffset] = getContainerOffset(editor, newRange.start)\n    const [focusNode, focusOffset] = getContainerOffset(editor, newRange.end)\n\n    selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)\n}\n\n// Inverse of `positionInEditor`\n// Traverse down the tree, always keeping the text content behind us lte position\nexport function getContainerOffset(node: Node, position: number): [Node, number] {\n    let offset = 0\n    while (node.childNodes.length > 0) {\n        node = node.childNodes.item(0)\n        while (offset + nodeContent(node).length < position && node.nextSibling !== null) {\n            offset += nodeContent(node).length\n            node = node.nextSibling\n        }\n    }\n    return [node, position - offset]\n}\n\nfunction spanFactory(colors: Colors): (token: AnnotatedToken['token'] | ParseError, content: (Node | string)[]) => HTMLSpanElement {\n    const brackets = new DefaultMap<string, number>(() => 0)\n\n    const basicConstants = ['true', 'false', 'null']\n\n    return (token, content) => {\n        const style: Record<string, string> = { position: 'relative' }\n        let title: string | undefined\n\n        switch (token.type) {\n            case 'bracket':\n                function levelColor(level: number): string {\n                    switch (level % 3) {\n                        case 0:\n                            return colors.hueColors.yellow\n                        case 1:\n                            return colors.hueColors.pink\n                        case 2:\n                            return colors.hueColors.blue\n                        default:\n                            throw Error()\n                    }\n                }\n\n                if (token.value === '(' || token.value === '[' || token.value === '{') {\n                    const level = Array.from(brackets.values()).reduce((sum, next) => sum + next, 0)\n                    brackets.set(token.value, brackets.get(token.value) + 1)\n                    style.color = levelColor(level)\n                }\n                else {\n                    const openEquivalent = ({\n                        ')': '(',\n                        ']': '[',\n                        '}': '{',\n                    } as const)[token.value]\n                    if (brackets.get(openEquivalent) === 0) {\n                        style.color = colors.hueColors.red\n                    }\n                    else {\n                        brackets.set(openEquivalent, brackets.get(openEquivalent) - 1)\n                        const level = Array.from(brackets.values()).reduce((sum, next) => sum + next, 0)\n                        style.color = levelColor(level)\n                    }\n                }\n                break\n            case 'number':\n                style.color = colors.hueColors.blue\n                break\n            case 'string':\n                style.color = colors.hueColors.green\n                break\n            case 'error':\n                // Safari doesn't support the shorthand 🙄\n                style['text-decoration-color'] = colors.hueColors.red\n                style['text-decoration-style'] = 'wavy'\n                style['text-decoration-line'] = 'underline'\n                style['text-decoration-skip-ink'] = 'none'\n\n                title = token.value\n                break\n            case 'operator':\n                style.color = colors.hueColors.orange\n                break\n            case 'identifier':\n                if (basicConstants.includes(token.value)) {\n                    style.color = colors.hueColors.orange\n                }\n                break\n            case 'keyword':\n                style.color = colors.hueColors.purple\n                break\n        }\n\n        const result = document.createElement('span')\n        result.setAttribute('style', styleToString(style))\n        result.title = title ?? ''\n        result.replaceChildren(...content)\n        return result\n    }\n}\n\nfunction styleToString(style: Record<string, string>): string {\n    return Object.entries(style).map(([key, value]) => `${key}:${value};`).join('')\n}\n\nexport function getAutocompleteOptions(typeEnvironment: Map<string, USSDocumentedType>, tokens: AnnotatedToken[], currentIdentifer: string): string[] {\n    const allIdentifiers = new Set<string>()\n    for (const t of tokens) {\n        if (t.token.type === 'identifier') {\n            allIdentifiers.add(t.token.value)\n        }\n    }\n    for (const [id] of typeEnvironment) {\n        allIdentifiers.add(id)\n    }\n    allIdentifiers.delete(currentIdentifer)\n\n    const sortedIdentifiers = Array.from(allIdentifiers).flatMap((option) => {\n        const match = isAMatch(currentIdentifer.toLowerCase(), option.toLowerCase())\n        if (match === 0) {\n            return []\n        }\n        else {\n            return [{ option, match }]\n        }\n    }).sort((a, b) => {\n        if (a.match !== b.match) {\n            return b.match - a.match\n        }\n        else if (a.option.length !== b.option.length) {\n            return a.option.length - b.option.length\n        }\n        else {\n            return a.option.localeCompare(b.option)\n        }\n    }).map(({ option }) => option)\n\n    return sortedIdentifiers\n}\n\nexport function createAutocompleteMenu(colors: Colors): HTMLElement {\n    const style = {\n        'position': 'absolute',\n        'top': '100%',\n        'left': '100%',\n        'user-select': 'none',\n        'z-index': '1',\n        'overflow': 'scroll',\n        'max-height': `10lh`,\n        'border-radius': TestUtils.shared.isTesting ? '0' : '5px',\n        'border': `1px solid ${colors.borderNonShadow}`,\n        'color': colors.textMain,\n    }\n\n    const result = document.createElement('div')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n\n    return result\n}\n\nexport function createPlaceholder(colors: Colors, placeholderText: string): HTMLElement {\n    const style = {\n        'position': 'absolute',\n        'user-select': 'none',\n        'white-space': 'pre',\n        'color': colors.hueColors.grey,\n        'pointer-events': 'none',\n    }\n\n    const result = document.createElement('span')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n\n    result.textContent = placeholderText\n\n    return result\n}\n\n// Custom hook interfaces\n\ninterface UndoRedoItem<T, S> {\n    time: number\n    state: T\n    selection: S\n}\n\nexport interface UndoRedoOptions {\n    undoChunking?: number\n    undoHistory?: number\n    onlyElement?: { current: HTMLElement | null }\n}\n\nexport function useUndoRedo<T, S>(\n    initialState: T,\n    initialSelection: S,\n    onStateChange: (state: T) => void,\n    onSelectionChange: (selection: S) => void,\n    { undoChunking = 1000, undoHistory = 100, onlyElement }: UndoRedoOptions = {},\n): {\n        addState: (state: T, selection: S) => void\n        updateCurrentSelection: (selection: S) => void\n    } {\n    const undoStack = useRef<UndoRedoItem<T, S>[]>([\n        { time: 0, state: initialState, selection: initialSelection },\n    ])\n    const redoStack = useRef<UndoRedoItem<T, S>[]>([])\n\n    const addState = useCallback((state: T, selection: S): void => {\n        const currentUndoState = undoStack.current[undoStack.current.length - 1]\n\n        if (currentUndoState.time + undoChunking > Date.now()) {\n            // Amend current item rather than making a new one\n            currentUndoState.state = state\n            currentUndoState.selection = selection\n        }\n        else {\n            undoStack.current.push({ time: Date.now(), state, selection })\n            while (undoStack.current.length > undoHistory) {\n                undoStack.current.shift()\n            }\n        }\n        redoStack.current = []\n    }, [undoChunking, undoHistory])\n\n    const updateCurrentSelection = useCallback((selection: S): void => {\n        undoStack.current[undoStack.current.length - 1].selection = selection\n    }, [])\n\n    const undo = useCallback((): void => {\n        if (undoStack.current.length >= 2) {\n            const prevState = undoStack.current[undoStack.current.length - 2]\n            // Prev state becomes current state, current state becomes redo state\n            redoStack.current.push(undoStack.current.pop()!)\n            onStateChange(prevState.state)\n            onSelectionChange(prevState.selection)\n        }\n    }, [onStateChange, onSelectionChange])\n\n    const redo = useCallback((): void => {\n        const futureState = redoStack.current.pop()\n        if (futureState !== undefined) {\n            undoStack.current.push(futureState)\n            onStateChange(futureState.state)\n            onSelectionChange(futureState.selection)\n        }\n    }, [onStateChange, onSelectionChange])\n\n    // Set up keyboard shortcuts\n    useEffect(() => {\n        const listener = (e: KeyboardEvent): void => {\n            if (onlyElement !== undefined && document.activeElement !== null && document.activeElement !== onlyElement.current) {\n                return\n            }\n\n            const isMac = navigator.userAgent.includes('Mac') && !TestUtils.shared.isTesting\n            if (isMac ? e.key.toLowerCase() === 'z' && e.metaKey && !e.shiftKey : e.key.toLowerCase() === 'z' && e.ctrlKey) {\n                e.preventDefault()\n                undo()\n            }\n            else if (isMac ? e.key.toLowerCase() === 'z' && e.metaKey && e.shiftKey : e.key.toLowerCase() === 'y' && e.ctrlKey) {\n                e.preventDefault()\n                redo()\n            }\n        }\n\n        window.addEventListener('keydown', listener)\n        return () => { window.removeEventListener('keydown', listener) }\n    }, [undo, redo, onlyElement])\n\n    return {\n        addState,\n        updateCurrentSelection,\n    }\n}\n","/*\n    Check whether a is a substring of b (does not have to be contiguous)\n*/\nexport function isAMatch(a: string, b: string): number {\n    let i = 0\n    let matchCount = 0\n    let prevMatch = true\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of -- b is a string\n    for (let j = 0; j < b.length; j++) {\n        if (a[i] === b[j]) {\n            i++\n            if (prevMatch) {\n                matchCount++\n            }\n            prevMatch = true\n        }\n        else {\n            prevMatch = false\n        }\n        if (i === a.length) {\n            return matchCount + 1\n        }\n    }\n    return 0\n}\n","import { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTStatement, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTArg, locationOf, unify } from './ast'\nimport { Context } from './context'\nimport { addAdditionalDims, broadcastApply, broadcastCall } from './forward-broadcasting'\nimport { LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\nimport { splitMask } from './split-broadcasting'\nimport { renderType, unifyType, USSRawValue, USSType, USSValue, USSVectorType, ValueArg, undocValue, canUnifyTo } from './types-values'\n\nexport interface Effect { type: 'warning', message: string, location: LocInfo }\n\nexport function renderLocInfo(loc: LocInfo): string {\n    if (loc.start.lineIdx === loc.end.lineIdx) {\n        if (loc.start.colIdx + 1 === loc.end.colIdx) {\n            // Single character location\n            return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}`\n        }\n        return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}-${loc.end.colIdx}`\n    }\n    return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1} - ${loc.end.lineIdx + 1}:${loc.end.colIdx}`\n}\n\nexport class InterpretationError extends Error {\n    public value: string\n    constructor(message: string, public location: LocInfo) {\n        super(`${message} at ${renderLocInfo(location)}`)\n        this.name = 'InterpretationError'\n        this.value = message\n        this.location = location\n    }\n}\n\nexport function evaluate(expr: UrbanStatsASTExpression, env: Context): USSValue {\n    switch (expr.type) {\n        case 'constant':\n            const value = expr.value.node\n            if (value.type === 'number') {\n                return undocValue(value.value, { type: 'number' })\n            }\n            return undocValue(value.value satisfies string, { type: 'string' })\n        case 'identifier':\n            const varName = expr.name.node\n            const res = env.getVariable(varName)\n            if (res !== undefined) {\n                return res\n            }\n            throw env.error(`Undefined variable: ${varName}`, expr.name.location)\n        case 'attribute':\n            const obj = evaluate(expr.expr, env)\n            const attr = expr.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, undefined)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(expr))\n            }\n            return lookupResult.value\n        case 'call':\n            const func = evaluate(expr.fn, env)\n            const args = expr.args.map(arg => evaluateArg(arg, env))\n            const broadcastResult = broadcastCall(func, args, env, locationOf(expr))\n            if (broadcastResult.type === 'error') {\n                throw env.error(broadcastResult.message, locationOf(expr))\n            }\n            return broadcastResult.result\n        case 'unaryOperator':\n            const operand = evaluate(expr.expr, env)\n            return evaluateUnaryOperator(operand, expr.operator.node, env, locationOf(expr))\n        case 'binaryOperator':\n            const left = evaluate(expr.left, env)\n            const right = evaluate(expr.right, env)\n            return evaluateBinaryOperator(left, right, expr.operator.node, env, locationOf(expr))\n        case 'vectorLiteral':\n            const elements = expr.elements.map(e => evaluate(e, env))\n            let elementType = { type: 'elementOfEmptyVector' } as USSType | { type: 'elementOfEmptyVector' }\n            for (const e of elements) {\n                elementType = unifyType(elementType, e.type, () => {\n                    assert(elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(e.value)}`)\n                    return env.error(`vector literal contains heterogenous types ${renderType(elementType)} and ${renderType(e.type)}`, locationOf(expr))\n                })\n            }\n            return undocValue(elements.map(e => e.value), { type: 'vector', elementType })\n        case 'objectLiteral':\n            const ts = new Map<string, USSType>()\n            const vs = new Map<string, USSRawValue>()\n            for (const [name, e] of expr.properties) {\n                const v = evaluate(e, env)\n                if (ts.has(name)) {\n                    throw env.error(`Duplicate key ${name} in object literal`, locationOf(e))\n                }\n                ts.set(name, v.type)\n                vs.set(name, v.value)\n            }\n            return undocValue(vs, {\n                type: 'object',\n                properties: ts,\n            })\n        case 'if':\n            const condition = evaluate(expr.condition, env)\n            return splitMask(\n                env,\n                condition,\n                (v: USSValue, subEnv: Context): USSValue => {\n                    if (v.type.type !== 'boolean') {\n                        throw env.error(`Condition in if statement must be a boolean, but got ${renderType(v.type)}`, locationOf(expr.condition))\n                    }\n                    if (v.value) {\n                        return execute(expr.then, subEnv)\n                    }\n                    if (expr.else === undefined) {\n                        return undocValue(null, { type: 'null' })\n                    }\n                    return execute(expr.else, subEnv)\n                },\n                locationOf(expr.condition),\n                locationOf(expr),\n            )\n        case 'do':\n            if (expr.statements.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let doResult: USSValue = execute(expr.statements[0], env)\n            for (const statement of expr.statements.slice(1)) {\n                doResult = execute(statement, env)\n            }\n            return doResult\n        case 'customNode':\n            // This is a custom node for internal purposes, we just evaluate the expression\n            const result = execute(expr.expr, env)\n\n            // Check type if expectedType is provided\n            if (expr.expectedType && !expr.expectedType.some(t => canUnifyTo(result.type, t))) {\n                throw env.error(\n                    `Custom expression expected to return type ${expr.expectedType.map(t => renderType(t)).join(' or ')}, but got ${renderType(result.type)}`,\n                    locationOf(expr),\n                )\n            }\n\n            return result\n    }\n}\n\nexport function execute(expr: UrbanStatsASTStatement, env: Context): USSValue {\n    switch (expr.type) {\n        case 'condition':\n            if (expr.rest.length === 0) {\n                throw env.error('condition(..) must be followed by at least one statement', locationOf(expr))\n            }\n            return evaluate(\n                { type: 'if',\n                    condition: expr.condition,\n                    then: { type: 'statements', result: expr.rest, entireLoc: unify(...expr.rest.map(locationOf)) },\n                    entireLoc: expr.entireLoc,\n                },\n                env,\n            )\n        case 'assignment':\n            const value = evaluate(expr.value, env)\n            evaluateLHS(expr.lhs, value, env)\n            return value\n        case 'expression':\n            return evaluate(expr.value, env)\n        case 'statements':\n            if (expr.result.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let result: USSValue = execute(expr.result[0], env)\n            for (const statement of expr.result.slice(1)) {\n                result = execute(statement, env)\n            }\n            return result\n        case 'parseError':\n            assert(expr.errors.length > 0, 'parseError node must have at least one error')\n            throw env.error(\n                `Parse error: ${expr.errors.map(e => e.value).join(', ')}`,\n                expr.errors[0].location,\n            )\n    }\n}\n\nexport function evaluateLHS(lhs: UrbanStatsASTLHS, value: USSValue, env: Context): void {\n    switch (lhs.type) {\n        case 'identifier':\n            const varName = lhs.name.node\n            const err = env.assignVariable(varName, value)\n            if (err !== undefined) {\n                throw env.error(err, locationOf(lhs))\n            }\n            return\n        case 'attribute':\n            const obj = evaluate(lhs.expr, env)\n            const attr = lhs.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, value)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(lhs))\n            }\n            return\n    }\n}\n\nfunction evaluateArg(arg: UrbanStatsASTArg, env: Context): ValueArg {\n    switch (arg.type) {\n        case 'named':\n            return {\n                type: 'named',\n                name: arg.name.node,\n                value: evaluate(arg.value, env),\n            }\n        case 'unnamed':\n            return {\n                type: 'unnamed',\n                value: evaluate(arg.value, env),\n            }\n    }\n}\n\nfunction attrLookupOrSet(\n    obj: USSValue,\n    attr: string,\n    orSet: USSValue | undefined,\n): { type: 'success', value: USSValue } | { type: 'error', message: string } {\n    const type = obj.type\n    if (type.type === 'object') {\n        const val = obj.value\n        assert(val instanceof Map, `Expected object type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        const aT = type.properties.get(attr)\n        if (aT === undefined) {\n            return {\n                type: 'error',\n                message: `Attribute ${attr} not found in object of type ${renderType(type)}`,\n            }\n        }\n        if (orSet !== undefined) {\n            if (renderType(aT) !== renderType(orSet.type)) {\n                return {\n                    type: 'error',\n                    message: `Type mismatch: expected ${renderType(aT)} but got ${renderType(orSet.type)} for attribute ${attr} in object of type ${renderType(type)}`,\n                }\n            }\n            // If orSet is provided, we set the attribute to the value\n            val.set(attr, orSet.value)\n            return {\n                type: 'success',\n                value: undocValue(orSet.value, aT),\n            }\n        }\n        const content = val.get(attr)\n        assert(content !== undefined, `Expected attribute ${attr} to be defined in object, but got undefined at ${JSON.stringify(obj.value)}`)\n        return {\n            type: 'success',\n            value: undocValue(val.get(attr)!, aT),\n        }\n    }\n    if (type.type === 'vector') {\n        const val = obj.value\n        assert(val instanceof Array, `Expected vector type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        let orSetLookp: (idx: number) => USSValue | undefined = () => undefined\n        if (orSet !== undefined) {\n            if (orSet.type.type !== 'vector') {\n                orSet = undocValue(addAdditionalDims([val.length], orSet.value), { type: 'vector', elementType: orSet.type })\n            }\n            assert(Array.isArray(orSet.value), `It should be an array at this point`)\n            if (orSet.value.length !== val.length) {\n                return { type: 'error', message: `Expected vector of length ${val.length} but got ${orSet.value.length} for attribute ${attr} in object of type ${renderType(type)}` }\n            }\n            const v = orSet.value\n            const t = (orSet.type as USSVectorType).elementType\n            assert(t.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(orSet.value)}`)\n            orSetLookp = (idx: number) => {\n                return undocValue(v[idx], t)\n            }\n        }\n        const resultsOrErr = val.map((x, i) => {\n            assert(type.elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(obj.value)}`)\n            return attrLookupOrSet(undocValue(x, type.elementType), attr, orSetLookp(i))\n        })\n        if (resultsOrErr.some(r => r.type === 'error')) {\n            return { type: 'error', message: resultsOrErr.filter(r => r.type === 'error').map(r => (r as { type: 'error', message: string }).message)[0] }\n        }\n        const results = resultsOrErr.map(r => (r as { type: 'success', value: USSValue }).value)\n        const rawValue = results.map(r => r.value)\n        const typ = results[0].type\n        return {\n            type: 'success',\n            value: undocValue(rawValue, { type: 'vector', elementType: typ }),\n        }\n    }\n    return { type: 'error', message: `Cannot access attribute of type ${renderType(type)}. Only objects and vectors support attributes.` }\n}\n\nfunction evaluateUnaryOperator(operand: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.unary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.unary(operator, errLoc),\n        [operand],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n\nfunction evaluateBinaryOperator(left: USSValue, right: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.binary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.binary(operator, errLoc),\n        [left, right],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n","import { assert } from '../utils/defensive'\n\nimport { Block, LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\n\nconst nonExpressionOperators = ['=', ',', ';', '.', ':']\nconst operatorCharacters = '!@$%^&*-+=~`<>/?:|,;.'\n\nconst keywords = ['if', 'do', 'else', 'customNode', 'condition']\nexport type Keyword = (typeof keywords)[number]\n\ninterface NumericToken { type: 'number', value: number }\ninterface IdentifierToken { type: 'identifier', value: string }\ninterface KeywordToken { type: 'keyword', value: Keyword }\ninterface StringToken { type: 'string', value: string }\ninterface OperatorToken { type: 'operator', value: string }\ninterface BracketToken { type: 'bracket', value: '(' | ')' | '{' | '}' | '[' | ']' }\ninterface ErrorToken { type: 'error', value: string }\ntype NonErrorToken = NumericToken | IdentifierToken | KeywordToken | StringToken | OperatorToken | BracketToken\ntype Token = NonErrorToken | ErrorToken\n\nexport interface AnnotatedToken {\n    token: Token\n    location: LocInfo\n}\n\nexport type AnnotatedTokenWithValue = AnnotatedToken & { token: NonErrorToken }\n\ninterface GenericLexer {\n    firstToken: (ch: string) => boolean\n    innerToken: (ch: string) => boolean\n    parse: (string: string) => Token\n}\n\nfunction isDigit(ch: string): boolean {\n    return ch >= '0' && ch <= '9'\n}\nfunction isAlpha(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_'\n}\n\nexport function emptyLocation(ident: string): LocInfo {\n    return {\n        start: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n        end: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n    }\n}\n\nexport function parseNumber(input: string): number | undefined {\n    if (/^-?\\d*(\\.\\d+)?([eE][+-]?\\d+)?$/i.test(input)) {\n        // normal number format\n        const value = parseFloat(input)\n        if (isNaN(value)) {\n            return\n        }\n        return value\n    }\n    if (input.endsWith('k')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000\n    }\n    if (input.endsWith('m')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000000\n    }\n    return\n}\n\nconst identifierLexer: GenericLexer = {\n    firstToken: isAlpha,\n    innerToken: (ch: string): boolean => isAlpha(ch) || isDigit(ch),\n    parse: (string: string): Token => { return { type: keywords.includes(string) ? 'keyword' : 'identifier', value: string } },\n}\n\nfunction isOperator(string: string): boolean {\n    return nonExpressionOperators.includes(string) || expressionOperatorMap.has(string)\n}\n\nconst operatorLexer: GenericLexer = {\n    firstToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    innerToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    parse: (string: string): Token => {\n        if (isOperator(string)) {\n            return { type: 'operator', value: string }\n        }\n        return { type: 'error', value: `Invalid operator: ${string}` }\n    },\n}\n\nfunction lexLine(input: string, block: Block, lineNo: number, charIdxOffset: number): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    // one line\n    assert(!input.includes('\\n'), 'Input contains new line characters')\n    let idx = 0\n    lex: while (idx < input.length) {\n        const char = input[idx]\n        if (char === ' ') {\n            idx++\n            continue\n        }\n        if (char === '(' || char === ')' || char === '{' || char === '}' || char === '[' || char === ']') {\n            const token: AnnotatedToken = {\n                token: { type: 'bracket', value: char },\n                location: {\n                    start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                    end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n                },\n            }\n            tokens.push(token)\n            idx++\n            continue\n        }\n        if (isDigit(char)) {\n            let token\n            [idx, token] = lexNumber(input, idx, block, lineNo, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue\n            }\n        }\n        for (const lexer of [identifierLexer, operatorLexer]) {\n            let token\n            [idx, token] = lexGeneric(input, idx, block, lineNo, lexer, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue lex\n            }\n        }\n        let token\n        [idx, token] = lexString(input, idx, block, lineNo, charIdxOffset)\n        if (token !== undefined) {\n            tokens.push(token)\n            continue\n        }\n        tokens.push({\n            token: { type: 'error', value: `Unexpected character: ${char}` },\n            location: {\n                start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n            },\n        })\n        idx++\n    }\n    return tokens\n}\n\nexport function lex(block: Block, input: string): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    const lines = input.split('\\n')\n    let charIdx = 0\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i]\n        const lineTokens = lexLine(line, block, i, charIdx)\n        tokens.push(...lineTokens)\n        charIdx += line.length\n        tokens.push({\n            token: { type: 'operator', value: 'EOL' },\n            location: {\n                start: { block, lineIdx: i, colIdx: line.length, charIdx },\n                end: { block, lineIdx: i, colIdx: line.length, charIdx },\n            },\n        })\n        charIdx += 1 // newline\n    }\n    return tokens\n}\n\nfunction lexGeneric(\n    input: string,\n    idx: number,\n    block: Block,\n    lineNo: number,\n    lexer: GenericLexer,\n    charIdxOffset: number,\n): [number, AnnotatedToken | undefined] {\n    if (!lexer.firstToken(input[idx])) {\n        return [idx, undefined]\n    }\n\n    const start = idx\n    while (idx < input.length && lexer.innerToken(input[idx])) {\n        idx++\n    }\n    const token: AnnotatedToken = {\n        token: lexer.parse(input.slice(start, idx)),\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexString(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    if (input[idx] !== '\"') {\n        return [idx, undefined]\n    }\n    const start = idx\n    idx++\n    while (true) {\n        if (idx >= input.length) {\n            return [idx, { token: { type: 'error', value: 'Unterminated string' }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + start } } }]\n        }\n        if (input[idx] === '\"') {\n            idx++\n            break\n        }\n        if (input[idx] === '\\\\') {\n            idx += 2\n            continue\n        }\n        idx++\n    }\n    let result: string\n    try {\n        const resultObj: unknown = JSON.parse(input.slice(start, idx))\n        assert(typeof resultObj === 'string', `Invalid string: ${input.slice(start, idx)}`)\n        result = resultObj\n    }\n    catch (e) {\n        return [idx, { token: { type: 'error', value: `Invalid string: ${input.slice(start, idx)}: ${e}` }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'string', value: result },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexNumber(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    const numberFormat = /^\\d+(\\.\\d+)?([eE][+-]?\\d+|k|m)?/i\n    const match = numberFormat.exec(input.slice(idx))\n    if (!match) {\n        return [idx, undefined]\n    }\n    const numberStr = match[0]\n    const number = parseNumber(numberStr)\n    if (number === undefined) {\n        return [idx + numberStr.length, { token: { type: 'error', value: `Invalid number format: ${numberStr}` }, location: { start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx }, end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'number', value: number },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n            end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length },\n        },\n    }\n    return [idx + numberStr.length, token]\n}\n","export type Block = { type: 'single', ident: string } | { type: 'multi' }\n\nexport interface SingleLocationWithinBlock {\n    lineIdx: number\n    colIdx: number\n    charIdx: number\n}\nexport type SingleLocation = SingleLocationWithinBlock & { block: Block }\n\nexport interface LocInfo {\n    start: SingleLocation\n    end: SingleLocation\n}\n\nexport const noLocation = { start: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 }, end: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 } } satisfies LocInfo\n\nexport function extendBlockIdPositionalArg(blockIdent: string, position: number): string {\n    return `${blockIdent}_pos_${position}`\n}\n\nexport function extendBlockIdKwarg(blockIdent: string, argName: string): string {\n    return `${blockIdent}_${argName}`\n}\n\nexport function extendBlockIdVectorElement(blockIdent: string, index: number): string {\n    return `${blockIdent}_el_${index}`\n}\n\nexport function extendBlockIdObjectProperty(blockIdent: string, property: string): string {\n    return `${blockIdent}_prop_${property}`\n}\n","import { assert } from '../utils/defensive'\n\nimport { locationOf, unify, UrbanStatsAST, UrbanStatsASTArg, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTStatement } from './ast'\nimport { Context } from './context'\nimport { AnnotatedToken, AnnotatedTokenWithValue, lex, Keyword, emptyLocation } from './lexer'\nimport { noLocation, LocInfo, Block } from './location'\nimport { expressionOperatorMap, infixOperators, unaryOperators } from './operators'\nimport { USSType } from './types-values'\n\nexport interface Decorated<T> {\n    node: T\n    location: LocInfo\n}\n\nexport interface ParseError { type: 'error', value: string, location: LocInfo }\n\ntype USSInfixSequenceElement = { type: 'operator', operatorType: 'unary' | 'binary', value: Decorated<string> } | UrbanStatsASTExpression\n\nexport function toSExp(node: UrbanStatsAST): string {\n    /**\n     * For testing purposes, we convert the AST to a simple S-expression format.\n     */\n    switch (node.type) {\n        case 'unnamed':\n            return toSExp(node.value)\n        case 'named':\n            return `(named ${node.name.node} ${toSExp(node.value)})`\n        case 'constant':\n            return `(const ${node.value.node.value})`\n        case 'identifier':\n            return `(id ${node.name.node})`\n        case 'attribute':\n            return `(attr ${toSExp(node.expr)} ${node.name.node})`\n        case 'call':\n            return `(fn ${[node.fn, ...node.args].map(toSExp).join(' ')})`\n        case 'unaryOperator':\n            return `(${node.operator.node} ${toSExp(node.expr)})`\n        case 'binaryOperator':\n            return `(${node.operator.node} ${toSExp(node.left)} ${toSExp(node.right)})`\n        case 'vectorLiteral':\n            return `(vector ${node.elements.map(toSExp).join(' ')})`\n        case 'objectLiteral':\n            return `(object ${node.properties.map(([key, value]) => `(${key} ${toSExp(value)})`).join(' ')})`\n        case 'assignment':\n            return `(assign ${toSExp(node.lhs)} ${toSExp(node.value)})`\n        case 'expression':\n            return `(expr ${toSExp(node.value)})`\n        case 'statements':\n            return `(statements ${node.result.map(toSExp).join(' ')})`\n        case 'if':\n            return `(if ${toSExp(node.condition)} ${toSExp(node.then)}${node.else ? ` ${toSExp(node.else)}` : ''})`\n        case 'do':\n            return `(do ${node.statements.map(toSExp).join(' ')})`\n        case 'condition':\n            return `(condition ${toSExp(node.condition)} ${node.rest.map(toSExp).join(' ')})`\n        case 'parseError':\n            return `(parseError ${JSON.stringify(node.originalCode)} ${JSON.stringify(node.errors)})`\n        case 'customNode':\n            return `(customNode ${toSExp(node.expr)} ${JSON.stringify(node.originalCode)})`\n    }\n}\n\nclass ParseState {\n    tokens: AnnotatedTokenWithValue[]\n    index: number\n    constructor(tokens: AnnotatedTokenWithValue[]) {\n        this.tokens = tokens\n        this.index = 0\n    }\n\n    skipEOL(): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === 'operator' && token.token.value === 'EOL') {\n            this.index++\n            return true\n        }\n        return false\n    }\n\n    consumeTokenOfType(type: string, ...values: (string | number)[]): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === type && (values.length === 0 || values.includes(token.token.value))) {\n            this.index++\n            return true\n        }\n        if (this.skipEOL()) {\n            if (this.consumeTokenOfType(type, ...values)) {\n                return true\n            }\n            this.index-- // backtrack\n        }\n        return false\n    }\n\n    consumeOperator(...oneOfOps: string[]): boolean {\n        return this.consumeTokenOfType('operator', ...oneOfOps)\n    }\n\n    consumeBracket(...oneOfBrackets: string[]): boolean {\n        return this.consumeTokenOfType('bracket', ...oneOfBrackets)\n    }\n\n    consumeIdentifier(): boolean {\n        return this.consumeTokenOfType('identifier')\n    }\n\n    consumeKeyword(...oneOfKeywords: Keyword[]): boolean {\n        return this.consumeTokenOfType('keyword', ...oneOfKeywords)\n    }\n\n    maybeLastNonEOLToken(offset: number): AnnotatedTokenWithValue {\n        for (let i = this.index + offset; i >= 0; i--) {\n            const token = this.tokens[i]\n            if (token.token.type !== 'operator' || token.token.value !== 'EOL') {\n                return token\n            }\n        }\n        return this.tokens[this.index + offset]\n    }\n\n    parseSingleExpression(): UrbanStatsASTExpression | ParseError {\n        while (this.skipEOL()) { }\n        if (this.index >= this.tokens.length) {\n            return { type: 'error', value: 'Unexpected end of input', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const token = this.tokens[this.index]\n        switch (token.token.type) {\n            case 'number':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'number', value: token.token.value }, location: token.location } }\n            case 'string':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'string', value: token.token.value }, location: token.location } }\n            case 'identifier':\n                this.index++\n                return { type: 'identifier', name: { node: token.token.value, location: token.location } }\n            case 'keyword':\n                throw new Error(`Unexpected keyword ${token.token.value}`)\n            case 'bracket':\n                switch (token.token.value) {\n                    case '(':\n                        this.index++\n                        const expr = this.parseExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        if (!this.consumeBracket(')')) {\n                            return { type: 'error', value: 'Expected closing bracket ) to match this one', location: token.location }\n                        }\n                        return expr\n                    case '{':\n                        this.index++\n                        const startLoc = token.location\n                        const properties: [string, UrbanStatsASTExpression][] = []\n                        while (!this.consumeBracket('}')) {\n                            if (properties.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: `Expected comma , or closing bracket } after object field name; instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n                            }\n                            if (!this.consumeIdentifier()) {\n                                return { type: 'error', value: 'Expected identifier for object field name', location: this.maybeLastNonEOLToken(-1).location }\n                            }\n                            const keyToken = this.tokens[this.index - 1]\n                            assert(keyToken.token.type === 'identifier', `Expected identifier token, but got ${keyToken.token.type}`)\n                            if (!this.consumeOperator(':')) {\n                                return { type: 'error', value: `Expected : token after object field name`, location: keyToken.location }\n                            }\n                            const value = this.parseExpression()\n                            if (value.type === 'error') {\n                                return value\n                            }\n                            properties.push([keyToken.token.value, value])\n                        }\n                        const endLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'objectLiteral',\n                            entireLoc: unify(startLoc, endLoc),\n                            properties,\n                        }\n                    case '[':\n                        this.index++\n                        const vectorStartLoc = token.location\n                        const elements: UrbanStatsASTExpression[] = []\n                        while (!this.consumeBracket(']')) {\n                            if (elements.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: 'Expected comma , or closing bracket ] after vector element', location: this.maybeLastNonEOLToken(0).location }\n                            }\n                            const element = this.parseExpression()\n                            if (element.type === 'error') {\n                                return element\n                            }\n                            elements.push(element)\n                        }\n                        const vectorEndLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'vectorLiteral',\n                            entireLoc: unify(vectorStartLoc, vectorEndLoc),\n                            elements,\n                        }\n                }\n                return { type: 'error', value: `Unexpected bracket ${token.token.value}`, location: token.location }\n            case 'operator':\n                return { type: 'error', value: `Unexpected operator ${token.token.value}`, location: token.location }\n        }\n    }\n\n    parseArg(): UrbanStatsASTArg | ParseError {\n        const exprOrName = this.parseExpression()\n        if (exprOrName.type === 'error') {\n            return exprOrName\n        }\n        if (!this.consumeOperator('=')) {\n            return { type: 'unnamed', value: exprOrName }\n        }\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (exprOrName.type !== 'identifier') {\n            return { type: 'error', value: 'Expected identifier for named argument', location: locationOf(exprOrName) }\n        }\n        return {\n            type: 'named',\n            name: { node: exprOrName.name.node, location: exprOrName.name.location },\n            value: expr,\n        }\n    }\n\n    parseParenthesizedArgs(): { type: 'args', args: [UrbanStatsASTArg[], LocInfo] } | ParseError | undefined {\n        if (!this.consumeBracket('(')) {\n            return undefined\n        }\n        const startLoc = this.tokens[this.index - 1].location\n        const args: UrbanStatsASTArg[] = []\n        while (true) {\n            if (this.consumeBracket(')')) {\n                const endLoc = this.tokens[this.index - 1].location\n                return { type: 'args', args: [args, unify(startLoc, endLoc)] }\n            }\n            if (args.length > 0 && !this.consumeOperator(',')) {\n                return { type: 'error', value: `Expected comma , or closing bracket ); instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n            }\n            const arg = this.parseArg()\n            if (arg.type === 'error') {\n                return arg\n            }\n            args.push(arg)\n        }\n    }\n\n    parseFunctionalExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('customNode')) {\n            return this.parseCustomNodeExpression()\n        }\n\n        let fn = this.parseSingleExpression()\n        if (fn.type === 'error') {\n            return fn\n        }\n        while (true) {\n            let done = true\n            const args = this.parseParenthesizedArgs()\n            if (args !== undefined) {\n                done = false\n                if (args.type === 'error') {\n                    return args\n                }\n                fn = {\n                    type: 'call',\n                    fn,\n                    entireLoc: unify(locationOf(fn), args.args[1]),\n                    args: args.args[0],\n                }\n            }\n            if (this.consumeOperator('.')) {\n                done = false\n                if (!this.consumeIdentifier()) {\n                    return { type: 'error', value: 'Expected identifier after the dot', location: this.maybeLastNonEOLToken(-1).location }\n                }\n                const token = this.tokens[this.index - 1]\n                assert(token.token.type === 'identifier', `Expected identifier token, but got ${token.token.type}`)\n                fn = {\n                    type: 'attribute',\n                    expr: fn,\n                    name: { node: token.token.value, location: token.location },\n                }\n            }\n            if (done) {\n                break\n            }\n        }\n        return fn\n    }\n\n    parseExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('if')) {\n            return this.parseIfExpression()\n        }\n\n        if (this.consumeKeyword('do')) {\n            return this.parseDoExpression()\n        }\n\n        const operatorExpSequence: USSInfixSequenceElement[] = []\n        // State Machine with states expressionOrUnaryOperator; binaryOperator\n        let state: 'expressionOrUnaryOperator' | 'binaryOperator' = 'expressionOrUnaryOperator'\n        loop: while (true) {\n            switch (state) {\n                case 'expressionOrUnaryOperator': {\n                    if (this.consumeOperator(...unaryOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'unary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        continue\n                    }\n                    else {\n                        const expr = this.parseFunctionalExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        operatorExpSequence.push(expr)\n                        state = 'binaryOperator'\n                    }\n                }\n                    break\n                case 'binaryOperator': {\n                    if (this.consumeOperator(...infixOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'binary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        state = 'expressionOrUnaryOperator'\n                    }\n                    else {\n                        break loop\n                    }\n                }\n            }\n        }\n        return this.parseInfixSequence(operatorExpSequence)\n    }\n\n    parseInfixSequence(operatorExpSequence: USSInfixSequenceElement[]): UrbanStatsASTExpression | ParseError {\n        assert(operatorExpSequence.length !== 0, 'Expected expression')\n        if (operatorExpSequence.length === 1) {\n            assert(operatorExpSequence[0].type !== 'operator', `Unexpected operator ${JSON.stringify(operatorExpSequence[0])} at beginning of infix sequence`)\n            return operatorExpSequence[0]\n        }\n        // Get the highest precedence operator\n        const precedences = operatorExpSequence.map(x => x.type === 'operator' ? expressionOperatorMap.get(x.value.node)?.precedence ?? 0 : 0)\n        const maxPrecedence = Math.max(...precedences)\n        assert(maxPrecedence > 0, 'No valid operator found in infix sequence')\n        const index = precedences.findIndex(p => p === maxPrecedence)\n        assert(index > -1, 'No operator found with maximum precedence; this should not happen')\n        return this.parseInfixSequence(this.resolveOperator(operatorExpSequence, index))\n    }\n\n    resolveOperator(operatorExpSequence: USSInfixSequenceElement[], index: number): USSInfixSequenceElement[] {\n        assert(operatorExpSequence[index].type === 'operator', `Expected operator at index ${index}, but found expression: ${JSON.stringify(operatorExpSequence[index])}`)\n        const next = operatorExpSequence[index + 1]\n        if (next.type === 'operator') {\n            return this.resolveOperator(operatorExpSequence, index + 1)\n        }\n        switch (operatorExpSequence[index].operatorType) {\n            case 'unary': {\n                return [\n                    ...operatorExpSequence.slice(0, index),\n                    { type: 'unaryOperator', operator: operatorExpSequence[index].value, expr: next },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n            case 'binary': {\n                // Split the sequence into left and right parts\n                const left = operatorExpSequence[index - 1]\n                const right = operatorExpSequence[index + 1]\n                assert(left.type !== 'operator' && right.type !== 'operator', 'unreachable: left or right should not be an operator')\n                return [\n                    ...operatorExpSequence.slice(0, index - 1),\n                    { type: 'binaryOperator', operator: operatorExpSequence[index].value, left, right },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n        }\n    }\n\n    checkLHS(expr: UrbanStatsASTExpression): UrbanStatsASTLHS | ParseError {\n        switch (expr.type) {\n            case 'identifier':\n            case 'attribute':\n                return expr\n            case 'constant':\n            case 'call':\n            case 'unaryOperator':\n            case 'binaryOperator':\n            case 'vectorLiteral':\n            case 'objectLiteral':\n            case 'if':\n            case 'do':\n            case 'customNode':\n                return { type: 'error', value: 'Cannot assign to this expression', location: locationOf(expr) }\n        }\n    }\n\n    parseStatement(): UrbanStatsASTStatement | ParseError {\n        if (this.consumeKeyword('condition')) {\n            return this.parseConditionStatement()\n        }\n\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (this.consumeOperator('=')) {\n            const value = this.parseExpression()\n            if (value.type === 'error') {\n                return value\n            }\n            const lhs = this.checkLHS(expr)\n            if (lhs.type === 'error') {\n                return lhs\n            }\n            return { type: 'assignment', lhs, value }\n        }\n        return { type: 'expression', value: expr }\n    }\n\n    parseIfExpression(): UrbanStatsASTExpression | ParseError {\n        const ifToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after if', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const then = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after if block')\n        if (then.type === 'error') {\n            return then\n        }\n        let elseBranch: UrbanStatsASTStatement | undefined = undefined\n        if (this.consumeKeyword('else')) {\n            if (!this.consumeBracket('{')) {\n                return { type: 'error', value: 'Expected opening bracket { after else', location: this.maybeLastNonEOLToken(-1).location }\n            }\n            const eb = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after else block')\n            if (eb.type === 'error') {\n                return eb\n            }\n            elseBranch = eb\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'if',\n            entireLoc: unify(ifToken.location, lastToken.location),\n            condition,\n            then,\n            else: elseBranch,\n        }\n    }\n\n    parseDoExpression(): UrbanStatsASTExpression | ParseError {\n        const doToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after do', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const statements = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after do block')\n        if (statements.type === 'error') {\n            return statements\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'do',\n            entireLoc: unify(doToken.location, lastToken.location),\n            statements: statements.type === 'statements' ? statements.result : [statements],\n        }\n    }\n\n    parseConditionStatement(): UrbanStatsASTStatement | ParseError {\n        const conditionToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return {\n            type: 'condition',\n            entireLoc: unify(conditionToken.location, this.tokens[this.index - 1].location),\n            condition,\n            rest: [],\n        }\n    }\n\n    parseStatements(canEnd: boolean = false, end: () => boolean = () => false, errMsg: string = 'Expected end of line or ; after'): UrbanStatsASTStatement | ParseError {\n        const statements: UrbanStatsASTStatement[] = []\n        while (this.index < this.tokens.length) {\n            if (end()) {\n                break\n            }\n            while (this.skipEOL()) { }\n            if (this.index >= this.tokens.length) {\n                break\n            }\n            const statement = this.parseStatement()\n            if (statement.type === 'error') {\n                return statement\n            }\n            statements.push(statement)\n            if (end()) {\n                break\n            }\n            if (!this.consumeOperator('EOL', ';')) {\n                return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n            }\n            while (this.skipEOL()) { }\n        }\n        if (this.index === this.tokens.length && canEnd) {\n            return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return mergeStatements(\n            statements,\n            this.index > 0\n                ? this.tokens[this.index - 1].location\n                /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n                : undefined,\n        )\n    }\n\n    parseCustomNodeExpression(): UrbanStatsASTExpression | ParseError {\n        const argsRes = this.parseParenthesizedArgs()\n\n        if (argsRes === undefined) {\n            return { type: 'error', value: 'Expected arguments for customNode', location: this.maybeLastNonEOLToken(-1).location }\n        }\n\n        if (argsRes.type === 'error') {\n            return argsRes\n        }\n\n        const [args, locArg] = argsRes.args\n\n        const code = args[0]\n\n        if (args.length !== 1 || code.type !== 'unnamed') {\n            return { type: 'error', value: 'Incorrect arguments for customNode, expected 1 unnamed argument', location: argsRes.args[1] }\n        }\n\n        if (code.value.type !== 'constant' || code.value.value.node.type !== 'string') {\n            return { type: 'error', value: 'Expected string constant as argument to customNode', location: locationOf(code) }\n        }\n\n        const parseResult = parse(code.value.value.node.value, code.value.value.location.start.block)\n\n        if (parseResult.type === 'error') {\n            return {\n                type: 'customNode',\n                expr: {\n                    type: 'parseError',\n                    errors: parseResult.errors,\n                    originalCode: code.value.value.node.value,\n                },\n                originalCode: code.value.value.node.value,\n                entireLoc: locArg,\n            }\n        }\n\n        return {\n            type: 'customNode',\n            expr: parseResult,\n            originalCode: code.value.value.node.value,\n            entireLoc: locArg,\n        }\n    }\n}\n\nexport function mergeStatements(statements: UrbanStatsASTStatement[], fallbackLocation?: LocInfo): UrbanStatsASTStatement {\n    statements = gulpRestForConditions(statements)\n    if (statements.length === 1) {\n        return statements[0]\n    }\n    const entireLoc: LocInfo = statements.length > 0\n        ? unify(...statements.map(locationOf))\n        : fallbackLocation\n        /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n        ?? noLocation\n    return { type: 'statements', result: statements, entireLoc }\n}\n\nfunction gulpRestForConditions(statements: UrbanStatsASTStatement[]): UrbanStatsASTStatement[] {\n    /**\n     * Handle condition statements by gulping the next statement into the condition's rest.\n     */\n    const result: UrbanStatsASTStatement[] = []\n    for (let i = 0; i < statements.length; i++) {\n        const stmt = statements[i]\n        if (stmt.type === 'condition') {\n            stmt.rest.push(...gulpRestForConditions(statements.slice(i + 1)))\n            result.push(stmt)\n            break\n        }\n        result.push(stmt)\n    }\n    return result\n}\n\nexport function parse(code: string, block?: Block, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const tokens = lex(block ?? { type: 'multi' }, code)\n    return parseTokens(tokens, code, returnParseErrorNode)\n}\n\nexport function parseTokens(tokens: AnnotatedToken[], originalCode: string, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const lexErrors = tokens.filter(token => token.token.type === 'error')\n    if (lexErrors.length > 0) {\n        const errors: ParseError[] = lexErrors.map(token => ({ type: 'error' as const, value: `Unrecognized token: ${token.token.value}`, location: token.location }))\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors }\n        }\n        return { type: 'error', errors }\n    }\n    const state = new ParseState(tokens as AnnotatedTokenWithValue[]) // we checked for errors above, so this cast is safe\n    const stmts = state.parseStatements()\n    if (stmts.type === 'error') {\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors: [stmts] }\n        }\n        return { type: 'error', errors: [stmts] }\n    }\n    assert(state.index === state.tokens.length, `Parser did not consume all tokens: ${state.index} < ${state.tokens.length}`)\n    return stmts\n}\n\nfunction allExpressions(node: UrbanStatsASTStatement | UrbanStatsASTExpression): UrbanStatsASTExpression[] {\n    const expressions: UrbanStatsASTExpression[] = []\n    function helper(n: UrbanStatsASTStatement | UrbanStatsASTExpression | UrbanStatsASTArg): boolean {\n        switch (n.type) {\n            case 'unnamed':\n                helper(n.value)\n                return true\n            case 'named':\n                expressions.push(n.value)\n                helper(n.value)\n                return true\n            case 'constant':\n            case 'identifier':\n                expressions.push(n)\n                return true\n            case 'attribute':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'call':\n                expressions.push(n)\n                helper(n.fn)\n                n.args.forEach(helper)\n                return true\n            case 'unaryOperator':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'binaryOperator':\n                expressions.push(n)\n                helper(n.left)\n                helper(n.right)\n                return true\n            case 'objectLiteral':\n                expressions.push(n)\n                n.properties.forEach(([key, value]) => {\n                    expressions.push({ type: 'constant', value: { node: { type: 'string', value: key }, location: n.entireLoc } })\n                    helper(value)\n                })\n                return true\n            case 'vectorLiteral':\n                expressions.push(n)\n                n.elements.forEach(helper)\n                return true\n            case 'assignment':\n                helper(n.lhs)\n                helper(n.value)\n                return true\n            case 'expression':\n                helper(n.value)\n                return true\n            case 'statements':\n                n.result.forEach(helper)\n                return true\n            case 'if':\n                helper(n.condition)\n                helper(n.then)\n                if (n.else) {\n                    helper(n.else)\n                }\n                return true\n            case 'do':\n                n.statements.forEach(helper)\n                return true\n            case 'condition':\n                helper(n.condition)\n                n.rest.forEach(helper)\n                return true\n            case 'parseError':\n                return true\n            case 'customNode':\n                // do not actually put this in the expressions list, as is for internal use only\n                helper(n.expr)\n                return true\n        }\n    }\n    helper(node)\n    return expressions\n}\n\nfunction identifiersInExpr(node: UrbanStatsASTStatement | UrbanStatsASTExpression): Set<string> {\n    const identifiers = new Set<string>()\n    allExpressions(node).forEach((expr) => {\n        if (expr.type === 'identifier') {\n            identifiers.add(expr.name.node)\n        }\n    })\n    return identifiers\n}\n\nexport function allIdentifiers(node: UrbanStatsASTStatement | UrbanStatsASTExpression, ctx: Context): Set<string> {\n    const identifiers = identifiersInExpr(node)\n    while (true) {\n        // make sure to include identifiers from default values of function arguments pulled in by the identifiers\n        const newIdentifiers = new Set<string>()\n        identifiers.forEach((id) => {\n            const t = ctx.getVariable(id)?.type\n            if (t === undefined || t.type !== 'function') {\n                return\n            }\n            Object.entries(t.namedArgs).forEach(([, arg]) => {\n                const dv = arg.defaultValue\n                if (dv === undefined) {\n                    return\n                }\n                identifiersInExpr(dv).forEach((newId) => {\n                    if (!identifiers.has(newId)) {\n                        newIdentifiers.add(newId)\n                    }\n                })\n            })\n        })\n        if (newIdentifiers.size === 0) {\n            break\n        }\n        newIdentifiers.forEach(id => identifiers.add(id))\n    }\n    return identifiers\n}\n\nexport function unparse(node: UrbanStatsASTStatement | UrbanStatsASTExpression, opts: { indent?: number, inline?: boolean, simplify?: boolean, expressionalContext?: boolean } = {}): string {\n    if (opts.inline) {\n        assert(opts.expressionalContext ?? false, 'inline must be true if expressionalContext is true')\n    }\n    opts.indent = opts.indent ?? 0\n    function isSimpleExpression(expr: UrbanStatsASTExpression): boolean {\n        return expr.type === 'identifier' || expr.type === 'vectorLiteral' || expr.type === 'constant' || expr.type === 'customNode'\n    }\n    function indentSpaces(level: number): string {\n        return '    '.repeat(level)\n    }\n    switch (node.type) {\n        case 'customNode':\n            if (!opts.simplify) {\n                return `customNode(${JSON.stringify(node.originalCode.trim())})`\n            }\n            if (opts.expressionalContext && node.expr.type !== 'expression') {\n                return unparse({ type: 'do', statements: [node.expr], entireLoc: locationOf(node.expr) }, { ...opts, inline: true })\n            }\n            else {\n                return node.originalCode.trim()\n            }\n        case 'parseError':\n            return node.originalCode\n        case 'constant':\n            if (node.value.node.type === 'string') {\n                return `\"${node.value.node.value}\"`\n            }\n            else {\n                return node.value.node.value.toString()\n            }\n        case 'identifier':\n            return node.name.node\n        case 'attribute':\n            const exprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            return `${exprStr}.${node.name.node}`\n        case 'call':\n            const fnStr = unparse(node.fn, { ...opts, inline: true, expressionalContext: true })\n            const argsStr = node.args.map((arg) => {\n                switch (arg.type) {\n                    case 'unnamed':\n                        return unparse(arg.value, { ...opts, inline: true, expressionalContext: true })\n                    case 'named':\n                        return `${arg.name.node}=${unparse(arg.value, { ...opts, inline: true, expressionalContext: true })}`\n                }\n            })\n            const fnNeedsParens = !isSimpleExpression(node.fn)\n            const fnWithParens = fnNeedsParens ? `(${fnStr})` : fnStr\n            return `${fnWithParens}(${argsStr.join(', ')})`\n        case 'unaryOperator':\n            const unaryExprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            const needsParens = !isSimpleExpression(node.expr)\n            const exprWithParens = needsParens ? `(${unaryExprStr})` : unaryExprStr\n            return `${node.operator.node}${exprWithParens}`\n        case 'binaryOperator':\n            const leftStr = unparse(node.left, { ...opts, inline: true, expressionalContext: true })\n            const rightStr = unparse(node.right, { ...opts, inline: true, expressionalContext: true })\n            const opPrecedence = expressionOperatorMap.get(node.operator.node)?.precedence ?? 0\n            let leftWithParens = leftStr\n            if (node.left.type === 'binaryOperator') {\n                const leftOpPrecedence = expressionOperatorMap.get(node.left.operator.node)?.precedence ?? 0\n                if (leftOpPrecedence < opPrecedence) {\n                    leftWithParens = `(${leftStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.left)) {\n                leftWithParens = `(${leftStr})`\n            }\n            let rightWithParens = rightStr\n            if (node.right.type === 'binaryOperator') {\n                const rightOpPrecedence = expressionOperatorMap.get(node.right.operator.node)?.precedence ?? 0\n                if (rightOpPrecedence <= opPrecedence) {\n                    rightWithParens = `(${rightStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.right)) {\n                rightWithParens = `(${rightStr})`\n            }\n            return `${leftWithParens} ${node.operator.node} ${rightWithParens}`\n        case 'vectorLiteral':\n            const elementsStr = node.elements.map(elem => unparse(elem, { ...opts, inline: true, expressionalContext: true }))\n            return `[${elementsStr.join(', ')}]`\n        case 'objectLiteral':\n            const propertiesStr = node.properties.map(([key, value]) => {\n                const valueStr = unparse(value, { ...opts, inline: true, expressionalContext: true })\n                return `${key}: ${valueStr}`\n            })\n            return `{${propertiesStr.join(', ')}}`\n        case 'assignment':\n            const lhsStr = unparse(node.lhs, { ...opts, expressionalContext: true })\n            const valueStr = unparse(node.value, { ...opts, expressionalContext: true })\n            return opts.inline ? `${lhsStr} = ${valueStr}` : `${indentSpaces(opts.indent)}${lhsStr} = ${valueStr}`\n        case 'expression':\n            // despite being an expression, it is not in an expressional context if its parent is not\n            return opts.inline ? unparse(node.value, opts) : `${indentSpaces(opts.indent)}${unparse(node.value, opts)}`\n        case 'statements':\n            const statementsStr = node.result\n                .map(stmt => unparse(stmt, opts))\n                .filter(s => s !== '' && s !== 'do {  }')\n            return statementsStr.join(opts.inline ? '; ' : ';\\n')\n        case 'if':\n            const conditionStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const thenStr = unparse(node.then, { ...opts, indent: opts.indent + 1 })\n            let ifStr = opts.inline\n                ? `if (${conditionStr}) { ${thenStr} }`\n                : `if (${conditionStr}) {\\n${thenStr}\\n${indentSpaces(opts.indent)}}`\n            if (node.else) {\n                const elseStr = unparse(node.else, { ...opts, indent: opts.indent + 1 })\n                ifStr += opts.inline\n                    ? ` else { ${elseStr} }`\n                    : ` else {\\n${elseStr}\\n${indentSpaces(opts.indent)}}`\n            }\n            return ifStr\n        case 'do':\n            const doStatements = { type: 'statements' as const, result: node.statements, entireLoc: node.entireLoc }\n            const doStr = unparse(doStatements, { ...opts, indent: opts.indent + 1 })\n            return opts.inline\n                ? `do { ${doStr} }`\n                : `do {\\n${doStr}\\n${indentSpaces(opts.indent)}}`\n        case 'condition':\n            const condStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const restStatements = { type: 'statements' as const, result: node.rest, entireLoc: node.entireLoc }\n            const restStr = unparse(restStatements, opts)\n            // If condition is literal \"true\", elide it\n            if (opts.simplify && node.condition.type === 'identifier' && node.condition.name.node === 'true') {\n                return restStr\n            }\n            return `${indentSpaces(opts.indent)}condition (${condStr})\\n${restStr}`\n    }\n}\n\nexport function parseNoError(uss: string, blockId: string): UrbanStatsASTStatement {\n    const result = parse(uss, { type: 'single', ident: blockId }, true)\n    assert(result.type !== 'error', `Should not have an error`)\n    return result\n}\n\nexport function parseNoErrorAsCustomNode(uss: string, blockId: string, expectedType?: USSType[]): Extract<UrbanStatsASTExpression, { type: 'customNode' }> {\n    assert(!blockId.startsWith('undefined'), 'blockId must not start with \"undefined\"')\n    const result = parseNoError(uss, blockId)\n    return {\n        type: 'customNode',\n        expr: result,\n        originalCode: uss,\n        expectedType,\n        entireLoc: emptyLocation(blockId),\n    }\n}\n\nexport function parseNoErrorAsExpression(uss: string, blockId: string): UrbanStatsASTExpression {\n    const result = parseNoError(uss, blockId)\n    assert(result.type === 'expression', 'Must be expression')\n    return result.value\n}\n","import { Basemap } from '../mapper/settings/utils'\nimport { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTExpression } from './ast'\nimport { Color, hexToColor } from './constants/color-utils'\nimport { CMap, Outline, PMap } from './constants/map'\nimport { RampT } from './constants/ramp'\nimport { Scale } from './constants/scale'\nimport { Context } from './context'\nimport { noLocation } from './location'\nimport { unparse } from './parser'\n\n// Define Inset and Insets types locally to avoid import issues\ninterface Inset { bottomLeft: [number, number], topRight: [number, number], coordBox?: [number, number, number, number], mainMap: boolean, name?: string }\ntype Insets = Inset[]\n\n// Define the tagged union for opaque values\nexport type USSOpaqueValue =\n    | { type: 'opaque', opaqueType: 'color', value: Color }\n    | { type: 'opaque', opaqueType: 'scale', value: Scale }\n    | { type: 'opaque', opaqueType: 'inset', value: Inset }\n    | { type: 'opaque', opaqueType: 'insets', value: Insets }\n    | { type: 'opaque', opaqueType: 'cMap', value: CMap }\n    | { type: 'opaque', opaqueType: 'pMap', value: PMap }\n    | { type: 'opaque', opaqueType: 'outline', value: Outline }\n    | { type: 'opaque', opaqueType: 'unit', value: { unit: string } }\n    | { type: 'opaque', opaqueType: 'ramp', value: RampT }\n    | { type: 'opaque', opaqueType: 'basemap', value: Basemap }\n    | { type: 'opaque', opaqueType: 'geoFeatureHandle', value: string }\n    | { type: 'opaque', opaqueType: 'geoCentroidHandle', value: string }\n\ninterface USSNumberType {\n    type: 'number'\n}\n\ninterface USSStringType {\n    type: 'string'\n}\ninterface USSBooleanType {\n    type: 'boolean'\n}\n\ninterface USSNullType {\n    type: 'null'\n}\n\nexport interface USSOpaqueType {\n    type: 'opaque'\n    name: string\n    allowCustomExpression?: boolean\n}\n\nexport interface USSVectorType {\n    type: 'vector'\n    elementType: USSType | { type: 'elementOfEmptyVector' }\n}\n\nexport interface USSObjectType {\n    type: 'object'\n    properties: Map<string, USSType>\n}\n\nexport type USSFunctionArgType = { type: 'concrete', value: USSType } | { type: 'anyPrimitive' }\nexport type USSFunctionReturnType = { type: 'concrete', value: USSType } | { type: 'inferFromPrimitive' }\n\nexport interface NamedFunctionArgumentWithDocumentation {\n    type: USSFunctionArgType\n    defaultValue?: UrbanStatsASTExpression\n    documentation?: NamedFunctionArgumentDocumentation\n}\n\nexport interface USSFunctionType {\n    type: 'function'\n    posArgs: USSFunctionArgType[]\n    namedArgs: Record<string, NamedFunctionArgumentWithDocumentation>\n    returnType: USSFunctionReturnType\n}\n\ninterface NamedFunctionArgumentDocumentation {\n    hide?: boolean\n}\n\nexport type USSType = (\n    USSNumberType\n    | USSStringType\n    | USSBooleanType\n    | USSNullType\n    | USSOpaqueType\n    | USSObjectType\n    | USSVectorType\n    | USSFunctionType\n)\n\nexport type USSPrimitiveRawValue = (\n    number |\n    string |\n    boolean |\n    null\n)\n\nexport interface OriginalFunctionArgs {\n    posArgs: USSValue[]\n    namedArgs: Record<string, USSValue>\n}\n\nexport type USSRawValue = (\n    USSPrimitiveRawValue |\n    USSRawValue[] |\n    Map<string, USSRawValue> |\n    (\n        (\n            ctx: Context,\n            posArgs: USSRawValue[],\n            namedArgs: Record<string, USSRawValue>,\n            // only used occasionally, for functions that need to access the original arguments\n            // to e.g., access their documentation\n            originalArgs: OriginalFunctionArgs\n        ) => USSRawValue\n    ) |\n    USSOpaqueValue\n)\n\nexport const constantCategories = ['basic', 'color', 'math', 'regression', 'mapper', 'logic', 'map', 'scale', 'ramp', 'unit', 'inset'] as const\n\nexport type ConstantCategory = typeof constantCategories[number]\n\nexport type DocumentationTable = 'mapper-data-variables' | 'predefined-colors' | 'unit-types' | 'predefined-ramps' | 'predefined-insets' | 'logarithm-functions' | 'trigonometric-functions'\n\nexport interface Documentation {\n    humanReadableName: string\n    priority?: number\n    /**\n     * True if this is the canonical default value for its type (e.g., the default ramp or scale).\n     */\n    isDefault?: boolean\n    /**\n     * Human-readable names for named arguments. Maps argument name to display name.\n     */\n    namedArgs?: Record<string, string>\n    /**\n     * Should be included when a constant should be deconstructed into an expression for user editing\n     */\n    equivalentExpressions?: UrbanStatsASTExpression[]\n    /**\n     * Included for all bulit-in constants.\n     */\n    category?: ConstantCategory\n    /**\n     * Whether the constant should be grouped with other constants in a table in the documentation.\n     * If present, this field groups the constant with other similar ones.\n     */\n    documentationTable?: DocumentationTable\n    /**\n     * Included for all bulit-in constants. Will be displayed in the documentation.\n     */\n    longDescription?: string\n}\n\nexport interface USSDocumentedType {\n    type: USSType\n    documentation?: Documentation\n\n}\n\nexport type USSValue = { value: USSRawValue } & USSDocumentedType\n\nexport function undocValue(value: USSRawValue, type: USSType): USSValue {\n    return {\n        type,\n        value,\n        documentation: undefined,\n    }\n}\n\nexport function createConstantExpression(value: number | string | boolean | null): UrbanStatsASTExpression {\n    // Create a simple constant expression for primitive values\n    if (typeof value === 'number') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'number', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'string') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'string', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'boolean') {\n        // For booleans, use identifier expressions that reference the predefined constants\n        return {\n            type: 'identifier',\n            name: { node: value.toString(), location: noLocation },\n        }\n    }\n    else {\n        // For null, use identifier expression that references the predefined null constant\n        return {\n            type: 'identifier',\n            name: { node: 'null', location: noLocation },\n        }\n    }\n}\n\nexport function unifyFunctionType(param: USSFunctionArgType, arg: USSType): boolean {\n    if (param.type === 'concrete') {\n        return renderType(param.value) === renderType(arg)\n    }\n    return arg.type === 'number' || arg.type === 'string' || arg.type === 'boolean' || arg.type === 'null'\n}\n\nexport function renderType(type: USSType): string {\n    if (type.type === 'number') {\n        return 'number'\n    }\n    if (type.type === 'string') {\n        return 'string'\n    }\n    if (type.type === 'boolean') {\n        return 'boolean'\n    }\n    if (type.type === 'vector') {\n        return `[${type.elementType.type === 'elementOfEmptyVector' ? '' : renderType(type.elementType)}]`\n    }\n    if (type.type === 'object') {\n        assert(type.properties instanceof Map, `Expected properties to be a Map, got ${typeof type.properties}`)\n        return `{${[...type.properties.entries()].sort().map(([k, v]) => `${k}: ${renderType(v)}`).join(', ')}}`\n    }\n    if (type.type === 'null') {\n        return 'null'\n    }\n    if (type.type === 'opaque') {\n        return type.name\n    }\n    return `(${type.posArgs.map(renderArgumentType).join(', ')}; ${Object.entries(type.namedArgs).map(([k, v]) => `${k}: ${renderKwargType(v)}`).join(', ')}) -> ${renderReturnType(type.returnType)}`\n}\n\nexport function renderArgumentType(arg: USSFunctionArgType): string {\n    if (arg.type === 'concrete') {\n        return renderType(arg.value)\n    }\n    return 'any'\n}\n\nexport function renderKwargType(arg: { type: USSFunctionArgType, defaultValue?: UrbanStatsASTExpression }): string {\n    const type = renderArgumentType(arg.type)\n    if (arg.defaultValue !== undefined) {\n        return `${type} = ${unparse(arg.defaultValue)}`\n    }\n    return type\n}\n\nfunction renderReturnType(ret: USSFunctionReturnType): string {\n    if (ret.type === 'concrete') {\n        return renderType(ret.value)\n    }\n    return 'any'\n}\n\nexport type ValueArg = (\n    { type: 'unnamed', value: USSValue } |\n    { type: 'named', name: string, value: USSValue }\n)\n\nexport function getPrimitiveType(value: USSRawValue, depth: number = 0): USSType {\n    if (depth === 0) {\n        if (typeof value === 'number') {\n            return { type: 'number' }\n        }\n        if (typeof value === 'string') {\n            return { type: 'string' }\n        }\n        if (typeof value === 'boolean') {\n            return { type: 'boolean' }\n        }\n        if (value === null) {\n            return { type: 'null' }\n        }\n    }\n    assert(Array.isArray(value), `Expected a primitive value, but got ${typeof value}`)\n    return getPrimitiveType(value[0], depth - 1)\n}\n\nexport function unifyType(\n    a: USSType | { type: 'elementOfEmptyVector' },\n    b: USSType | { type: 'elementOfEmptyVector' },\n    error: () => Error,\n): USSType | { type: 'elementOfEmptyVector' } {\n    if (a.type === 'elementOfEmptyVector') {\n        return b\n    }\n    if (b.type === 'elementOfEmptyVector') {\n        return a\n    }\n    if (renderType(a) === renderType(b)) {\n        return a\n    }\n    if (a.type === 'vector' && b.type === 'vector') {\n        return {\n            type: 'vector',\n            elementType: unifyType(a.elementType, b.elementType, error),\n        }\n    }\n    if (a.type === 'object' && b.type === 'object') {\n        if (JSON.stringify([...a.properties.keys()].sort()) !== JSON.stringify([...b.properties.keys()].sort())) {\n            throw error()\n        }\n        const properties = new Map<string, USSType>()\n        for (const [key, type] of a.properties) {\n            properties.set(key, type)\n        }\n        for (const [key, type] of b.properties) {\n            const res = unifyType(properties.get(key)!, type, error)\n            assert(res.type !== 'elementOfEmptyVector', `Unreachable`)\n            properties.set(key, res)\n        }\n        return {\n            type: 'object',\n            properties,\n        }\n    }\n    throw error()\n}\n\nexport function renderValue(input: USSValue): string {\n    function helper(value: USSValue, indent: string): string {\n        const type = value.type\n        switch (type.type) {\n            case 'boolean':\n            case 'null':\n            case 'number':\n                return `${value.value}`\n            case 'string':\n                return `\"${value.value}\"`\n            case 'opaque':\n                const opaqueValue = value.value as USSOpaqueValue\n                switch (opaqueValue.opaqueType) {\n                    case 'scale':\n                    case 'pMap':\n                    case 'cMap':\n                    case 'basemap':\n                    case 'inset':\n                    case 'insets':\n                    case 'geoFeatureHandle':\n                    case 'geoCentroidHandle':\n                    case 'unit':\n                        return `[${opaqueValue.opaqueType} object]`\n                    case 'color':\n                        const colorValue = opaqueValue.value as { r: number, g: number, b: number, a: number }\n                        if (colorValue.a === 255) {\n                            return `rgb(${colorValue.r / 255}, ${colorValue.g / 255}, ${colorValue.b / 255})`\n                        }\n                        else {\n                            return `rgb(${colorValue.r / 255}, ${colorValue.g / 255}, ${colorValue.b / 255}, a=${colorValue.a / 255})`\n                        }\n                    case 'outline':\n                        const outline = opaqueValue.value as { color: { r: number, g: number, b: number, a: number }, weight: number }\n                        const outlineColor = outline.color\n                        if (outlineColor.a === 255) {\n                            return `constructOutline(color=rgb(${outlineColor.r / 255}, ${outlineColor.g / 255}, ${outlineColor.b / 255}), weight=${outline.weight})`\n                        }\n                        else {\n                            return `constructOutline(color=rgb(${outlineColor.r / 255}, ${outlineColor.g / 255}, ${outlineColor.b / 255}, a=${outlineColor.a / 255}), weight=${outline.weight})`\n                        }\n                    case 'ramp':\n                        const ramp = opaqueValue.value\n                        const rampValue = ramp.map(\n                            ([position, color]) => {\n                                const contents: [string, USSRawValue][] = [\n                                        ['value', position] satisfies [string, USSRawValue],\n                                        ['color', { type: 'opaque', opaqueType: 'color', value: hexToColor(color) }] satisfies [string, USSRawValue],\n                                ] satisfies [string, USSRawValue][]\n                                return new Map(contents) satisfies Map<string, USSRawValue>\n                            },\n                        )\n                        const interior = undocValue(rampValue,\n                            {\n                                type: 'vector',\n                                elementType: {\n                                    type: 'object',\n                                    properties: new Map([\n                                        ['value', { type: 'number' }],\n                                        ['color', { type: 'opaque', name: 'color' }],\n                                    ]),\n                                },\n                            },\n                        )\n                        return `[ramp ${renderValue(interior)}]`\n                }\n            case 'vector':\n                const vector = value.value as USSRawValue[]\n                if (vector.length === 0) {\n                    return `[]`\n                }\n                // USSType assertion is OK since we handle zero-length vectors above\n                return `[\n${vector.map(element => `${indent}    ${helper(undocValue(element, type.elementType as USSType), `${indent}    `)}`).join(',\\n')}\n${indent}]`\n            case 'object':\n                const map = value.value as Map<string, USSRawValue>\n                if (map.size === 0) {\n                    return `{}`\n                }\n                return `{\n${Array.from(map.entries()).map(([key, element]) => `${indent}    ${key}: ${helper(undocValue(element, type.properties.get(key)!), `${indent}    `)}`).join(',\\n')}\n${indent}}`\n            case 'function':\n                return renderType(type)\n        }\n    }\n    return helper(input, '')\n}\n\nexport function canUnifyTo(a: USSType, b: USSType): boolean {\n    // returns true iff a can be used in a context where b is expected\n    if (renderType(a) === renderType(b)) {\n        return true\n    }\n    // at this point, the types are different\n    switch (b.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'null':\n        case 'opaque':\n            // these are all primitive types, so no way to substitute them\n            return false\n        case 'vector':\n            assert(b.elementType.type !== 'elementOfEmptyVector', `Unreachable`)\n            return canUnifyTo(a, b.elementType)\n        case 'object':\n            if (a.type !== 'object') {\n                return false\n            }\n            if (a.properties.size !== b.properties.size) {\n                return false\n            }\n            if (![...a.properties.keys()].every(key => b.properties.has(key))) {\n                return false\n            }\n            return [...a.properties.keys()].every(key => canUnifyTo(a.properties.get(key)!, b.properties.get(key)!))\n        case 'function':\n            return false\n    }\n}\n","import validGeographies from '../data/mapper/used_geographies'\nimport { Universe } from '../universe'\n\nimport { UrbanStatsASTStatement } from './ast'\nimport { EditorError } from './editor-utils'\nimport { USSOpaqueType, USSOpaqueValue, USSValue } from './types-values'\n\nexport type USSExecutionDescriptor = { kind: 'generic' } | { kind: 'mapper', geographyKind: typeof validGeographies[number], universe: Universe }\nexport interface USSExecutionRequest { descriptor: USSExecutionDescriptor, stmts: UrbanStatsASTStatement }\nexport type AsyncInterpretationError = EditorError[]\n\nexport interface USSExecutionResult<Value extends USSValue = USSValue> { resultingValue?: Value, error: AsyncInterpretationError }\n\nexport function executeAsync(request: { descriptor: { kind: 'mapper', geographyKind: typeof validGeographies[number], universe: Universe }, stmts: UrbanStatsASTStatement }): Promise<USSExecutionResult<{ type: USSOpaqueType, value: USSOpaqueValue & { opaqueType: 'cMap' | 'pMap' } }>>\nexport function executeAsync(request: USSExecutionRequest): Promise<USSExecutionResult>\nexport async function executeAsync(request: USSExecutionRequest): Promise<USSExecutionResult> {\n    if (sharedUSSWorker === undefined) {\n        sharedUSSWorker = createUSSWorker()\n    }\n    return await sharedUSSWorker(request)\n}\n\ntype USSWorker = (params: USSExecutionRequest) => Promise<USSExecutionResult>\n\nlet sharedUSSWorker: USSWorker | undefined\n\nconst terminationDelay = 10_000\n\nfunction createUSSWorker(): USSWorker {\n    const worker = new Worker(new URL('./worker', import.meta.url), { name: 'sharedUSSWorker' })\n    // The worker may return responses out of order, so we need to give them identifiers\n    const messageQueue = new Map<number, (result: USSExecutionResult) => void>()\n    worker.addEventListener('message', (message: MessageEvent<{ result: USSExecutionResult, id: number }>) => {\n        messageQueue.get(message.data.id)!(message.data.result)\n        messageQueue.delete(message.data.id)\n    })\n\n    // worker should terminate if not used\n    let terminationTimer: ReturnType<typeof setTimeout> | undefined\n    function resetTerminationTimer(): void {\n        clearTimeout(terminationTimer)\n        terminationTimer = setTimeout(() => {\n            if (messageQueue.size > 0) {\n                resetTerminationTimer()\n            }\n            else {\n                worker.terminate()\n                sharedUSSWorker = undefined\n            }\n        }, terminationDelay)\n    }\n    resetTerminationTimer()\n\n    let counter = 0\n    const result: USSWorker = (request) => {\n        resetTerminationTimer()\n        const id = ++counter\n        worker.postMessage({ request, id })\n        return new Promise((resolve) => {\n            messageQueue.set(id, resolve)\n        })\n    }\n\n    return result\n}\n"],"names":["Editor","param","uss","setUss","typeEnvironment","results","placeholder","selection","setSelection","eRef","setSelectionRef","useRef","script","useMemo","makeScript","colors","useColors","editorRef","_useState","undefined","autocompleteState","setAutocompleteState","_useState1","autocompleteSelectionIdx","setAutocompleteSelectionIdx","renderScript","useCallback","newScript","fragment","renderCode","r","token","content","t","createPlaceholder","editor","_editor","lastRenderScript","lastScript","useEffect","setRange","editScript","newUss","newRange","listener","range","getRange","s","document","nodeContent","tokenValue","options","getAutocompleteOptions","createAutocompleteMenu","apply","optionIdx","option","delta","e","i","range1","borderColor","useResultsColor","colorKey","codeStyle","TestUtils","DisplayResults","createPortal","Autocomplete","cKey","props","color","border","style","error","_","errors","longMessage","index","AutocompleteOption","hovering","setHovering","optionRef","_optionRef_current","locationOfLastExpression","node","locationOf","assert","unify","_key","locations","startLine","min","loc","Math","Number","endLine","max","startCol","endCol","startChar","endChar","getAllParseErrors","collectErrors","n","value","_errors","toStatement","colorType","rgbToColor","red","green","blue","alpha","tolerateError","Error","g","b","a","hsvToColor","hue","saturation","ColorLib","rgb","createConstantExpression","ctx","posArgs","namedArgs","hsv","renderColor","doRender","ignoreAlpha","hex","x","hexValue","h","drawFunction","functionName","param1","param2","param3","round","format","num","alphaPart","rgbColorExpression","_ref","forceAlpha","hsvColorExpression","c","colorConstant","name","isDefault","humanReadableName","camelToHuman","capitalizedName","hexToColor","parseNoErrorAsExpression","colorConstants","Object","hueColors","insetType","insetsType","boundsType","Map","constructInsetValue","screenBounds","mapBounds","screenBoundsObj","mapBoundsObj","mainMap","constructInsetsValue","insetsList","item","computeInsetConstantName","insetConsts","insets","regionInsets","inset","insetName","constantName","expr","insetNameToConstantName","instantiate","descriptor","_instantiate","forward","inverse","scaleType","linearScale","values","center","isNaN","isFinite","_Math","_Math1","computedMin","computedMax","linearScaleValue","logScaleValue","result","includeLocationInfo","renderLocInfo","renderValue","lex","modfiyTokenContent","span","brackets","DefaultMap","basicConstants","title","levelColor","level","Array","sum","next","openEquivalent","styleToString","_result","lexSpans","errorSpans","charIdx","indexInTokens","indexInErrors","errorLoc","errorLoc1","_errorSpans_spans1","_errorSpans_spans","_node_textContent","HTMLElement","window","positionInEditor","offset","sibling","currentRange","_getContainerOffset","anchorNode","anchorOffset","_getContainerOffset1","focusNode","focusOffset","getContainerOffset","position","key","tokens","currentIdentifer","allIdentifiers","Set","_iteratorError","_iteratorError1","id","match","isAMatch","matchCount","prevMatch","j","placeholderText","useUndoRedo","initialState","initialSelection","onStateChange","onSelectionChange","undoChunking","undoHistory","onlyElement","undoStack","redoStack","addState","state","currentUndoState","Date","updateCurrentSelection","undo","prevState","redo","futureState","isMac","navigator","InterpretationError","message","location","p","evaluate","env","undocValue","varName","res","lookupResult","attrLookupOrSet","func","args","arg","broadcastResult","broadcastCall","evaluateUnaryOperator","operand","operator","errLoc","operatorObj","expressionOperatorMap","broadcastApply","evaluateBinaryOperator","left","right","elements","elementType","unifyType","JSON","renderType","ts","vs","v","condition","splitMask","subEnv","execute","doResult","_iteratorError2","statement","canUnifyTo","evaluateLHS","lhs","err","obj","attr","orSet","type","val","_instanceof","_type_of","aT","val1","orSetLookp","addAdditionalDims","idx","resultsOrErr","rawValue","typ","nonExpressionOperators","operatorCharacters","keywords","isDigit","ch","isAlpha","emptyLocation","ident","parseNumber","input","parseFloat","component","component1","identifierLexer","string","operatorLexer","block","lines","line","lineTokens","lexLine","lineNo","charIdxOffset","char","token1","lexNumber","numberFormat","numberStr","number","_iter","lexer","token2","lexGeneric","start","token3","lexString","resultObj","_tokens","noLocation","extendBlockIdPositionalArg","blockIdent","extendBlockIdKwarg","argName","extendBlockIdVectorElement","extendBlockIdObjectProperty","property","unparse","opts","isSimpleExpression","indentSpaces","_opts_expressionalContext","_opts_indent","exprStr","fnStr","argsStr","fnNeedsParens","unaryExprStr","needsParens","exprWithParens","_expressionOperatorMap_get_precedence","_expressionOperatorMap_get_precedence1","_expressionOperatorMap_get_precedence2","leftStr","rightStr","opPrecedence","leftWithParens","leftOpPrecedence","rightWithParens","rightOpPrecedence","elementsStr","elem","propertiesStr","valueStr","lhsStr","statementsStr","stmt","conditionStr","thenStr","ifStr","elseStr","doStr","condStr","restStr","ParseState","skipEOL","consumeTokenOfType","consumeOperator","oneOfOps","consumeBracket","oneOfBrackets","consumeIdentifier","consumeKeyword","oneOfKeywords","maybeLastNonEOLToken","parseSingleExpression","startLoc","properties","keyToken","endLoc","vectorStartLoc","element","vectorEndLoc","parseArg","exprOrName","parseParenthesizedArgs","parseFunctionalExpression","fn","done","parseExpression","operatorExpSequence","loop","unaryOperators","infixOperators","operator1","parseInfixSequence","precedences","maxPrecedence","resolveOperator","checkLHS","parseStatement","parseIfExpression","ifToken","then","elseBranch","eb","lastToken","parseDoExpression","doToken","statements","parseConditionStatement","conditionToken","parseStatements","canEnd","end","errMsg","mergeStatements","fallbackLocation","gulpRestForConditions","_stmt_rest","entireLoc","parseCustomNodeExpression","argsRes","_argsRes_args","locArg","code","parseResult","parse","returnParseErrorNode","parseTokens","originalCode","lexErrors","stmts","identifiersInExpr","expressions","identifiers","allExpressions","helper","newIdentifiers","_ctx_getVariable","dv","newId","parseNoError","blockId","parseNoErrorAsCustomNode","expectedType","getPrimitiveType","depth","indent","opaqueValue","colorValue","outline","outlineColor","interior","ramp","vector","map","key1","type1","constantCategories","unifyFunctionType","ret","k","renderArgumentType","renderReturnType","renderKwargType","sharedUSSWorker","executeAsync","request","createUSSWorker","terminationTimer","worker","Worker","URL","messageQueue","resetTerminationTimer","clearTimeout","setTimeout","counter","Promise","resolve"],"mappings":"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"}