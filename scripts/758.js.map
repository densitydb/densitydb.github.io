{"version":3,"file":"758.js","sources":["webpack://assets/./src/urban-stats-script/context.ts","webpack://assets/./src/urban-stats-script/worker.ts"],"sourcesContent":["import assert from 'assert'\n\nimport { Effect, InterpretationError } from './interpreter'\nimport { LocInfo } from './location'\nimport { USSValue } from './types-values'\n\nexport class Context {\n    #effect: (eff: Effect) => void\n    #error: (msg: string, location: LocInfo) => InterpretationError\n    #constants: Map<string, USSValue>\n    #variables: Map<string, USSValue>\n\n    constructor(effect: (eff: Effect) => void, error: (msg: string, location: LocInfo) => InterpretationError, constants: Map<string, USSValue>, variables: Map<string, USSValue>) {\n        this.#effect = effect\n        this.#error = error\n        this.#constants = constants\n        this.#variables = variables\n        for (const name of variables.keys()) {\n            assert(!constants.has(name), `Variable name \"${name}\" conflicts with a constant`)\n        }\n    }\n\n    effect(eff: Effect): void {\n        this.#effect(eff)\n    }\n\n    error(msg: string, location: LocInfo): InterpretationError {\n        return this.#error(msg, location)\n    }\n\n    getVariable(name: string): USSValue | undefined {\n        if (this.#constants.has(name)) {\n            return this.#constants.get(name)\n        }\n        return this.#variables.get(name)\n    }\n\n    assignVariable(name: string, value: USSValue): string | undefined {\n        if (this.#constants.has(name)) {\n            return `Cannot assign to constant \"${name}\"`\n        }\n        this.#variables.set(name, value)\n        return undefined\n    }\n\n    variableEntries(): IterableIterator<[string, USSValue]> {\n        return this.#variables.entries()\n    }\n\n    evolveVariables(variables: Map<string, USSValue>): Context {\n        return new Context(\n            this.#effect,\n            this.#error,\n            this.#constants,\n            variables,\n        )\n    }\n}\n","import { emptyContext } from '../../unit/urban-stats-script-utils'\nimport { Inset, Insets } from '../components/map'\nimport insets from '../data/insets'\nimport validGeographies from '../data/mapper/used_geographies'\nimport statistic_path_list from '../data/statistic_path_list'\nimport statistic_variables_info from '../data/statistic_variables_info'\nimport { loadDataInIndexOrder, loadProtobuf } from '../load_json'\nimport { mapperContext, defaultTypeEnvironment } from '../mapper/context'\nimport { indexLink } from '../navigation/links'\nimport { Universe } from '../universe'\nimport { assert } from '../utils/defensive'\n\nimport { locationOfLastExpression, UrbanStatsASTExpression } from './ast'\nimport { insetNameToConstantName } from './constants/insets'\nimport { Context } from './context'\nimport { EditorError } from './editor-utils'\nimport { Effect, execute, InterpretationError } from './interpreter'\nimport { noLocation } from './location'\nimport { renderType, USSRawValue, USSValue } from './types-values'\nimport { USSExecutionRequest, USSExecutionResult } from './workerManager'\n\nlet mapperCache: {\n    universe: Universe\n    geographyKind: typeof validGeographies[number]\n    longnames: string[]\n    dataCache: Map<string, number[]>\n} | undefined\n\nasync function executeRequest(request: USSExecutionRequest): Promise<USSExecutionResult> {\n    let context, getWarnings\n    try {\n        ([context, getWarnings] = await contextForRequest(request))\n\n        const result = execute(request.stmts, context)\n\n        switch (request.descriptor.kind) {\n            case 'generic': {\n                break\n            }\n            case 'mapper': {\n                // no idea why we need this, but it's obviously correct from the switch\n                if (renderType(result.type) !== 'cMap' && renderType(result.type) !== 'pMap') {\n                    throw new InterpretationError(`USS expression did not return a cMap or pMap type, got: ${renderType(result.type)}`, locationOfLastExpression(request.stmts))\n                }\n                break\n            }\n        }\n        return { resultingValue: { type: result.type, value: removeFunctions(result.value) }, error: getWarnings() }\n    }\n    catch (error) {\n        let interpretationError: InterpretationError\n        if (error instanceof InterpretationError) {\n            interpretationError = error\n        }\n        else {\n            console.error('Unknown interpretation error', error)\n            interpretationError = new InterpretationError('Unknown interpretation error', noLocation)\n        }\n        return { error: [{ type: 'error', value: interpretationError.value, location: interpretationError.location, kind: 'error' }, ...(getWarnings?.() ?? [])] }\n    }\n}\n\nasync function contextForRequest(request: USSExecutionRequest): Promise<[Context, () => EditorError[]]> {\n    const effects: Effect[] = []\n    const getWarnings = (): EditorError[] => {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- just so if there's additonal types, we're safe\n        return effects.filter(eff => eff.type === 'warning').map(eff => ({\n            type: 'error',\n            value: eff.message,\n            location: eff.location,\n            kind: 'warning',\n        }))\n    }\n    switch (request.descriptor.kind) {\n        case 'generic':\n            return [emptyContext(effects), getWarnings]\n        case 'mapper':\n            return [await mapperContextForRequest(request as USSExecutionRequest & { descriptor: { kind: 'mapper' } }, effects), getWarnings]\n    }\n}\n\nasync function mapperContextForRequest(request: USSExecutionRequest & { descriptor: { kind: 'mapper' } }, effects: Effect[]): Promise<Context> {\n    const geographyKind = request.descriptor.geographyKind\n    const universe = request.descriptor.universe\n    const dte = defaultTypeEnvironment(universe)\n    if (!validGeographies.includes(geographyKind)) {\n        throw new Error('invalid geography')\n    }\n\n    // Load geography names and set up cache\n    let longnames: string[]\n\n    if (mapperCache?.geographyKind === geographyKind && mapperCache.universe === universe) {\n        longnames = mapperCache.longnames\n    }\n    else {\n        // Load geography names from index\n        const indexData = await loadProtobuf(indexLink(universe, geographyKind), 'ArticleOrderingList')\n        longnames = indexData.longnames\n        mapperCache = {\n            universe,\n            geographyKind,\n            longnames,\n            dataCache: new Map(),\n        }\n    }\n\n    const annotateType = (name: string, val: USSRawValue): USSValue => {\n        const typeInfo = dte.get(name)\n        assert(typeInfo !== undefined, `Type info for ${name} not found`)\n        return {\n            type: typeInfo.type,\n            documentation: typeInfo.documentation,\n            value: val,\n        }\n    }\n\n    const getVariable = async (name: string): Promise<USSValue | undefined> => {\n        assert(mapperCache !== undefined, 'mapperCache was initialized above and is never undefined after that')\n        if (name === 'geo') {\n            return annotateType('geo', longnames.map(longname => ({ type: 'opaque', opaqueType: 'geoFeatureHandle', value: longname })))\n        }\n        if (name === 'geoCentroid') {\n            return annotateType('geoCentroid', longnames.map(longname => ({ type: 'opaque', opaqueType: 'geoCentroidHandle', value: longname })))\n        }\n        if (name === 'defaultInsets') {\n            return annotateType('defaultInsets', { type: 'opaque', opaqueType: 'insets', value: loadInset(request.descriptor.universe) })\n        }\n        const variableInfo = statistic_variables_info.variableNames.find(v => v.varName === name)\n        if (!variableInfo) {\n            return undefined\n        }\n        const index = variableInfo.index\n\n        // Check cache first\n        const existing = mapperCache.dataCache.get(name)\n        if (existing !== undefined) {\n            return annotateType(name, existing)\n        }\n\n        const statpath = statistic_path_list[index]\n\n        const variableData = await loadDataInIndexOrder(universe, statpath, geographyKind)\n        assert(Array.isArray(variableData), `Expected variable data for ${name} to be an array`)\n        mapperCache.dataCache.set(name, variableData)\n        return annotateType(name, variableData)\n    }\n\n    const context = await mapperContext(request.stmts, getVariable, effects, universe)\n    return context\n}\n\nfunction removeFunctions(value: USSRawValue): USSRawValue {\n    if (value instanceof Function) {\n        return null\n    }\n    else if (Array.isArray(value)) {\n        return value.map(removeFunctions)\n    }\n    else if (value instanceof Map) {\n        return new Map(Array.from(value.entries()).map(([k, v]) => [k, removeFunctions(v)]))\n    }\n    else if (value instanceof Object && value.value instanceof Function) {\n        assert(value.opaqueType === 'scale', 'only scales can have functions in their value')\n        return null\n    }\n    return value\n}\n\nonmessage = async (message: MessageEvent<{ request: USSExecutionRequest, id: number }>) => {\n    if (!('request' in message.data)) {\n        // Some other message (e.g. from React devtools)\n        return\n    }\n    const result = await executeRequest(message.data.request)\n    postMessage({ result, id: message.data.id })\n}\n\nexport function loadInset(universe: Universe): Insets {\n    const insetsU = insets[universe]\n    assert(insetsU.length > 0, `No insets for universe ${universe}`)\n    assert(insetsU[0].mainMap, `No main map for universe ${universe}`)\n    const insetsProc = insetsU.map((inset) => {\n        return {\n            bottomLeft: [inset.bottomLeft[0], inset.bottomLeft[1]],\n            topRight: [inset.topRight[0], inset.topRight[1]],\n            // copy to get rid of readonly\n            coordBox: [...inset.coordBox],\n            mainMap: inset.mainMap,\n        } satisfies Inset\n    })\n    return insetsProc\n}\n\nexport function loadInsetExpression(universe: Universe): UrbanStatsASTExpression {\n    const insetsU = insets[universe]\n    const names = insetsU.map(x => x.name)\n\n    const exprs = names.map((name) => {\n        const expr = insetNameToConstantName.get(name)\n        assert(expr !== undefined, `No inset constant for ${name}`)\n        return { type: 'identifier', name: { node: expr, location: noLocation } } satisfies UrbanStatsASTExpression\n    })\n\n    return {\n        type: 'call',\n        fn: { type: 'identifier', name: { node: 'constructInsets', location: noLocation } },\n        args: [{\n            type: 'unnamed',\n            value: {\n                type: 'vectorLiteral',\n                elements: exprs,\n                entireLoc: noLocation,\n            } satisfies UrbanStatsASTExpression,\n        }],\n        entireLoc: noLocation,\n    } satisfies UrbanStatsASTExpression\n}\n"],"names":["_effect","_error","_constants","_variables","Context","effect","error","constants","variables","_iteratorError","name","assert","eff","msg","location","getVariable","assignVariable","value","variableEntries","evolveVariables","mapperCache","loadInset","universe","insetsU","insets","inset","loadInsetExpression","exprs","names","x","expr","insetNameToConstantName","undefined","noLocation","onmessage","message","request","context","getWarnings","result","interpretationError","_getWarnings","effects","emptyContext","geographyKind","dte","longnames","annotateType","defaultTypeEnvironment","validGeographies","Error","loadProtobuf","indexLink","indexData","Map","val","typeInfo","variableInfo","index","existing","statpath","variableData","longname","statistic_variables_info","v","statistic_path_list","loadDataInIndexOrder","Array","mapperContext","execute","renderType","InterpretationError","locationOfLastExpression","removeFunctions","_instanceof","Function","k","Object","console","postMessage"],"mappings":"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"}