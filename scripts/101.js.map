{"version":3,"file":"101.js","sources":["webpack://assets/./src/utils/partition.ts","webpack://assets/./src/map-partition.ts"],"sourcesContent":["/**\n * Efficiently finds the best partition in some search space, given a hueristic\n * The hueristic must not increase when an element is added to any partition in the partition set that is ordred greater than all the elements already in the partition\n *\n * Example: (match numbers to partition group index parity)\n * bestPartition(3, 2, ps => ps.reduce((a, p, i) => a + p.reduce((b, n) => b + n % 2 !== i % 2 ? 1 : 0, 0), 0), (a, b) => b - a) -> [[0, 2], [1]]\n *\n * This function has a built-in time limit, and will stop generating if it starts taking too long\n */\nexport function bestPartition<Score>(upperBound: number, maxPartitions: number, score: (partition: number[][]) => Score, compareScores: (a: Score, b: Score) => number): number[][] {\n    const timeLimit = Date.now() + 500\n    let bestScore: Score | undefined\n    let best: number[][] | undefined\n\n    function helper(index: number, current: number[][], currentScore?: Score): void {\n        if (Date.now() > timeLimit) {\n            throw new Error('out of time')\n        }\n\n        if (index === upperBound) {\n            currentScore = currentScore ?? score(current)\n            if (bestScore === undefined || compareScores(currentScore, bestScore) > 0) {\n                bestScore = currentScore\n                best = current\n            }\n            return\n        }\n\n        if (current.length === 0) {\n            helper(index + 1, [[index]])\n            return\n        }\n\n        for (let i = 0; i < current.length; i++) {\n            const newPartition = current.map((subset, j) =>\n                i === j ? [...subset, index] : subset,\n            )\n            const newPartitionScore = score(newPartition)\n            if (bestScore === undefined || compareScores(newPartitionScore, bestScore) >= 0) {\n                helper(index + 1, newPartition, newPartitionScore)\n            }\n        }\n\n        if (current.length < maxPartitions) {\n            const newPartition = [...current, [index]]\n            helper(index + 1, newPartition)\n        }\n    }\n\n    helper(0, [])\n    return best!\n}\n","import geojsonExtent from '@mapbox/geojson-extent'\nimport maplibregl from 'maplibre-gl'\nimport { min } from 'mathjs'\n\nimport { bestPartition } from './utils/partition'\nimport { Feature } from './utils/protos'\nimport { loadFeatureFromPossibleSymlink } from './utils/symlinks'\nimport { NormalizeProto } from './utils/types'\n\nexport function geometry(poly: NormalizeProto<Feature>): GeoJSON.Geometry {\n    if (poly.geometry === 'multipolygon') {\n        const polys = poly.multipolygon.polygons\n        const coords = polys.map(\n            multiPoly => multiPoly.rings.map(\n                ring => ring.coords.map(\n                    coordinate => [coordinate.lon, coordinate.lat],\n                ),\n            ),\n        )\n        return {\n            type: 'MultiPolygon',\n            coordinates: coords,\n        }\n    }\n    else {\n        const coords = poly.polygon.rings.map(\n            ring => ring.coords.map(\n                coordinate => [coordinate.lon, coordinate.lat],\n            ),\n        )\n        return {\n            type: 'Polygon',\n            coordinates: coords,\n        }\n    }\n}\n\nconst boundingBoxCache = new WeakMap<GeoJSON.Geometry, maplibregl.LngLatBounds>()\n\nexport function boundingBox(geo: GeoJSON.Geometry): maplibregl.LngLatBounds {\n    let result: maplibregl.LngLatBounds | undefined\n    if ((result = boundingBoxCache.get(geo)) !== undefined) {\n        return result\n    }\n\n    const bbox = geojsonExtent(geo)\n    result = new maplibregl.LngLatBounds(\n        new maplibregl.LngLat(bbox[0], bbox[1]),\n        new maplibregl.LngLat(bbox[2], bbox[3]),\n    )\n    boundingBoxCache.set(geo, result)\n\n    return result\n}\n\nexport function extendBoxes(boxes: maplibregl.LngLatBounds[]): maplibregl.LngLatBounds {\n    return boxes.reduce((result, box) => result.extend(box), new maplibregl.LngLatBounds())\n}\n\n// Area of bounds in EPSG:3857 projection\nfunction area(bounds: maplibregl.LngLatBounds): number {\n    const sw = maplibregl.MercatorCoordinate.fromLngLat(bounds.getSouthWest())\n    const ne = maplibregl.MercatorCoordinate.fromLngLat(bounds.getNorthEast())\n    // Handle wrapping by normalizing x difference\n    let dx = ne.x - sw.x\n    if (dx < 0) {\n        dx += 1 // Web Mercator x wraps at 1\n    }\n    return Math.abs(dx * (ne.y - sw.y))\n}\n\nfunction proportionFilled(boxes: maplibregl.LngLatBounds[]): number {\n    return boxes.reduce((a, box) => a + area(box), 0) / area(extendBoxes(boxes))\n}\n\n/**\n * Given many regions to be compared, determine how best to split them into multiple maps\n *\n * If the bounds of the regions fill a map above some threshold, put all the regions in the same map\n *\n * Otherwise, weigh multiple groupings to determine the best one\n */\nexport async function partitionLongnames(longnames: string[]): Promise<number[][]> {\n    const fillThreshold = 0.1\n    const maxMaps = 6\n\n    const boundingBoxes = await Promise.all(longnames.map(async longname => boundingBox(geometry(await loadFeatureFromPossibleSymlink(longname) as NormalizeProto<Feature>))))\n\n    // We need to sort the bounding boxes otherwise there could be an edge case when partitioning where a region gets added in the middle of a partition two other regions\n    // The partition of those two far partitions would not have been explored in `bestPartition`, since the hueristic would have eliminated that search space.\n    // Therefore, we need to sort the bounding boxes\n    const sortedBoundingBoxes = Array.from(boundingBoxes.entries())\n        .sort(([, a], [, b]) => a.getCenter().lat - b.getCenter().lat)\n        .sort(([, a], [, b]) => a.getCenter().lng - b.getCenter().lng)\n\n    try {\n        const partitions = bestPartition(sortedBoundingBoxes.length, maxMaps,\n            ps => ps.map((partition) => {\n                const filled = proportionFilled(partition.map(index => sortedBoundingBoxes[index][1]))\n                if (filled >= fillThreshold) {\n                    return partition.length\n                }\n                return filled\n            }).sort((a, b) => a - b),\n            (a, b) => {\n                for (let i = 0; i < Math.min(a.length, b.length); i++) {\n                    if (a[i] !== b[i]) {\n                        return a[i] - b[i]\n                    }\n                }\n                return a.length - b.length\n            },\n        )\n\n        // Un-sort the indices\n        // Also re-sort the partitions by the unsorted indices\n        const unsortedPartitions = partitions.map(partition => partition.map(index => sortedBoundingBoxes[index][0])\n            .sort((a, b) => a - b)).sort((a, b) => min(a) - min(b))\n\n        return unsortedPartitions\n    }\n    catch (e) {\n        console.warn('Error partitioning maps', e)\n    }\n\n    // Give up\n    return [longnames.map((_, i) => i)]\n}\n"],"names":["geometry","poly","polys","multiPoly","ring","coordinate","boundingBoxCache","WeakMap","boundingBox","geo","result","undefined","bbox","geojsonExtent","maplibregl","extendBoxes","boxes","box","area","bounds","sw","ne","dx","Math","partitionLongnames","longnames","fillThreshold","maxMaps","sortedBoundingBoxes","unsortedPartitions","Promise","longname","loadFeatureFromPossibleSymlink","Array","boundingBoxes","a","b","upperBound","maxPartitions","score","compareScores","bestScore","best","timeLimit","ps","partition","filled","index","i","Date","helper","current","currentScore","newPartition","subset","j","newPartitionScore","Error","partitions","min","e","console","_"],"mappings":"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"}