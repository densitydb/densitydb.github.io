{"version":3,"file":"101.js","sources":["webpack://assets/./src/utils/partition.ts","webpack://assets/./src/map-partition.ts"],"sourcesContent":["/**\n * indexPartitions(2, () => true) -> [[0, 1]], [[0], [1]]\n * indexPartitions(3, () => true) -> [[0, 1, 2]], [[0, 1], [2]], [[0, 2], [1]], [[0], [1, 2]], [[0], [1], [2]]\n * indexPartitions(3, p => p.every(i => Math.abs(p[0] - i) < 2)) -> [[0, 1], [2]], [[0], [1, 2]], [[0], [1], [2]]\n *\n * `goodPartition` is a filter function that reduces the search space if a partition could not possibly become valid by adding more elements with a higher index\n *\n * This function has a built-in time limit, and will stop generating if it starts taking too long\n */\nexport function indexPartitions(upperBound: number, goodPartition: (partition: number[]) => boolean): Generator<number[][], void> {\n    const timeLimit = Date.now() + 500\n\n    function* helper(index: number, current: number[][]): Generator<number[][], void> {\n        if (Date.now() > timeLimit) {\n            throw new Error('out of time')\n        }\n\n        if (index === upperBound) {\n            yield current\n            return\n        }\n\n        if (current.length === 0) {\n            yield* helper(index + 1, [[index]])\n            return\n        }\n\n        for (let i = 0; i < current.length; i++) {\n            if (goodPartition([...current[i], index])) {\n                const newPartition = current.map((subset, j) =>\n                    i === j ? [...subset, index] : subset,\n                )\n                yield* helper(index + 1, newPartition)\n            }\n        }\n\n        yield* helper(index + 1, [...current, [index]])\n    }\n\n    return helper(0, [])\n}\n","import geojsonExtent from '@mapbox/geojson-extent'\nimport maplibregl from 'maplibre-gl'\nimport { min } from 'mathjs'\n\nimport { indexPartitions } from './utils/partition'\nimport { Feature } from './utils/protos'\nimport { loadShapeFromPossibleSymlink } from './utils/symlinks'\nimport { NormalizeProto } from './utils/types'\n\nexport function geometry(poly: NormalizeProto<Feature>): GeoJSON.Geometry {\n    if (poly.geometry === 'multipolygon') {\n        const polys = poly.multipolygon.polygons\n        const coords = polys.map(\n            multiPoly => multiPoly.rings.map(\n                ring => ring.coords.map(\n                    coordinate => [coordinate.lon, coordinate.lat],\n                ),\n            ),\n        )\n        return {\n            type: 'MultiPolygon',\n            coordinates: coords,\n        }\n    }\n    else {\n        const coords = poly.polygon.rings.map(\n            ring => ring.coords.map(\n                coordinate => [coordinate.lon, coordinate.lat],\n            ),\n        )\n        return {\n            type: 'Polygon',\n            coordinates: coords,\n        }\n    }\n}\n\nexport function boundingBox(geo: GeoJSON.Geometry): maplibregl.LngLatBounds {\n    const bbox = geojsonExtent(geo)\n    return new maplibregl.LngLatBounds(\n        new maplibregl.LngLat(bbox[0], bbox[1]),\n        new maplibregl.LngLat(bbox[2], bbox[3]),\n    )\n}\n\nexport function extendBoxes(boxes: maplibregl.LngLatBounds[]): maplibregl.LngLatBounds {\n    return boxes.reduce((result, box) => result.extend(box), new maplibregl.LngLatBounds())\n}\n\n// Area of bounds in EPSG:3857 projection\nfunction area(bounds: maplibregl.LngLatBounds): number {\n    const sw = maplibregl.MercatorCoordinate.fromLngLat(bounds.getSouthWest())\n    const ne = maplibregl.MercatorCoordinate.fromLngLat(bounds.getNorthEast())\n    // Handle wrapping by normalizing x difference\n    let dx = ne.x - sw.x\n    if (dx < 0) {\n        dx += 1 // Web Mercator x wraps at 1\n    }\n    return Math.abs(dx * (ne.y - sw.y))\n}\n\nfunction proportionFilled(boxes: maplibregl.LngLatBounds[]): number {\n    return boxes.reduce((a, box) => a + area(box), 0) / area(extendBoxes(boxes))\n}\n\n/**\n * Given many regions to be compared, determine how best to split them into multiple maps\n *\n * If the bounds of the regions fill a map above some threshold, put all the regions in the same map\n *\n * Otherwise, weigh multiple groupings to determine the best one\n */\nexport async function partitionLongnames(longnames: string[]): Promise<number[][]> {\n    const fillThreshold = 0.1\n\n    const boundingBoxes = await Promise.all(longnames.map(async longname => boundingBox(geometry(await loadShapeFromPossibleSymlink(longname) as NormalizeProto<Feature>))))\n\n    // We need to sort the bounding boxes otherwise there could be an edge case when partitioning where a region gets added in the middle of a partition two other regions\n    // The partition of those two far partitions would not have been explored in `indexPartitions`, since `goodPartition` would have eliminated that search space.\n    // Therefore, we need to sort the bounding boxes\n    const sortedBoundingBoxes = Array.from(boundingBoxes.entries())\n        .sort(([, a], [, b]) => a.getCenter().lat - b.getCenter().lat)\n        .sort(([, a], [, b]) => a.getCenter().lng - b.getCenter().lng)\n\n    try {\n        for (const partitions of indexPartitions(sortedBoundingBoxes.length, partition => proportionFilled(partition.map(index => sortedBoundingBoxes[index][1])) > fillThreshold)) {\n            // Only iterates over good partitions\n\n            // Un-sort the indices\n            // Also re-sort the partitions by the unsorted indices\n            const unsortedPartitions = partitions.map(partition => partition.map(index => sortedBoundingBoxes[index][0])\n                .sort((a, b) => a - b)).sort((a, b) => min(a) - min(b))\n            return unsortedPartitions\n        }\n    }\n    catch (e) {\n        console.warn('Error partitioning maps', e)\n    }\n\n    // Give up\n    return [longnames.map((_, i) => i)]\n}\n"],"names":["geometry","poly","polys","multiPoly","ring","coordinate","boundingBox","geo","bbox","geojsonExtent","maplibregl","extendBoxes","boxes","result","box","area","bounds","sw","ne","dx","Math","partitionLongnames","longnames","fillThreshold","sortedBoundingBoxes","_iteratorError","unsortedPartitions","Promise","longname","loadShapeFromPossibleSymlink","Array","boundingBoxes","a","b","upperBound","goodPartition","timeLimit","indexPartitions","partition","proportionFilled","index","Date","helper","current","i","newPartition","subset","j","Error","partitions","min","e","console","_"],"mappings":"0PAQC,gB,2/ICCM,SAASA,EAASC,CAA6B,QAClD,AAAIA,AAAkB,iBAAlBA,EAAK,QAAQ,CASN,CACH,KAAM,eACN,YATWC,AADDD,EAAK,YAAY,CAAC,QAAQ,CACnB,GAAG,CACpBE,SAAAA,CAAS,E,OAAIA,EAAU,KAAK,CAAC,GAAG,CAC5BC,SAAAA,CAAI,E,OAAIA,EAAK,MAAM,CAAC,GAAG,CACnBC,SAAAA,CAAU,E,MAAI,CAACA,EAAW,GAAG,CAAEA,EAAW,GAAG,CAAC,A,MAO1D,EAQO,CACH,KAAM,UACN,YAPWJ,EAAK,OAAO,CAAC,KAAK,CAAC,GAAG,CACjCG,SAAAA,CAAI,E,OAAIA,EAAK,MAAM,CAAC,GAAG,CACnBC,SAAAA,CAAU,E,MAAI,CAACA,EAAW,GAAG,CAAEA,EAAW,GAAG,CAAC,A,IAMtD,CAER,CAEO,SAASC,EAAYC,CAAqB,EAC7C,IAAMC,EAAOC,IAAcF,GAC3B,OAAO,GAAIG,AAAAA,CAAAA,GAAAA,EAAAA,YAAuB,CAC9B,GAAIA,AAAAA,CAAAA,GAAAA,EAAAA,MAAiB,CAACF,CAAI,CAAC,EAAE,CAAEA,CAAI,CAAC,EAAE,EACtC,GAAIE,AAAAA,CAAAA,GAAAA,EAAAA,MAAiB,CAACF,CAAI,CAAC,EAAE,CAAEA,CAAI,CAAC,EAAE,EAE9C,CAEO,SAASG,EAAYC,CAAgC,EACxD,OAAOA,EAAM,MAAM,CAAC,SAACC,CAAM,CAAEC,CAAG,E,OAAKD,EAAO,MAAM,CAACC,E,EAAM,GAAIJ,AAAAA,CAAAA,GAAAA,EAAAA,YAAuB,CACxF,CAGA,SAASK,EAAKC,CAA+B,EACzC,IAAMC,EAAKP,IAAAA,kBAAAA,CAAAA,UAAwC,CAACM,EAAO,YAAY,IACjEE,EAAKR,IAAAA,kBAAAA,CAAAA,UAAwC,CAACM,EAAO,YAAY,IAEnEG,EAAKD,EAAG,CAAC,CAAGD,EAAG,CAAC,CAIpB,OAHIE,EAAK,GACLA,CAAAA,GAAM,GAEHC,KAAK,GAAG,CAACD,EAAMD,CAAAA,EAAG,CAAC,CAAGD,EAAG,CAAC,AAAD,EACpC,CAaO,SAAeI,EAAmBC,CAAmB,E,wBAClDC,EAOAC,EAKGC,EAAAA,EAAAA,EAAAA,EAAAA,EAKKC,E,iDAfQ,OAFhBH,EAAgB,GAEA,C,EAAMI,QAAQ,GAAG,CAACL,EAAU,GAAG,CAAC,SAAMM,CAAQ,E,qEAAyB,O,EAAMC,AAAAA,GAAAA,EAAAA,EAAAA,AAAAA,EAA6BD,G,iBAAxDtB,EAAAA,KAAAA,CAAAA,KAAAA,EAAAA,CAAYN,EAAAA,KAAAA,CAAAA,KAAAA,EAAAA,CAAS,S,uBAKvFwB,EAAsBM,MAAM,IAAI,CAACC,AALjB,SAK+B,OAAO,IACvD,IAAI,CAAC,c,IAAIC,EAAAA,A,MAAAA,CAAAA,EAAAA,CAAOC,EAAAA,AAAPD,EAAAA,EAAAA,EAAOC,CAAAA,EAAAA,C,OAAOD,EAAE,SAAS,GAAG,GAAG,CAAGC,EAAE,SAAS,GAAG,GAAG,A,GAC5D,IAAI,CAAC,c,IAAID,EAAAA,A,MAAAA,CAAAA,EAAAA,CAAOC,EAAAA,AAAPD,EAAAA,EAAAA,EAAOC,CAAAA,EAAAA,C,OAAOD,EAAE,SAAS,GAAG,GAAG,CAAGC,EAAE,SAAS,GAAG,GAAG,A,GAEjE,GAAI,CACKR,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,O,QD5EmBS,EAAoBC,EAC1CC,EC2EF,IAAKX,EAAoBY,CD5EDH,EC4EiBV,EAAoB,MAAM,CD5EvBW,EC4EyBG,SAAAA,CAAS,MAxB5D1B,E,MAwBgE2B,AAvB/E3B,CADeA,EAwBiF0B,EAAU,GAAG,CAACE,SAAAA,CAAK,E,OAAIhB,CAAmB,CAACgB,EAAM,CAAC,EAAE,A,IAvB9I,MAAM,CAAC,SAACR,CAAC,CAAElB,CAAG,E,OAAKkB,EAAIjB,EAAKD,E,EAAM,GAAKC,EAAKJ,EAAYC,IAuB2FW,C,ED3E1Ja,EAAYK,KAAK,GAAG,GAAK,IA6BxBC,AA3BP,SAAUA,EAAOF,CAAa,CAAEG,CAAmB,E,MAetCC,E,iDAdT,G,kBAgBcC,E,qDADNV,EAAe,EAAGQ,CAAO,CAACC,EAAE,UAAEJ,E,GAA9BL,MAAAA,C,KAIA,OAHMU,EAAeF,EAAQ,GAAG,CAAC,SAACG,CAAM,CAAEC,CAAC,E,OACvCH,IAAMG,EAAK,EAAGD,GAAAA,MAAAA,CAAJ,CAAYN,EAAM,EAAGM,C,GAEnC,C,IAAOJ,EAAOF,EAAQ,EAAGK,I,QAAzB,S,6BAER,EArBIJ,KAAK,GAAG,GAAKL,EACb,MAAM,AAAIY,MAAM,e,GAGhBR,IAAUN,EAAVM,MAAAA,C,KACA,O,EAAMG,E,eACN,OADA,SACA,C,aAGAA,AAAmB,IAAnBA,EAAQ,MAAM,CAAdA,MAAAA,C,KACA,O,IAAOD,EAAOF,EAAQ,EAAG,C,CAAEA,E,YAItBI,EAAI,E,qBAAGA,CAAAA,EAAID,EAAQ,MAAK,S,+DAAGC,I,aASpC,O,IAAOF,EAAOF,EAAQ,EAAI,EAAGG,GAAAA,MAAAA,CAAAA,C,CAAUH,E,oBAAvC,S,MACJ,EAEc,EAAG,EAAE,E,qBC8CVf,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,AAAAA,EAAAA,EAAAA,GAOD,OAFMC,EAAqBuB,AAL1BxB,EAAAA,KAAAA,CAKqC,GAAG,CAACa,SAAAA,CAAS,E,OAAIA,EAAU,GAAG,CAACE,SAAAA,CAAK,E,OAAIhB,CAAmB,CAACgB,EAAM,CAAC,EAAE,A,GACtG,IAAI,CAAC,SAACR,CAAC,CAAEC,CAAC,E,OAAKD,EAAIC,C,KAAI,IAAI,CAAC,SAACD,CAAC,CAAEC,CAAC,E,MAAKiB,AAAAA,GAAAA,EAAAA,GAAAA,AAAAA,EAAIlB,GAAKkB,AAAAA,GAAAA,EAAAA,GAAAA,AAAAA,EAAIjB,E,GACjD,C,EAAAP,E,UAPND,EAAAA,GAAAA,EAAAA,C,aAAAA,GAAAA,AAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,MAAAA,E,YAAAA,E,MAAAA,C,EAST,CACA,MAAO0B,EAAG,CACNC,EAAQ,IAAI,CAAC,0BAA2BD,EAC5C,CAGA,MAAO,C,GAAC7B,EAAU,GAAG,CAAC,SAAC+B,CAAC,CAAET,CAAC,E,OAAKA,C,OACpC,I"}