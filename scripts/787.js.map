{"version":3,"file":"787.js","sources":["webpack://assets/./src/urban-stats-script/ast.ts","webpack://assets/./src/urban-stats-script/constants/color.ts","webpack://assets/./src/urban-stats-script/constants/insets.ts","webpack://assets/./src/urban-stats-script/constants/rich-text.ts","webpack://assets/./src/urban-stats-script/constants/text-box.ts","webpack://assets/./src/urban-stats-script/editor-utils.tsx","webpack://assets/./src/utils/isAMatch.ts","webpack://assets/./src/urban-stats-script/interpreter.ts","webpack://assets/./src/urban-stats-script/lexer.ts","webpack://assets/./src/urban-stats-script/location.ts","webpack://assets/./src/urban-stats-script/parser.ts","webpack://assets/./src/urban-stats-script/types-values.ts"],"sourcesContent":["import assert from 'assert'\n\nimport { LocInfo } from './location'\nimport { Decorated, ParseError } from './parser'\nimport { USSType } from './types-values'\n\nexport type UrbanStatsASTArg = (\n    { type: 'unnamed', value: UrbanStatsASTExpression } |\n    { type: 'named', name: Decorated<string>, value: UrbanStatsASTExpression })\n\nexport type UrbanStatsASTLHS = (\n    { type: 'identifier', name: Decorated<string> } |\n    { type: 'attribute', expr: UrbanStatsASTExpression, name: Decorated<string> })\n\nexport type UrbanStatsASTExpression = (\n    UrbanStatsASTLHS |\n    { type: 'constant', value: Decorated<{ type: 'number', value: number } | { type: 'string', value: string }> } |\n    { type: 'call', fn: UrbanStatsASTExpression, args: UrbanStatsASTArg[], entireLoc: LocInfo } |\n    { type: 'binaryOperator', operator: Decorated<string>, left: UrbanStatsASTExpression, right: UrbanStatsASTExpression } |\n    { type: 'unaryOperator', operator: Decorated<string>, expr: UrbanStatsASTExpression } |\n    { type: 'objectLiteral', entireLoc: LocInfo, properties: [string, UrbanStatsASTExpression][] } |\n    { type: 'vectorLiteral', entireLoc: LocInfo, elements: UrbanStatsASTExpression[] } |\n    { type: 'if', entireLoc: LocInfo, condition: UrbanStatsASTExpression, then: UrbanStatsASTStatement, else?: UrbanStatsASTStatement } |\n    { type: 'do', entireLoc: LocInfo, statements: UrbanStatsASTStatement[] } |\n    // for internal purposes only\n    { type: 'customNode', entireLoc: LocInfo, expr: UrbanStatsASTStatement, originalCode: string, expectedType?: USSType[] }\n)\n\nexport type UrbanStatsASTStatement = (\n    { type: 'assignment', lhs: UrbanStatsASTLHS, value: UrbanStatsASTExpression } |\n    { type: 'expression', value: UrbanStatsASTExpression } |\n    { type: 'statements', entireLoc: LocInfo, result: UrbanStatsASTStatement[] } |\n    { type: 'condition', entireLoc: LocInfo, condition: UrbanStatsASTExpression, rest: UrbanStatsASTStatement[] } |\n    { type: 'parseError', originalCode: string, errors: ParseError[] })\n\nexport type UrbanStatsAST = UrbanStatsASTArg | UrbanStatsASTExpression | UrbanStatsASTStatement\n\nexport function unify(...locations: LocInfo[]): LocInfo {\n    assert(locations.length > 0, 'At least one location must be provided for unification')\n    const startLine = locations.reduce((min, loc) => Math.min(min, loc.start.lineIdx), Number.MAX_VALUE)\n    const endLine = locations.reduce((max, loc) => Math.max(max, loc.end.lineIdx), -Number.MAX_VALUE)\n    const startCol = locations.reduce((min, loc) => Math.min(min, loc.start.colIdx), Number.MAX_VALUE)\n    const endCol = locations.reduce((max, loc) => Math.max(max, loc.end.colIdx), -Number.MAX_VALUE)\n    const startChar = locations.reduce((min, loc) => Math.min(min, loc.start.charIdx), Number.MAX_VALUE)\n    const endChar = locations.reduce((max, loc) => Math.max(max, loc.end.charIdx), -Number.MAX_VALUE)\n    return {\n        start: { block: locations[0].start.block, lineIdx: startLine, colIdx: startCol, charIdx: startChar },\n        end: { block: locations[0].end.block, lineIdx: endLine, colIdx: endCol, charIdx: endChar },\n    }\n}\n\nexport function locationOf(node: UrbanStatsAST): LocInfo {\n    /* c8 ignore start -- This function doesn't need to be tested in detail, as it is a simple location extractor */\n    switch (node.type) {\n        case 'unnamed':\n            return locationOf(node.value)\n        case 'named':\n            return unify(node.name.location, locationOf(node.value))\n        case 'constant':\n            return node.value.location\n        case 'identifier':\n            return node.name.location\n        case 'attribute':\n            return unify(node.name.location, locationOf(node.expr))\n        case 'call':\n            return node.entireLoc\n        case 'unaryOperator':\n            return unify(node.operator.location, locationOf(node.expr))\n        case 'binaryOperator':\n            return unify(locationOf(node.left), locationOf(node.right), node.operator.location)\n        case 'objectLiteral':\n        case 'vectorLiteral':\n        case 'if':\n        case 'do':\n        case 'condition':\n        case 'statements':\n            return node.entireLoc\n        case 'assignment':\n            return unify(locationOf(node.lhs), locationOf(node.value))\n        case 'expression':\n            return locationOf(node.value)\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        case 'customNode':\n            return node.entireLoc\n    }\n    /* c8 ignore stop */\n}\n\nexport function locationOfLastExpression(node: UrbanStatsAST): LocInfo {\n    switch (node.type) {\n        case 'assignment':\n            return locationOf(node.value)\n        case 'statements':\n            return locationOfLastExpression(node.result[node.result.length - 1])\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        default:\n            return locationOf(node)\n    }\n}\n\nexport function getAllParseErrors(node: UrbanStatsAST): ParseError[] {\n    const errors: ParseError[] = []\n\n    function collectErrors(n: UrbanStatsAST): void {\n        switch (n.type) {\n            case 'unnamed':\n                collectErrors(n.value)\n                break\n            case 'named':\n                collectErrors(n.value)\n                break\n            case 'constant':\n            case 'identifier':\n                // No parse errors in these\n                break\n            case 'attribute':\n                collectErrors(n.expr)\n                break\n            case 'call':\n                collectErrors(n.fn)\n                n.args.forEach(collectErrors)\n                break\n            case 'unaryOperator':\n                collectErrors(n.expr)\n                break\n            case 'binaryOperator':\n                collectErrors(n.left)\n                collectErrors(n.right)\n                break\n            case 'objectLiteral':\n                n.properties.forEach(([, value]) => {\n                    collectErrors(value)\n                })\n                break\n            case 'vectorLiteral':\n                n.elements.forEach(collectErrors)\n                break\n            case 'if':\n                collectErrors(n.condition)\n                collectErrors(n.then)\n                if (n.else) {\n                    collectErrors(n.else)\n                }\n                break\n            case 'do':\n                n.statements.forEach(collectErrors)\n                break\n            case 'assignment':\n                collectErrors(n.lhs)\n                collectErrors(n.value)\n                break\n            case 'expression':\n                collectErrors(n.value)\n                break\n            case 'statements':\n                n.result.forEach(collectErrors)\n                break\n            case 'condition':\n                collectErrors(n.condition)\n                n.rest.forEach(collectErrors)\n                break\n            case 'parseError':\n                errors.push(...n.errors)\n                break\n            case 'customNode':\n                collectErrors(n.expr)\n                break\n        }\n    }\n\n    collectErrors(node)\n    return errors\n}\n\nexport function toStatement(node: UrbanStatsASTExpression | UrbanStatsASTStatement): UrbanStatsASTStatement {\n    switch (node.type) {\n        case 'statements':\n        case 'assignment':\n        case 'expression':\n        case 'condition':\n        case 'parseError':\n            return node\n        default:\n            return { type: 'expression', value: node }\n    }\n}\n","import hueColors from '../../data/hueColors'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue, createConstantExpression } from '../types-values'\n\nimport { Color, doRender, hexToColor, hsvColorExpression, rgbColorExpression } from './color-utils'\nimport { camelToHuman } from './utils'\n\nexport const colorType = { type: 'opaque', name: 'color' } satisfies USSType\n\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError: true): Color | undefined\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number): Color\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (red < 0 || red > 1 || green < 0 || green > 1 || blue < 0 || blue > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`RGB values must be between 0 and 1, got (${red}, ${green}, ${blue}, ${alpha})`)\n    }\n    return { r: red, g: green, b: blue, a: alpha }\n}\n\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError: true): Color | undefined\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number): Color\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (hue < 0 || hue > 360 || saturation < 0 || saturation > 1 || value < 0 || value > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`HSV values must be (hue: 0-360, saturation: 0-1, value: 0-1, alpha: 0-1), got (${hue}, ${saturation}, ${value}, ${alpha})`)\n    }\n    return {\n        h: hue,\n        s: saturation,\n        v: value,\n        a: alpha,\n    }\n}\n\nexport const rgb = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // red\n            { type: 'concrete', value: { type: 'number' } }, // green\n            { type: 'concrete', value: { type: 'number' } }, // blue\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: rgbToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (RGB)',\n        category: 'color',\n        namedArgs: { a: 'Alpha' },\n        longDescription: 'Creates a color using RGB (Red, Green, Blue) values. Each component ranges from 0 to 1, where 0 is no color and 1 is full intensity.',\n    },\n} satisfies USSValue\n\nexport const hsv = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // hue\n            { type: 'concrete', value: { type: 'number' } }, // saturation\n            { type: 'concrete', value: { type: 'number' } }, // value\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: hsvToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (HSV)',\n        category: 'color',\n        longDescription: 'Creates a color using HSV (Hue, Saturation, Value) values. Hue ranges from 0 to 360 degrees, saturation and value range from 0 to 1.',\n    },\n} satisfies USSValue\n\nexport const renderColor = {\n    type: {\n        type: 'function',\n        posArgs: [{ type: 'concrete', value: colorType }],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: { type: 'string' } },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): string => {\n        const color = (posArgs[0] as { type: 'opaque', value: { r: number, g: number, b: number, a: number } }).value\n        return doRender(color)\n    },\n    documentation: {\n        humanReadableName: 'Color to String',\n        category: 'color',\n        longDescription: 'Converts a color object to its hexadecimal string representation (e.g., \"#ff0000\" for red). If the alpha channel is not 255, it will be included in the string, e.g., \"#ff000088\" for red with 50% opacity.',\n    },\n} satisfies USSValue\n\nfunction colorConstant(name: string, value: string, isDefault?: boolean): [string, USSValue] {\n    const round = 3 // Min value that doesn't introduce error into hex expressions (with conversions)\n    const humanReadableName = camelToHuman(name)\n    const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1)\n    const color = hexToColor(value, round)\n    return [`color${capitalizedName}`, {\n        type: colorType,\n        value: { type: 'opaque', opaqueType: 'color', value: color },\n        documentation: {\n            humanReadableName,\n            category: 'color',\n            equivalentExpressions: [parseNoErrorAsExpression(rgbColorExpression(color, { round }), ''), parseNoErrorAsExpression(hsvColorExpression(color, { round }), '')],\n            isDefault,\n            longDescription: `Predefined color constant representing ${humanReadableName.toLowerCase()}.`,\n            documentationTable: 'predefined-colors',\n            selectorRendering: {\n                kind: 'gradientBackground',\n                ramp: [[0, value], [1, value]],\n            },\n        },\n    }] satisfies [string, USSValue]\n}\n\nexport const colorConstants = [\n    ...Object.entries(hueColors).map(([name, value]) => colorConstant(name, value)),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('white', '#ffffff'),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('black', '#000000', true),\n]\n","import { round } from 'mathjs'\n\nimport insets from '../../data/insets'\nimport { UrbanStatsASTExpression } from '../ast'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue } from '../types-values'\n\nexport interface Inset {\n    bottomLeft: [number, number]\n    topRight: [number, number]\n    coordBox: [number, number, number, number]\n    mainMap: boolean\n    name?: string\n}\n\nexport const insetType = {\n    type: 'opaque',\n    name: 'inset',\n} satisfies USSType\n\nexport const insetsType = {\n    type: 'opaque',\n    name: 'insets',\n} satisfies USSType\n\nexport const boundsType = {\n    type: 'object',\n    properties: new Map([\n        ['west', { type: 'number' }],\n        ['east', { type: 'number' }],\n        ['north', { type: 'number' }],\n        ['south', { type: 'number' }],\n    ]),\n} satisfies USSType\n\nexport function constructInset(\n    screenBounds: { west: number, east: number, north: number, south: number },\n    mapBounds: { west: number, east: number, north: number, south: number },\n    mainMap: boolean,\n    name?: string,\n): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'inset',\n        value: {\n            bottomLeft: [screenBounds.west, screenBounds.south],\n            topRight: [screenBounds.east, screenBounds.north],\n            coordBox: [mapBounds.west, mapBounds.south, mapBounds.east, mapBounds.north],\n            mainMap,\n            name,\n        } satisfies Inset & { name?: string },\n    }\n}\n\nexport function constructInsets(insetList: Inset[]): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'insets',\n        value: insetList,\n    }\n}\n\nexport const constructInsetValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            screenBounds: { type: { type: 'concrete', value: boundsType } },\n            mapBounds: { type: { type: 'concrete', value: boundsType } },\n            mainMap: { type: { type: 'concrete', value: { type: 'boolean' } } },\n            name: { type: { type: 'concrete', value: { type: 'string' } } },\n        },\n        returnType: { type: 'concrete', value: insetType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const screenBoundsObj = namedArgs.screenBounds as Map<string, USSRawValue>\n        const mapBoundsObj = namedArgs.mapBounds as Map<string, USSRawValue>\n        const mainMap = namedArgs.mainMap as boolean\n        const name = namedArgs.name as string\n        return constructInset(\n            {\n                west: screenBoundsObj.get('west') as number,\n                east: screenBoundsObj.get('east') as number,\n                north: screenBoundsObj.get('north') as number,\n                south: screenBoundsObj.get('south') as number,\n            },\n            {\n                west: mapBoundsObj.get('west') as number,\n                east: mapBoundsObj.get('east') as number,\n                north: mapBoundsObj.get('north') as number,\n                south: mapBoundsObj.get('south') as number,\n            },\n            mainMap,\n            name,\n        )\n    },\n    documentation: {\n        humanReadableName: 'Custom Inset',\n        category: 'inset',\n        longDescription: 'Creates a custom map inset with specified screen bounds (bounding box of the inset on the screen, where bottom left corner has (0, 0) and top right corner has (1, 1)), map bounds (bounding box of the inset on the map, in longitude and latitude), and whether it is the main map (the interactive map).',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructInsetsValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [\n            {\n                type: 'concrete',\n                value: {\n                    type: 'vector',\n                    elementType: insetType,\n                },\n            },\n        ],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: insetsType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const insetsList = posArgs[0] as { type: 'opaque', opaqueType: 'inset', value: Inset }[]\n        return constructInsets(insetsList.map(item => item.value))\n    },\n    documentation: {\n        humanReadableName: 'Custom Insets',\n        category: 'inset',\n        isDefault: true,\n        longDescription: 'Creates a collection of map insets.',\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nfunction computeInsetConstantName(name: string): string {\n    name = name.replace(/[\\s,().-]/g, '')\n    name = name.replaceAll('+', 'Plus')\n    name = `inset${name}`\n    return name\n}\n\nexport function deconstruct(inset: typeof insets[keyof typeof insets][number] | Inset): UrbanStatsASTExpression {\n    const uss = `constructInset(screenBounds={ north: ${round(inset.topRight[1], 3)}, east: ${round(inset.topRight[0], 3)}, south: ${round(inset.bottomLeft[1], 3)}, west: ${round(inset.bottomLeft[0], 3)} }, mapBounds={ north: ${round(inset.coordBox[3], 3)}, east: ${round(inset.coordBox[2], 3)}, south: ${round(inset.coordBox[1], 3)}, west: ${round(inset.coordBox[0], 3)} }, mainMap=${inset.mainMap}, name=\"${inset.name}\")`\n    return parseNoErrorAsExpression(uss, '')\n}\n\nexport const insetConsts: [string, USSValue][] = Object.entries(insets).flatMap(([, regionInsets]) =>\n    regionInsets.map((inset) => {\n        const insetName = inset.name\n        const constantName = computeInsetConstantName(insetName)\n\n        return [\n            constantName,\n            {\n                type: insetType,\n                value: {\n                    type: 'opaque',\n                    opaqueType: 'inset',\n                    value: {\n                        bottomLeft: [...inset.bottomLeft] as [number, number],\n                        topRight: [...inset.topRight] as [number, number],\n                        // copy to get rid of readonly\n                        coordBox: [...inset.coordBox] as [number, number, number, number],\n                        mainMap: inset.mainMap,\n                        name: inset.name,\n                    } satisfies Inset,\n                },\n                documentation: {\n                    humanReadableName: insetName,\n                    category: 'inset',\n                    equivalentExpressions: [deconstruct(inset)],\n                    longDescription: `Predefined map inset for the region \"${insetName}\".`,\n                    documentationTable: 'predefined-insets',\n                },\n            } satisfies USSValue,\n        ] as [string, USSValue]\n    }),\n)\n\nexport const insetNameToConstantName = new Map<string, string>(\n    Object.entries(insets).flatMap(([, regionInsets]) =>\n        regionInsets.map((inset) => {\n            const insetName = inset.name\n            return [insetName, computeInsetConstantName(insetName)]\n        }),\n    ),\n)\n","import { z } from 'zod'\n\nimport { RemoveOptionals, SwapKeysValues } from '../../utils/types'\nimport { Context } from '../context'\nimport { createConstantExpression, NamedFunctionArgumentWithDocumentation, USSRawValue, USSType, USSValue } from '../types-values'\n\nimport { colorType } from './color'\nimport { Color, hexToColor } from './color-utils'\n\nexport type RichTextDocument = RichTextSegment[]\n\nexport function documentLength(document: RichTextDocument): number {\n    return document.reduce((sum, segment) => sum + (typeof segment.insert === 'string' ? segment.insert.length : 1), 0)\n}\n\nconst colorSchema = z.string().transform((c) => {\n    try {\n        return hexToColor(c)\n    }\n    catch {\n        console.warn(`${c} is not a valid color`)\n        return undefined\n    }\n})\n\nexport const richTextAttributesSchema = z.object({\n    size: z.optional(z.string().transform((s) => {\n        if (!s.endsWith('px')) {\n            console.warn(`Font size ${s} does not end with \"px\"`)\n            return undefined\n        }\n        const pixels = s.slice(0, s.length - 2)\n        const result = parseFloat(pixels)\n        if (!isFinite(result)) {\n            console.warn(`Font pixels ${pixels} is not a valid number`)\n            return undefined\n        }\n        return result\n    })),\n    font: z.optional(z.string()),\n    // Sometimes when selecting a different colored formula along with text, color is an array. In that case, just take the first one\n    color: z.optional(z.union([colorSchema, z.array(colorSchema).transform(array => array.length === 0 ? undefined : array[0])])),\n    bold: z.optional(z.boolean()),\n    italic: z.optional(z.boolean()),\n    underline: z.optional(z.boolean()),\n    strike: z.optional(z.boolean()),\n    list: z.optional(z.union([z.literal('ordered'), z.literal('bullet'), z.literal('')])),\n    indent: z.optional(z.number()),\n    align: z.optional(z.enum(['', 'center', 'right', 'justify'])),\n})\n\nexport const richTextSegmentSchema = z.object({\n    insert: z.union([\n        z.string(),\n        z.object({ formula: z.string() }),\n        z.object({ image: z.string().refine(link => !link.startsWith('data:')) }), // Images must be linked, not enough room to store them in the url\n    ]),\n    attributes: z.optional(richTextAttributesSchema),\n})\n\nexport type RichTextSegment = z.infer<typeof richTextSegmentSchema>\n\nexport type RichTextAttributes = RemoveOptionals<RichTextSegment>['attributes']\n\nexport const richTextDocumentType = {\n    type: 'opaque',\n    name: 'richTextDocument',\n} satisfies USSType\n\nexport const richTextSegmentType = {\n    type: 'opaque',\n    name: 'richTextSegment',\n} satisfies USSType\n\nexport const constructRichTextDocumentValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'vector', elementType: richTextSegmentType } },\n        ],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: richTextDocumentType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        let segmentsList = (posArgs[0] as { type: 'opaque', opaqueType: 'richTextSegment', value: RichTextSegment }[]).map(({ value }) => value)\n        if (segmentsList.length === 0) {\n            segmentsList = [{ insert: '\\n' }] // bugs on applying attributes to empty text without this\n        }\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextDocument',\n            value: segmentsList,\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text Document',\n        category: 'richText',\n        longDescription: 'Creates a rich text document from a list of rich text segments.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const richTextListType = {\n    type: 'opaque',\n    name: 'richTextList',\n} satisfies USSType\n\nexport const richTextAlignType = {\n    type: 'opaque',\n    name: 'richTextAlign',\n} satisfies USSType\n\nconst attributesNamedArgs: { [K in keyof RemoveOptionals<RichTextSegment>['attributes']]-?: NamedFunctionArgumentWithDocumentation } = {\n    size: {\n        type: { type: 'concrete', value: { type: 'number' } },\n        defaultValue: createConstantExpression(null),\n    },\n    font: {\n        type: { type: 'concrete', value: { type: 'string' } },\n        defaultValue: createConstantExpression(null),\n    },\n    color: {\n        type: { type: 'concrete', value: colorType },\n        defaultValue: createConstantExpression(null),\n    },\n    bold: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    italic: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    underline: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    strike: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    list: {\n        type: { type: 'concrete', value: richTextListType },\n        defaultValue: createConstantExpression(null),\n    },\n    indent: {\n        type: { type: 'concrete', value: { type: 'number' } },\n        defaultValue: createConstantExpression(null),\n    },\n    align: {\n        type: { type: 'concrete', value: richTextAlignType },\n        defaultValue: createConstantExpression(null),\n    },\n}\n\nfunction attributesFromNamedArgs(namedArgs: Record<string, USSRawValue>): RichTextSegment['attributes'] {\n    const color = (namedArgs.color as ({ value: Color } | null))?.value\n\n    const entries = Object.entries({\n        size: (namedArgs.size as number | null) ?? undefined,\n        font: (namedArgs.font as string | null) ?? undefined,\n        color,\n        bold: (namedArgs.bold as boolean | null) ?? undefined,\n        italic: (namedArgs.italic as boolean | null) ?? undefined,\n        underline: (namedArgs.underline as boolean | null) ?? undefined,\n        list: (namedArgs.list as { value: RichTextAttributes['list'] } | null)?.value,\n        indent: (namedArgs.indent as number | null) ?? undefined,\n        align: (namedArgs.align as { value: RichTextAttributes['align'] } | null)?.value,\n        strike: (namedArgs.strike as boolean | null) ?? undefined,\n    }).filter(([, v]) => v !== undefined)\n\n    if (entries.length === 0) {\n        return undefined\n    }\n\n    return Object.fromEntries(entries)\n}\n\nconst richTextSegmentConstructorType: USSType = {\n    type: 'function',\n    posArgs: [\n        { type: 'concrete', value: { type: 'string' } },\n    ],\n    namedArgs: attributesNamedArgs,\n    returnType: { type: 'concrete', value: richTextSegmentType },\n}\n\nexport const constructRichTextStringSegmentValue: USSValue = {\n    type: richTextSegmentConstructorType,\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const text = posArgs[0] as string\n        const attributes = attributesFromNamedArgs(namedArgs)\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextSegment',\n            value: {\n                insert: text,\n                ...(attributes && { attributes }),\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text String Segment',\n        category: 'richText',\n        longDescription: 'Creates a rich text segment containing a plain string. The string can have optional formatting attributes.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructRichTextFormulaSegmentValue: USSValue = {\n    type: richTextSegmentConstructorType,\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const formula = posArgs[0] as string\n        const attributes = attributesFromNamedArgs(namedArgs)\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextSegment',\n            value: {\n                insert: { formula },\n                ...(attributes && { attributes }),\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text Formula Segment',\n        category: 'richText',\n        longDescription: 'Creates a rich text segment containing a formula. The formula is represented as a string and can have optional formatting attributes.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructRichTextImageSegmentValue: USSValue = {\n    type: richTextSegmentConstructorType,\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const image = posArgs[0] as string\n        const attributes = attributesFromNamedArgs(namedArgs)\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextSegment',\n            value: {\n                insert: { image },\n                ...(attributes && { attributes }),\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text Image Segment',\n        category: 'richText',\n        longDescription: 'Creates a rich text segment containing an image. The image is represented as a URL string and can have optional formatting attributes.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const alignIdentifierToValue = {\n    alignLeft: '',\n    alignCenter: 'center',\n    alignRight: 'right',\n    alignJustify: 'justify',\n} as const\n\nexport const alignValueToIdentifer: SwapKeysValues<typeof alignIdentifierToValue> = {\n    '': 'alignLeft',\n    'center': 'alignCenter',\n    'right': 'alignRight',\n    'justify': 'alignJustify',\n}\n\nfunction alignConstant(value: RichTextAttributes['align']): USSValue {\n    return {\n        type: richTextAlignType,\n        value: { type: 'opaque', opaqueType: 'richTextAlign', value },\n        documentation: {\n            humanReadableName: `Align ${value === '' ? 'Left' : value.charAt(0).toUpperCase() + value.slice(1)}`,\n            category: 'richText',\n            longDescription: `Specifies the alignment of the text as ${value === '' ? 'left' : value}.`,\n            selectorRendering: { kind: 'subtitleLongDescription' },\n            customConstructor: false,\n        },\n    }\n}\n\nexport const listIdentifierToValue = {\n    listOrdered: 'ordered',\n    listBullet: 'bullet',\n    listNone: '',\n} as const\n\nexport const listValueToIdentifier: SwapKeysValues<typeof listIdentifierToValue> = {\n    ordered: 'listOrdered',\n    bullet: 'listBullet',\n    ['']: 'listNone',\n}\n\nfunction listConstant(value: RichTextAttributes['list']): USSValue {\n    return {\n        type: richTextListType,\n        value: { type: 'opaque', opaqueType: 'richTextList', value },\n        documentation: {\n            humanReadableName: `List ${(value && value.charAt(0).toUpperCase() + value.slice(1)) || 'None'}`,\n            category: 'richText',\n            longDescription: `Specifies the list type as ${value || 'none'}.`,\n            selectorRendering: { kind: 'subtitleLongDescription' },\n            customConstructor: false,\n        },\n    }\n}\n\nexport const richTextConstants: [string, USSValue][] = [\n    ['rtfDocument', constructRichTextDocumentValue],\n    ['rtfString', constructRichTextStringSegmentValue],\n    ['rtfFormula', constructRichTextFormulaSegmentValue],\n    ['rtfImage', constructRichTextImageSegmentValue],\n    ...Object.entries(alignIdentifierToValue).map(([id, value]) => [id, alignConstant(value)] satisfies [unknown, unknown]),\n    ...Object.entries(listIdentifierToValue).map(([id, value]) => [id, listConstant(value)] satisfies [unknown, unknown]),\n]\n","import { round } from 'mathjs'\n\nimport { colorThemes } from '../../page_template/color-themes'\nimport { UrbanStatsASTExpression } from '../ast'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue } from '../types-values'\n\nimport { colorType } from './color'\nimport { Color, deconstructColor, hexToColor } from './color-utils'\nimport { boundsType } from './insets'\nimport { alignValueToIdentifer, listValueToIdentifier, RichTextDocument, richTextDocumentType, RichTextSegment } from './rich-text'\n\nexport interface TextBox {\n    bottomLeft: [number, number]\n    topRight: [number, number]\n    text: RichTextDocument\n    backgroundColor: Color\n    borderColor: Color\n    borderWidth: number\n}\n\nexport const defaults = {\n    backgroundColor: hexToColor(colorThemes['Light Mode'].background),\n    borderColor: hexToColor(colorThemes['Light Mode'].borderShadow),\n    borderWidth: 1,\n}\n\nexport function deconstruct(textBox: TextBox): UrbanStatsASTExpression {\n    const uss = `textBox(\n        screenBounds={\n            north: ${round(textBox.topRight[1], 3)},\n            east: ${round(textBox.topRight[0], 3)},\n            south: ${round(textBox.bottomLeft[1], 3)},\n            west: ${round(textBox.bottomLeft[0], 3)}\n        },\n        text=${deconstructRichTextDocument(textBox.text)},\n        backgroundColor=${deconstructColor(textBox.backgroundColor)},\n        borderColor=${deconstructColor(textBox.borderColor)},\n        borderWidth=${textBox.borderWidth}\n    )`\n    return parseNoErrorAsExpression(uss, '')\n}\n\nfunction deconstructRichTextDocument(doc: RichTextDocument): string {\n    return `rtfDocument([${doc.map(deconstructRichTextSegment).join(', ')}])`\n}\n\nfunction deconstructRichTextSegment(segment: RichTextSegment): string {\n    if (typeof segment.insert === 'string') {\n        return `rtfString(${JSON.stringify(segment.insert)}${deconstructRichTextAttributes(segment.attributes)})`\n    }\n    if ('formula' in segment.insert) {\n        return `rtfFormula(\"${segment.insert.formula}\"${deconstructRichTextAttributes(segment.attributes)})`\n    }\n    if ('image' in segment.insert) {\n        return `rtfImage(\"${segment.insert.image}\"${deconstructRichTextAttributes(segment.attributes)})`\n    }\n    throw new Error()\n}\n\nfunction deconstructRichTextAttributes(attributes: RichTextSegment['attributes']): string {\n    if (attributes === undefined) {\n        return ''\n    }\n    const list = Object.entries(attributes).filter(([, value]) => value !== undefined)\n    if (list.length === 0) {\n        return ''\n    }\n    return `, ${list.flatMap((pair) => {\n        if (pair[1] === undefined) {\n            return []\n        }\n\n        const value = (() => {\n            switch (pair[0]) {\n                case 'align':\n                    return [alignValueToIdentifer[pair[1]]]\n                case 'list':\n                    return [listValueToIdentifier[pair[1]]]\n                case 'color':\n                    return deconstructColor(pair[1])\n                case 'bold':\n                case 'italic':\n                case 'underline':\n                case 'strike':\n                    return pair[1] ? 'true' : 'false'\n                case 'size':\n                case 'indent':\n                    return pair[1].toString()\n                case 'font':\n                    return `\"${pair[1]}\"`\n            }\n        })()\n\n        return `${pair[0]}=${value}`\n    }).join(', ')}`\n}\n\nexport const textBoxType = {\n    type: 'opaque',\n    name: 'textBox',\n} satisfies USSType\n\nexport const constructTextBoxValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            screenBounds: { type: { type: 'concrete', value: boundsType } },\n            text: { type: { type: 'concrete', value: richTextDocumentType } },\n            backgroundColor: { type: { type: 'concrete', value: colorType }, defaultValue: parseNoErrorAsExpression(deconstructColor(defaults.backgroundColor), '') },\n            borderColor: { type: { type: 'concrete', value: colorType }, defaultValue: parseNoErrorAsExpression(deconstructColor(defaults.borderColor), '') },\n            borderWidth: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: parseNoErrorAsExpression(`${defaults.borderWidth}`, '') },\n        },\n        returnType: { type: 'concrete', value: textBoxType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const screenBounds = namedArgs.screenBounds as Map<string, USSRawValue>\n\n        const text = (namedArgs.text as { type: 'opaque', opaqueType: 'richTextDocument', value: RichTextDocument }).value\n        const backgroundColor = (namedArgs.backgroundColor as { type: 'opaque', opaqueType: 'color', value: Color }).value\n        const borderColor = (namedArgs.borderColor as { type: 'opaque', opaqueType: 'color', value: Color }).value\n        const borderWidth = namedArgs.borderWidth as number\n\n        return {\n            type: 'opaque',\n            opaqueType: 'textBox',\n            value: {\n                bottomLeft: [screenBounds.get('west') as number, screenBounds.get('south') as number],\n                topRight: [screenBounds.get('east') as number, screenBounds.get('north') as number],\n                text,\n                backgroundColor,\n                borderColor,\n                borderWidth,\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Map Text Box',\n        category: 'map',\n        longDescription: 'Create a text box on the map with specified screen bounds (bounding box of the inset on the screen, where bottom left corner has (0, 0) and top right corner has (1, 1))',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n","import React, { CSSProperties, ReactNode, useCallback, useEffect, useRef, useState } from 'react'\n\nimport { totalOffset } from '../components/screenshot'\nimport { Colors } from '../page_template/color-themes'\nimport { DefaultMap } from '../utils/DefaultMap'\nimport { TestUtils } from '../utils/TestUtils'\nimport { isAMatch } from '../utils/isAMatch'\nimport { useMobileLayout } from '../utils/responsive'\nimport { zIndex } from '../utils/zIndex'\n\nimport { renderLocInfo } from './interpreter'\nimport { AnnotatedToken, lex } from './lexer'\nimport { ParseError } from './parser'\nimport { renderValue, TypeEnvironment, USSValue } from './types-values'\n\nexport type EditorError = ParseError & { kind: 'error' | 'warning' }\nexport type EditorResult = EditorError | { kind: 'success', result: USSValue }\n\nexport function longMessage(result: EditorResult, includeLocationInfo: boolean): string {\n    switch (result.kind) {\n        case 'error':\n        case 'warning':\n            return includeLocationInfo ? `${result.value} at ${renderLocInfo(result.location)}` : result.value\n        case 'success':\n            return renderValue(result.result)\n    }\n}\n\nexport interface Script { uss: string, tokens: AnnotatedToken[] }\n\nexport function makeScript(uss: string): Script {\n    if (!uss.endsWith('\\n')) {\n        uss = `${uss}\\n`\n    }\n    return { uss, tokens: lex({ type: 'single', ident: 'editor' }, uss) }\n}\n\n// `errors` may not overlap\nexport function renderCode(\n    script: Script,\n    colors: Colors,\n    errors: EditorError[],\n    modfiyTokenContent: (token: AnnotatedToken, content: Node[]) => void,\n    modifyTokenSpan: (token: AnnotatedToken, span: HTMLSpanElement) => void,\n): Node[] {\n    const span = spanFactory(colors)\n\n    const lexSpans: Node[] = []\n    let errorSpans: { error: EditorError, spans: Node[] } | undefined = undefined\n    let charIdx = 0\n    let indexInTokens = 0\n    let indexInErrors = 0\n    while (indexInTokens < script.tokens.length && charIdx < script.uss.length) {\n        if (indexInErrors < errors.length) {\n            const errorLoc = errors[indexInErrors].location\n            if (charIdx >= errorLoc.start.charIdx) {\n                errorSpans = { spans: [], error: errors[indexInErrors] }\n                indexInErrors++\n            }\n        }\n        if (errorSpans !== undefined) {\n            const errorLoc = errorSpans.error.location\n            if (charIdx >= errorLoc.end.charIdx) {\n                lexSpans.push(span(errorSpans.error, errorSpans.spans))\n                errorSpans = undefined\n            }\n        }\n\n        const token = script.tokens[indexInTokens]\n        if (charIdx === token.location.start.charIdx) {\n            const content: Node[] = [document.createTextNode(script.uss.slice(token.location.start.charIdx, token.location.end.charIdx))]\n            modfiyTokenContent(token, content)\n            const tokenSpan = span(token.token, content)\n            modifyTokenSpan(token, tokenSpan);\n            (errorSpans?.spans ?? lexSpans).push(tokenSpan)\n            charIdx = token.location.end.charIdx\n            indexInTokens++\n        }\n        else if (charIdx < token.location.start.charIdx) {\n            (errorSpans?.spans ?? lexSpans).push(document.createTextNode(script.uss.slice(charIdx, token.location.start.charIdx)))\n            charIdx = token.location.start.charIdx\n        }\n        else {\n            throw new Error('invalid state')\n        }\n    }\n\n    if (errorSpans !== undefined) {\n        lexSpans.push(span(errorSpans.error, errorSpans.spans))\n        errorSpans = undefined\n    }\n\n    return lexSpans\n}\n\nexport function nodeContent(node: Node): string {\n    if (node instanceof HTMLElement) {\n        if (!node.isContentEditable) {\n            return ''\n        }\n        return Array.from(node.childNodes).map(nodeContent).join('')\n    }\n    else {\n        return node.textContent ?? ''\n    }\n}\n\nexport interface Range { start: number, end: number }\n\nexport function getRange(editor: HTMLElement): Range | null {\n    const selection = window.getSelection()\n    if (selection?.rangeCount === 1) {\n        const range = selection.getRangeAt(0)\n        if (editor.contains(range.startContainer) && editor.contains(range.endContainer)) {\n            if (editor === range.startContainer || editor === range.endContainer) {\n                return { start: 0, end: 0 }\n            }\n            return { start: positionInEditor(editor, range.startContainer, range.startOffset), end: positionInEditor(editor, range.endContainer, range.endOffset) }\n        }\n    }\n\n    return null\n}\n\n// Traverse up the tree, counting text content of previous siblings along the way\nfunction positionInEditor(editor: Node, node: Node, offset: number): number {\n    while (node !== editor) {\n        let sibling = node.previousSibling\n        while (sibling !== null) {\n            offset += nodeContent(sibling).length\n            sibling = sibling.previousSibling\n        }\n        node = node.parentNode!\n    }\n    return offset\n}\n\nexport function setRange(editor: HTMLElement, newRange: Range | null): void {\n    const currentRange = getRange(editor)\n\n    if (currentRange?.start === newRange?.start && currentRange?.end === newRange?.end) {\n        return\n    }\n\n    const selection = window.getSelection()!\n\n    if (newRange === null) {\n        selection.removeAllRanges()\n        editor.blur()\n        return\n    }\n\n    if (currentRange === null) {\n        editor.focus()\n    }\n\n    const [anchorNode, anchorOffset] = getContainerOffset(editor, newRange.start)\n    const [focusNode, focusOffset] = getContainerOffset(editor, newRange.end)\n\n    selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)\n}\n\n// Inverse of `positionInEditor`\n// Traverse down the tree, always keeping the text content behind us lte position\nexport function getContainerOffset(node: Node, position: number): [Node, number] {\n    let offset = 0\n    while (node.childNodes.length > 0) {\n        node = node.childNodes.item(0)\n        while (offset + nodeContent(node).length < position && node.nextSibling !== null) {\n            offset += nodeContent(node).length\n            node = node.nextSibling\n        }\n    }\n    return [node, position - offset]\n}\n\nfunction spanFactory(colors: Colors): (token: AnnotatedToken['token'] | ParseError, content: (Node | string)[]) => HTMLSpanElement {\n    const brackets = new DefaultMap<string, number>(() => 0)\n\n    const basicConstants = ['true', 'false', 'null']\n\n    return (token, content) => {\n        const style: Record<string, string> = { position: 'relative' }\n        let title: string | undefined\n\n        switch (token.type) {\n            case 'bracket':\n                function levelColor(level: number): string {\n                    switch (level % 3) {\n                        case 0:\n                            return colors.hueColors.yellow\n                        case 1:\n                            return colors.hueColors.pink\n                        case 2:\n                            return colors.hueColors.blue\n                        default:\n                            throw Error()\n                    }\n                }\n\n                if (token.value === '(' || token.value === '[' || token.value === '{') {\n                    const level = Array.from(brackets.values()).reduce((sum, next) => sum + next, 0)\n                    brackets.set(token.value, brackets.get(token.value) + 1)\n                    style.color = levelColor(level)\n                }\n                else {\n                    const openEquivalent = ({\n                        ')': '(',\n                        ']': '[',\n                        '}': '{',\n                    } as const)[token.value]\n                    if (brackets.get(openEquivalent) === 0) {\n                        style.color = colors.hueColors.red\n                    }\n                    else {\n                        brackets.set(openEquivalent, brackets.get(openEquivalent) - 1)\n                        const level = Array.from(brackets.values()).reduce((sum, next) => sum + next, 0)\n                        style.color = levelColor(level)\n                    }\n                }\n                break\n            case 'number':\n                style.color = colors.hueColors.blue\n                break\n            case 'string':\n                style.color = colors.hueColors.green\n                break\n            case 'error':\n                // Safari doesn't support the shorthand \n                style['text-decoration-color'] = colors.hueColors.red\n                style['text-decoration-style'] = 'wavy'\n                style['text-decoration-line'] = 'underline'\n                style['text-decoration-skip-ink'] = 'none'\n\n                title = token.value\n                break\n            case 'operator':\n                style.color = colors.hueColors.orange\n                break\n            case 'identifier':\n                if (basicConstants.includes(token.value)) {\n                    style.color = colors.hueColors.orange\n                }\n                break\n            case 'keyword':\n                style.color = colors.hueColors.purple\n                break\n        }\n\n        const result = document.createElement('span')\n        result.setAttribute('style', styleToString(style))\n        result.title = title ?? ''\n        result.replaceChildren(...content)\n        return result\n    }\n}\n\nfunction styleToString(style: Record<string, string>): string {\n    return Object.entries(style).map(([key, value]) => `${key}:${value};`).join('')\n}\n\nexport function getAutocompleteOptions(typeEnvironment: TypeEnvironment, tokens: AnnotatedToken[], currentIdentifer: string): string[] {\n    const allIdentifiers = new Set<string>()\n    for (const t of tokens) {\n        if (t.token.type === 'identifier') {\n            allIdentifiers.add(t.token.value)\n        }\n    }\n    for (const [id] of typeEnvironment) {\n        allIdentifiers.add(id)\n    }\n    allIdentifiers.delete(currentIdentifer)\n\n    const sortedIdentifiers = Array.from(allIdentifiers).flatMap((option) => {\n        const match = isAMatch(currentIdentifer.toLowerCase(), option.toLowerCase())\n        if (match === 0) {\n            return []\n        }\n        else {\n            return [{ option, match }]\n        }\n    }).sort((a, b) => {\n        if (a.match !== b.match) {\n            return b.match - a.match\n        }\n        else if (a.option.length !== b.option.length) {\n            return a.option.length - b.option.length\n        }\n        else {\n            return a.option.localeCompare(b.option)\n        }\n    }).map(({ option }) => option)\n\n    return sortedIdentifiers\n}\n\nexport function createAutocompleteMenu(colors: Colors): HTMLElement {\n    const style = {\n        'position': 'absolute',\n        'top': '100%',\n        'left': '100%',\n        'user-select': 'none',\n        'z-index': '3',\n        'overflow': 'scroll',\n        'max-height': `10lh`,\n        'border-radius': TestUtils.shared.isTesting ? '0' : '5px',\n        'border': `1px solid ${colors.borderNonShadow}`,\n        'color': colors.textMain,\n    }\n\n    const result = document.createElement('div')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n\n    return result\n}\n\nexport function createDocumentationPopover(colors: Colors, editor: HTMLPreElement, elemOffset: number): HTMLElement {\n    const width = Math.min(400, editor.offsetWidth)\n\n    const tokenOffset = elemOffset - totalOffset(editor).left\n\n    const style = {\n        'position': 'absolute',\n        'top': '100%',\n        'left': '0%',\n        'user-select': 'none',\n        'z-index': '3',\n        'overflow': 'scroll',\n        'max-height': `10lh`,\n        'border-radius': TestUtils.shared.isTesting ? '0' : '5px',\n        'border': `1px solid ${colors.borderNonShadow}`,\n        'color': colors.textMain,\n        'background-color': colors.slightlyDifferentBackground,\n        'width': `${width}px`,\n        'padding': '0 1.33em',\n        'transform': `translateX(${Math.min(0, editor.offsetWidth - (tokenOffset + width))}px)`,\n    }\n\n    const result = document.createElement('div')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n    result.className = 'serif'\n\n    return result\n}\n\nexport function createPlaceholder(colors: Colors, placeholderText: string): HTMLElement {\n    const style = {\n        'position': 'absolute',\n        'user-select': 'none',\n        'white-space': 'pre',\n        'color': colors.hueColors.grey,\n        'pointer-events': 'none',\n    }\n\n    const result = document.createElement('span')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n\n    result.textContent = placeholderText\n\n    return result\n}\n\n// Custom hook interfaces\n\ninterface UndoRedoItem<T, S> {\n    time: number\n    state: T\n    selection: S\n}\n\nexport interface UndoRedoOptions {\n    undoChunking?: number\n    undoHistory?: number\n    onlyElement?: { current: HTMLElement | null }\n}\n\nconst logMessages: boolean = true\n\nfunction debugUndo(arg: string): void {\n    if (logMessages) {\n        // eslint-disable-next-line no-console -- Conditionally logger\n        console.log(arg)\n    }\n}\n\nexport function useUndoRedo<T, S>(\n    initialState: T,\n    initialSelection: S,\n    onStateChange: (state: T) => void,\n    onSelectionChange: (selection: S) => void,\n    { undoChunking = 1000, undoHistory = 100, onlyElement }: UndoRedoOptions = {},\n): {\n        addState: (state: T, selection: S) => void\n        updateCurrentSelection: (selection: S) => void\n        updateCurrentState: (state: T) => void\n        ui: ReactNode\n        canUndo: boolean\n        canRedo: boolean\n    } {\n    const undoStack = useRef<UndoRedoItem<T, S>[]>([\n        { time: 0, state: initialState, selection: initialSelection },\n    ])\n    const redoStack = useRef<UndoRedoItem<T, S>[]>([])\n\n    const [canUndo, setCanUndo] = useState(false)\n    const [canRedo, setCanRedo] = useState(false)\n\n    const addState = useCallback((state: T, selection: S): void => {\n        const currentUndoState = undoStack.current[undoStack.current.length - 1]\n\n        if (currentUndoState.time + undoChunking > Date.now()) {\n            // Amend current item rather than making a new one\n            currentUndoState.state = state\n            currentUndoState.selection = selection\n\n            debugUndo(`Updated undo stack tail`)\n        }\n        else {\n            undoStack.current.push({ time: Date.now(), state, selection })\n            while (undoStack.current.length > undoHistory) {\n                undoStack.current.shift()\n            }\n            setCanUndo(true)\n            debugUndo(`Pushed to undo stack. Length: ${undoStack.current.length}`)\n        }\n        redoStack.current = []\n        setCanRedo(false)\n    }, [undoChunking, undoHistory])\n\n    const updateCurrentSelection = useCallback((selection: S): void => {\n        undoStack.current[undoStack.current.length - 1].selection = selection\n    }, [])\n\n    const updateCurrentState = useCallback((state: T): void => {\n        undoStack.current[undoStack.current.length - 1].state = state\n    }, [])\n\n    const doUndo = useCallback((): void => {\n        if (undoStack.current.length >= 2) {\n            const prevState = undoStack.current[undoStack.current.length - 2]\n            // Prev state becomes current state, current state becomes redo state\n            redoStack.current.push(undoStack.current.pop()!)\n            onStateChange(prevState.state)\n            onSelectionChange(prevState.selection)\n            setCanRedo(true)\n            setCanUndo(undoStack.current.length >= 2)\n            debugUndo(`Undo completed, Undo Stack: ${undoStack.current.length}, Redo Stack: ${redoStack.current.length}`)\n        }\n        else {\n            debugUndo(`Undo requested but stack is too short (${undoStack.current.length})`)\n        }\n    }, [onStateChange, onSelectionChange])\n\n    const doRedo = useCallback((): void => {\n        const futureState = redoStack.current.pop()\n        if (futureState !== undefined) {\n            undoStack.current.push(futureState)\n            onStateChange(futureState.state)\n            onSelectionChange(futureState.selection)\n            setCanUndo(true)\n            setCanRedo(redoStack.current.length >= 1)\n            debugUndo(`Redo completed, Undo Stack: ${undoStack.current.length}, Redo Stack: ${redoStack.current.length}`)\n        }\n        else {\n            debugUndo(`Redo requested but stack is too short (${redoStack.current.length})`)\n        }\n    }, [onStateChange, onSelectionChange])\n\n    const getIsActive = useCallback(() => {\n        return onlyElement === undefined || (document.activeElement !== null && document.activeElement === onlyElement.current)\n    }, [onlyElement])\n\n    // Set up keyboard shortcuts\n    useEffect(() => {\n        const listener = (e: KeyboardEvent): void => {\n            if (!getIsActive()) {\n                return\n            }\n\n            const isMac = navigator.userAgent.includes('Mac') && !TestUtils.shared.isTesting\n            if (isMac ? e.key.toLowerCase() === 'z' && e.metaKey && !e.shiftKey : e.key.toLowerCase() === 'z' && e.ctrlKey) {\n                e.preventDefault()\n                doUndo()\n            }\n            else if (isMac ? e.key.toLowerCase() === 'z' && e.metaKey && e.shiftKey : e.key.toLowerCase() === 'y' && e.ctrlKey) {\n                e.preventDefault()\n                doRedo()\n            }\n        }\n\n        window.addEventListener('keydown', listener)\n        return () => { window.removeEventListener('keydown', listener) }\n    }, [doUndo, doRedo, getIsActive])\n\n    const [isActive, setIsActive] = useState(getIsActive)\n\n    useEffect(() => {\n        const listener = (): void => {\n            setIsActive(getIsActive())\n        }\n        window.addEventListener('focusin', listener)\n        window.addEventListener('focusout', listener)\n        listener()\n        return () => {\n            window.removeEventListener('focusin', listener)\n            window.removeEventListener('focusout', listener)\n        }\n    }, [getIsActive])\n\n    const ui: ReactNode = isActive ? <UndoRedoControls {...{ doUndo, doRedo, canUndo, canRedo }} /> : null\n\n    return {\n        addState,\n        updateCurrentSelection,\n        updateCurrentState,\n        ui,\n        canUndo,\n        canRedo,\n    }\n}\n\nfunction UndoRedoControls({ doUndo, doRedo, canUndo, canRedo }: { doUndo: () => void, doRedo: () => void, canUndo: boolean, canRedo: boolean }): ReactNode {\n    const outer = useRef<HTMLDivElement>(null)\n    const inner = useRef<HTMLDivElement>(null)\n\n    const width = 150\n    const height = 50\n\n    const padding = 10\n\n    /**\n     * iPhone safari is awful and ignores `position: fixed` when they keyboard is out\n     * So we need to do manual positioning\n     */\n    const positionInner = useCallback(() => {\n        // Get outer's position in the window\n        // Position inner at an offset from outer that matches up with the current scroll position\n        if (outer.current === null || inner.current === null) {\n            return\n        }\n\n        const outerBounds = outer.current.getBoundingClientRect()\n\n        const offsetParent = outer.current.offsetParent as HTMLElement\n\n        inner.current.style.top = `${Math.min((window.visualViewport?.height ?? window.innerHeight) - outerBounds.top, (offsetParent.offsetHeight - outer.current.offsetTop)) - height}px`\n        inner.current.style.left = `${Math.min((window.visualViewport?.width ?? window.innerWidth) - outerBounds.left, (offsetParent.offsetWidth - outer.current.offsetLeft)) - width}px`\n    }, [])\n\n    useEffect(positionInner, [positionInner])\n\n    useEffect(() => {\n        window.addEventListener('scroll', positionInner)\n        window.addEventListener('resize', positionInner)\n        window.visualViewport?.addEventListener('resize', positionInner)\n        return () => {\n            window.removeEventListener('scroll', positionInner)\n            window.removeEventListener('resize', positionInner)\n            window.visualViewport?.removeEventListener('resize', positionInner)\n        }\n    }, [positionInner])\n\n    const isMobile = useMobileLayout()\n\n    useEffect(() => {\n        if (isMobile) {\n            debugUndo(`canUndo=${canUndo}, canRedo=${canRedo}`)\n        }\n    }, [canUndo, canRedo, isMobile])\n\n    if (!isMobile) {\n        return null\n    }\n\n    const buttonStyle: CSSProperties = { flex: 1, touchAction: 'manipulation', zIndex: zIndex.mobileUndoRedoControls }\n\n    return (\n        <div ref={outer} style={{ position: 'absolute' }}>\n            <div\n                ref={inner}\n                style={{\n                    position: 'absolute',\n                    display: 'flex',\n                    width: `${width}px`,\n                    height: `${height}px`,\n                    gap: `${padding}px`,\n                    padding: `${padding}px`,\n                }}\n            >\n                <button\n                    onPointerDown={(e) => {\n                        debugUndo(`Got mobile undo touch`)\n                        e.preventDefault()\n                        doUndo()\n                    }}\n                    disabled={!canUndo}\n                    style={buttonStyle}\n                >\n                    Undo\n                </button>\n                <button\n                    onPointerDown={(e) => {\n                        debugUndo(`Got mobile redo touch`)\n                        e.preventDefault()\n                        doRedo()\n                    }}\n                    disabled={!canRedo}\n                    style={buttonStyle}\n                >\n                    Redo\n                </button>\n            </div>\n        </div>\n    )\n}\n","/*\n    Check whether a is a substring of b (does not have to be contiguous)\n*/\nexport function isAMatch(a: string, b: string): number {\n    let i = 0\n    let matchCount = 0\n    let prevMatch = true\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of -- b is a string\n    for (let j = 0; j < b.length; j++) {\n        if (a[i] === b[j]) {\n            i++\n            if (prevMatch) {\n                matchCount++\n            }\n            prevMatch = true\n        }\n        else {\n            prevMatch = false\n        }\n        if (i === a.length) {\n            return matchCount + 1\n        }\n    }\n    return 0\n}\n","import { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTStatement, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTArg, locationOf, unify } from './ast'\nimport { Context } from './context'\nimport { addAdditionalDims, broadcastApply, broadcastCall } from './forward-broadcasting'\nimport { LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\nimport { splitMask } from './split-broadcasting'\nimport { renderType, unifyType, USSRawValue, USSType, USSValue, USSVectorType, ValueArg, undocValue, canUnifyTo } from './types-values'\n\nexport interface Effect { type: 'warning', message: string, location: LocInfo }\n\nexport function renderLocInfo(loc: LocInfo): string {\n    if (loc.start.lineIdx === loc.end.lineIdx) {\n        if (loc.start.colIdx + 1 === loc.end.colIdx) {\n            // Single character location\n            return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}`\n        }\n        return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}-${loc.end.colIdx}`\n    }\n    return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1} - ${loc.end.lineIdx + 1}:${loc.end.colIdx}`\n}\n\nexport class InterpretationError extends Error {\n    public value: string\n    constructor(message: string, public location: LocInfo) {\n        super(`${message} at ${renderLocInfo(location)}`)\n        this.name = 'InterpretationError'\n        this.value = message\n        this.location = location\n    }\n}\n\nexport function evaluate(expr: UrbanStatsASTExpression, env: Context): USSValue {\n    switch (expr.type) {\n        case 'constant':\n            const value = expr.value.node\n            if (value.type === 'number') {\n                return undocValue(value.value, { type: 'number' })\n            }\n            return undocValue(value.value satisfies string, { type: 'string' })\n        case 'identifier':\n            const varName = expr.name.node\n            const res = env.getVariable(varName)\n            if (res !== undefined) {\n                return res\n            }\n            throw env.error(`Undefined variable: ${varName}`, expr.name.location)\n        case 'attribute':\n            const obj = evaluate(expr.expr, env)\n            const attr = expr.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, undefined)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(expr))\n            }\n            return lookupResult.value\n        case 'call':\n            const func = evaluate(expr.fn, env)\n            const args = expr.args.map(arg => evaluateArg(arg, env))\n            const broadcastResult = broadcastCall(func, args, env, locationOf(expr))\n            if (broadcastResult.type === 'error') {\n                throw env.error(broadcastResult.message, locationOf(expr))\n            }\n            return broadcastResult.result\n        case 'unaryOperator':\n            const operand = evaluate(expr.expr, env)\n            return evaluateUnaryOperator(operand, expr.operator.node, env, locationOf(expr))\n        case 'binaryOperator':\n            const left = evaluate(expr.left, env)\n            const right = evaluate(expr.right, env)\n            return evaluateBinaryOperator(left, right, expr.operator.node, env, locationOf(expr))\n        case 'vectorLiteral':\n            const elements = expr.elements.map(e => evaluate(e, env))\n            let elementType = { type: 'elementOfEmptyVector' } as USSType | { type: 'elementOfEmptyVector' }\n            for (const e of elements) {\n                elementType = unifyType(elementType, e.type, () => {\n                    assert(elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(e.value)}`)\n                    return env.error(`vector literal contains heterogenous types ${renderType(elementType)} and ${renderType(e.type)}`, locationOf(expr))\n                })\n            }\n            return undocValue(elements.map(e => e.value), { type: 'vector', elementType })\n        case 'objectLiteral':\n            const ts = new Map<string, USSType>()\n            const vs = new Map<string, USSRawValue>()\n            for (const [name, e] of expr.properties) {\n                const v = evaluate(e, env)\n                if (ts.has(name)) {\n                    throw env.error(`Duplicate key ${name} in object literal`, locationOf(e))\n                }\n                ts.set(name, v.type)\n                vs.set(name, v.value)\n            }\n            return undocValue(vs, {\n                type: 'object',\n                properties: ts,\n            })\n        case 'if':\n            const condition = evaluate(expr.condition, env)\n            return splitMask(\n                env,\n                condition,\n                (v: USSValue, subEnv: Context): USSValue => {\n                    if (v.type.type !== 'boolean') {\n                        throw env.error(`Condition in if statement must be a boolean, but got ${renderType(v.type)}`, locationOf(expr.condition))\n                    }\n                    if (v.value) {\n                        return execute(expr.then, subEnv)\n                    }\n                    if (expr.else === undefined) {\n                        return undocValue(null, { type: 'null' })\n                    }\n                    return execute(expr.else, subEnv)\n                },\n                locationOf(expr.condition),\n                locationOf(expr),\n            )\n        case 'do':\n            if (expr.statements.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let doResult: USSValue = execute(expr.statements[0], env)\n            for (const statement of expr.statements.slice(1)) {\n                doResult = execute(statement, env)\n            }\n            return doResult\n        case 'customNode':\n            // This is a custom node for internal purposes, we just evaluate the expression\n            const result = execute(expr.expr, env)\n\n            // Check type if expectedType is provided\n            if (expr.expectedType && !expr.expectedType.some(t => canUnifyTo(result.type, t))) {\n                throw env.error(\n                    `Custom expression expected to return type ${expr.expectedType.map(t => renderType(t)).join(' or ')}, but got ${renderType(result.type)}`,\n                    locationOf(expr),\n                )\n            }\n\n            return result\n    }\n}\n\nexport function execute(expr: UrbanStatsASTStatement, env: Context): USSValue {\n    switch (expr.type) {\n        case 'condition':\n            if (expr.rest.length === 0) {\n                throw env.error('condition(..) must be followed by at least one statement', locationOf(expr))\n            }\n            return evaluate(\n                { type: 'if',\n                    condition: expr.condition,\n                    then: { type: 'statements', result: expr.rest, entireLoc: unify(...expr.rest.map(locationOf)) },\n                    entireLoc: expr.entireLoc,\n                },\n                env,\n            )\n        case 'assignment':\n            const value = evaluate(expr.value, env)\n            evaluateLHS(expr.lhs, value, env)\n            return value\n        case 'expression':\n            return evaluate(expr.value, env)\n        case 'statements':\n            if (expr.result.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let result: USSValue = execute(expr.result[0], env)\n            for (const statement of expr.result.slice(1)) {\n                result = execute(statement, env)\n            }\n            return result\n        case 'parseError':\n            assert(expr.errors.length > 0, 'parseError node must have at least one error')\n            throw env.error(\n                `Parse error: ${expr.errors.map(e => e.value).join(', ')}`,\n                expr.errors[0].location,\n            )\n    }\n}\n\nexport function evaluateLHS(lhs: UrbanStatsASTLHS, value: USSValue, env: Context): void {\n    switch (lhs.type) {\n        case 'identifier':\n            const varName = lhs.name.node\n            const err = env.assignVariable(varName, value)\n            if (err !== undefined) {\n                throw env.error(err, locationOf(lhs))\n            }\n            return\n        case 'attribute':\n            const obj = evaluate(lhs.expr, env)\n            const attr = lhs.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, value)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(lhs))\n            }\n            return\n    }\n}\n\nfunction evaluateArg(arg: UrbanStatsASTArg, env: Context): ValueArg {\n    switch (arg.type) {\n        case 'named':\n            return {\n                type: 'named',\n                name: arg.name.node,\n                value: evaluate(arg.value, env),\n            }\n        case 'unnamed':\n            return {\n                type: 'unnamed',\n                value: evaluate(arg.value, env),\n            }\n    }\n}\n\nfunction attrLookupOrSet(\n    obj: USSValue,\n    attr: string,\n    orSet: USSValue | undefined,\n): { type: 'success', value: USSValue } | { type: 'error', message: string } {\n    const type = obj.type\n    if (type.type === 'object') {\n        const val = obj.value\n        assert(val instanceof Map, `Expected object type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        const aT = type.properties.get(attr)\n        if (aT === undefined) {\n            return {\n                type: 'error',\n                message: `Attribute ${attr} not found in object of type ${renderType(type)}`,\n            }\n        }\n        if (orSet !== undefined) {\n            if (renderType(aT) !== renderType(orSet.type)) {\n                return {\n                    type: 'error',\n                    message: `Type mismatch: expected ${renderType(aT)} but got ${renderType(orSet.type)} for attribute ${attr} in object of type ${renderType(type)}`,\n                }\n            }\n            // If orSet is provided, we set the attribute to the value\n            val.set(attr, orSet.value)\n            return {\n                type: 'success',\n                value: undocValue(orSet.value, aT),\n            }\n        }\n        const content = val.get(attr)\n        assert(content !== undefined, `Expected attribute ${attr} to be defined in object, but got undefined at ${JSON.stringify(obj.value)}`)\n        return {\n            type: 'success',\n            value: undocValue(val.get(attr)!, aT),\n        }\n    }\n    if (type.type === 'vector') {\n        const val = obj.value\n        assert(val instanceof Array, `Expected vector type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        let orSetLookp: (idx: number) => USSValue | undefined = () => undefined\n        if (orSet !== undefined) {\n            if (orSet.type.type !== 'vector') {\n                orSet = undocValue(addAdditionalDims([val.length], orSet.value), { type: 'vector', elementType: orSet.type })\n            }\n            assert(Array.isArray(orSet.value), `It should be an array at this point`)\n            if (orSet.value.length !== val.length) {\n                return { type: 'error', message: `Expected vector of length ${val.length} but got ${orSet.value.length} for attribute ${attr} in object of type ${renderType(type)}` }\n            }\n            const v = orSet.value\n            const t = (orSet.type as USSVectorType).elementType\n            assert(t.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(orSet.value)}`)\n            orSetLookp = (idx: number) => {\n                return undocValue(v[idx], t)\n            }\n        }\n        const resultsOrErr = val.map((x, i) => {\n            assert(type.elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(obj.value)}`)\n            return attrLookupOrSet(undocValue(x, type.elementType), attr, orSetLookp(i))\n        })\n        if (resultsOrErr.some(r => r.type === 'error')) {\n            return { type: 'error', message: resultsOrErr.filter(r => r.type === 'error').map(r => (r as { type: 'error', message: string }).message)[0] }\n        }\n        const results = resultsOrErr.map(r => (r as { type: 'success', value: USSValue }).value)\n        const rawValue = results.map(r => r.value)\n        const typ = results[0].type\n        return {\n            type: 'success',\n            value: undocValue(rawValue, { type: 'vector', elementType: typ }),\n        }\n    }\n    return { type: 'error', message: `Cannot access attribute of type ${renderType(type)}. Only objects and vectors support attributes.` }\n}\n\nfunction evaluateUnaryOperator(operand: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.unary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.unary(operator, errLoc),\n        [operand],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n\nfunction evaluateBinaryOperator(left: USSValue, right: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.binary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.binary(operator, errLoc),\n        [left, right],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n","import { assert } from '../utils/defensive'\n\nimport { Block, LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\n\nconst nonExpressionOperators = ['=', ',', ';', '.', ':']\nconst operatorCharacters = '!@$%^&*-+=~`<>/?:|,;.'\n\nconst keywords = ['if', 'do', 'else', 'customNode', 'condition']\nexport type Keyword = (typeof keywords)[number]\n\ninterface NumericToken { type: 'number', value: number }\ninterface IdentifierToken { type: 'identifier', value: string }\ninterface KeywordToken { type: 'keyword', value: Keyword }\ninterface StringToken { type: 'string', value: string }\ninterface OperatorToken { type: 'operator', value: string }\ninterface BracketToken { type: 'bracket', value: '(' | ')' | '{' | '}' | '[' | ']' }\ninterface ErrorToken { type: 'error', value: string }\ntype NonErrorToken = NumericToken | IdentifierToken | KeywordToken | StringToken | OperatorToken | BracketToken\ntype Token = NonErrorToken | ErrorToken\n\nexport interface AnnotatedToken {\n    token: Token\n    location: LocInfo\n}\n\nexport type AnnotatedTokenWithValue = AnnotatedToken & { token: NonErrorToken }\n\ninterface GenericLexer {\n    firstToken: (ch: string) => boolean\n    innerToken: (ch: string) => boolean\n    parse: (string: string) => Token\n}\n\nfunction isDigit(ch: string): boolean {\n    return ch >= '0' && ch <= '9'\n}\nfunction isAlpha(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_'\n}\n\nexport function emptyLocation(ident: string): LocInfo {\n    return {\n        start: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n        end: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n    }\n}\n\nexport function parseNumber(input: string): number | undefined {\n    if (/^-?\\d*(\\.\\d+)?([eE][+-]?\\d+)?$/i.test(input)) {\n        // normal number format\n        const value = parseFloat(input)\n        if (isNaN(value)) {\n            return\n        }\n        return value\n    }\n    if (input.endsWith('k')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000\n    }\n    if (input.endsWith('m')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000000\n    }\n    return\n}\n\nconst identifierLexer: GenericLexer = {\n    firstToken: isAlpha,\n    innerToken: (ch: string): boolean => isAlpha(ch) || isDigit(ch),\n    parse: (string: string): Token => { return { type: keywords.includes(string) ? 'keyword' : 'identifier', value: string } },\n}\n\nexport function allOperators(): string[] {\n    const ops = new Set<string>(nonExpressionOperators)\n    for (const op of expressionOperatorMap.keys()) {\n        ops.add(op)\n    }\n    // sort operators in descending length order to ensure longest match first\n    return Array.from(ops).sort((a, b) => b.length - a.length)\n}\n\nfunction tokenizeOperators(input: string): string[] | undefined {\n    const allOps = allOperators()\n    // console.log(allOps)\n    const tokens: string[] = []\n    let idx = 0\n    while (idx < input.length) {\n        let didMatch = false\n        for (const op of allOps) {\n            if (input.startsWith(op, idx)) {\n                tokens.push(op)\n                idx += op.length\n                didMatch = true\n                break\n            }\n        }\n        if (!didMatch)\n            return undefined\n    }\n    if (idx !== input.length) {\n        return undefined\n    }\n    return tokens\n}\n\nfunction lexOperators(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken[]] {\n    const [finalIdx, supertok] = lexGeneric(input, idx, block, lineNo, operatorLexer, charIdxOffset)\n    if (finalIdx === idx) {\n        return [idx, []]\n    }\n    // console.log(supertok)\n    assert(supertok !== undefined, 'unreachable')\n    assert(supertok.token.type === 'operator', 'unreachable')\n    const tokenizedOperators = tokenizeOperators(supertok.token.value)\n    // console.log(tokenizedOperators)\n    if (tokenizedOperators === undefined) {\n        return [finalIdx, [\n            {\n                token: { type: 'error', value: `Invalid operator sequence: ${supertok.token.value}` },\n                location: supertok.location,\n            },\n        ]]\n    }\n    let start = idx\n    const separatedTokens = tokenizedOperators.map((op) => {\n        const location: LocInfo = {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: start + op.length, charIdx: charIdxOffset + start + op.length },\n        }\n        start += op.length\n        return {\n            token: { type: 'operator', value: op },\n            location,\n        } satisfies AnnotatedToken\n    })\n    // console.log(separatedTokens)\n    return [finalIdx, separatedTokens]\n}\n\nconst operatorLexer: GenericLexer = {\n    firstToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    innerToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    parse: (string: string): Token => {\n        return { type: 'operator', value: string }\n    },\n}\n\nfunction lexLine(input: string, block: Block, lineNo: number, charIdxOffset: number): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    // one line\n    assert(!input.includes('\\n'), 'Input contains new line characters')\n    let idx = 0\n    lex: while (idx < input.length) {\n        const char = input[idx]\n        if (char === ' ') {\n            idx++\n            continue\n        }\n        if (char === '(' || char === ')' || char === '{' || char === '}' || char === '[' || char === ']') {\n            const token: AnnotatedToken = {\n                token: { type: 'bracket', value: char },\n                location: {\n                    start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                    end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n                },\n            }\n            tokens.push(token)\n            idx++\n            continue\n        }\n        if (isDigit(char)) {\n            let token\n            [idx, token] = lexNumber(input, idx, block, lineNo, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue\n            }\n        }\n        for (const lexer of [identifierLexer]) {\n            let token\n            [idx, token] = lexGeneric(input, idx, block, lineNo, lexer, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue lex\n            }\n        }\n        {\n            let toks\n            [idx, toks] = lexOperators(input, idx, block, lineNo, charIdxOffset)\n            if (toks.length > 0) {\n                tokens.push(...toks)\n                continue\n            }\n        }\n        let token\n        [idx, token] = lexString(input, idx, block, lineNo, charIdxOffset)\n        if (token !== undefined) {\n            tokens.push(token)\n            continue\n        }\n        tokens.push({\n            token: { type: 'error', value: `Unexpected character: ${char}` },\n            location: {\n                start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n            },\n        })\n        idx++\n    }\n    return tokens\n}\n\nexport function lex(block: Block, input: string): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    const lines = input.split('\\n')\n    let charIdx = 0\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i]\n        const lineTokens = lexLine(line, block, i, charIdx)\n        tokens.push(...lineTokens)\n        charIdx += line.length\n        tokens.push({\n            token: { type: 'operator', value: 'EOL' },\n            location: {\n                start: { block, lineIdx: i, colIdx: line.length, charIdx },\n                end: { block, lineIdx: i, colIdx: line.length, charIdx },\n            },\n        })\n        charIdx += 1 // newline\n    }\n    return tokens\n}\n\nfunction lexGeneric(\n    input: string,\n    idx: number,\n    block: Block,\n    lineNo: number,\n    lexer: GenericLexer,\n    charIdxOffset: number,\n): [number, AnnotatedToken | undefined] {\n    if (!lexer.firstToken(input[idx])) {\n        return [idx, undefined]\n    }\n\n    const start = idx\n    while (idx < input.length && lexer.innerToken(input[idx])) {\n        idx++\n    }\n    const token: AnnotatedToken = {\n        token: lexer.parse(input.slice(start, idx)),\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexString(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    if (input[idx] !== '\"') {\n        return [idx, undefined]\n    }\n    const start = idx\n    idx++\n    while (true) {\n        if (idx >= input.length) {\n            return [idx, { token: { type: 'error', value: 'Unterminated string' }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + start } } }]\n        }\n        if (input[idx] === '\"') {\n            idx++\n            break\n        }\n        if (input[idx] === '\\\\') {\n            idx += 2\n            continue\n        }\n        idx++\n    }\n    let result: string\n    try {\n        const resultObj: unknown = JSON.parse(input.slice(start, idx))\n        assert(typeof resultObj === 'string', `Invalid string: ${input.slice(start, idx)}`)\n        result = resultObj\n    }\n    catch (e) {\n        return [idx, { token: { type: 'error', value: `Invalid string: ${input.slice(start, idx)}: ${e}` }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'string', value: result },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexNumber(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    const numberFormat = /^\\d+(\\.\\d+)?([eE][+-]?\\d+|k|m)?/i\n    const match = numberFormat.exec(input.slice(idx))\n    if (!match) {\n        return [idx, undefined]\n    }\n    const numberStr = match[0]\n    const number = parseNumber(numberStr)\n    if (number === undefined) {\n        return [idx + numberStr.length, { token: { type: 'error', value: `Invalid number format: ${numberStr}` }, location: { start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx }, end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'number', value: number },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n            end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length },\n        },\n    }\n    return [idx + numberStr.length, token]\n}\n","export type Block = { type: 'single', ident: string } | { type: 'multi' }\n\nexport interface SingleLocationWithinBlock {\n    lineIdx: number\n    colIdx: number\n    charIdx: number\n}\nexport type SingleLocation = SingleLocationWithinBlock & { block: Block }\n\nexport interface LocInfo {\n    start: SingleLocation\n    end: SingleLocation\n}\n\nexport const noLocation = { start: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 }, end: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 } } satisfies LocInfo\n\nexport function extendBlockIdPositionalArg(blockIdent: string, position: number): string {\n    return `${blockIdent}_pos_${position}`\n}\n\nexport function extendBlockIdKwarg(blockIdent: string, argName: string): string {\n    return `${blockIdent}_${argName}`\n}\n\nexport function extendBlockIdVectorElement(blockIdent: string, index: number): string {\n    return `${blockIdent}_el_${index}`\n}\n\nexport function extendBlockIdObjectProperty(blockIdent: string, property: string): string {\n    return `${blockIdent}_prop_${property}`\n}\n","import { assert } from '../utils/defensive'\n\nimport { locationOf, unify, UrbanStatsAST, UrbanStatsASTArg, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTStatement } from './ast'\nimport { Context } from './context'\nimport { AnnotatedToken, AnnotatedTokenWithValue, lex, Keyword, emptyLocation } from './lexer'\nimport { noLocation, LocInfo, Block } from './location'\nimport { expressionOperatorMap, infixOperators, unaryOperators } from './operators'\nimport { USSType } from './types-values'\n\nexport interface Decorated<T> {\n    node: T\n    location: LocInfo\n}\n\nexport interface ParseError { type: 'error', value: string, location: LocInfo }\n\ntype USSInfixSequenceElement = { type: 'operator', operatorType: 'unary' | 'binary', value: Decorated<string> } | UrbanStatsASTExpression\n\nexport function toSExp(node: UrbanStatsAST): string {\n    /**\n     * For testing purposes, we convert the AST to a simple S-expression format.\n     */\n    switch (node.type) {\n        case 'unnamed':\n            return toSExp(node.value)\n        case 'named':\n            return `(named ${node.name.node} ${toSExp(node.value)})`\n        case 'constant':\n            return `(const ${node.value.node.value})`\n        case 'identifier':\n            return `(id ${node.name.node})`\n        case 'attribute':\n            return `(attr ${toSExp(node.expr)} ${node.name.node})`\n        case 'call':\n            return `(fn ${[node.fn, ...node.args].map(toSExp).join(' ')})`\n        case 'unaryOperator':\n            return `(${node.operator.node} ${toSExp(node.expr)})`\n        case 'binaryOperator':\n            return `(${node.operator.node} ${toSExp(node.left)} ${toSExp(node.right)})`\n        case 'vectorLiteral':\n            return `(vector ${node.elements.map(toSExp).join(' ')})`\n        case 'objectLiteral':\n            return `(object ${node.properties.map(([key, value]) => `(${key} ${toSExp(value)})`).join(' ')})`\n        case 'assignment':\n            return `(assign ${toSExp(node.lhs)} ${toSExp(node.value)})`\n        case 'expression':\n            return `(expr ${toSExp(node.value)})`\n        case 'statements':\n            return `(statements ${node.result.map(toSExp).join(' ')})`\n        case 'if':\n            return `(if ${toSExp(node.condition)} ${toSExp(node.then)}${node.else ? ` ${toSExp(node.else)}` : ''})`\n        case 'do':\n            return `(do ${node.statements.map(toSExp).join(' ')})`\n        case 'condition':\n            return `(condition ${toSExp(node.condition)} ${node.rest.map(toSExp).join(' ')})`\n        case 'parseError':\n            return `(parseError ${JSON.stringify(node.originalCode)} ${JSON.stringify(node.errors)})`\n        case 'customNode':\n            return `(customNode ${toSExp(node.expr)} ${JSON.stringify(node.originalCode)})`\n    }\n}\n\nclass ParseState {\n    tokens: AnnotatedTokenWithValue[]\n    index: number\n    constructor(tokens: AnnotatedTokenWithValue[]) {\n        this.tokens = tokens\n        this.index = 0\n    }\n\n    skipEOL(): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === 'operator' && token.token.value === 'EOL') {\n            this.index++\n            return true\n        }\n        return false\n    }\n\n    consumeTokenOfType(type: string, ...values: (string | number)[]): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === type && (values.length === 0 || values.includes(token.token.value))) {\n            this.index++\n            return true\n        }\n        if (this.skipEOL()) {\n            if (this.consumeTokenOfType(type, ...values)) {\n                return true\n            }\n            this.index-- // backtrack\n        }\n        return false\n    }\n\n    consumeOperator(...oneOfOps: string[]): boolean {\n        return this.consumeTokenOfType('operator', ...oneOfOps)\n    }\n\n    consumeBracket(...oneOfBrackets: string[]): boolean {\n        return this.consumeTokenOfType('bracket', ...oneOfBrackets)\n    }\n\n    consumeIdentifier(): boolean {\n        return this.consumeTokenOfType('identifier')\n    }\n\n    consumeKeyword(...oneOfKeywords: Keyword[]): boolean {\n        return this.consumeTokenOfType('keyword', ...oneOfKeywords)\n    }\n\n    maybeLastNonEOLToken(offset: number): AnnotatedTokenWithValue {\n        for (let i = this.index + offset; i >= 0; i--) {\n            const token = this.tokens[i]\n            if (token.token.type !== 'operator' || token.token.value !== 'EOL') {\n                return token\n            }\n        }\n        return this.tokens[this.index + offset]\n    }\n\n    parseSingleExpression(): UrbanStatsASTExpression | ParseError {\n        while (this.skipEOL()) { }\n        if (this.index >= this.tokens.length) {\n            return { type: 'error', value: 'Unexpected end of input', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const token = this.tokens[this.index]\n        switch (token.token.type) {\n            case 'number':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'number', value: token.token.value }, location: token.location } }\n            case 'string':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'string', value: token.token.value }, location: token.location } }\n            case 'identifier':\n                this.index++\n                return { type: 'identifier', name: { node: token.token.value, location: token.location } }\n            case 'keyword':\n                return { type: 'error', value: `Unexpected keyword ${token.token.value}`, location: token.location }\n            case 'bracket':\n                switch (token.token.value) {\n                    case '(':\n                        this.index++\n                        const expr = this.parseExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        if (!this.consumeBracket(')')) {\n                            return { type: 'error', value: 'Expected closing bracket ) to match this one', location: token.location }\n                        }\n                        return expr\n                    case '{':\n                        this.index++\n                        const startLoc = token.location\n                        const properties: [string, UrbanStatsASTExpression][] = []\n                        while (!this.consumeBracket('}')) {\n                            if (properties.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: `Expected comma , or closing bracket } after object field name; instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n                            }\n                            if (!this.consumeIdentifier()) {\n                                return { type: 'error', value: 'Expected identifier for object field name', location: this.maybeLastNonEOLToken(-1).location }\n                            }\n                            const keyToken = this.tokens[this.index - 1]\n                            assert(keyToken.token.type === 'identifier', `Expected identifier token, but got ${keyToken.token.type}`)\n                            if (!this.consumeOperator(':')) {\n                                return { type: 'error', value: `Expected : token after object field name`, location: keyToken.location }\n                            }\n                            const value = this.parseExpression()\n                            if (value.type === 'error') {\n                                return value\n                            }\n                            properties.push([keyToken.token.value, value])\n                        }\n                        const endLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'objectLiteral',\n                            entireLoc: unify(startLoc, endLoc),\n                            properties,\n                        }\n                    case '[':\n                        this.index++\n                        const vectorStartLoc = token.location\n                        const elements: UrbanStatsASTExpression[] = []\n                        while (!this.consumeBracket(']')) {\n                            if (elements.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: 'Expected comma , or closing bracket ] after vector element', location: this.maybeLastNonEOLToken(0).location }\n                            }\n                            const element = this.parseExpression()\n                            if (element.type === 'error') {\n                                return element\n                            }\n                            elements.push(element)\n                        }\n                        const vectorEndLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'vectorLiteral',\n                            entireLoc: unify(vectorStartLoc, vectorEndLoc),\n                            elements,\n                        }\n                }\n                return { type: 'error', value: `Unexpected bracket ${token.token.value}`, location: token.location }\n            case 'operator':\n                return { type: 'error', value: `Unexpected operator ${token.token.value}`, location: token.location }\n        }\n    }\n\n    parseArg(): UrbanStatsASTArg | ParseError {\n        const exprOrName = this.parseExpression()\n        if (exprOrName.type === 'error') {\n            return exprOrName\n        }\n        if (!this.consumeOperator('=')) {\n            return { type: 'unnamed', value: exprOrName }\n        }\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (exprOrName.type !== 'identifier') {\n            return { type: 'error', value: 'Expected identifier for named argument', location: locationOf(exprOrName) }\n        }\n        return {\n            type: 'named',\n            name: { node: exprOrName.name.node, location: exprOrName.name.location },\n            value: expr,\n        }\n    }\n\n    parseParenthesizedArgs(): { type: 'args', args: [UrbanStatsASTArg[], LocInfo] } | ParseError | undefined {\n        if (!this.consumeBracket('(')) {\n            return undefined\n        }\n        const startLoc = this.tokens[this.index - 1].location\n        const args: UrbanStatsASTArg[] = []\n        while (true) {\n            if (this.consumeBracket(')')) {\n                const endLoc = this.tokens[this.index - 1].location\n                return { type: 'args', args: [args, unify(startLoc, endLoc)] }\n            }\n            if (args.length > 0 && !this.consumeOperator(',')) {\n                return { type: 'error', value: `Expected comma , or closing bracket ); instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n            }\n            const arg = this.parseArg()\n            if (arg.type === 'error') {\n                return arg\n            }\n            args.push(arg)\n        }\n    }\n\n    parseFunctionalExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('customNode')) {\n            return this.parseCustomNodeExpression()\n        }\n\n        let fn = this.parseSingleExpression()\n        if (fn.type === 'error') {\n            return fn\n        }\n        while (true) {\n            let done = true\n            const args = this.parseParenthesizedArgs()\n            if (args !== undefined) {\n                done = false\n                if (args.type === 'error') {\n                    return args\n                }\n                fn = {\n                    type: 'call',\n                    fn,\n                    entireLoc: unify(locationOf(fn), args.args[1]),\n                    args: args.args[0],\n                }\n            }\n            if (this.consumeOperator('.')) {\n                done = false\n                if (!this.consumeIdentifier()) {\n                    return { type: 'error', value: 'Expected identifier after the dot', location: this.maybeLastNonEOLToken(-1).location }\n                }\n                const token = this.tokens[this.index - 1]\n                assert(token.token.type === 'identifier', `Expected identifier token, but got ${token.token.type}`)\n                fn = {\n                    type: 'attribute',\n                    expr: fn,\n                    name: { node: token.token.value, location: token.location },\n                }\n            }\n            if (done) {\n                break\n            }\n        }\n        return fn\n    }\n\n    parseExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('if')) {\n            return this.parseIfExpression()\n        }\n\n        if (this.consumeKeyword('do')) {\n            return this.parseDoExpression()\n        }\n\n        const operatorExpSequence: USSInfixSequenceElement[] = []\n        // State Machine with states expressionOrUnaryOperator; binaryOperator\n        let state: 'expressionOrUnaryOperator' | 'binaryOperator' = 'expressionOrUnaryOperator'\n        loop: while (true) {\n            switch (state) {\n                case 'expressionOrUnaryOperator': {\n                    if (this.consumeOperator(...unaryOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'unary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        continue\n                    }\n                    else {\n                        const expr = this.parseFunctionalExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        operatorExpSequence.push(expr)\n                        state = 'binaryOperator'\n                    }\n                }\n                    break\n                case 'binaryOperator': {\n                    if (this.consumeOperator(...infixOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'binary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        state = 'expressionOrUnaryOperator'\n                    }\n                    else {\n                        break loop\n                    }\n                }\n            }\n        }\n        return this.parseInfixSequence(operatorExpSequence)\n    }\n\n    parseInfixSequence(operatorExpSequence: USSInfixSequenceElement[]): UrbanStatsASTExpression | ParseError {\n        assert(operatorExpSequence.length !== 0, 'Expected expression')\n        if (operatorExpSequence.length === 1) {\n            assert(operatorExpSequence[0].type !== 'operator', `Unexpected operator ${JSON.stringify(operatorExpSequence[0])} at beginning of infix sequence`)\n            return operatorExpSequence[0]\n        }\n        // Get the highest precedence operator\n        const precedences = operatorExpSequence.map(x => x.type === 'operator' ? expressionOperatorMap.get(x.value.node)?.precedence ?? 0 : 0)\n        const maxPrecedence = Math.max(...precedences)\n        assert(maxPrecedence > 0, 'No valid operator found in infix sequence')\n        const index = precedences.findIndex(p => p === maxPrecedence)\n        assert(index > -1, 'No operator found with maximum precedence; this should not happen')\n        return this.parseInfixSequence(this.resolveOperator(operatorExpSequence, index))\n    }\n\n    resolveOperator(operatorExpSequence: USSInfixSequenceElement[], index: number): USSInfixSequenceElement[] {\n        assert(operatorExpSequence[index].type === 'operator', `Expected operator at index ${index}, but found expression: ${JSON.stringify(operatorExpSequence[index])}`)\n        const next = operatorExpSequence[index + 1]\n        if (next.type === 'operator') {\n            return this.resolveOperator(operatorExpSequence, index + 1)\n        }\n        switch (operatorExpSequence[index].operatorType) {\n            case 'unary': {\n                return [\n                    ...operatorExpSequence.slice(0, index),\n                    { type: 'unaryOperator', operator: operatorExpSequence[index].value, expr: next },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n            case 'binary': {\n                // Split the sequence into left and right parts\n                const left = operatorExpSequence[index - 1]\n                const right = operatorExpSequence[index + 1]\n                assert(left.type !== 'operator' && right.type !== 'operator', 'unreachable: left or right should not be an operator')\n                return [\n                    ...operatorExpSequence.slice(0, index - 1),\n                    { type: 'binaryOperator', operator: operatorExpSequence[index].value, left, right },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n        }\n    }\n\n    checkLHS(expr: UrbanStatsASTExpression): UrbanStatsASTLHS | ParseError {\n        switch (expr.type) {\n            case 'identifier':\n            case 'attribute':\n                return expr\n            case 'constant':\n            case 'call':\n            case 'unaryOperator':\n            case 'binaryOperator':\n            case 'vectorLiteral':\n            case 'objectLiteral':\n            case 'if':\n            case 'do':\n            case 'customNode':\n                return { type: 'error', value: 'Cannot assign to this expression', location: locationOf(expr) }\n        }\n    }\n\n    parseStatement(): UrbanStatsASTStatement | ParseError {\n        if (this.consumeKeyword('condition')) {\n            return this.parseConditionStatement()\n        }\n\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (this.consumeOperator('=')) {\n            const value = this.parseExpression()\n            if (value.type === 'error') {\n                return value\n            }\n            const lhs = this.checkLHS(expr)\n            if (lhs.type === 'error') {\n                return lhs\n            }\n            return { type: 'assignment', lhs, value }\n        }\n        return { type: 'expression', value: expr }\n    }\n\n    parseIfExpression(): UrbanStatsASTExpression | ParseError {\n        const ifToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after if', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const then = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after if block')\n        if (then.type === 'error') {\n            return then\n        }\n        let elseBranch: UrbanStatsASTStatement | undefined = undefined\n        if (this.consumeKeyword('else')) {\n            if (!this.consumeBracket('{')) {\n                return { type: 'error', value: 'Expected opening bracket { after else', location: this.maybeLastNonEOLToken(-1).location }\n            }\n            const eb = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after else block')\n            if (eb.type === 'error') {\n                return eb\n            }\n            elseBranch = eb\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'if',\n            entireLoc: unify(ifToken.location, lastToken.location),\n            condition,\n            then,\n            else: elseBranch,\n        }\n    }\n\n    parseDoExpression(): UrbanStatsASTExpression | ParseError {\n        const doToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after do', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const statements = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after do block')\n        if (statements.type === 'error') {\n            return statements\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'do',\n            entireLoc: unify(doToken.location, lastToken.location),\n            statements: statements.type === 'statements' ? statements.result : [statements],\n        }\n    }\n\n    parseConditionStatement(): UrbanStatsASTStatement | ParseError {\n        const conditionToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return {\n            type: 'condition',\n            entireLoc: unify(conditionToken.location, this.tokens[this.index - 1].location),\n            condition,\n            rest: [],\n        }\n    }\n\n    parseStatements(canEnd: boolean = false, end: () => boolean = () => false, errMsg: string = 'Expected end of line or ; after'): UrbanStatsASTStatement | ParseError {\n        const statements: UrbanStatsASTStatement[] = []\n        while (this.index < this.tokens.length) {\n            if (end()) {\n                break\n            }\n            while (this.skipEOL()) { }\n            if (this.index >= this.tokens.length) {\n                break\n            }\n            const statement = this.parseStatement()\n            if (statement.type === 'error') {\n                return statement\n            }\n            statements.push(statement)\n            if (end()) {\n                break\n            }\n            if (!this.consumeOperator('EOL', ';')) {\n                return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n            }\n            while (this.skipEOL()) { }\n        }\n        if (this.index === this.tokens.length && canEnd) {\n            return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return mergeStatements(\n            statements,\n            this.index > 0\n                ? this.tokens[this.index - 1].location\n                /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n                : undefined,\n        )\n    }\n\n    parseCustomNodeExpression(): UrbanStatsASTExpression | ParseError {\n        const argsRes = this.parseParenthesizedArgs()\n\n        if (argsRes === undefined) {\n            return { type: 'error', value: 'Expected arguments for customNode', location: this.maybeLastNonEOLToken(-1).location }\n        }\n\n        if (argsRes.type === 'error') {\n            return argsRes\n        }\n\n        const [args, locArg] = argsRes.args\n\n        const code = args[0]\n\n        if (args.length !== 1 || code.type !== 'unnamed') {\n            return { type: 'error', value: 'Incorrect arguments for customNode, expected 1 unnamed argument', location: argsRes.args[1] }\n        }\n\n        if (code.value.type !== 'constant' || code.value.value.node.type !== 'string') {\n            return { type: 'error', value: 'Expected string constant as argument to customNode', location: locationOf(code) }\n        }\n\n        const parseResult = parse(code.value.value.node.value, code.value.value.location.start.block)\n\n        if (parseResult.type === 'error') {\n            return {\n                type: 'customNode',\n                expr: {\n                    type: 'parseError',\n                    errors: parseResult.errors,\n                    originalCode: code.value.value.node.value,\n                },\n                originalCode: code.value.value.node.value,\n                entireLoc: locArg,\n            }\n        }\n\n        return {\n            type: 'customNode',\n            expr: parseResult,\n            originalCode: code.value.value.node.value,\n            entireLoc: locArg,\n        }\n    }\n}\n\nexport function mergeStatements(statements: UrbanStatsASTStatement[], fallbackLocation?: LocInfo): UrbanStatsASTStatement {\n    statements = gulpRestForConditions(statements)\n    if (statements.length === 1) {\n        return statements[0]\n    }\n    const entireLoc: LocInfo = statements.length > 0\n        ? unify(...statements.map(locationOf))\n        : fallbackLocation\n        /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n        ?? noLocation\n    return { type: 'statements', result: statements, entireLoc }\n}\n\nfunction gulpRestForConditions(statements: UrbanStatsASTStatement[]): UrbanStatsASTStatement[] {\n    /**\n     * Handle condition statements by gulping the next statement into the condition's rest.\n     */\n    const result: UrbanStatsASTStatement[] = []\n    for (let i = 0; i < statements.length; i++) {\n        const stmt = statements[i]\n        if (stmt.type === 'condition') {\n            stmt.rest.push(...gulpRestForConditions(statements.slice(i + 1)))\n            result.push(stmt)\n            break\n        }\n        result.push(stmt)\n    }\n    return result\n}\n\nexport function parse(code: string, block?: Block, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const tokens = lex(block ?? { type: 'multi' }, code)\n    return parseTokens(tokens, code, returnParseErrorNode)\n}\n\nexport function parseTokens(tokens: AnnotatedToken[], originalCode: string, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const lexErrors = tokens.filter(token => token.token.type === 'error')\n    if (lexErrors.length > 0) {\n        const errors: ParseError[] = lexErrors.map(token => ({ type: 'error' as const, value: `Unrecognized token: ${token.token.value}`, location: token.location }))\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors }\n        }\n        return { type: 'error', errors }\n    }\n    const state = new ParseState(tokens as AnnotatedTokenWithValue[]) // we checked for errors above, so this cast is safe\n    const stmts = state.parseStatements()\n    if (stmts.type === 'error') {\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors: [stmts] }\n        }\n        return { type: 'error', errors: [stmts] }\n    }\n    assert(state.index === state.tokens.length, `Parser did not consume all tokens: ${state.index} < ${state.tokens.length}`)\n    return stmts\n}\n\nfunction allExpressions(node: UrbanStatsASTStatement | UrbanStatsASTExpression): UrbanStatsASTExpression[] {\n    const expressions: UrbanStatsASTExpression[] = []\n    function helper(n: UrbanStatsASTStatement | UrbanStatsASTExpression | UrbanStatsASTArg): boolean {\n        switch (n.type) {\n            case 'unnamed':\n                helper(n.value)\n                return true\n            case 'named':\n                expressions.push(n.value)\n                helper(n.value)\n                return true\n            case 'constant':\n            case 'identifier':\n                expressions.push(n)\n                return true\n            case 'attribute':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'call':\n                expressions.push(n)\n                helper(n.fn)\n                n.args.forEach(helper)\n                return true\n            case 'unaryOperator':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'binaryOperator':\n                expressions.push(n)\n                helper(n.left)\n                helper(n.right)\n                return true\n            case 'objectLiteral':\n                expressions.push(n)\n                n.properties.forEach(([key, value]) => {\n                    expressions.push({ type: 'constant', value: { node: { type: 'string', value: key }, location: n.entireLoc } })\n                    helper(value)\n                })\n                return true\n            case 'vectorLiteral':\n                expressions.push(n)\n                n.elements.forEach(helper)\n                return true\n            case 'assignment':\n                helper(n.lhs)\n                helper(n.value)\n                return true\n            case 'expression':\n                helper(n.value)\n                return true\n            case 'statements':\n                n.result.forEach(helper)\n                return true\n            case 'if':\n                helper(n.condition)\n                helper(n.then)\n                if (n.else) {\n                    helper(n.else)\n                }\n                return true\n            case 'do':\n                n.statements.forEach(helper)\n                return true\n            case 'condition':\n                helper(n.condition)\n                n.rest.forEach(helper)\n                return true\n            case 'parseError':\n                return true\n            case 'customNode':\n                // do not actually put this in the expressions list, as is for internal use only\n                helper(n.expr)\n                return true\n        }\n    }\n    helper(node)\n    return expressions\n}\n\nfunction identifiersInExpr(node: UrbanStatsASTStatement | UrbanStatsASTExpression): Set<string> {\n    const identifiers = new Set<string>()\n    allExpressions(node).forEach((expr) => {\n        if (expr.type === 'identifier') {\n            identifiers.add(expr.name.node)\n        }\n    })\n    return identifiers\n}\n\nexport function allIdentifiers(node: UrbanStatsASTStatement | UrbanStatsASTExpression, ctx: Context): Set<string> {\n    const identifiers = identifiersInExpr(node)\n    while (true) {\n        // make sure to include identifiers from default values of function arguments pulled in by the identifiers\n        const newIdentifiers = new Set<string>()\n        identifiers.forEach((id) => {\n            const t = ctx.getVariable(id)?.type\n            if (t === undefined || t.type !== 'function') {\n                return\n            }\n            Object.entries(t.namedArgs).forEach(([, arg]) => {\n                const dv = arg.defaultValue\n                if (dv === undefined) {\n                    return\n                }\n                identifiersInExpr(dv).forEach((newId) => {\n                    if (!identifiers.has(newId)) {\n                        newIdentifiers.add(newId)\n                    }\n                })\n            })\n        })\n        if (newIdentifiers.size === 0) {\n            break\n        }\n        newIdentifiers.forEach(id => identifiers.add(id))\n    }\n    return identifiers\n}\n\nexport function unparse(node: UrbanStatsASTStatement | UrbanStatsASTExpression, opts: { indent?: number, inline?: boolean, simplify?: boolean, expressionalContext?: boolean, wrap?: boolean } = {}): string {\n    if (opts.inline) {\n        assert(opts.expressionalContext ?? false, 'expressionalContext must be true if inline is true')\n    }\n    opts.indent = opts.indent ?? 0\n    opts.wrap = opts.wrap ?? true\n    function isSimpleExpression(expr: UrbanStatsASTExpression): boolean {\n        return expr.type === 'identifier' || expr.type === 'vectorLiteral' || expr.type === 'constant' || expr.type === 'customNode'\n    }\n    function indentSpaces(level: number): string {\n        return '    '.repeat(level)\n    }\n\n    const characterLimit = 80 - indentSpaces(opts.indent).length\n\n    switch (node.type) {\n        case 'customNode':\n            if (!opts.simplify) {\n                return `customNode(${JSON.stringify(node.originalCode.trim())})`\n            }\n            if (opts.expressionalContext && node.expr.type !== 'expression') {\n                return unparse({ type: 'do', statements: [node.expr], entireLoc: locationOf(node.expr) }, { ...opts, inline: true })\n            }\n            else {\n                return node.originalCode.trim()\n            }\n        case 'parseError':\n            return node.originalCode\n        case 'constant':\n            if (node.value.node.type === 'string') {\n                return JSON.stringify(node.value.node.value)\n            }\n            else {\n                return node.value.node.value.toString()\n            }\n        case 'identifier':\n            return node.name.node\n        case 'attribute':\n            const exprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            return `${exprStr}.${node.name.node}`\n        case 'call': {\n            const fnStr = unparse(node.fn, { ...opts, inline: true, expressionalContext: true })\n            const argsStr = node.args.map((arg) => {\n                switch (arg.type) {\n                    case 'unnamed':\n                        return unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: false })\n                    case 'named':\n                        return `${arg.name.node}=${unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: false })}`\n                }\n            })\n            const fnNeedsParens = !isSimpleExpression(node.fn)\n            const fnWithParens = fnNeedsParens ? `(${fnStr})` : fnStr\n            const notWrapped = `${fnWithParens}(${argsStr.join(', ')})`\n            if (notWrapped.length > characterLimit && opts.wrap) {\n                // Special case for one unnamed argument that's a vector literal\n                if (node.args.length === 1 && node.args[0].type === 'unnamed' && node.args[0].value.type === 'vectorLiteral') {\n                    return `${fnWithParens}(${unparse(node.args[0].value, { ...opts, inline: true, expressionalContext: true, wrap: true })})`\n                }\n                const wrappedArgs = node.args.map((arg) => {\n                    switch (arg.type) {\n                        case 'unnamed':\n                            return `${indentSpaces(opts.indent! + 1)}${unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: true, indent: opts.indent! + 1 })}`\n                        case 'named':\n                            return `${indentSpaces(opts.indent! + 1)}${arg.name.node}=${unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: true, indent: opts.indent! + 1 })}`\n                    }\n                })\n                return `${fnWithParens}(\\n${wrappedArgs.join(',\\n')}\\n${indentSpaces(opts.indent)})`\n            }\n            return notWrapped\n        }\n        case 'unaryOperator':\n            const unaryExprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            const needsParens = !isSimpleExpression(node.expr)\n            const exprWithParens = needsParens ? `(${unaryExprStr})` : unaryExprStr\n            return `${node.operator.node}${exprWithParens}`\n        case 'binaryOperator':\n            const leftStr = unparse(node.left, { ...opts, inline: true, expressionalContext: true })\n            const rightStr = unparse(node.right, { ...opts, inline: true, expressionalContext: true })\n            const opPrecedence = expressionOperatorMap.get(node.operator.node)?.precedence ?? 0\n            let leftWithParens = leftStr\n            if (node.left.type === 'binaryOperator') {\n                const leftOpPrecedence = expressionOperatorMap.get(node.left.operator.node)?.precedence ?? 0\n                if (leftOpPrecedence < opPrecedence) {\n                    leftWithParens = `(${leftStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.left)) {\n                leftWithParens = `(${leftStr})`\n            }\n            let rightWithParens = rightStr\n            if (node.right.type === 'binaryOperator') {\n                const rightOpPrecedence = expressionOperatorMap.get(node.right.operator.node)?.precedence ?? 0\n                if (rightOpPrecedence <= opPrecedence) {\n                    rightWithParens = `(${rightStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.right)) {\n                rightWithParens = `(${rightStr})`\n            }\n            return `${leftWithParens} ${node.operator.node} ${rightWithParens}`\n        case 'vectorLiteral': {\n            const elementsStr = node.elements.map(elem => unparse(elem, { ...opts, inline: true, expressionalContext: true, wrap: false }))\n            const notWrapped = `[${elementsStr.join(', ')}]`\n            if (notWrapped.length > characterLimit && opts.wrap) {\n                const wrappedElements = node.elements.map(elem => `${indentSpaces(opts.indent! + 1)}${unparse(elem, { ...opts, inline: true, expressionalContext: true, wrap: true, indent: opts.indent! + 1 })}`)\n                return `[\\n${wrappedElements.join(',\\n')}\\n${indentSpaces(opts.indent)}]`\n            }\n            return notWrapped\n        }\n        case 'objectLiteral': {\n            const propertiesStr = node.properties.map(([key, value]) => {\n                const valueStr = unparse(value, { ...opts, inline: true, expressionalContext: true, wrap: false })\n                return `${key}: ${valueStr}`\n            })\n            const notWrapped = `{${propertiesStr.join(', ')}}`\n            if (notWrapped.length > characterLimit && opts.wrap) {\n                const wrappedProperties = node.properties.map(([key, value]) => {\n                    const valueStr = unparse(value, { ...opts, inline: true, expressionalContext: true, wrap: true })\n                    return `${indentSpaces(opts.indent! + 1)}${key}: ${valueStr}`\n                })\n                return `{\\n${wrappedProperties.join(',\\n')}\\n${indentSpaces(opts.indent)}}`\n            }\n            return notWrapped\n        }\n        case 'assignment':\n            const lhsStr = unparse(node.lhs, { ...opts, expressionalContext: true })\n            const valueStr = unparse(node.value, { ...opts, expressionalContext: true })\n            return opts.inline ? `${lhsStr} = ${valueStr}` : `${indentSpaces(opts.indent)}${lhsStr} = ${valueStr}`\n        case 'expression':\n            // despite being an expression, it is not in an expressional context if its parent is not\n            return opts.inline ? unparse(node.value, opts) : `${indentSpaces(opts.indent)}${unparse(node.value, opts)}`\n        case 'statements':\n            const statementsStr = node.result\n                .map(stmt => unparse(stmt, opts))\n                .filter(s => s !== '' && s !== 'do {  }')\n            return statementsStr.join(opts.inline ? '; ' : ';\\n')\n        case 'if':\n            const conditionStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const thenStr = unparse(node.then, { ...opts, indent: opts.indent + 1 })\n            let ifStr = opts.inline\n                ? `if (${conditionStr}) { ${thenStr} }`\n                : `if (${conditionStr}) {\\n${thenStr}\\n${indentSpaces(opts.indent)}}`\n            if (node.else) {\n                const elseStr = unparse(node.else, { ...opts, indent: opts.indent + 1 })\n                ifStr += opts.inline\n                    ? ` else { ${elseStr} }`\n                    : ` else {\\n${elseStr}\\n${indentSpaces(opts.indent)}}`\n            }\n            return ifStr\n        case 'do':\n            const doStatements = { type: 'statements' as const, result: node.statements, entireLoc: node.entireLoc }\n            const doStr = unparse(doStatements, { ...opts, indent: opts.indent + 1 })\n            return opts.inline\n                ? `do { ${doStr} }`\n                : `do {\\n${doStr}\\n${indentSpaces(opts.indent)}}`\n        case 'condition':\n            const condStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const restStatements = { type: 'statements' as const, result: node.rest, entireLoc: node.entireLoc }\n            const restStr = unparse(restStatements, opts)\n            // If condition is literal \"true\", elide it\n            if (opts.simplify && node.condition.type === 'identifier' && node.condition.name.node === 'true') {\n                return restStr\n            }\n            return `${indentSpaces(opts.indent)}condition (${condStr})\\n${restStr}`\n    }\n}\n\nexport function parseNoError(uss: string, blockId: string): UrbanStatsASTStatement {\n    const result = parse(uss, { type: 'single', ident: blockId }, true)\n    assert(result.type !== 'error', `Should not have an error`)\n    return result\n}\n\nexport function parseNoErrorAsCustomNode(uss: string, blockId: string, expectedType?: USSType[]): Extract<UrbanStatsASTExpression, { type: 'customNode' }> {\n    assert(!blockId.startsWith('undefined'), 'blockId must not start with \"undefined\"')\n    const result = parseNoError(uss, blockId)\n    return {\n        type: 'customNode',\n        expr: result,\n        originalCode: uss,\n        expectedType,\n        entireLoc: emptyLocation(blockId),\n    }\n}\n\nexport function parseNoErrorAsExpression(uss: string, blockId: string): UrbanStatsASTExpression {\n    const result = parseNoError(uss, blockId)\n    assert(result.type === 'expression', `Must be expression, got ${JSON.stringify(result)}`)\n    return result.value\n}\n","import { Basemap } from '../mapper/settings/utils'\nimport { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTExpression } from './ast'\nimport { Color, deconstructColor, hexToColor } from './constants/color-utils'\nimport { CMap, CMapRGB, Outline, PMap } from './constants/map'\nimport { RampT } from './constants/ramp'\nimport { RichTextAttributes, RichTextDocument, RichTextSegment } from './constants/rich-text'\nimport { Scale } from './constants/scale'\nimport { TextBox } from './constants/text-box'\nimport { Context } from './context'\nimport { noLocation } from './location'\nimport { unparse } from './parser'\n\n// Define Inset and Insets types locally to avoid import issues\ninterface Inset { bottomLeft: [number, number], topRight: [number, number], coordBox?: [number, number, number, number], mainMap: boolean, name?: string }\ntype Insets = Inset[]\n\n// Define the tagged union for opaque values\nexport type USSOpaqueValue =\n    | { type: 'opaque', opaqueType: 'color', value: Color }\n    | { type: 'opaque', opaqueType: 'scale', value: Scale }\n    | { type: 'opaque', opaqueType: 'inset', value: Inset }\n    | { type: 'opaque', opaqueType: 'insets', value: Insets }\n    | { type: 'opaque', opaqueType: 'cMap', value: CMap }\n    | { type: 'opaque', opaqueType: 'cMapRGB', value: CMapRGB }\n    | { type: 'opaque', opaqueType: 'pMap', value: PMap }\n    | { type: 'opaque', opaqueType: 'outline', value: Outline }\n    | { type: 'opaque', opaqueType: 'unit', value: { unit: string } }\n    | { type: 'opaque', opaqueType: 'ramp', value: RampT }\n    | { type: 'opaque', opaqueType: 'basemap', value: Basemap }\n    | { type: 'opaque', opaqueType: 'geoFeatureHandle', value: string }\n    | { type: 'opaque', opaqueType: 'geoCentroidHandle', value: string }\n    | { type: 'opaque', opaqueType: 'textBox', value: TextBox }\n    | { type: 'opaque', opaqueType: 'richTextDocument', value: RichTextDocument }\n    | { type: 'opaque', opaqueType: 'richTextSegment', value: RichTextSegment }\n    | { type: 'opaque', opaqueType: 'richTextList', value: RichTextAttributes['list'] }\n    | { type: 'opaque', opaqueType: 'richTextAlign', value: RichTextAttributes['align'] }\n\ninterface USSNumberType {\n    type: 'number'\n}\n\ninterface USSStringType {\n    type: 'string'\n}\ninterface USSBooleanType {\n    type: 'boolean'\n}\n\ninterface USSNullType {\n    type: 'null'\n}\n\nexport interface USSOpaqueType {\n    type: 'opaque'\n    name: string\n    allowCustomExpression?: boolean\n}\n\nexport interface USSVectorType {\n    type: 'vector'\n    elementType: USSType | { type: 'elementOfEmptyVector' }\n}\n\nexport interface USSObjectType {\n    type: 'object'\n    properties: Map<string, USSType>\n}\n\nexport type USSFunctionArgType = { type: 'concrete', value: USSType } | { type: 'anyPrimitive' }\nexport type USSFunctionReturnType = { type: 'concrete', value: USSType } | { type: 'inferFromPrimitive' }\n\nexport interface NamedFunctionArgumentWithDocumentation {\n    type: USSFunctionArgType\n    defaultValue?: UrbanStatsASTExpression\n    documentation?: NamedFunctionArgumentDocumentation\n}\n\nexport interface USSFunctionType {\n    type: 'function'\n    posArgs: USSFunctionArgType[]\n    namedArgs: Record<string, NamedFunctionArgumentWithDocumentation>\n    returnType: USSFunctionReturnType\n}\n\ninterface NamedFunctionArgumentDocumentation {\n    hide?: boolean\n}\n\nexport type USSType = (\n    USSNumberType\n    | USSStringType\n    | USSBooleanType\n    | USSNullType\n    | USSOpaqueType\n    | USSObjectType\n    | USSVectorType\n    | USSFunctionType\n)\n\nexport type USSPrimitiveRawValue = (\n    number |\n    string |\n    boolean |\n    null\n)\n\nexport interface OriginalFunctionArgs {\n    posArgs: USSValue[]\n    namedArgs: Record<string, USSValue>\n}\n\nexport type USSRawValue = (\n    USSPrimitiveRawValue |\n    USSRawValue[] |\n    Map<string, USSRawValue> |\n    (\n        (\n            ctx: Context,\n            posArgs: USSRawValue[],\n            namedArgs: Record<string, USSRawValue>,\n            // only used occasionally, for functions that need to access the original arguments\n            // to e.g., access their documentation\n            originalArgs: OriginalFunctionArgs\n        ) => USSRawValue\n    ) |\n    USSOpaqueValue\n)\n\nexport const constantCategories = ['basic', 'color', 'math', 'regression', 'mapper', 'logic', 'map', 'scale', 'ramp', 'unit', 'inset', 'richText'] as const\n\nexport type ConstantCategory = typeof constantCategories[number]\n\nexport type DocumentationTable = 'mapper-data-variables' | 'predefined-colors' | 'unit-types' | 'predefined-ramps' | 'predefined-insets' | 'logarithm-functions' | 'trigonometric-functions'\n\nexport type SelectorRendering = { kind: 'subtitleLongDescription' } | { kind: 'gradientBackground', ramp: RampT }\nexport interface Documentation {\n    humanReadableName: string\n    priority?: number\n    /**\n     * True if this is the canonical default value for its type (e.g., the default ramp or scale).\n     */\n    isDefault?: boolean\n    /**\n     * Human-readable names for named arguments. Maps argument name to display name.\n     */\n    namedArgs?: Record<string, string>\n    /**\n     * Should be included when a constant should be deconstructed into an expression for user editing\n     */\n    equivalentExpressions?: UrbanStatsASTExpression[]\n    /**\n     * Included for all bulit-in constants.\n     */\n    category?: ConstantCategory\n    /**\n     * Whether the constant should be grouped with other constants in a table in the documentation.\n     * If present, this field groups the constant with other similar ones.\n     */\n    documentationTable?: DocumentationTable\n    /**\n     * Included for all bulit-in constants. Will be displayed in the documentation.\n     */\n    longDescription?: string\n    /**\n     * Used when displaying this value in a selector\n     */\n    selectorRendering?: SelectorRendering\n    /**\n     * True if this is a custom constructor that should invoke edit icons elsewhere\n     */\n    customConstructor?: boolean\n    /**\n     * True if the constant is derived from a statistic column. These should all have type number[]\n     */\n    fromStatisticColumn?: boolean\n    /**\n     * True if this should be outputted in the context returned by the worker. If this is true, the value\n     * should also be serializable to JSON.\n     */\n    includedInOutputContext?: boolean\n}\n\nexport interface USSDocumentedType {\n    type: USSType\n    documentation?: Documentation\n\n}\n\nexport type TypeEnvironment = Map<string, USSDocumentedType>\n\nexport type USSValue = { value: USSRawValue } & USSDocumentedType\n\nexport function undocValue(value: USSRawValue, type: USSType): USSValue {\n    return {\n        type,\n        value,\n        documentation: undefined,\n    }\n}\n\nexport function createConstantExpression(value: number | string | boolean | null): UrbanStatsASTExpression {\n    // Create a simple constant expression for primitive values\n    if (typeof value === 'number') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'number', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'string') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'string', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'boolean') {\n        // For booleans, use identifier expressions that reference the predefined constants\n        return {\n            type: 'identifier',\n            name: { node: value.toString(), location: noLocation },\n        }\n    }\n    else {\n        // For null, use identifier expression that references the predefined null constant\n        return {\n            type: 'identifier',\n            name: { node: 'null', location: noLocation },\n        }\n    }\n}\n\nexport function unifyFunctionType(param: USSFunctionArgType, arg: USSType): boolean {\n    if (param.type === 'concrete') {\n        return renderType(param.value) === renderType(arg)\n    }\n    return arg.type === 'number' || arg.type === 'string' || arg.type === 'boolean' || arg.type === 'null'\n}\n\nexport function renderType(type: USSType): string {\n    if (type.type === 'number') {\n        return 'number'\n    }\n    if (type.type === 'string') {\n        return 'string'\n    }\n    if (type.type === 'boolean') {\n        return 'boolean'\n    }\n    if (type.type === 'vector') {\n        return `[${type.elementType.type === 'elementOfEmptyVector' ? '' : renderType(type.elementType)}]`\n    }\n    if (type.type === 'object') {\n        assert(type.properties instanceof Map, `Expected properties to be a Map, got ${typeof type.properties}`)\n        return `{${[...type.properties.entries()].sort().map(([k, v]) => `${k}: ${renderType(v)}`).join(', ')}}`\n    }\n    if (type.type === 'null') {\n        return 'null'\n    }\n    if (type.type === 'opaque') {\n        return type.name\n    }\n    return `(${type.posArgs.map(renderArgumentType).join(', ')}; ${Object.entries(type.namedArgs).map(([k, v]) => `${k}: ${renderKwargType(v)}`).join(', ')}) -> ${renderReturnType(type.returnType)}`\n}\n\nexport function renderArgumentType(arg: USSFunctionArgType): string {\n    if (arg.type === 'concrete') {\n        return renderType(arg.value)\n    }\n    return 'any'\n}\n\nexport function renderKwargType(arg: { type: USSFunctionArgType, defaultValue?: UrbanStatsASTExpression }): string {\n    const type = renderArgumentType(arg.type)\n    if (arg.defaultValue !== undefined) {\n        return `${type} = ${unparse(arg.defaultValue)}`\n    }\n    return type\n}\n\nfunction renderReturnType(ret: USSFunctionReturnType): string {\n    if (ret.type === 'concrete') {\n        return renderType(ret.value)\n    }\n    return 'any'\n}\n\nexport type ValueArg = (\n    { type: 'unnamed', value: USSValue } |\n    { type: 'named', name: string, value: USSValue }\n)\n\nexport function getPrimitiveType(value: USSRawValue, depth: number = 0): USSType {\n    if (depth === 0) {\n        if (typeof value === 'number') {\n            return { type: 'number' }\n        }\n        if (typeof value === 'string') {\n            return { type: 'string' }\n        }\n        if (typeof value === 'boolean') {\n            return { type: 'boolean' }\n        }\n        if (value === null) {\n            return { type: 'null' }\n        }\n    }\n    assert(Array.isArray(value), `Expected a primitive value, but got ${typeof value}`)\n    return getPrimitiveType(value[0], depth - 1)\n}\n\nexport function unifyType(\n    a: USSType | { type: 'elementOfEmptyVector' },\n    b: USSType | { type: 'elementOfEmptyVector' },\n    error: () => Error,\n): USSType | { type: 'elementOfEmptyVector' } {\n    if (a.type === 'elementOfEmptyVector') {\n        return b\n    }\n    if (b.type === 'elementOfEmptyVector') {\n        return a\n    }\n    if (renderType(a) === renderType(b)) {\n        return a\n    }\n    if (a.type === 'vector' && b.type === 'vector') {\n        return {\n            type: 'vector',\n            elementType: unifyType(a.elementType, b.elementType, error),\n        }\n    }\n    if (a.type === 'object' && b.type === 'object') {\n        if (JSON.stringify([...a.properties.keys()].sort()) !== JSON.stringify([...b.properties.keys()].sort())) {\n            throw error()\n        }\n        const properties = new Map<string, USSType>()\n        for (const [key, type] of a.properties) {\n            properties.set(key, type)\n        }\n        for (const [key, type] of b.properties) {\n            const res = unifyType(properties.get(key)!, type, error)\n            assert(res.type !== 'elementOfEmptyVector', `Unreachable`)\n            properties.set(key, res)\n        }\n        return {\n            type: 'object',\n            properties,\n        }\n    }\n    throw error()\n}\n\nexport function renderValue(input: USSValue): string {\n    function helper(value: USSValue, indent: string): string {\n        const type = value.type\n        switch (type.type) {\n            case 'boolean':\n            case 'null':\n            case 'number':\n                return `${value.value}`\n            case 'string':\n                return `\"${value.value}\"`\n            case 'opaque':\n                const opaqueValue = value.value as USSOpaqueValue\n                switch (opaqueValue.opaqueType) {\n                    case 'scale':\n                    case 'pMap':\n                    case 'cMap':\n                    case 'cMapRGB':\n                    case 'basemap':\n                    case 'inset':\n                    case 'insets':\n                    case 'geoFeatureHandle':\n                    case 'geoCentroidHandle':\n                    case 'unit':\n                    case 'textBox':\n                    case 'richTextDocument':\n                    case 'richTextSegment':\n                    case 'richTextAlign':\n                    case 'richTextList':\n                        return `[${opaqueValue.opaqueType} object]`\n                    case 'color':\n                        return deconstructColor(opaqueValue.value)\n                    case 'outline':\n                        const outline = opaqueValue.value\n                        return `constructOutline(color=${deconstructColor(outline.color)}, weight=${outline.weight})`\n                    case 'ramp':\n                        const ramp = opaqueValue.value\n                        const rampValue = ramp.map(\n                            ([position, color]) => {\n                                const contents: [string, USSRawValue][] = [\n                                        ['value', position] satisfies [string, USSRawValue],\n                                        ['color', { type: 'opaque', opaqueType: 'color', value: hexToColor(color) }] satisfies [string, USSRawValue],\n                                ] satisfies [string, USSRawValue][]\n                                return new Map(contents) satisfies Map<string, USSRawValue>\n                            },\n                        )\n                        const interior = undocValue(rampValue,\n                            {\n                                type: 'vector',\n                                elementType: {\n                                    type: 'object',\n                                    properties: new Map([\n                                        ['value', { type: 'number' }],\n                                        ['color', { type: 'opaque', name: 'color' }],\n                                    ]),\n                                },\n                            },\n                        )\n                        return `[ramp ${renderValue(interior)}]`\n                }\n            case 'vector':\n                const vector = value.value as USSRawValue[]\n                if (vector.length === 0) {\n                    return `[]`\n                }\n                // USSType assertion is OK since we handle zero-length vectors above\n                return `[\n${vector.map(element => `${indent}    ${helper(undocValue(element, type.elementType as USSType), `${indent}    `)}`).join(',\\n')}\n${indent}]`\n            case 'object':\n                const map = value.value as Map<string, USSRawValue>\n                if (map.size === 0) {\n                    return `{}`\n                }\n                return `{\n${Array.from(map.entries()).map(([key, element]) => `${indent}    ${key}: ${helper(undocValue(element, type.properties.get(key)!), `${indent}    `)}`).join(',\\n')}\n${indent}}`\n            case 'function':\n                return renderType(type)\n        }\n    }\n    return helper(input, '')\n}\n\nexport function canUnifyTo(a: USSType, b: USSType): boolean {\n    // returns true iff a can be used in a context where b is expected\n    if (renderType(a) === renderType(b)) {\n        return true\n    }\n    // at this point, the types are different\n    switch (b.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'null':\n        case 'opaque':\n            // these are all primitive types, so no way to substitute them\n            return false\n        case 'vector':\n            assert(b.elementType.type !== 'elementOfEmptyVector', `Unreachable`)\n            return canUnifyTo(a, b.elementType)\n        case 'object':\n            if (a.type !== 'object') {\n                return false\n            }\n            if (a.properties.size !== b.properties.size) {\n                return false\n            }\n            if (![...a.properties.keys()].every(key => b.properties.has(key))) {\n                return false\n            }\n            return [...a.properties.keys()].every(key => canUnifyTo(a.properties.get(key)!, b.properties.get(key)!))\n        case 'function':\n            return false\n    }\n}\n"],"names":["locationOf","node","unify","assert","_key","locations","startLine","min","loc","Math","Number","endLine","max","startCol","endCol","startChar","endChar","getAllParseErrors","errors","collectErrors","n","value","_errors","toStatement","colorType","rgbToColor","red","green","blue","alpha","tolerateError","Error","hsvToColor","hue","saturation","rgb","createConstantExpression","ctx","posArgs","namedArgs","hsv","renderColor","color","doRender","colorConstant","name","isDefault","humanReadableName","camelToHuman","capitalizedName","hexToColor","parseNoErrorAsExpression","rgbColorExpression","round","hsvColorExpression","colorConstants","Object","hueColors","insetType","insetsType","boundsType","Map","constructInsetValue","screenBounds","mapBounds","screenBoundsObj","mapBoundsObj","mainMap","constructInsetsValue","insetsList","item","computeInsetConstantName","deconstruct","inset","uss","insetConsts","insets","regionInsets","insetName","insetNameToConstantName","documentLength","document","sum","segment","colorSchema","z","c","console","richTextAttributesSchema","s","pixels","result","parseFloat","isFinite","array","undefined","richTextSegmentSchema","link","richTextDocumentType","richTextSegmentType","richTextListType","richTextAlignType","attributesFromNamedArgs","_namedArgs_color","_namedArgs_list","_namedArgs_align","_namedArgs_size","_namedArgs_font","_namedArgs_bold","_namedArgs_italic","_namedArgs_underline","_namedArgs_indent","_namedArgs_strike","entries","v","richTextSegmentConstructorType","alignIdentifierToValue","alignValueToIdentifer","listIdentifierToValue","listValueToIdentifier","richTextConstants","segmentsList","text","attributes","formula","image","id","defaults","colorThemes","textBox","doc","deconstructRichTextDocument","deconstructColor","deconstructRichTextSegment","deconstructRichTextAttributes","JSON","list","pair","textBoxType","constructTextBoxValue","backgroundColor","borderColor","borderWidth","longMessage","includeLocationInfo","renderLocInfo","renderValue","makeScript","lex","renderCode","script","colors","modfiyTokenContent","modifyTokenSpan","span","brackets","DefaultMap","basicConstants","token","content","title","style","levelColor","level","Array","next","openEquivalent","styleToString","_result","lexSpans","errorSpans","charIdx","indexInTokens","indexInErrors","errorLoc","errorLoc1","_errorSpans_spans1","_errorSpans_spans","tokenSpan","nodeContent","_node_textContent","HTMLElement","getRange","editor","selection","window","range","positionInEditor","offset","sibling","setRange","newRange","currentRange","_getContainerOffset","anchorNode","anchorOffset","_getContainerOffset1","focusNode","focusOffset","getContainerOffset","position","key","getAutocompleteOptions","typeEnvironment","tokens","currentIdentifer","allIdentifiers","Set","_iteratorError","t","_iteratorError1","option","match","isAMatch","a","b","i","matchCount","prevMatch","j","createAutocompleteMenu","TestUtils","createDocumentationPopover","elemOffset","width","tokenOffset","totalOffset","createPlaceholder","placeholderText","debugUndo","arg","useUndoRedo","initialState","initialSelection","onStateChange","onSelectionChange","_ref","undoChunking","undoHistory","onlyElement","undoStack","useRef","redoStack","_useState","canUndo","setCanUndo","_useState1","canRedo","setCanRedo","addState","useCallback","state","currentUndoState","Date","updateCurrentSelection","updateCurrentState","doUndo","prevState","doRedo","futureState","getIsActive","useEffect","listener","e","isMac","navigator","_useState2","isActive","setIsActive","ui","UndoRedoControls","param","outer","inner","positionInner","_window_visualViewport_height","_window_visualViewport_width","outerBounds","offsetParent","_window_visualViewport","isMobile","useMobileLayout","buttonStyle","zIndex","nonExpressionOperators","operatorCharacters","keywords","isDigit","ch","isAlpha","emptyLocation","ident","parseNumber","input","isNaN","component","component1","identifierLexer","string","operatorLexer","block","lines","line","lineTokens","lexLine","lineNo","charIdxOffset","idx","char","token1","lexNumber","numberFormat","numberStr","number","_iter","lexer","token2","lexGeneric","toks","lexOperators","_lexGeneric","finalIdx","supertok","tokenizedOperators","tokenizeOperators","allOps","allOperators","ops","expressionOperatorMap","op","didMatch","start","location","_tokens","token3","lexString","resultObj","noLocation","extendBlockIdPositionalArg","blockIdent","extendBlockIdKwarg","argName","extendBlockIdVectorElement","index","extendBlockIdObjectProperty","property","unparse","opts","isSimpleExpression","expr","indentSpaces","_opts_expressionalContext","_opts_indent","_opts_wrap","characterLimit","exprStr","fnStr","argsStr","fnWithParens","fnNeedsParens","notWrapped","wrappedArgs","unaryExprStr","needsParens","exprWithParens","_expressionOperatorMap_get_precedence","_expressionOperatorMap_get_precedence1","_expressionOperatorMap_get_precedence2","leftStr","rightStr","opPrecedence","leftWithParens","leftOpPrecedence","rightWithParens","rightOpPrecedence","elementsStr","elem","notWrapped1","wrappedElements","propertiesStr","valueStr","notWrapped2","wrappedProperties","lhsStr","statementsStr","stmt","conditionStr","thenStr","ifStr","elseStr","doStr","condStr","restStr","ParseState","skipEOL","consumeTokenOfType","type","values","consumeOperator","oneOfOps","consumeBracket","oneOfBrackets","consumeIdentifier","consumeKeyword","oneOfKeywords","maybeLastNonEOLToken","parseSingleExpression","startLoc","properties","keyToken","endLoc","vectorStartLoc","elements","element","vectorEndLoc","parseArg","exprOrName","parseParenthesizedArgs","args","parseFunctionalExpression","fn","done","parseExpression","operatorExpSequence","loop","unaryOperators","operator","infixOperators","operator1","parseInfixSequence","_Math","precedences","x","maxPrecedence","p","resolveOperator","left","right","checkLHS","parseStatement","lhs","parseIfExpression","ifToken","condition","then","elseBranch","eb","lastToken","parseDoExpression","doToken","statements","parseConditionStatement","conditionToken","parseStatements","canEnd","end","errMsg","statement","mergeStatements","fallbackLocation","gulpRestForConditions","_stmt_rest","entireLoc","parseCustomNodeExpression","argsRes","_argsRes_args","locArg","code","parseResult","parse","returnParseErrorNode","parseTokens","originalCode","lexErrors","stmts","parseNoError","blockId","parseNoErrorAsCustomNode","expectedType","getPrimitiveType","depth","_type_of","helper","indent","opaqueValue","outline","interior","undocValue","ramp","vector","map","renderType","constantCategories","ret","_instanceof","k","renderArgumentType","renderReturnType","renderKwargType"],"mappings":"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"}