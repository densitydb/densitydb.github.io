{"version":3,"file":"787.js","sources":["webpack://assets/./src/urban-stats-script/ast.ts","webpack://assets/./src/urban-stats-script/constants/color.ts","webpack://assets/./src/urban-stats-script/constants/insets.ts","webpack://assets/./src/urban-stats-script/constants/rich-text.ts","webpack://assets/./src/urban-stats-script/constants/text-box.ts","webpack://assets/./src/urban-stats-script/editor-utils.tsx","webpack://assets/./src/utils/isAMatch.ts","webpack://assets/./src/urban-stats-script/interpreter.ts","webpack://assets/./src/urban-stats-script/lexer.ts","webpack://assets/./src/urban-stats-script/location.ts","webpack://assets/./src/urban-stats-script/parser.ts","webpack://assets/./src/urban-stats-script/types-values.ts"],"sourcesContent":["import assert from 'assert'\n\nimport { LocInfo } from './location'\nimport { Decorated, ParseError } from './parser'\nimport { USSType } from './types-values'\n\nexport type UrbanStatsASTArg = (\n    { type: 'unnamed', value: UrbanStatsASTExpression } |\n    { type: 'named', name: Decorated<string>, value: UrbanStatsASTExpression })\n\nexport type UrbanStatsASTLHS = (\n    { type: 'identifier', name: Decorated<string> } |\n    { type: 'attribute', expr: UrbanStatsASTExpression, name: Decorated<string> })\n\nexport type UrbanStatsASTExpression = (\n    UrbanStatsASTLHS |\n    { type: 'constant', value: Decorated<{ type: 'number', value: number } | { type: 'string', value: string }> } |\n    { type: 'call', fn: UrbanStatsASTExpression, args: UrbanStatsASTArg[], entireLoc: LocInfo } |\n    { type: 'binaryOperator', operator: Decorated<string>, left: UrbanStatsASTExpression, right: UrbanStatsASTExpression } |\n    { type: 'unaryOperator', operator: Decorated<string>, expr: UrbanStatsASTExpression } |\n    { type: 'objectLiteral', entireLoc: LocInfo, properties: [string, UrbanStatsASTExpression][] } |\n    { type: 'vectorLiteral', entireLoc: LocInfo, elements: UrbanStatsASTExpression[] } |\n    { type: 'if', entireLoc: LocInfo, condition: UrbanStatsASTExpression, then: UrbanStatsASTStatement, else?: UrbanStatsASTStatement } |\n    { type: 'do', entireLoc: LocInfo, statements: UrbanStatsASTStatement[] } |\n    // for internal purposes only\n    { type: 'customNode', entireLoc: LocInfo, expr: UrbanStatsASTStatement, originalCode: string, expectedType?: USSType[] }\n)\n\nexport type UrbanStatsASTStatement = (\n    { type: 'assignment', lhs: UrbanStatsASTLHS, value: UrbanStatsASTExpression } |\n    { type: 'expression', value: UrbanStatsASTExpression } |\n    { type: 'statements', entireLoc: LocInfo, result: UrbanStatsASTStatement[] } |\n    { type: 'condition', entireLoc: LocInfo, condition: UrbanStatsASTExpression, rest: UrbanStatsASTStatement[] } |\n    { type: 'parseError', originalCode: string, errors: ParseError[] })\n\nexport type UrbanStatsAST = UrbanStatsASTArg | UrbanStatsASTExpression | UrbanStatsASTStatement\n\nexport function unify(...locations: LocInfo[]): LocInfo {\n    assert(locations.length > 0, 'At least one location must be provided for unification')\n    const startLine = locations.reduce((min, loc) => Math.min(min, loc.start.lineIdx), Number.MAX_VALUE)\n    const endLine = locations.reduce((max, loc) => Math.max(max, loc.end.lineIdx), -Number.MAX_VALUE)\n    const startCol = locations.reduce((min, loc) => Math.min(min, loc.start.colIdx), Number.MAX_VALUE)\n    const endCol = locations.reduce((max, loc) => Math.max(max, loc.end.colIdx), -Number.MAX_VALUE)\n    const startChar = locations.reduce((min, loc) => Math.min(min, loc.start.charIdx), Number.MAX_VALUE)\n    const endChar = locations.reduce((max, loc) => Math.max(max, loc.end.charIdx), -Number.MAX_VALUE)\n    return {\n        start: { block: locations[0].start.block, lineIdx: startLine, colIdx: startCol, charIdx: startChar },\n        end: { block: locations[0].end.block, lineIdx: endLine, colIdx: endCol, charIdx: endChar },\n    }\n}\n\nexport function locationOf(node: UrbanStatsAST): LocInfo {\n    /* c8 ignore start -- This function doesn't need to be tested in detail, as it is a simple location extractor */\n    switch (node.type) {\n        case 'unnamed':\n            return locationOf(node.value)\n        case 'named':\n            return unify(node.name.location, locationOf(node.value))\n        case 'constant':\n            return node.value.location\n        case 'identifier':\n            return node.name.location\n        case 'attribute':\n            return unify(node.name.location, locationOf(node.expr))\n        case 'call':\n            return node.entireLoc\n        case 'unaryOperator':\n            return unify(node.operator.location, locationOf(node.expr))\n        case 'binaryOperator':\n            return unify(locationOf(node.left), locationOf(node.right), node.operator.location)\n        case 'objectLiteral':\n        case 'vectorLiteral':\n        case 'if':\n        case 'do':\n        case 'condition':\n        case 'statements':\n            return node.entireLoc\n        case 'assignment':\n            return unify(locationOf(node.lhs), locationOf(node.value))\n        case 'expression':\n            return locationOf(node.value)\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        case 'customNode':\n            return node.entireLoc\n    }\n    /* c8 ignore stop */\n}\n\nexport function locationOfLastExpression(node: UrbanStatsAST): LocInfo {\n    switch (node.type) {\n        case 'assignment':\n            return locationOf(node.value)\n        case 'statements':\n            return locationOfLastExpression(node.result[node.result.length - 1])\n        case 'parseError':\n            assert(node.errors.length > 0, 'parseError node must have at least one error')\n            return node.errors[0].location\n        default:\n            return locationOf(node)\n    }\n}\n\nexport function getAllParseErrors(node: UrbanStatsAST): ParseError[] {\n    const errors: ParseError[] = []\n\n    function collectErrors(n: UrbanStatsAST): void {\n        switch (n.type) {\n            case 'unnamed':\n                collectErrors(n.value)\n                break\n            case 'named':\n                collectErrors(n.value)\n                break\n            case 'constant':\n            case 'identifier':\n                // No parse errors in these\n                break\n            case 'attribute':\n                collectErrors(n.expr)\n                break\n            case 'call':\n                collectErrors(n.fn)\n                n.args.forEach(collectErrors)\n                break\n            case 'unaryOperator':\n                collectErrors(n.expr)\n                break\n            case 'binaryOperator':\n                collectErrors(n.left)\n                collectErrors(n.right)\n                break\n            case 'objectLiteral':\n                n.properties.forEach(([, value]) => {\n                    collectErrors(value)\n                })\n                break\n            case 'vectorLiteral':\n                n.elements.forEach(collectErrors)\n                break\n            case 'if':\n                collectErrors(n.condition)\n                collectErrors(n.then)\n                if (n.else) {\n                    collectErrors(n.else)\n                }\n                break\n            case 'do':\n                n.statements.forEach(collectErrors)\n                break\n            case 'assignment':\n                collectErrors(n.lhs)\n                collectErrors(n.value)\n                break\n            case 'expression':\n                collectErrors(n.value)\n                break\n            case 'statements':\n                n.result.forEach(collectErrors)\n                break\n            case 'condition':\n                collectErrors(n.condition)\n                n.rest.forEach(collectErrors)\n                break\n            case 'parseError':\n                errors.push(...n.errors)\n                break\n            case 'customNode':\n                collectErrors(n.expr)\n                break\n        }\n    }\n\n    collectErrors(node)\n    return errors\n}\n\nexport function toStatement(node: UrbanStatsASTExpression | UrbanStatsASTStatement): UrbanStatsASTStatement {\n    switch (node.type) {\n        case 'statements':\n        case 'assignment':\n        case 'expression':\n        case 'condition':\n        case 'parseError':\n            return node\n        default:\n            return { type: 'expression', value: node }\n    }\n}\n","import hueColors from '../../data/hueColors'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue, createConstantExpression } from '../types-values'\n\nimport { Color, doRender, hexToColor, hsvColorExpression, rgbColorExpression } from './color-utils'\nimport { camelToHuman } from './utils'\n\nexport const colorType = { type: 'opaque', name: 'color' } satisfies USSType\n\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError: true): Color | undefined\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number): Color\nexport function rgbToColor(red: number, green: number, blue: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (red < 0 || red > 1 || green < 0 || green > 1 || blue < 0 || blue > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`RGB values must be between 0 and 1, got (${red}, ${green}, ${blue}, ${alpha})`)\n    }\n    return { r: red, g: green, b: blue, a: alpha }\n}\n\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError: true): Color | undefined\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number): Color\nexport function hsvToColor(hue: number, saturation: number, value: number, alpha: number, tolerateError?: boolean): Color | undefined {\n    if (hue < 0 || hue > 360 || saturation < 0 || saturation > 1 || value < 0 || value > 1 || alpha < 0 || alpha > 1) {\n        if (tolerateError) {\n            return undefined\n        }\n        throw new Error(`HSV values must be (hue: 0-360, saturation: 0-1, value: 0-1, alpha: 0-1), got (${hue}, ${saturation}, ${value}, ${alpha})`)\n    }\n    return {\n        h: hue,\n        s: saturation,\n        v: value,\n        a: alpha,\n    }\n}\n\nexport const rgb = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // red\n            { type: 'concrete', value: { type: 'number' } }, // green\n            { type: 'concrete', value: { type: 'number' } }, // blue\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: rgbToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (RGB)',\n        category: 'color',\n        namedArgs: { a: 'Alpha' },\n        longDescription: 'Creates a color using RGB (Red, Green, Blue) values. Each component ranges from 0 to 1, where 0 is no color and 1 is full intensity.',\n    },\n} satisfies USSValue\n\nexport const hsv = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'number' } }, // hue\n            { type: 'concrete', value: { type: 'number' } }, // saturation\n            { type: 'concrete', value: { type: 'number' } }, // value\n        ],\n        namedArgs: {\n            a: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: createConstantExpression(1) },\n        },\n        returnType: { type: 'concrete', value: colorType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const alpha = namedArgs.a as number\n        return { type: 'opaque', opaqueType: 'color', value: hsvToColor(posArgs[0] as number, posArgs[1] as number, posArgs[2] as number, alpha) }\n    },\n    documentation: {\n        humanReadableName: 'Color (HSV)',\n        category: 'color',\n        longDescription: 'Creates a color using HSV (Hue, Saturation, Value) values. Hue ranges from 0 to 360 degrees, saturation and value range from 0 to 1.',\n    },\n} satisfies USSValue\n\nexport const renderColor = {\n    type: {\n        type: 'function',\n        posArgs: [{ type: 'concrete', value: colorType }],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: { type: 'string' } },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): string => {\n        const color = (posArgs[0] as { type: 'opaque', value: { r: number, g: number, b: number, a: number } }).value\n        return doRender(color)\n    },\n    documentation: {\n        humanReadableName: 'Color to String',\n        category: 'color',\n        longDescription: 'Converts a color object to its hexadecimal string representation (e.g., \"#ff0000\" for red). If the alpha channel is not 255, it will be included in the string, e.g., \"#ff000088\" for red with 50% opacity.',\n    },\n} satisfies USSValue\n\nfunction colorConstant(name: string, value: string, isDefault?: boolean): [string, USSValue] {\n    const round = 3 // Min value that doesn't introduce error into hex expressions (with conversions)\n    const humanReadableName = camelToHuman(name)\n    const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1)\n    const color = hexToColor(value, round)\n    return [`color${capitalizedName}`, {\n        type: colorType,\n        value: { type: 'opaque', opaqueType: 'color', value: color },\n        documentation: {\n            humanReadableName,\n            category: 'color',\n            equivalentExpressions: [parseNoErrorAsExpression(rgbColorExpression(color, { round }), ''), parseNoErrorAsExpression(hsvColorExpression(color, { round }), '')],\n            isDefault,\n            longDescription: `Predefined color constant representing ${humanReadableName.toLowerCase()}.`,\n            documentationTable: 'predefined-colors',\n            selectorRendering: {\n                kind: 'gradientBackground',\n                ramp: [[0, value], [1, value]],\n            },\n        },\n    }] satisfies [string, USSValue]\n}\n\nexport const colorConstants = [\n    ...Object.entries(hueColors).map(([name, value]) => colorConstant(name, value)),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('white', '#ffffff'),\n    // eslint-disable-next-line no-restricted-syntax -- Allow hex colors for constants\n    colorConstant('black', '#000000', true),\n]\n","import { round } from 'mathjs'\n\nimport insets from '../../data/insets'\nimport { UrbanStatsASTExpression } from '../ast'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue } from '../types-values'\n\nexport interface Inset {\n    bottomLeft: [number, number]\n    topRight: [number, number]\n    coordBox: [number, number, number, number]\n    mainMap: boolean\n    name?: string\n}\n\nexport const insetType = {\n    type: 'opaque',\n    name: 'inset',\n} satisfies USSType\n\nexport const insetsType = {\n    type: 'opaque',\n    name: 'insets',\n} satisfies USSType\n\nexport const boundsType = {\n    type: 'object',\n    properties: new Map([\n        ['west', { type: 'number' }],\n        ['east', { type: 'number' }],\n        ['north', { type: 'number' }],\n        ['south', { type: 'number' }],\n    ]),\n} satisfies USSType\n\nexport function constructInset(\n    screenBounds: { west: number, east: number, north: number, south: number },\n    mapBounds: { west: number, east: number, north: number, south: number },\n    mainMap: boolean,\n    name?: string,\n): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'inset',\n        value: {\n            bottomLeft: [screenBounds.west, screenBounds.south],\n            topRight: [screenBounds.east, screenBounds.north],\n            coordBox: [mapBounds.west, mapBounds.south, mapBounds.east, mapBounds.north],\n            mainMap,\n            name,\n        } satisfies Inset & { name?: string },\n    }\n}\n\nexport function constructInsets(insetList: Inset[]): USSRawValue {\n    return {\n        type: 'opaque',\n        opaqueType: 'insets',\n        value: insetList,\n    }\n}\n\nexport const constructInsetValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            screenBounds: { type: { type: 'concrete', value: boundsType } },\n            mapBounds: { type: { type: 'concrete', value: boundsType } },\n            mainMap: { type: { type: 'concrete', value: { type: 'boolean' } } },\n            name: { type: { type: 'concrete', value: { type: 'string' } } },\n        },\n        returnType: { type: 'concrete', value: insetType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const screenBoundsObj = namedArgs.screenBounds as Map<string, USSRawValue>\n        const mapBoundsObj = namedArgs.mapBounds as Map<string, USSRawValue>\n        const mainMap = namedArgs.mainMap as boolean\n        const name = namedArgs.name as string\n        return constructInset(\n            {\n                west: screenBoundsObj.get('west') as number,\n                east: screenBoundsObj.get('east') as number,\n                north: screenBoundsObj.get('north') as number,\n                south: screenBoundsObj.get('south') as number,\n            },\n            {\n                west: mapBoundsObj.get('west') as number,\n                east: mapBoundsObj.get('east') as number,\n                north: mapBoundsObj.get('north') as number,\n                south: mapBoundsObj.get('south') as number,\n            },\n            mainMap,\n            name,\n        )\n    },\n    documentation: {\n        humanReadableName: 'Custom Inset',\n        category: 'inset',\n        longDescription: 'Creates a custom map inset with specified screen bounds (bounding box of the inset on the screen, where bottom left corner has (0, 0) and top right corner has (1, 1)), map bounds (bounding box of the inset on the map, in longitude and latitude), and whether it is the main map (the interactive map).',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructInsetsValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [\n            {\n                type: 'concrete',\n                value: {\n                    type: 'vector',\n                    elementType: insetType,\n                },\n            },\n        ],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: insetsType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const insetsList = posArgs[0] as { type: 'opaque', opaqueType: 'inset', value: Inset }[]\n        return constructInsets(insetsList.map(item => item.value))\n    },\n    documentation: {\n        humanReadableName: 'Custom Insets',\n        category: 'inset',\n        isDefault: true,\n        longDescription: 'Creates a collection of map insets.',\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nfunction computeInsetConstantName(name: string): string {\n    name = name.replace(/[\\s,().-]/g, '')\n    name = name.replaceAll('+', 'Plus')\n    name = `inset${name}`\n    return name\n}\n\nexport function deconstruct(inset: typeof insets[keyof typeof insets][number] | Inset): UrbanStatsASTExpression {\n    const uss = `constructInset(screenBounds={ north: ${round(inset.topRight[1], 3)}, east: ${round(inset.topRight[0], 3)}, south: ${round(inset.bottomLeft[1], 3)}, west: ${round(inset.bottomLeft[0], 3)} }, mapBounds={ north: ${round(inset.coordBox[3], 3)}, east: ${round(inset.coordBox[2], 3)}, south: ${round(inset.coordBox[1], 3)}, west: ${round(inset.coordBox[0], 3)} }, mainMap=${inset.mainMap}, name=\"${inset.name}\")`\n    return parseNoErrorAsExpression(uss, '')\n}\n\nexport const insetConsts: [string, USSValue][] = Object.entries(insets).flatMap(([, regionInsets]) =>\n    regionInsets.map((inset) => {\n        const insetName = inset.name\n        const constantName = computeInsetConstantName(insetName)\n\n        return [\n            constantName,\n            {\n                type: insetType,\n                value: {\n                    type: 'opaque',\n                    opaqueType: 'inset',\n                    value: {\n                        bottomLeft: [...inset.bottomLeft] as [number, number],\n                        topRight: [...inset.topRight] as [number, number],\n                        // copy to get rid of readonly\n                        coordBox: [...inset.coordBox] as [number, number, number, number],\n                        mainMap: inset.mainMap,\n                        name: inset.name,\n                    } satisfies Inset,\n                },\n                documentation: {\n                    humanReadableName: insetName,\n                    category: 'inset',\n                    equivalentExpressions: [deconstruct(inset)],\n                    longDescription: `Predefined map inset for the region \"${insetName}\".`,\n                    documentationTable: 'predefined-insets',\n                },\n            } satisfies USSValue,\n        ] as [string, USSValue]\n    }),\n)\n\nexport const insetNameToConstantName = new Map<string, string>(\n    Object.entries(insets).flatMap(([, regionInsets]) =>\n        regionInsets.map((inset) => {\n            const insetName = inset.name\n            return [insetName, computeInsetConstantName(insetName)]\n        }),\n    ),\n)\n","import { z } from 'zod'\n\nimport { RemoveOptionals, SwapKeysValues } from '../../utils/types'\nimport { Context } from '../context'\nimport { createConstantExpression, NamedFunctionArgumentWithDocumentation, USSRawValue, USSType, USSValue } from '../types-values'\n\nimport { colorType } from './color'\nimport { Color, hexToColor } from './color-utils'\n\nexport type RichTextDocument = RichTextSegment[]\n\nexport function documentLength(document: RichTextDocument): number {\n    return document.reduce((sum, segment) => sum + (typeof segment.insert === 'string' ? segment.insert.length : 1), 0)\n}\n\nconst colorSchema = z.string().transform((c) => {\n    try {\n        return hexToColor(c)\n    }\n    catch {\n        console.warn(`${c} is not a valid color`)\n        return undefined\n    }\n})\n\nexport const richTextAttributesSchema = z.object({\n    size: z.optional(z.string().transform((s) => {\n        if (!s.endsWith('px')) {\n            console.warn(`Font size ${s} does not end with \"px\"`)\n            return undefined\n        }\n        const pixels = s.slice(0, s.length - 2)\n        const result = parseFloat(pixels)\n        if (!isFinite(result)) {\n            console.warn(`Font pixels ${pixels} is not a valid number`)\n            return undefined\n        }\n        return result\n    })),\n    font: z.optional(z.string()),\n    // Sometimes when selecting a different colored formula along with text, color is an array. In that case, just take the first one\n    color: z.optional(z.union([colorSchema, z.array(colorSchema).transform(array => array.length === 0 ? undefined : array[0])])),\n    bold: z.optional(z.boolean()),\n    italic: z.optional(z.boolean()),\n    underline: z.optional(z.boolean()),\n    strike: z.optional(z.boolean()),\n    list: z.optional(z.union([z.literal('ordered'), z.literal('bullet'), z.literal('')])),\n    indent: z.optional(z.number()),\n    align: z.optional(z.enum(['', 'center', 'right', 'justify'])),\n})\n\nexport const richTextSegmentSchema = z.object({\n    insert: z.union([\n        z.string(),\n        z.object({ formula: z.string() }),\n        z.object({ image: z.string().refine(link => !link.startsWith('data:')) }), // Images must be linked, not enough room to store them in the url\n    ]),\n    attributes: z.optional(richTextAttributesSchema),\n})\n\nexport type RichTextSegment = z.infer<typeof richTextSegmentSchema>\n\nexport type RichTextAttributes = RemoveOptionals<RichTextSegment>['attributes']\n\nexport const richTextDocumentType = {\n    type: 'opaque',\n    name: 'richTextDocument',\n} satisfies USSType\n\nexport const richTextSegmentType = {\n    type: 'opaque',\n    name: 'richTextSegment',\n} satisfies USSType\n\nexport const constructRichTextDocumentValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [\n            { type: 'concrete', value: { type: 'vector', elementType: richTextSegmentType } },\n        ],\n        namedArgs: {},\n        returnType: { type: 'concrete', value: richTextDocumentType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        let segmentsList = (posArgs[0] as { type: 'opaque', opaqueType: 'richTextSegment', value: RichTextSegment }[]).map(({ value }) => value)\n        if (segmentsList.length === 0) {\n            segmentsList = [{ insert: '\\n' }] // bugs on applying attributes to empty text without this\n        }\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextDocument',\n            value: segmentsList,\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text Document',\n        category: 'richText',\n        longDescription: 'Creates a rich text document from a list of rich text segments.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const richTextListType = {\n    type: 'opaque',\n    name: 'richTextList',\n} satisfies USSType\n\nexport const richTextAlignType = {\n    type: 'opaque',\n    name: 'richTextAlign',\n} satisfies USSType\n\nconst attributesNamedArgs: { [K in keyof RemoveOptionals<RichTextSegment>['attributes']]-?: NamedFunctionArgumentWithDocumentation } = {\n    size: {\n        type: { type: 'concrete', value: { type: 'number' } },\n        defaultValue: createConstantExpression(null),\n    },\n    font: {\n        type: { type: 'concrete', value: { type: 'string' } },\n        defaultValue: createConstantExpression(null),\n    },\n    color: {\n        type: { type: 'concrete', value: colorType },\n        defaultValue: createConstantExpression(null),\n    },\n    bold: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    italic: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    underline: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    strike: {\n        type: { type: 'concrete', value: { type: 'boolean' } },\n        defaultValue: createConstantExpression(null),\n    },\n    list: {\n        type: { type: 'concrete', value: richTextListType },\n        defaultValue: createConstantExpression(null),\n    },\n    indent: {\n        type: { type: 'concrete', value: { type: 'number' } },\n        defaultValue: createConstantExpression(null),\n    },\n    align: {\n        type: { type: 'concrete', value: richTextAlignType },\n        defaultValue: createConstantExpression(null),\n    },\n}\n\nfunction attributesFromNamedArgs(namedArgs: Record<string, USSRawValue>): RichTextSegment['attributes'] {\n    const color = (namedArgs.color as ({ value: Color } | null))?.value\n\n    const entries = Object.entries({\n        size: (namedArgs.size as number | null) ?? undefined,\n        font: (namedArgs.font as string | null) ?? undefined,\n        color,\n        bold: (namedArgs.bold as boolean | null) ?? undefined,\n        italic: (namedArgs.italic as boolean | null) ?? undefined,\n        underline: (namedArgs.underline as boolean | null) ?? undefined,\n        list: (namedArgs.list as { value: RichTextAttributes['list'] } | null)?.value,\n        indent: (namedArgs.indent as number | null) ?? undefined,\n        align: (namedArgs.align as { value: RichTextAttributes['align'] } | null)?.value,\n        strike: (namedArgs.strike as boolean | null) ?? undefined,\n    }).filter(([, v]) => v !== undefined)\n\n    if (entries.length === 0) {\n        return undefined\n    }\n\n    return Object.fromEntries(entries)\n}\n\nconst richTextSegmentConstructorType: USSType = {\n    type: 'function',\n    posArgs: [\n        { type: 'concrete', value: { type: 'string' } },\n    ],\n    namedArgs: attributesNamedArgs,\n    returnType: { type: 'concrete', value: richTextSegmentType },\n}\n\nexport const constructRichTextStringSegmentValue: USSValue = {\n    type: richTextSegmentConstructorType,\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const text = posArgs[0] as string\n        const attributes = attributesFromNamedArgs(namedArgs)\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextSegment',\n            value: {\n                insert: text,\n                ...(attributes && { attributes }),\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text String Segment',\n        category: 'richText',\n        longDescription: 'Creates a rich text segment containing a plain string. The string can have optional formatting attributes.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructRichTextFormulaSegmentValue: USSValue = {\n    type: richTextSegmentConstructorType,\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const formula = posArgs[0] as string\n        const attributes = attributesFromNamedArgs(namedArgs)\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextSegment',\n            value: {\n                insert: { formula },\n                ...(attributes && { attributes }),\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text Formula Segment',\n        category: 'richText',\n        longDescription: 'Creates a rich text segment containing a formula. The formula is represented as a string and can have optional formatting attributes.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const constructRichTextImageSegmentValue: USSValue = {\n    type: richTextSegmentConstructorType,\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const image = posArgs[0] as string\n        const attributes = attributesFromNamedArgs(namedArgs)\n        return {\n            type: 'opaque',\n            opaqueType: 'richTextSegment',\n            value: {\n                insert: { image },\n                ...(attributes && { attributes }),\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Rich Text Image Segment',\n        category: 'richText',\n        longDescription: 'Creates a rich text segment containing an image. The image is represented as a URL string and can have optional formatting attributes.',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n\nexport const alignIdentifierToValue = {\n    alignLeft: '',\n    alignCenter: 'center',\n    alignRight: 'right',\n    alignJustify: 'justify',\n} as const\n\nexport const alignValueToIdentifer: SwapKeysValues<typeof alignIdentifierToValue> = {\n    '': 'alignLeft',\n    'center': 'alignCenter',\n    'right': 'alignRight',\n    'justify': 'alignJustify',\n}\n\nfunction alignConstant(value: RichTextAttributes['align']): USSValue {\n    return {\n        type: richTextAlignType,\n        value: { type: 'opaque', opaqueType: 'richTextAlign', value },\n        documentation: {\n            humanReadableName: `Align ${value === '' ? 'Left' : value.charAt(0).toUpperCase() + value.slice(1)}`,\n            category: 'richText',\n            longDescription: `Specifies the alignment of the text as ${value === '' ? 'left' : value}.`,\n            selectorRendering: { kind: 'subtitleLongDescription' },\n            customConstructor: false,\n        },\n    }\n}\n\nexport const listIdentifierToValue = {\n    listOrdered: 'ordered',\n    listBullet: 'bullet',\n    listNone: '',\n} as const\n\nexport const listValueToIdentifier: SwapKeysValues<typeof listIdentifierToValue> = {\n    ordered: 'listOrdered',\n    bullet: 'listBullet',\n    ['']: 'listNone',\n}\n\nfunction listConstant(value: RichTextAttributes['list']): USSValue {\n    return {\n        type: richTextListType,\n        value: { type: 'opaque', opaqueType: 'richTextList', value },\n        documentation: {\n            humanReadableName: `List ${(value && value.charAt(0).toUpperCase() + value.slice(1)) || 'None'}`,\n            category: 'richText',\n            longDescription: `Specifies the list type as ${value || 'none'}.`,\n            selectorRendering: { kind: 'subtitleLongDescription' },\n            customConstructor: false,\n        },\n    }\n}\n\nexport const richTextConstants: [string, USSValue][] = [\n    ['rtfDocument', constructRichTextDocumentValue],\n    ['rtfString', constructRichTextStringSegmentValue],\n    ['rtfFormula', constructRichTextFormulaSegmentValue],\n    ['rtfImage', constructRichTextImageSegmentValue],\n    ...Object.entries(alignIdentifierToValue).map(([id, value]) => [id, alignConstant(value)] satisfies [unknown, unknown]),\n    ...Object.entries(listIdentifierToValue).map(([id, value]) => [id, listConstant(value)] satisfies [unknown, unknown]),\n]\n","import { round } from 'mathjs'\n\nimport { colorThemes } from '../../page_template/color-themes'\nimport { UrbanStatsASTExpression } from '../ast'\nimport { Context } from '../context'\nimport { parseNoErrorAsExpression } from '../parser'\nimport { USSRawValue, USSType, USSValue } from '../types-values'\n\nimport { colorType } from './color'\nimport { Color, deconstructColor, hexToColor } from './color-utils'\nimport { boundsType } from './insets'\nimport { alignValueToIdentifer, listValueToIdentifier, RichTextDocument, richTextDocumentType, RichTextSegment } from './rich-text'\n\nexport interface TextBox {\n    bottomLeft: [number, number]\n    topRight: [number, number]\n    text: RichTextDocument\n    backgroundColor: Color\n    borderColor: Color\n    borderWidth: number\n}\n\nexport const defaults = {\n    backgroundColor: hexToColor(colorThemes['Light Mode'].background),\n    borderColor: hexToColor(colorThemes['Light Mode'].borderShadow),\n    borderWidth: 1,\n}\n\nexport function deconstruct(textBox: TextBox): UrbanStatsASTExpression {\n    const uss = `textBox(\n        screenBounds={\n            north: ${round(textBox.topRight[1], 3)},\n            east: ${round(textBox.topRight[0], 3)},\n            south: ${round(textBox.bottomLeft[1], 3)},\n            west: ${round(textBox.bottomLeft[0], 3)}\n        },\n        text=${deconstructRichTextDocument(textBox.text)},\n        backgroundColor=${deconstructColor(textBox.backgroundColor)},\n        borderColor=${deconstructColor(textBox.borderColor)},\n        borderWidth=${textBox.borderWidth}\n    )`\n    return parseNoErrorAsExpression(uss, '')\n}\n\nfunction deconstructRichTextDocument(doc: RichTextDocument): string {\n    return `rtfDocument([${doc.map(deconstructRichTextSegment).join(', ')}])`\n}\n\nfunction deconstructRichTextSegment(segment: RichTextSegment): string {\n    if (typeof segment.insert === 'string') {\n        return `rtfString(${JSON.stringify(segment.insert)}${deconstructRichTextAttributes(segment.attributes)})`\n    }\n    if ('formula' in segment.insert) {\n        return `rtfFormula(\"${segment.insert.formula}\"${deconstructRichTextAttributes(segment.attributes)})`\n    }\n    if ('image' in segment.insert) {\n        return `rtfImage(\"${segment.insert.image}\"${deconstructRichTextAttributes(segment.attributes)})`\n    }\n    throw new Error()\n}\n\nfunction deconstructRichTextAttributes(attributes: RichTextSegment['attributes']): string {\n    if (attributes === undefined) {\n        return ''\n    }\n    const list = Object.entries(attributes).filter(([, value]) => value !== undefined)\n    if (list.length === 0) {\n        return ''\n    }\n    return `, ${list.flatMap((pair) => {\n        if (pair[1] === undefined) {\n            return []\n        }\n\n        const value = (() => {\n            switch (pair[0]) {\n                case 'align':\n                    return [alignValueToIdentifer[pair[1]]]\n                case 'list':\n                    return [listValueToIdentifier[pair[1]]]\n                case 'color':\n                    return deconstructColor(pair[1])\n                case 'bold':\n                case 'italic':\n                case 'underline':\n                case 'strike':\n                    return pair[1] ? 'true' : 'false'\n                case 'size':\n                case 'indent':\n                    return pair[1].toString()\n                case 'font':\n                    return `\"${pair[1]}\"`\n            }\n        })()\n\n        return `${pair[0]}=${value}`\n    }).join(', ')}`\n}\n\nexport const textBoxType = {\n    type: 'opaque',\n    name: 'textBox',\n} satisfies USSType\n\nexport const constructTextBoxValue: USSValue = {\n    type: {\n        type: 'function',\n        posArgs: [],\n        namedArgs: {\n            screenBounds: { type: { type: 'concrete', value: boundsType } },\n            text: { type: { type: 'concrete', value: richTextDocumentType } },\n            backgroundColor: { type: { type: 'concrete', value: colorType }, defaultValue: parseNoErrorAsExpression(deconstructColor(defaults.backgroundColor), '') },\n            borderColor: { type: { type: 'concrete', value: colorType }, defaultValue: parseNoErrorAsExpression(deconstructColor(defaults.borderColor), '') },\n            borderWidth: { type: { type: 'concrete', value: { type: 'number' } }, defaultValue: parseNoErrorAsExpression(`${defaults.borderWidth}`, '') },\n        },\n        returnType: { type: 'concrete', value: textBoxType },\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- needed for USSValue interface\n    value: (ctx: Context, posArgs: USSRawValue[], namedArgs: Record<string, USSRawValue>): USSRawValue => {\n        const screenBounds = namedArgs.screenBounds as Map<string, USSRawValue>\n\n        const text = (namedArgs.text as { type: 'opaque', opaqueType: 'richTextDocument', value: RichTextDocument }).value\n        const backgroundColor = (namedArgs.backgroundColor as { type: 'opaque', opaqueType: 'color', value: Color }).value\n        const borderColor = (namedArgs.borderColor as { type: 'opaque', opaqueType: 'color', value: Color }).value\n        const borderWidth = namedArgs.borderWidth as number\n\n        return {\n            type: 'opaque',\n            opaqueType: 'textBox',\n            value: {\n                bottomLeft: [screenBounds.get('west') as number, screenBounds.get('south') as number],\n                topRight: [screenBounds.get('east') as number, screenBounds.get('north') as number],\n                text,\n                backgroundColor,\n                borderColor,\n                borderWidth,\n            },\n        }\n    },\n    documentation: {\n        humanReadableName: 'Map Text Box',\n        category: 'map',\n        longDescription: 'Create a text box on the map with specified screen bounds (bounding box of the inset on the screen, where bottom left corner has (0, 0) and top right corner has (1, 1))',\n        selectorRendering: { kind: 'subtitleLongDescription' },\n        customConstructor: true,\n    },\n} satisfies USSValue\n","import React, { CSSProperties, ReactNode, useCallback, useEffect, useRef, useState } from 'react'\n\nimport { totalOffset } from '../components/screenshot'\nimport { Colors } from '../page_template/color-themes'\nimport { DefaultMap } from '../utils/DefaultMap'\nimport { TestUtils } from '../utils/TestUtils'\nimport { isAMatch } from '../utils/isAMatch'\nimport { useMobileLayout } from '../utils/responsive'\nimport { zIndex } from '../utils/zIndex'\n\nimport { renderLocInfo } from './interpreter'\nimport { AnnotatedToken, lex } from './lexer'\nimport { ParseError } from './parser'\nimport { renderValue, TypeEnvironment, USSValue } from './types-values'\n\nexport type EditorError = ParseError & { kind: 'error' | 'warning' }\nexport type EditorResult = EditorError | { kind: 'success', result: USSValue }\n\nexport function longMessage(result: EditorResult, includeLocationInfo: boolean): string {\n    switch (result.kind) {\n        case 'error':\n        case 'warning':\n            return includeLocationInfo ? `${result.value} at ${renderLocInfo(result.location)}` : result.value\n        case 'success':\n            return renderValue(result.result)\n    }\n}\n\nexport interface Script { uss: string, tokens: AnnotatedToken[] }\n\nexport function makeScript(uss: string): Script {\n    if (!uss.endsWith('\\n')) {\n        uss = `${uss}\\n`\n    }\n    return { uss, tokens: lex({ type: 'single', ident: 'editor' }, uss) }\n}\n\n// `errors` may not overlap\nexport function renderCode(\n    script: Script,\n    colors: Colors,\n    errors: EditorError[],\n    modfiyTokenContent: (token: AnnotatedToken, content: Node[]) => void,\n    modifyTokenSpan: (token: AnnotatedToken, span: HTMLSpanElement) => void,\n): Node[] {\n    const span = spanFactory(colors)\n\n    const lexSpans: Node[] = []\n    let errorSpans: { error: EditorError, spans: Node[] } | undefined = undefined\n    let charIdx = 0\n    let indexInTokens = 0\n    let indexInErrors = 0\n    while (indexInTokens < script.tokens.length && charIdx < script.uss.length) {\n        if (indexInErrors < errors.length) {\n            const errorLoc = errors[indexInErrors].location\n            if (charIdx >= errorLoc.start.charIdx) {\n                errorSpans = { spans: [], error: errors[indexInErrors] }\n                indexInErrors++\n            }\n        }\n        if (errorSpans !== undefined) {\n            const errorLoc = errorSpans.error.location\n            if (charIdx >= errorLoc.end.charIdx) {\n                lexSpans.push(span(errorSpans.error, errorSpans.spans))\n                errorSpans = undefined\n            }\n        }\n\n        const token = script.tokens[indexInTokens]\n        if (charIdx === token.location.start.charIdx) {\n            const content: Node[] = [document.createTextNode(script.uss.slice(token.location.start.charIdx, token.location.end.charIdx))]\n            modfiyTokenContent(token, content)\n            const tokenSpan = span(token.token, content)\n            modifyTokenSpan(token, tokenSpan);\n            (errorSpans?.spans ?? lexSpans).push(tokenSpan)\n            charIdx = token.location.end.charIdx\n            indexInTokens++\n        }\n        else if (charIdx < token.location.start.charIdx) {\n            (errorSpans?.spans ?? lexSpans).push(document.createTextNode(script.uss.slice(charIdx, token.location.start.charIdx)))\n            charIdx = token.location.start.charIdx\n        }\n        else {\n            throw new Error('invalid state')\n        }\n    }\n\n    if (errorSpans !== undefined) {\n        lexSpans.push(span(errorSpans.error, errorSpans.spans))\n        errorSpans = undefined\n    }\n\n    return lexSpans\n}\n\nexport function nodeContent(node: Node): string {\n    if (node instanceof HTMLElement) {\n        if (!node.isContentEditable) {\n            return ''\n        }\n        return Array.from(node.childNodes).map(nodeContent).join('')\n    }\n    else {\n        return node.textContent ?? ''\n    }\n}\n\nexport interface Range { start: number, end: number }\n\nexport function getRange(editor: HTMLElement): Range | null {\n    const selection = window.getSelection()\n    if (selection?.rangeCount === 1) {\n        const range = selection.getRangeAt(0)\n        if (editor.contains(range.startContainer) && editor.contains(range.endContainer)) {\n            if (editor === range.startContainer || editor === range.endContainer) {\n                return { start: 0, end: 0 }\n            }\n            return { start: positionInEditor(editor, range.startContainer, range.startOffset), end: positionInEditor(editor, range.endContainer, range.endOffset) }\n        }\n    }\n\n    return null\n}\n\n// Traverse up the tree, counting text content of previous siblings along the way\nfunction positionInEditor(editor: Node, node: Node, offset: number): number {\n    while (node !== editor) {\n        let sibling = node.previousSibling\n        while (sibling !== null) {\n            offset += nodeContent(sibling).length\n            sibling = sibling.previousSibling\n        }\n        node = node.parentNode!\n    }\n    return offset\n}\n\nexport function setRange(editor: HTMLElement, newRange: Range | null): void {\n    const currentRange = getRange(editor)\n\n    if (currentRange?.start === newRange?.start && currentRange?.end === newRange?.end) {\n        return\n    }\n\n    const selection = window.getSelection()!\n\n    if (newRange === null) {\n        selection.removeAllRanges()\n        editor.blur()\n        return\n    }\n\n    if (currentRange === null) {\n        editor.focus()\n    }\n\n    const [anchorNode, anchorOffset] = getContainerOffset(editor, newRange.start)\n    const [focusNode, focusOffset] = getContainerOffset(editor, newRange.end)\n\n    selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)\n}\n\n// Inverse of `positionInEditor`\n// Traverse down the tree, always keeping the text content behind us lte position\nexport function getContainerOffset(node: Node, position: number): [Node, number] {\n    let offset = 0\n    while (node.childNodes.length > 0) {\n        node = node.childNodes.item(0)\n        while (offset + nodeContent(node).length < position && node.nextSibling !== null) {\n            offset += nodeContent(node).length\n            node = node.nextSibling\n        }\n    }\n    return [node, position - offset]\n}\n\nfunction spanFactory(colors: Colors): (token: AnnotatedToken['token'] | ParseError, content: (Node | string)[]) => HTMLSpanElement {\n    const brackets = new DefaultMap<string, number>(() => 0)\n\n    const basicConstants = ['true', 'false', 'null']\n\n    return (token, content) => {\n        const style: Record<string, string> = { position: 'relative' }\n        let title: string | undefined\n\n        switch (token.type) {\n            case 'bracket':\n                function levelColor(level: number): string {\n                    switch (level % 3) {\n                        case 0:\n                            return colors.hueColors.yellow\n                        case 1:\n                            return colors.hueColors.pink\n                        case 2:\n                            return colors.hueColors.blue\n                        default:\n                            throw Error()\n                    }\n                }\n\n                if (token.value === '(' || token.value === '[' || token.value === '{') {\n                    const level = Array.from(brackets.values()).reduce((sum, next) => sum + next, 0)\n                    brackets.set(token.value, brackets.get(token.value) + 1)\n                    style.color = levelColor(level)\n                }\n                else {\n                    const openEquivalent = ({\n                        ')': '(',\n                        ']': '[',\n                        '}': '{',\n                    } as const)[token.value]\n                    if (brackets.get(openEquivalent) === 0) {\n                        style.color = colors.hueColors.red\n                    }\n                    else {\n                        brackets.set(openEquivalent, brackets.get(openEquivalent) - 1)\n                        const level = Array.from(brackets.values()).reduce((sum, next) => sum + next, 0)\n                        style.color = levelColor(level)\n                    }\n                }\n                break\n            case 'number':\n                style.color = colors.hueColors.blue\n                break\n            case 'string':\n                style.color = colors.hueColors.green\n                break\n            case 'error':\n                // Safari doesn't support the shorthand \n                style['text-decoration-color'] = colors.hueColors.red\n                style['text-decoration-style'] = 'wavy'\n                style['text-decoration-line'] = 'underline'\n                style['text-decoration-skip-ink'] = 'none'\n\n                title = token.value\n                break\n            case 'operator':\n                style.color = colors.hueColors.orange\n                break\n            case 'identifier':\n                if (basicConstants.includes(token.value)) {\n                    style.color = colors.hueColors.orange\n                }\n                break\n            case 'keyword':\n                style.color = colors.hueColors.purple\n                break\n        }\n\n        const result = document.createElement('span')\n        result.setAttribute('style', styleToString(style))\n        result.title = title ?? ''\n        result.replaceChildren(...content)\n        return result\n    }\n}\n\nfunction styleToString(style: Record<string, string>): string {\n    return Object.entries(style).map(([key, value]) => `${key}:${value};`).join('')\n}\n\nexport function getAutocompleteOptions(typeEnvironment: TypeEnvironment, tokens: AnnotatedToken[], currentIdentifer: string): string[] {\n    const allIdentifiers = new Set<string>()\n    for (const t of tokens) {\n        if (t.token.type === 'identifier') {\n            allIdentifiers.add(t.token.value)\n        }\n    }\n    for (const [id] of typeEnvironment) {\n        allIdentifiers.add(id)\n    }\n    allIdentifiers.delete(currentIdentifer)\n\n    const sortedIdentifiers = Array.from(allIdentifiers).flatMap((option) => {\n        const match = isAMatch(currentIdentifer.toLowerCase(), option.toLowerCase())\n        if (match === 0) {\n            return []\n        }\n        else {\n            return [{ option, match }]\n        }\n    }).sort((a, b) => {\n        if (a.match !== b.match) {\n            return b.match - a.match\n        }\n        else if (a.option.length !== b.option.length) {\n            return a.option.length - b.option.length\n        }\n        else {\n            return a.option.localeCompare(b.option)\n        }\n    }).map(({ option }) => option)\n\n    return sortedIdentifiers\n}\n\nexport function createAutocompleteMenu(colors: Colors): HTMLElement {\n    const style = {\n        'position': 'absolute',\n        'top': '100%',\n        'left': '100%',\n        'user-select': 'none',\n        'z-index': '3',\n        'overflow': 'scroll',\n        'max-height': `10lh`,\n        'border-radius': TestUtils.shared.isTesting ? '0' : '5px',\n        'border': `1px solid ${colors.borderNonShadow}`,\n        'color': colors.textMain,\n    }\n\n    const result = document.createElement('div')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n\n    return result\n}\n\nexport function createDocumentationPopover(colors: Colors, editor: HTMLPreElement, elemOffset: number): HTMLElement {\n    const width = Math.min(400, editor.offsetWidth)\n\n    const tokenOffset = elemOffset - totalOffset(editor).left\n\n    const style = {\n        'position': 'absolute',\n        'top': '100%',\n        'left': '0%',\n        'user-select': 'none',\n        'z-index': '3',\n        'overflow': 'scroll',\n        'max-height': `10lh`,\n        'border-radius': TestUtils.shared.isTesting ? '0' : '5px',\n        'border': `1px solid ${colors.borderNonShadow}`,\n        'color': colors.textMain,\n        'background-color': colors.slightlyDifferentBackground,\n        'width': `${width}px`,\n        'padding': '0 1.33em',\n        'transform': `translateX(${Math.min(0, editor.offsetWidth - (tokenOffset + width))}px)`,\n    }\n\n    const result = document.createElement('div')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n    result.className = 'serif'\n\n    return result\n}\n\nexport function createPlaceholder(colors: Colors, placeholderText: string): HTMLElement {\n    const style = {\n        'position': 'absolute',\n        'user-select': 'none',\n        'white-space': 'pre',\n        'color': colors.hueColors.grey,\n        'pointer-events': 'none',\n    }\n\n    const result = document.createElement('span')\n    result.setAttribute('contenteditable', 'false')\n    result.setAttribute('style', styleToString(style))\n\n    result.textContent = placeholderText\n\n    return result\n}\n\n// Custom hook interfaces\n\ninterface UndoRedoItem<T, S> {\n    time: number\n    state: T\n    selection: S\n}\n\nexport interface UndoRedoOptions {\n    undoChunking?: number\n    undoHistory?: number\n    onlyElement?: { current: HTMLElement | null }\n}\n\nexport function useUndoRedo<T, S>(\n    initialState: T,\n    initialSelection: S,\n    onStateChange: (state: T) => void,\n    onSelectionChange: (selection: S) => void,\n    { undoChunking = 1000, undoHistory = 100, onlyElement }: UndoRedoOptions = {},\n): {\n        addState: (state: T, selection: S) => void\n        updateCurrentSelection: (selection: S) => void\n        ui: ReactNode\n        canUndo: boolean\n        canRedo: boolean\n    } {\n    const undoStack = useRef<UndoRedoItem<T, S>[]>([\n        { time: 0, state: initialState, selection: initialSelection },\n    ])\n    const redoStack = useRef<UndoRedoItem<T, S>[]>([])\n\n    const [canUndo, setCanUndo] = useState(false)\n    const [canRedo, setCanRedo] = useState(false)\n\n    const addState = useCallback((state: T, selection: S): void => {\n        const currentUndoState = undoStack.current[undoStack.current.length - 1]\n\n        if (currentUndoState.time + undoChunking > Date.now()) {\n            // Amend current item rather than making a new one\n            currentUndoState.state = state\n            currentUndoState.selection = selection\n        }\n        else {\n            undoStack.current.push({ time: Date.now(), state, selection })\n            while (undoStack.current.length > undoHistory) {\n                undoStack.current.shift()\n            }\n            setCanUndo(true)\n        }\n        redoStack.current = []\n        setCanRedo(false)\n    }, [undoChunking, undoHistory])\n\n    const updateCurrentSelection = useCallback((selection: S): void => {\n        undoStack.current[undoStack.current.length - 1].selection = selection\n    }, [])\n\n    const doUndo = useCallback((): void => {\n        if (undoStack.current.length >= 2) {\n            const prevState = undoStack.current[undoStack.current.length - 2]\n            // Prev state becomes current state, current state becomes redo state\n            redoStack.current.push(undoStack.current.pop()!)\n            onStateChange(prevState.state)\n            onSelectionChange(prevState.selection)\n            setCanRedo(true)\n            setCanUndo(undoStack.current.length >= 2)\n        }\n    }, [onStateChange, onSelectionChange])\n\n    const doRedo = useCallback((): void => {\n        const futureState = redoStack.current.pop()\n        if (futureState !== undefined) {\n            undoStack.current.push(futureState)\n            onStateChange(futureState.state)\n            onSelectionChange(futureState.selection)\n            setCanUndo(true)\n            setCanRedo(redoStack.current.length >= 1)\n        }\n    }, [onStateChange, onSelectionChange])\n\n    const getIsActive = useCallback(() => {\n        return onlyElement === undefined || (document.activeElement !== null && document.activeElement === onlyElement.current)\n    }, [onlyElement])\n\n    // Set up keyboard shortcuts\n    useEffect(() => {\n        const listener = (e: KeyboardEvent): void => {\n            if (!getIsActive()) {\n                return\n            }\n\n            const isMac = navigator.userAgent.includes('Mac') && !TestUtils.shared.isTesting\n            if (isMac ? e.key.toLowerCase() === 'z' && e.metaKey && !e.shiftKey : e.key.toLowerCase() === 'z' && e.ctrlKey) {\n                e.preventDefault()\n                doUndo()\n            }\n            else if (isMac ? e.key.toLowerCase() === 'z' && e.metaKey && e.shiftKey : e.key.toLowerCase() === 'y' && e.ctrlKey) {\n                e.preventDefault()\n                doRedo()\n            }\n        }\n\n        window.addEventListener('keydown', listener)\n        return () => { window.removeEventListener('keydown', listener) }\n    }, [doUndo, doRedo, getIsActive])\n\n    const [isActive, setIsActive] = useState(getIsActive)\n\n    useEffect(() => {\n        const listener = (): void => {\n            setIsActive(getIsActive())\n        }\n        window.addEventListener('focusin', listener)\n        window.addEventListener('focusout', listener)\n        listener()\n        return () => {\n            window.removeEventListener('focusin', listener)\n            window.removeEventListener('focusout', listener)\n        }\n    }, [getIsActive])\n\n    const ui: ReactNode = isActive ? <UndoRedoControls {...{ doUndo, doRedo, canUndo, canRedo }} /> : null\n\n    return {\n        addState,\n        updateCurrentSelection,\n        ui,\n        canUndo,\n        canRedo,\n    }\n}\n\nfunction UndoRedoControls({ doUndo, doRedo, canUndo, canRedo }: { doUndo: () => void, doRedo: () => void, canUndo: boolean, canRedo: boolean }): ReactNode {\n    const outer = useRef<HTMLDivElement>(null)\n    const inner = useRef<HTMLDivElement>(null)\n\n    const width = 150\n    const height = 50\n\n    const padding = 10\n\n    /**\n     * iPhone safari is awful and ignores `position: fixed` when they keyboard is out\n     * So we need to do manual positioning\n     */\n    const positionInner = useCallback(() => {\n        // Get outer's position in the window\n        // Position inner at an offset from outer that matches up with the current scroll position\n        if (outer.current === null || inner.current === null) {\n            return\n        }\n\n        const outerBounds = outer.current.getBoundingClientRect()\n\n        const offsetParent = outer.current.offsetParent as HTMLElement\n\n        inner.current.style.top = `${Math.min((window.visualViewport?.height ?? window.innerHeight) - outerBounds.top, (offsetParent.offsetHeight - outer.current.offsetTop)) - height}px`\n        inner.current.style.left = `${Math.min((window.visualViewport?.width ?? window.innerWidth) - outerBounds.left, (offsetParent.offsetWidth - outer.current.offsetLeft)) - width}px`\n    }, [])\n\n    useEffect(positionInner, [positionInner])\n\n    useEffect(() => {\n        window.addEventListener('scroll', positionInner)\n        window.addEventListener('resize', positionInner)\n        window.visualViewport?.addEventListener('resize', positionInner)\n        return () => {\n            window.removeEventListener('scroll', positionInner)\n            window.removeEventListener('resize', positionInner)\n            window.visualViewport?.removeEventListener('resize', positionInner)\n        }\n    }, [positionInner])\n\n    const isMobile = useMobileLayout()\n\n    if (!isMobile) {\n        return null\n    }\n\n    const buttonStyle: CSSProperties = { flex: 1, touchAction: 'manipulation', zIndex: zIndex.mobileUndoRedoControls }\n\n    return (\n        <div ref={outer} style={{ position: 'absolute' }}>\n            <div\n                ref={inner}\n                style={{\n                    position: 'absolute',\n                    display: 'flex',\n                    width: `${width}px`,\n                    height: `${height}px`,\n                    gap: `${padding}px`,\n                    padding: `${padding}px`,\n                }}\n            >\n                <button\n                    onPointerDown={(e) => {\n                        e.preventDefault()\n                        doUndo()\n                    }}\n                    disabled={!canUndo}\n                    style={buttonStyle}\n                >\n                    Undo\n                </button>\n                <button\n                    onPointerDown={(e) => {\n                        e.preventDefault()\n                        doRedo()\n                    }}\n                    disabled={!canRedo}\n                    style={buttonStyle}\n                >\n                    Redo\n                </button>\n            </div>\n        </div>\n    )\n}\n","/*\n    Check whether a is a substring of b (does not have to be contiguous)\n*/\nexport function isAMatch(a: string, b: string): number {\n    let i = 0\n    let matchCount = 0\n    let prevMatch = true\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of -- b is a string\n    for (let j = 0; j < b.length; j++) {\n        if (a[i] === b[j]) {\n            i++\n            if (prevMatch) {\n                matchCount++\n            }\n            prevMatch = true\n        }\n        else {\n            prevMatch = false\n        }\n        if (i === a.length) {\n            return matchCount + 1\n        }\n    }\n    return 0\n}\n","import { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTStatement, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTArg, locationOf, unify } from './ast'\nimport { Context } from './context'\nimport { addAdditionalDims, broadcastApply, broadcastCall } from './forward-broadcasting'\nimport { LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\nimport { splitMask } from './split-broadcasting'\nimport { renderType, unifyType, USSRawValue, USSType, USSValue, USSVectorType, ValueArg, undocValue, canUnifyTo } from './types-values'\n\nexport interface Effect { type: 'warning', message: string, location: LocInfo }\n\nexport function renderLocInfo(loc: LocInfo): string {\n    if (loc.start.lineIdx === loc.end.lineIdx) {\n        if (loc.start.colIdx + 1 === loc.end.colIdx) {\n            // Single character location\n            return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}`\n        }\n        return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1}-${loc.end.colIdx}`\n    }\n    return `${loc.start.lineIdx + 1}:${loc.start.colIdx + 1} - ${loc.end.lineIdx + 1}:${loc.end.colIdx}`\n}\n\nexport class InterpretationError extends Error {\n    public value: string\n    constructor(message: string, public location: LocInfo) {\n        super(`${message} at ${renderLocInfo(location)}`)\n        this.name = 'InterpretationError'\n        this.value = message\n        this.location = location\n    }\n}\n\nexport function evaluate(expr: UrbanStatsASTExpression, env: Context): USSValue {\n    switch (expr.type) {\n        case 'constant':\n            const value = expr.value.node\n            if (value.type === 'number') {\n                return undocValue(value.value, { type: 'number' })\n            }\n            return undocValue(value.value satisfies string, { type: 'string' })\n        case 'identifier':\n            const varName = expr.name.node\n            const res = env.getVariable(varName)\n            if (res !== undefined) {\n                return res\n            }\n            throw env.error(`Undefined variable: ${varName}`, expr.name.location)\n        case 'attribute':\n            const obj = evaluate(expr.expr, env)\n            const attr = expr.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, undefined)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(expr))\n            }\n            return lookupResult.value\n        case 'call':\n            const func = evaluate(expr.fn, env)\n            const args = expr.args.map(arg => evaluateArg(arg, env))\n            const broadcastResult = broadcastCall(func, args, env, locationOf(expr))\n            if (broadcastResult.type === 'error') {\n                throw env.error(broadcastResult.message, locationOf(expr))\n            }\n            return broadcastResult.result\n        case 'unaryOperator':\n            const operand = evaluate(expr.expr, env)\n            return evaluateUnaryOperator(operand, expr.operator.node, env, locationOf(expr))\n        case 'binaryOperator':\n            const left = evaluate(expr.left, env)\n            const right = evaluate(expr.right, env)\n            return evaluateBinaryOperator(left, right, expr.operator.node, env, locationOf(expr))\n        case 'vectorLiteral':\n            const elements = expr.elements.map(e => evaluate(e, env))\n            let elementType = { type: 'elementOfEmptyVector' } as USSType | { type: 'elementOfEmptyVector' }\n            for (const e of elements) {\n                elementType = unifyType(elementType, e.type, () => {\n                    assert(elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(e.value)}`)\n                    return env.error(`vector literal contains heterogenous types ${renderType(elementType)} and ${renderType(e.type)}`, locationOf(expr))\n                })\n            }\n            return undocValue(elements.map(e => e.value), { type: 'vector', elementType })\n        case 'objectLiteral':\n            const ts = new Map<string, USSType>()\n            const vs = new Map<string, USSRawValue>()\n            for (const [name, e] of expr.properties) {\n                const v = evaluate(e, env)\n                if (ts.has(name)) {\n                    throw env.error(`Duplicate key ${name} in object literal`, locationOf(e))\n                }\n                ts.set(name, v.type)\n                vs.set(name, v.value)\n            }\n            return undocValue(vs, {\n                type: 'object',\n                properties: ts,\n            })\n        case 'if':\n            const condition = evaluate(expr.condition, env)\n            return splitMask(\n                env,\n                condition,\n                (v: USSValue, subEnv: Context): USSValue => {\n                    if (v.type.type !== 'boolean') {\n                        throw env.error(`Condition in if statement must be a boolean, but got ${renderType(v.type)}`, locationOf(expr.condition))\n                    }\n                    if (v.value) {\n                        return execute(expr.then, subEnv)\n                    }\n                    if (expr.else === undefined) {\n                        return undocValue(null, { type: 'null' })\n                    }\n                    return execute(expr.else, subEnv)\n                },\n                locationOf(expr.condition),\n                locationOf(expr),\n            )\n        case 'do':\n            if (expr.statements.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let doResult: USSValue = execute(expr.statements[0], env)\n            for (const statement of expr.statements.slice(1)) {\n                doResult = execute(statement, env)\n            }\n            return doResult\n        case 'customNode':\n            // This is a custom node for internal purposes, we just evaluate the expression\n            const result = execute(expr.expr, env)\n\n            // Check type if expectedType is provided\n            if (expr.expectedType && !expr.expectedType.some(t => canUnifyTo(result.type, t))) {\n                throw env.error(\n                    `Custom expression expected to return type ${expr.expectedType.map(t => renderType(t)).join(' or ')}, but got ${renderType(result.type)}`,\n                    locationOf(expr),\n                )\n            }\n\n            return result\n    }\n}\n\nexport function execute(expr: UrbanStatsASTStatement, env: Context): USSValue {\n    switch (expr.type) {\n        case 'condition':\n            if (expr.rest.length === 0) {\n                throw env.error('condition(..) must be followed by at least one statement', locationOf(expr))\n            }\n            return evaluate(\n                { type: 'if',\n                    condition: expr.condition,\n                    then: { type: 'statements', result: expr.rest, entireLoc: unify(...expr.rest.map(locationOf)) },\n                    entireLoc: expr.entireLoc,\n                },\n                env,\n            )\n        case 'assignment':\n            const value = evaluate(expr.value, env)\n            evaluateLHS(expr.lhs, value, env)\n            return value\n        case 'expression':\n            return evaluate(expr.value, env)\n        case 'statements':\n            if (expr.result.length === 0) {\n                return undocValue(null, { type: 'null' })\n            }\n            let result: USSValue = execute(expr.result[0], env)\n            for (const statement of expr.result.slice(1)) {\n                result = execute(statement, env)\n            }\n            return result\n        case 'parseError':\n            assert(expr.errors.length > 0, 'parseError node must have at least one error')\n            throw env.error(\n                `Parse error: ${expr.errors.map(e => e.value).join(', ')}`,\n                expr.errors[0].location,\n            )\n    }\n}\n\nexport function evaluateLHS(lhs: UrbanStatsASTLHS, value: USSValue, env: Context): void {\n    switch (lhs.type) {\n        case 'identifier':\n            const varName = lhs.name.node\n            const err = env.assignVariable(varName, value)\n            if (err !== undefined) {\n                throw env.error(err, locationOf(lhs))\n            }\n            return\n        case 'attribute':\n            const obj = evaluate(lhs.expr, env)\n            const attr = lhs.name.node\n            const lookupResult = attrLookupOrSet(obj, attr, value)\n            if (lookupResult.type === 'error') {\n                throw env.error(lookupResult.message, locationOf(lhs))\n            }\n            return\n    }\n}\n\nfunction evaluateArg(arg: UrbanStatsASTArg, env: Context): ValueArg {\n    switch (arg.type) {\n        case 'named':\n            return {\n                type: 'named',\n                name: arg.name.node,\n                value: evaluate(arg.value, env),\n            }\n        case 'unnamed':\n            return {\n                type: 'unnamed',\n                value: evaluate(arg.value, env),\n            }\n    }\n}\n\nfunction attrLookupOrSet(\n    obj: USSValue,\n    attr: string,\n    orSet: USSValue | undefined,\n): { type: 'success', value: USSValue } | { type: 'error', message: string } {\n    const type = obj.type\n    if (type.type === 'object') {\n        const val = obj.value\n        assert(val instanceof Map, `Expected object type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        const aT = type.properties.get(attr)\n        if (aT === undefined) {\n            return {\n                type: 'error',\n                message: `Attribute ${attr} not found in object of type ${renderType(type)}`,\n            }\n        }\n        if (orSet !== undefined) {\n            if (renderType(aT) !== renderType(orSet.type)) {\n                return {\n                    type: 'error',\n                    message: `Type mismatch: expected ${renderType(aT)} but got ${renderType(orSet.type)} for attribute ${attr} in object of type ${renderType(type)}`,\n                }\n            }\n            // If orSet is provided, we set the attribute to the value\n            val.set(attr, orSet.value)\n            return {\n                type: 'success',\n                value: undocValue(orSet.value, aT),\n            }\n        }\n        const content = val.get(attr)\n        assert(content !== undefined, `Expected attribute ${attr} to be defined in object, but got undefined at ${JSON.stringify(obj.value)}`)\n        return {\n            type: 'success',\n            value: undocValue(val.get(attr)!, aT),\n        }\n    }\n    if (type.type === 'vector') {\n        const val = obj.value\n        assert(val instanceof Array, `Expected vector type because of ${renderType(type)}, but got ${typeof val} at ${JSON.stringify(obj.value)}`)\n        let orSetLookp: (idx: number) => USSValue | undefined = () => undefined\n        if (orSet !== undefined) {\n            if (orSet.type.type !== 'vector') {\n                orSet = undocValue(addAdditionalDims([val.length], orSet.value), { type: 'vector', elementType: orSet.type })\n            }\n            assert(Array.isArray(orSet.value), `It should be an array at this point`)\n            if (orSet.value.length !== val.length) {\n                return { type: 'error', message: `Expected vector of length ${val.length} but got ${orSet.value.length} for attribute ${attr} in object of type ${renderType(type)}` }\n            }\n            const v = orSet.value\n            const t = (orSet.type as USSVectorType).elementType\n            assert(t.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(orSet.value)}`)\n            orSetLookp = (idx: number) => {\n                return undocValue(v[idx], t)\n            }\n        }\n        const resultsOrErr = val.map((x, i) => {\n            assert(type.elementType.type !== 'elementOfEmptyVector', `Unreachable: elementType should not be elementOfEmptyVector at ${JSON.stringify(obj.value)}`)\n            return attrLookupOrSet(undocValue(x, type.elementType), attr, orSetLookp(i))\n        })\n        if (resultsOrErr.some(r => r.type === 'error')) {\n            return { type: 'error', message: resultsOrErr.filter(r => r.type === 'error').map(r => (r as { type: 'error', message: string }).message)[0] }\n        }\n        const results = resultsOrErr.map(r => (r as { type: 'success', value: USSValue }).value)\n        const rawValue = results.map(r => r.value)\n        const typ = results[0].type\n        return {\n            type: 'success',\n            value: undocValue(rawValue, { type: 'vector', elementType: typ }),\n        }\n    }\n    return { type: 'error', message: `Cannot access attribute of type ${renderType(type)}. Only objects and vectors support attributes.` }\n}\n\nfunction evaluateUnaryOperator(operand: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.unary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.unary(operator, errLoc),\n        [operand],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n\nfunction evaluateBinaryOperator(left: USSValue, right: USSValue, operator: string, env: Context, errLoc: LocInfo): USSValue {\n    const operatorObj = expressionOperatorMap.get(operator)\n    assert(operatorObj?.binary !== undefined, `Unknown operator: ${operator}`)\n    const res = broadcastApply(\n        operatorObj.binary(operator, errLoc),\n        [left, right],\n        [],\n        env,\n        errLoc,\n    )\n    if (res.type === 'error') {\n        throw env.error(res.message, errLoc)\n    }\n    return res.result\n}\n","import { assert } from '../utils/defensive'\n\nimport { Block, LocInfo } from './location'\nimport { expressionOperatorMap } from './operators'\n\nconst nonExpressionOperators = ['=', ',', ';', '.', ':']\nconst operatorCharacters = '!@$%^&*-+=~`<>/?:|,;.'\n\nconst keywords = ['if', 'do', 'else', 'customNode', 'condition']\nexport type Keyword = (typeof keywords)[number]\n\ninterface NumericToken { type: 'number', value: number }\ninterface IdentifierToken { type: 'identifier', value: string }\ninterface KeywordToken { type: 'keyword', value: Keyword }\ninterface StringToken { type: 'string', value: string }\ninterface OperatorToken { type: 'operator', value: string }\ninterface BracketToken { type: 'bracket', value: '(' | ')' | '{' | '}' | '[' | ']' }\ninterface ErrorToken { type: 'error', value: string }\ntype NonErrorToken = NumericToken | IdentifierToken | KeywordToken | StringToken | OperatorToken | BracketToken\ntype Token = NonErrorToken | ErrorToken\n\nexport interface AnnotatedToken {\n    token: Token\n    location: LocInfo\n}\n\nexport type AnnotatedTokenWithValue = AnnotatedToken & { token: NonErrorToken }\n\ninterface GenericLexer {\n    firstToken: (ch: string) => boolean\n    innerToken: (ch: string) => boolean\n    parse: (string: string) => Token\n}\n\nfunction isDigit(ch: string): boolean {\n    return ch >= '0' && ch <= '9'\n}\nfunction isAlpha(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_'\n}\n\nexport function emptyLocation(ident: string): LocInfo {\n    return {\n        start: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n        end: { block: { type: 'single', ident }, lineIdx: 0, colIdx: 0, charIdx: 0 },\n    }\n}\n\nexport function parseNumber(input: string): number | undefined {\n    if (/^-?\\d*(\\.\\d+)?([eE][+-]?\\d+)?$/i.test(input)) {\n        // normal number format\n        const value = parseFloat(input)\n        if (isNaN(value)) {\n            return\n        }\n        return value\n    }\n    if (input.endsWith('k')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000\n    }\n    if (input.endsWith('m')) {\n        const component = parseNumber(input.slice(0, -1))\n        if (component === undefined) {\n            return\n        }\n        return component * 1000000\n    }\n    return\n}\n\nconst identifierLexer: GenericLexer = {\n    firstToken: isAlpha,\n    innerToken: (ch: string): boolean => isAlpha(ch) || isDigit(ch),\n    parse: (string: string): Token => { return { type: keywords.includes(string) ? 'keyword' : 'identifier', value: string } },\n}\n\nexport function allOperators(): string[] {\n    const ops = new Set<string>(nonExpressionOperators)\n    for (const op of expressionOperatorMap.keys()) {\n        ops.add(op)\n    }\n    // sort operators in descending length order to ensure longest match first\n    return Array.from(ops).sort((a, b) => b.length - a.length)\n}\n\nfunction tokenizeOperators(input: string): string[] | undefined {\n    const allOps = allOperators()\n    // console.log(allOps)\n    const tokens: string[] = []\n    let idx = 0\n    while (idx < input.length) {\n        let didMatch = false\n        for (const op of allOps) {\n            if (input.startsWith(op, idx)) {\n                tokens.push(op)\n                idx += op.length\n                didMatch = true\n                break\n            }\n        }\n        if (!didMatch)\n            return undefined\n    }\n    if (idx !== input.length) {\n        return undefined\n    }\n    return tokens\n}\n\nfunction lexOperators(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken[]] {\n    const [finalIdx, supertok] = lexGeneric(input, idx, block, lineNo, operatorLexer, charIdxOffset)\n    if (finalIdx === idx) {\n        return [idx, []]\n    }\n    // console.log(supertok)\n    assert(supertok !== undefined, 'unreachable')\n    assert(supertok.token.type === 'operator', 'unreachable')\n    const tokenizedOperators = tokenizeOperators(supertok.token.value)\n    // console.log(tokenizedOperators)\n    if (tokenizedOperators === undefined) {\n        return [finalIdx, [\n            {\n                token: { type: 'error', value: `Invalid operator sequence: ${supertok.token.value}` },\n                location: supertok.location,\n            },\n        ]]\n    }\n    let start = idx\n    const separatedTokens = tokenizedOperators.map((op) => {\n        const location: LocInfo = {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: start + op.length, charIdx: charIdxOffset + start + op.length },\n        }\n        start += op.length\n        return {\n            token: { type: 'operator', value: op },\n            location,\n        } satisfies AnnotatedToken\n    })\n    // console.log(separatedTokens)\n    return [finalIdx, separatedTokens]\n}\n\nconst operatorLexer: GenericLexer = {\n    firstToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    innerToken: (ch: string): boolean => operatorCharacters.includes(ch),\n    parse: (string: string): Token => {\n        return { type: 'operator', value: string }\n    },\n}\n\nfunction lexLine(input: string, block: Block, lineNo: number, charIdxOffset: number): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    // one line\n    assert(!input.includes('\\n'), 'Input contains new line characters')\n    let idx = 0\n    lex: while (idx < input.length) {\n        const char = input[idx]\n        if (char === ' ') {\n            idx++\n            continue\n        }\n        if (char === '(' || char === ')' || char === '{' || char === '}' || char === '[' || char === ']') {\n            const token: AnnotatedToken = {\n                token: { type: 'bracket', value: char },\n                location: {\n                    start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                    end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n                },\n            }\n            tokens.push(token)\n            idx++\n            continue\n        }\n        if (isDigit(char)) {\n            let token\n            [idx, token] = lexNumber(input, idx, block, lineNo, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue\n            }\n        }\n        for (const lexer of [identifierLexer]) {\n            let token\n            [idx, token] = lexGeneric(input, idx, block, lineNo, lexer, charIdxOffset)\n            if (token !== undefined) {\n                tokens.push(token)\n                continue lex\n            }\n        }\n        {\n            let toks\n            [idx, toks] = lexOperators(input, idx, block, lineNo, charIdxOffset)\n            if (toks.length > 0) {\n                tokens.push(...toks)\n                continue\n            }\n        }\n        let token\n        [idx, token] = lexString(input, idx, block, lineNo, charIdxOffset)\n        if (token !== undefined) {\n            tokens.push(token)\n            continue\n        }\n        tokens.push({\n            token: { type: 'error', value: `Unexpected character: ${char}` },\n            location: {\n                start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n                end: { block, lineIdx: lineNo, colIdx: idx + 1, charIdx: charIdxOffset + idx + 1 },\n            },\n        })\n        idx++\n    }\n    return tokens\n}\n\nexport function lex(block: Block, input: string): AnnotatedToken[] {\n    const tokens: AnnotatedToken[] = []\n    const lines = input.split('\\n')\n    let charIdx = 0\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i]\n        const lineTokens = lexLine(line, block, i, charIdx)\n        tokens.push(...lineTokens)\n        charIdx += line.length\n        tokens.push({\n            token: { type: 'operator', value: 'EOL' },\n            location: {\n                start: { block, lineIdx: i, colIdx: line.length, charIdx },\n                end: { block, lineIdx: i, colIdx: line.length, charIdx },\n            },\n        })\n        charIdx += 1 // newline\n    }\n    return tokens\n}\n\nfunction lexGeneric(\n    input: string,\n    idx: number,\n    block: Block,\n    lineNo: number,\n    lexer: GenericLexer,\n    charIdxOffset: number,\n): [number, AnnotatedToken | undefined] {\n    if (!lexer.firstToken(input[idx])) {\n        return [idx, undefined]\n    }\n\n    const start = idx\n    while (idx < input.length && lexer.innerToken(input[idx])) {\n        idx++\n    }\n    const token: AnnotatedToken = {\n        token: lexer.parse(input.slice(start, idx)),\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexString(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    if (input[idx] !== '\"') {\n        return [idx, undefined]\n    }\n    const start = idx\n    idx++\n    while (true) {\n        if (idx >= input.length) {\n            return [idx, { token: { type: 'error', value: 'Unterminated string' }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + start } } }]\n        }\n        if (input[idx] === '\"') {\n            idx++\n            break\n        }\n        if (input[idx] === '\\\\') {\n            idx += 2\n            continue\n        }\n        idx++\n    }\n    let result: string\n    try {\n        const resultObj: unknown = JSON.parse(input.slice(start, idx))\n        assert(typeof resultObj === 'string', `Invalid string: ${input.slice(start, idx)}`)\n        result = resultObj\n    }\n    catch (e) {\n        return [idx, { token: { type: 'error', value: `Invalid string: ${input.slice(start, idx)}: ${e}` }, location: { start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start }, end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'string', value: result },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: start, charIdx: charIdxOffset + start },\n            end: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n        },\n    }\n    return [idx, token]\n}\n\nfunction lexNumber(input: string, idx: number, block: Block, lineNo: number, charIdxOffset: number): [number, AnnotatedToken | undefined] {\n    const numberFormat = /^\\d+(\\.\\d+)?([eE][+-]?\\d+|k|m)?/i\n    const match = numberFormat.exec(input.slice(idx))\n    if (!match) {\n        return [idx, undefined]\n    }\n    const numberStr = match[0]\n    const number = parseNumber(numberStr)\n    if (number === undefined) {\n        return [idx + numberStr.length, { token: { type: 'error', value: `Invalid number format: ${numberStr}` }, location: { start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx }, end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length } } }]\n    }\n    const token: AnnotatedToken = {\n        token: { type: 'number', value: number },\n        location: {\n            start: { block, lineIdx: lineNo, colIdx: idx, charIdx: charIdxOffset + idx },\n            end: { block, lineIdx: lineNo, colIdx: idx + numberStr.length, charIdx: charIdxOffset + idx + numberStr.length },\n        },\n    }\n    return [idx + numberStr.length, token]\n}\n","export type Block = { type: 'single', ident: string } | { type: 'multi' }\n\nexport interface SingleLocationWithinBlock {\n    lineIdx: number\n    colIdx: number\n    charIdx: number\n}\nexport type SingleLocation = SingleLocationWithinBlock & { block: Block }\n\nexport interface LocInfo {\n    start: SingleLocation\n    end: SingleLocation\n}\n\nexport const noLocation = { start: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 }, end: { block: { type: 'multi' }, lineIdx: 0, colIdx: 0, charIdx: 0 } } satisfies LocInfo\n\nexport function extendBlockIdPositionalArg(blockIdent: string, position: number): string {\n    return `${blockIdent}_pos_${position}`\n}\n\nexport function extendBlockIdKwarg(blockIdent: string, argName: string): string {\n    return `${blockIdent}_${argName}`\n}\n\nexport function extendBlockIdVectorElement(blockIdent: string, index: number): string {\n    return `${blockIdent}_el_${index}`\n}\n\nexport function extendBlockIdObjectProperty(blockIdent: string, property: string): string {\n    return `${blockIdent}_prop_${property}`\n}\n","import { assert } from '../utils/defensive'\n\nimport { locationOf, unify, UrbanStatsAST, UrbanStatsASTArg, UrbanStatsASTExpression, UrbanStatsASTLHS, UrbanStatsASTStatement } from './ast'\nimport { Context } from './context'\nimport { AnnotatedToken, AnnotatedTokenWithValue, lex, Keyword, emptyLocation } from './lexer'\nimport { noLocation, LocInfo, Block } from './location'\nimport { expressionOperatorMap, infixOperators, unaryOperators } from './operators'\nimport { USSType } from './types-values'\n\nexport interface Decorated<T> {\n    node: T\n    location: LocInfo\n}\n\nexport interface ParseError { type: 'error', value: string, location: LocInfo }\n\ntype USSInfixSequenceElement = { type: 'operator', operatorType: 'unary' | 'binary', value: Decorated<string> } | UrbanStatsASTExpression\n\nexport function toSExp(node: UrbanStatsAST): string {\n    /**\n     * For testing purposes, we convert the AST to a simple S-expression format.\n     */\n    switch (node.type) {\n        case 'unnamed':\n            return toSExp(node.value)\n        case 'named':\n            return `(named ${node.name.node} ${toSExp(node.value)})`\n        case 'constant':\n            return `(const ${node.value.node.value})`\n        case 'identifier':\n            return `(id ${node.name.node})`\n        case 'attribute':\n            return `(attr ${toSExp(node.expr)} ${node.name.node})`\n        case 'call':\n            return `(fn ${[node.fn, ...node.args].map(toSExp).join(' ')})`\n        case 'unaryOperator':\n            return `(${node.operator.node} ${toSExp(node.expr)})`\n        case 'binaryOperator':\n            return `(${node.operator.node} ${toSExp(node.left)} ${toSExp(node.right)})`\n        case 'vectorLiteral':\n            return `(vector ${node.elements.map(toSExp).join(' ')})`\n        case 'objectLiteral':\n            return `(object ${node.properties.map(([key, value]) => `(${key} ${toSExp(value)})`).join(' ')})`\n        case 'assignment':\n            return `(assign ${toSExp(node.lhs)} ${toSExp(node.value)})`\n        case 'expression':\n            return `(expr ${toSExp(node.value)})`\n        case 'statements':\n            return `(statements ${node.result.map(toSExp).join(' ')})`\n        case 'if':\n            return `(if ${toSExp(node.condition)} ${toSExp(node.then)}${node.else ? ` ${toSExp(node.else)}` : ''})`\n        case 'do':\n            return `(do ${node.statements.map(toSExp).join(' ')})`\n        case 'condition':\n            return `(condition ${toSExp(node.condition)} ${node.rest.map(toSExp).join(' ')})`\n        case 'parseError':\n            return `(parseError ${JSON.stringify(node.originalCode)} ${JSON.stringify(node.errors)})`\n        case 'customNode':\n            return `(customNode ${toSExp(node.expr)} ${JSON.stringify(node.originalCode)})`\n    }\n}\n\nclass ParseState {\n    tokens: AnnotatedTokenWithValue[]\n    index: number\n    constructor(tokens: AnnotatedTokenWithValue[]) {\n        this.tokens = tokens\n        this.index = 0\n    }\n\n    skipEOL(): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === 'operator' && token.token.value === 'EOL') {\n            this.index++\n            return true\n        }\n        return false\n    }\n\n    consumeTokenOfType(type: string, ...values: (string | number)[]): boolean {\n        if (this.index >= this.tokens.length) {\n            return false\n        }\n        const token = this.tokens[this.index]\n        if (token.token.type === type && (values.length === 0 || values.includes(token.token.value))) {\n            this.index++\n            return true\n        }\n        if (this.skipEOL()) {\n            if (this.consumeTokenOfType(type, ...values)) {\n                return true\n            }\n            this.index-- // backtrack\n        }\n        return false\n    }\n\n    consumeOperator(...oneOfOps: string[]): boolean {\n        return this.consumeTokenOfType('operator', ...oneOfOps)\n    }\n\n    consumeBracket(...oneOfBrackets: string[]): boolean {\n        return this.consumeTokenOfType('bracket', ...oneOfBrackets)\n    }\n\n    consumeIdentifier(): boolean {\n        return this.consumeTokenOfType('identifier')\n    }\n\n    consumeKeyword(...oneOfKeywords: Keyword[]): boolean {\n        return this.consumeTokenOfType('keyword', ...oneOfKeywords)\n    }\n\n    maybeLastNonEOLToken(offset: number): AnnotatedTokenWithValue {\n        for (let i = this.index + offset; i >= 0; i--) {\n            const token = this.tokens[i]\n            if (token.token.type !== 'operator' || token.token.value !== 'EOL') {\n                return token\n            }\n        }\n        return this.tokens[this.index + offset]\n    }\n\n    parseSingleExpression(): UrbanStatsASTExpression | ParseError {\n        while (this.skipEOL()) { }\n        if (this.index >= this.tokens.length) {\n            return { type: 'error', value: 'Unexpected end of input', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const token = this.tokens[this.index]\n        switch (token.token.type) {\n            case 'number':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'number', value: token.token.value }, location: token.location } }\n            case 'string':\n                this.index++\n                return { type: 'constant', value: { node: { type: 'string', value: token.token.value }, location: token.location } }\n            case 'identifier':\n                this.index++\n                return { type: 'identifier', name: { node: token.token.value, location: token.location } }\n            case 'keyword':\n                return { type: 'error', value: `Unexpected keyword ${token.token.value}`, location: token.location }\n            case 'bracket':\n                switch (token.token.value) {\n                    case '(':\n                        this.index++\n                        const expr = this.parseExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        if (!this.consumeBracket(')')) {\n                            return { type: 'error', value: 'Expected closing bracket ) to match this one', location: token.location }\n                        }\n                        return expr\n                    case '{':\n                        this.index++\n                        const startLoc = token.location\n                        const properties: [string, UrbanStatsASTExpression][] = []\n                        while (!this.consumeBracket('}')) {\n                            if (properties.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: `Expected comma , or closing bracket } after object field name; instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n                            }\n                            if (!this.consumeIdentifier()) {\n                                return { type: 'error', value: 'Expected identifier for object field name', location: this.maybeLastNonEOLToken(-1).location }\n                            }\n                            const keyToken = this.tokens[this.index - 1]\n                            assert(keyToken.token.type === 'identifier', `Expected identifier token, but got ${keyToken.token.type}`)\n                            if (!this.consumeOperator(':')) {\n                                return { type: 'error', value: `Expected : token after object field name`, location: keyToken.location }\n                            }\n                            const value = this.parseExpression()\n                            if (value.type === 'error') {\n                                return value\n                            }\n                            properties.push([keyToken.token.value, value])\n                        }\n                        const endLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'objectLiteral',\n                            entireLoc: unify(startLoc, endLoc),\n                            properties,\n                        }\n                    case '[':\n                        this.index++\n                        const vectorStartLoc = token.location\n                        const elements: UrbanStatsASTExpression[] = []\n                        while (!this.consumeBracket(']')) {\n                            if (elements.length > 0 && !this.consumeOperator(',')) {\n                                return { type: 'error', value: 'Expected comma , or closing bracket ] after vector element', location: this.maybeLastNonEOLToken(0).location }\n                            }\n                            const element = this.parseExpression()\n                            if (element.type === 'error') {\n                                return element\n                            }\n                            elements.push(element)\n                        }\n                        const vectorEndLoc = this.tokens[this.index - 1].location\n                        return {\n                            type: 'vectorLiteral',\n                            entireLoc: unify(vectorStartLoc, vectorEndLoc),\n                            elements,\n                        }\n                }\n                return { type: 'error', value: `Unexpected bracket ${token.token.value}`, location: token.location }\n            case 'operator':\n                return { type: 'error', value: `Unexpected operator ${token.token.value}`, location: token.location }\n        }\n    }\n\n    parseArg(): UrbanStatsASTArg | ParseError {\n        const exprOrName = this.parseExpression()\n        if (exprOrName.type === 'error') {\n            return exprOrName\n        }\n        if (!this.consumeOperator('=')) {\n            return { type: 'unnamed', value: exprOrName }\n        }\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (exprOrName.type !== 'identifier') {\n            return { type: 'error', value: 'Expected identifier for named argument', location: locationOf(exprOrName) }\n        }\n        return {\n            type: 'named',\n            name: { node: exprOrName.name.node, location: exprOrName.name.location },\n            value: expr,\n        }\n    }\n\n    parseParenthesizedArgs(): { type: 'args', args: [UrbanStatsASTArg[], LocInfo] } | ParseError | undefined {\n        if (!this.consumeBracket('(')) {\n            return undefined\n        }\n        const startLoc = this.tokens[this.index - 1].location\n        const args: UrbanStatsASTArg[] = []\n        while (true) {\n            if (this.consumeBracket(')')) {\n                const endLoc = this.tokens[this.index - 1].location\n                return { type: 'args', args: [args, unify(startLoc, endLoc)] }\n            }\n            if (args.length > 0 && !this.consumeOperator(',')) {\n                return { type: 'error', value: `Expected comma , or closing bracket ); instead received ${this.tokens[this.index].token.value}`, location: this.tokens[this.index].location }\n            }\n            const arg = this.parseArg()\n            if (arg.type === 'error') {\n                return arg\n            }\n            args.push(arg)\n        }\n    }\n\n    parseFunctionalExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('customNode')) {\n            return this.parseCustomNodeExpression()\n        }\n\n        let fn = this.parseSingleExpression()\n        if (fn.type === 'error') {\n            return fn\n        }\n        while (true) {\n            let done = true\n            const args = this.parseParenthesizedArgs()\n            if (args !== undefined) {\n                done = false\n                if (args.type === 'error') {\n                    return args\n                }\n                fn = {\n                    type: 'call',\n                    fn,\n                    entireLoc: unify(locationOf(fn), args.args[1]),\n                    args: args.args[0],\n                }\n            }\n            if (this.consumeOperator('.')) {\n                done = false\n                if (!this.consumeIdentifier()) {\n                    return { type: 'error', value: 'Expected identifier after the dot', location: this.maybeLastNonEOLToken(-1).location }\n                }\n                const token = this.tokens[this.index - 1]\n                assert(token.token.type === 'identifier', `Expected identifier token, but got ${token.token.type}`)\n                fn = {\n                    type: 'attribute',\n                    expr: fn,\n                    name: { node: token.token.value, location: token.location },\n                }\n            }\n            if (done) {\n                break\n            }\n        }\n        return fn\n    }\n\n    parseExpression(): UrbanStatsASTExpression | ParseError {\n        if (this.consumeKeyword('if')) {\n            return this.parseIfExpression()\n        }\n\n        if (this.consumeKeyword('do')) {\n            return this.parseDoExpression()\n        }\n\n        const operatorExpSequence: USSInfixSequenceElement[] = []\n        // State Machine with states expressionOrUnaryOperator; binaryOperator\n        let state: 'expressionOrUnaryOperator' | 'binaryOperator' = 'expressionOrUnaryOperator'\n        loop: while (true) {\n            switch (state) {\n                case 'expressionOrUnaryOperator': {\n                    if (this.consumeOperator(...unaryOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'unary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        continue\n                    }\n                    else {\n                        const expr = this.parseFunctionalExpression()\n                        if (expr.type === 'error') {\n                            return expr\n                        }\n                        operatorExpSequence.push(expr)\n                        state = 'binaryOperator'\n                    }\n                }\n                    break\n                case 'binaryOperator': {\n                    if (this.consumeOperator(...infixOperators)) {\n                        const operator = this.tokens[this.index - 1]\n                        assert(operator.token.type === 'operator', 'Expected operator token')\n                        operatorExpSequence.push({\n                            type: 'operator',\n                            operatorType: 'binary',\n                            value: { node: operator.token.value, location: operator.location },\n                        })\n                        state = 'expressionOrUnaryOperator'\n                    }\n                    else {\n                        break loop\n                    }\n                }\n            }\n        }\n        return this.parseInfixSequence(operatorExpSequence)\n    }\n\n    parseInfixSequence(operatorExpSequence: USSInfixSequenceElement[]): UrbanStatsASTExpression | ParseError {\n        assert(operatorExpSequence.length !== 0, 'Expected expression')\n        if (operatorExpSequence.length === 1) {\n            assert(operatorExpSequence[0].type !== 'operator', `Unexpected operator ${JSON.stringify(operatorExpSequence[0])} at beginning of infix sequence`)\n            return operatorExpSequence[0]\n        }\n        // Get the highest precedence operator\n        const precedences = operatorExpSequence.map(x => x.type === 'operator' ? expressionOperatorMap.get(x.value.node)?.precedence ?? 0 : 0)\n        const maxPrecedence = Math.max(...precedences)\n        assert(maxPrecedence > 0, 'No valid operator found in infix sequence')\n        const index = precedences.findIndex(p => p === maxPrecedence)\n        assert(index > -1, 'No operator found with maximum precedence; this should not happen')\n        return this.parseInfixSequence(this.resolveOperator(operatorExpSequence, index))\n    }\n\n    resolveOperator(operatorExpSequence: USSInfixSequenceElement[], index: number): USSInfixSequenceElement[] {\n        assert(operatorExpSequence[index].type === 'operator', `Expected operator at index ${index}, but found expression: ${JSON.stringify(operatorExpSequence[index])}`)\n        const next = operatorExpSequence[index + 1]\n        if (next.type === 'operator') {\n            return this.resolveOperator(operatorExpSequence, index + 1)\n        }\n        switch (operatorExpSequence[index].operatorType) {\n            case 'unary': {\n                return [\n                    ...operatorExpSequence.slice(0, index),\n                    { type: 'unaryOperator', operator: operatorExpSequence[index].value, expr: next },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n            case 'binary': {\n                // Split the sequence into left and right parts\n                const left = operatorExpSequence[index - 1]\n                const right = operatorExpSequence[index + 1]\n                assert(left.type !== 'operator' && right.type !== 'operator', 'unreachable: left or right should not be an operator')\n                return [\n                    ...operatorExpSequence.slice(0, index - 1),\n                    { type: 'binaryOperator', operator: operatorExpSequence[index].value, left, right },\n                    ...operatorExpSequence.slice(index + 2),\n                ]\n            }\n        }\n    }\n\n    checkLHS(expr: UrbanStatsASTExpression): UrbanStatsASTLHS | ParseError {\n        switch (expr.type) {\n            case 'identifier':\n            case 'attribute':\n                return expr\n            case 'constant':\n            case 'call':\n            case 'unaryOperator':\n            case 'binaryOperator':\n            case 'vectorLiteral':\n            case 'objectLiteral':\n            case 'if':\n            case 'do':\n            case 'customNode':\n                return { type: 'error', value: 'Cannot assign to this expression', location: locationOf(expr) }\n        }\n    }\n\n    parseStatement(): UrbanStatsASTStatement | ParseError {\n        if (this.consumeKeyword('condition')) {\n            return this.parseConditionStatement()\n        }\n\n        const expr = this.parseExpression()\n        if (expr.type === 'error') {\n            return expr\n        }\n        if (this.consumeOperator('=')) {\n            const value = this.parseExpression()\n            if (value.type === 'error') {\n                return value\n            }\n            const lhs = this.checkLHS(expr)\n            if (lhs.type === 'error') {\n                return lhs\n            }\n            return { type: 'assignment', lhs, value }\n        }\n        return { type: 'expression', value: expr }\n    }\n\n    parseIfExpression(): UrbanStatsASTExpression | ParseError {\n        const ifToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after if', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after if condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const then = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after if block')\n        if (then.type === 'error') {\n            return then\n        }\n        let elseBranch: UrbanStatsASTStatement | undefined = undefined\n        if (this.consumeKeyword('else')) {\n            if (!this.consumeBracket('{')) {\n                return { type: 'error', value: 'Expected opening bracket { after else', location: this.maybeLastNonEOLToken(-1).location }\n            }\n            const eb = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after else block')\n            if (eb.type === 'error') {\n                return eb\n            }\n            elseBranch = eb\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'if',\n            entireLoc: unify(ifToken.location, lastToken.location),\n            condition,\n            then,\n            else: elseBranch,\n        }\n    }\n\n    parseDoExpression(): UrbanStatsASTExpression | ParseError {\n        const doToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('{')) {\n            return { type: 'error', value: 'Expected opening bracket { after do', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const statements = this.parseStatements(true, () => this.consumeBracket('}'), 'Expected } after do block')\n        if (statements.type === 'error') {\n            return statements\n        }\n        const lastToken = this.tokens[this.index - 1]\n        return {\n            type: 'do',\n            entireLoc: unify(doToken.location, lastToken.location),\n            statements: statements.type === 'statements' ? statements.result : [statements],\n        }\n    }\n\n    parseConditionStatement(): UrbanStatsASTStatement | ParseError {\n        const conditionToken = this.tokens[this.index - 1]\n        if (!this.consumeBracket('(')) {\n            return { type: 'error', value: 'Expected opening bracket ( after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        const condition = this.parseExpression()\n        if (condition.type === 'error') {\n            return condition\n        }\n        if (!this.consumeBracket(')')) {\n            return { type: 'error', value: 'Expected closing bracket ) after condition', location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return {\n            type: 'condition',\n            entireLoc: unify(conditionToken.location, this.tokens[this.index - 1].location),\n            condition,\n            rest: [],\n        }\n    }\n\n    parseStatements(canEnd: boolean = false, end: () => boolean = () => false, errMsg: string = 'Expected end of line or ; after'): UrbanStatsASTStatement | ParseError {\n        const statements: UrbanStatsASTStatement[] = []\n        while (this.index < this.tokens.length) {\n            if (end()) {\n                break\n            }\n            while (this.skipEOL()) { }\n            if (this.index >= this.tokens.length) {\n                break\n            }\n            const statement = this.parseStatement()\n            if (statement.type === 'error') {\n                return statement\n            }\n            statements.push(statement)\n            if (end()) {\n                break\n            }\n            if (!this.consumeOperator('EOL', ';')) {\n                return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n            }\n            while (this.skipEOL()) { }\n        }\n        if (this.index === this.tokens.length && canEnd) {\n            return { type: 'error', value: errMsg, location: this.maybeLastNonEOLToken(-1).location }\n        }\n        return mergeStatements(\n            statements,\n            this.index > 0\n                ? this.tokens[this.index - 1].location\n                /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n                : undefined,\n        )\n    }\n\n    parseCustomNodeExpression(): UrbanStatsASTExpression | ParseError {\n        const argsRes = this.parseParenthesizedArgs()\n\n        if (argsRes === undefined) {\n            return { type: 'error', value: 'Expected arguments for customNode', location: this.maybeLastNonEOLToken(-1).location }\n        }\n\n        if (argsRes.type === 'error') {\n            return argsRes\n        }\n\n        const [args, locArg] = argsRes.args\n\n        const code = args[0]\n\n        if (args.length !== 1 || code.type !== 'unnamed') {\n            return { type: 'error', value: 'Incorrect arguments for customNode, expected 1 unnamed argument', location: argsRes.args[1] }\n        }\n\n        if (code.value.type !== 'constant' || code.value.value.node.type !== 'string') {\n            return { type: 'error', value: 'Expected string constant as argument to customNode', location: locationOf(code) }\n        }\n\n        const parseResult = parse(code.value.value.node.value, code.value.value.location.start.block)\n\n        if (parseResult.type === 'error') {\n            return {\n                type: 'customNode',\n                expr: {\n                    type: 'parseError',\n                    errors: parseResult.errors,\n                    originalCode: code.value.value.node.value,\n                },\n                originalCode: code.value.value.node.value,\n                entireLoc: locArg,\n            }\n        }\n\n        return {\n            type: 'customNode',\n            expr: parseResult,\n            originalCode: code.value.value.node.value,\n            entireLoc: locArg,\n        }\n    }\n}\n\nexport function mergeStatements(statements: UrbanStatsASTStatement[], fallbackLocation?: LocInfo): UrbanStatsASTStatement {\n    statements = gulpRestForConditions(statements)\n    if (statements.length === 1) {\n        return statements[0]\n    }\n    const entireLoc: LocInfo = statements.length > 0\n        ? unify(...statements.map(locationOf))\n        : fallbackLocation\n        /* c8 ignore next -- This case should not happen in practice, but we handle it gracefully */\n        ?? noLocation\n    return { type: 'statements', result: statements, entireLoc }\n}\n\nfunction gulpRestForConditions(statements: UrbanStatsASTStatement[]): UrbanStatsASTStatement[] {\n    /**\n     * Handle condition statements by gulping the next statement into the condition's rest.\n     */\n    const result: UrbanStatsASTStatement[] = []\n    for (let i = 0; i < statements.length; i++) {\n        const stmt = statements[i]\n        if (stmt.type === 'condition') {\n            stmt.rest.push(...gulpRestForConditions(statements.slice(i + 1)))\n            result.push(stmt)\n            break\n        }\n        result.push(stmt)\n    }\n    return result\n}\n\nexport function parse(code: string, block?: Block, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const tokens = lex(block ?? { type: 'multi' }, code)\n    return parseTokens(tokens, code, returnParseErrorNode)\n}\n\nexport function parseTokens(tokens: AnnotatedToken[], originalCode: string, returnParseErrorNode: boolean = false): UrbanStatsASTStatement | { type: 'error', errors: ParseError[] } {\n    const lexErrors = tokens.filter(token => token.token.type === 'error')\n    if (lexErrors.length > 0) {\n        const errors: ParseError[] = lexErrors.map(token => ({ type: 'error' as const, value: `Unrecognized token: ${token.token.value}`, location: token.location }))\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors }\n        }\n        return { type: 'error', errors }\n    }\n    const state = new ParseState(tokens as AnnotatedTokenWithValue[]) // we checked for errors above, so this cast is safe\n    const stmts = state.parseStatements()\n    if (stmts.type === 'error') {\n        if (returnParseErrorNode) {\n            return { type: 'parseError', originalCode, errors: [stmts] }\n        }\n        return { type: 'error', errors: [stmts] }\n    }\n    assert(state.index === state.tokens.length, `Parser did not consume all tokens: ${state.index} < ${state.tokens.length}`)\n    return stmts\n}\n\nfunction allExpressions(node: UrbanStatsASTStatement | UrbanStatsASTExpression): UrbanStatsASTExpression[] {\n    const expressions: UrbanStatsASTExpression[] = []\n    function helper(n: UrbanStatsASTStatement | UrbanStatsASTExpression | UrbanStatsASTArg): boolean {\n        switch (n.type) {\n            case 'unnamed':\n                helper(n.value)\n                return true\n            case 'named':\n                expressions.push(n.value)\n                helper(n.value)\n                return true\n            case 'constant':\n            case 'identifier':\n                expressions.push(n)\n                return true\n            case 'attribute':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'call':\n                expressions.push(n)\n                helper(n.fn)\n                n.args.forEach(helper)\n                return true\n            case 'unaryOperator':\n                expressions.push(n)\n                helper(n.expr)\n                return true\n            case 'binaryOperator':\n                expressions.push(n)\n                helper(n.left)\n                helper(n.right)\n                return true\n            case 'objectLiteral':\n                expressions.push(n)\n                n.properties.forEach(([key, value]) => {\n                    expressions.push({ type: 'constant', value: { node: { type: 'string', value: key }, location: n.entireLoc } })\n                    helper(value)\n                })\n                return true\n            case 'vectorLiteral':\n                expressions.push(n)\n                n.elements.forEach(helper)\n                return true\n            case 'assignment':\n                helper(n.lhs)\n                helper(n.value)\n                return true\n            case 'expression':\n                helper(n.value)\n                return true\n            case 'statements':\n                n.result.forEach(helper)\n                return true\n            case 'if':\n                helper(n.condition)\n                helper(n.then)\n                if (n.else) {\n                    helper(n.else)\n                }\n                return true\n            case 'do':\n                n.statements.forEach(helper)\n                return true\n            case 'condition':\n                helper(n.condition)\n                n.rest.forEach(helper)\n                return true\n            case 'parseError':\n                return true\n            case 'customNode':\n                // do not actually put this in the expressions list, as is for internal use only\n                helper(n.expr)\n                return true\n        }\n    }\n    helper(node)\n    return expressions\n}\n\nfunction identifiersInExpr(node: UrbanStatsASTStatement | UrbanStatsASTExpression): Set<string> {\n    const identifiers = new Set<string>()\n    allExpressions(node).forEach((expr) => {\n        if (expr.type === 'identifier') {\n            identifiers.add(expr.name.node)\n        }\n    })\n    return identifiers\n}\n\nexport function allIdentifiers(node: UrbanStatsASTStatement | UrbanStatsASTExpression, ctx: Context): Set<string> {\n    const identifiers = identifiersInExpr(node)\n    while (true) {\n        // make sure to include identifiers from default values of function arguments pulled in by the identifiers\n        const newIdentifiers = new Set<string>()\n        identifiers.forEach((id) => {\n            const t = ctx.getVariable(id)?.type\n            if (t === undefined || t.type !== 'function') {\n                return\n            }\n            Object.entries(t.namedArgs).forEach(([, arg]) => {\n                const dv = arg.defaultValue\n                if (dv === undefined) {\n                    return\n                }\n                identifiersInExpr(dv).forEach((newId) => {\n                    if (!identifiers.has(newId)) {\n                        newIdentifiers.add(newId)\n                    }\n                })\n            })\n        })\n        if (newIdentifiers.size === 0) {\n            break\n        }\n        newIdentifiers.forEach(id => identifiers.add(id))\n    }\n    return identifiers\n}\n\nexport function unparse(node: UrbanStatsASTStatement | UrbanStatsASTExpression, opts: { indent?: number, inline?: boolean, simplify?: boolean, expressionalContext?: boolean, wrap?: boolean } = {}): string {\n    if (opts.inline) {\n        assert(opts.expressionalContext ?? false, 'expressionalContext must be true if inline is true')\n    }\n    opts.indent = opts.indent ?? 0\n    opts.wrap = opts.wrap ?? true\n    function isSimpleExpression(expr: UrbanStatsASTExpression): boolean {\n        return expr.type === 'identifier' || expr.type === 'vectorLiteral' || expr.type === 'constant' || expr.type === 'customNode'\n    }\n    function indentSpaces(level: number): string {\n        return '    '.repeat(level)\n    }\n\n    const characterLimit = 80 - indentSpaces(opts.indent).length\n\n    switch (node.type) {\n        case 'customNode':\n            if (!opts.simplify) {\n                return `customNode(${JSON.stringify(node.originalCode.trim())})`\n            }\n            if (opts.expressionalContext && node.expr.type !== 'expression') {\n                return unparse({ type: 'do', statements: [node.expr], entireLoc: locationOf(node.expr) }, { ...opts, inline: true })\n            }\n            else {\n                return node.originalCode.trim()\n            }\n        case 'parseError':\n            return node.originalCode\n        case 'constant':\n            if (node.value.node.type === 'string') {\n                return JSON.stringify(node.value.node.value)\n            }\n            else {\n                return node.value.node.value.toString()\n            }\n        case 'identifier':\n            return node.name.node\n        case 'attribute':\n            const exprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            return `${exprStr}.${node.name.node}`\n        case 'call': {\n            const fnStr = unparse(node.fn, { ...opts, inline: true, expressionalContext: true })\n            const argsStr = node.args.map((arg) => {\n                switch (arg.type) {\n                    case 'unnamed':\n                        return unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: false })\n                    case 'named':\n                        return `${arg.name.node}=${unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: false })}`\n                }\n            })\n            const fnNeedsParens = !isSimpleExpression(node.fn)\n            const fnWithParens = fnNeedsParens ? `(${fnStr})` : fnStr\n            const notWrapped = `${fnWithParens}(${argsStr.join(', ')})`\n            if (notWrapped.length > characterLimit && opts.wrap) {\n                // Special case for one unnamed argument that's a vector literal\n                if (node.args.length === 1 && node.args[0].type === 'unnamed' && node.args[0].value.type === 'vectorLiteral') {\n                    return `${fnWithParens}(${unparse(node.args[0].value, { ...opts, inline: true, expressionalContext: true, wrap: true })})`\n                }\n                const wrappedArgs = node.args.map((arg) => {\n                    switch (arg.type) {\n                        case 'unnamed':\n                            return `${indentSpaces(opts.indent! + 1)}${unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: true, indent: opts.indent! + 1 })}`\n                        case 'named':\n                            return `${indentSpaces(opts.indent! + 1)}${arg.name.node}=${unparse(arg.value, { ...opts, inline: true, expressionalContext: true, wrap: true, indent: opts.indent! + 1 })}`\n                    }\n                })\n                return `${fnWithParens}(\\n${wrappedArgs.join(',\\n')}\\n${indentSpaces(opts.indent)})`\n            }\n            return notWrapped\n        }\n        case 'unaryOperator':\n            const unaryExprStr = unparse(node.expr, { ...opts, inline: true, expressionalContext: true })\n            const needsParens = !isSimpleExpression(node.expr)\n            const exprWithParens = needsParens ? `(${unaryExprStr})` : unaryExprStr\n            return `${node.operator.node}${exprWithParens}`\n        case 'binaryOperator':\n            const leftStr = unparse(node.left, { ...opts, inline: true, expressionalContext: true })\n            const rightStr = unparse(node.right, { ...opts, inline: true, expressionalContext: true })\n            const opPrecedence = expressionOperatorMap.get(node.operator.node)?.precedence ?? 0\n            let leftWithParens = leftStr\n            if (node.left.type === 'binaryOperator') {\n                const leftOpPrecedence = expressionOperatorMap.get(node.left.operator.node)?.precedence ?? 0\n                if (leftOpPrecedence < opPrecedence) {\n                    leftWithParens = `(${leftStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.left)) {\n                leftWithParens = `(${leftStr})`\n            }\n            let rightWithParens = rightStr\n            if (node.right.type === 'binaryOperator') {\n                const rightOpPrecedence = expressionOperatorMap.get(node.right.operator.node)?.precedence ?? 0\n                if (rightOpPrecedence <= opPrecedence) {\n                    rightWithParens = `(${rightStr})`\n                }\n            }\n            else if (!isSimpleExpression(node.right)) {\n                rightWithParens = `(${rightStr})`\n            }\n            return `${leftWithParens} ${node.operator.node} ${rightWithParens}`\n        case 'vectorLiteral': {\n            const elementsStr = node.elements.map(elem => unparse(elem, { ...opts, inline: true, expressionalContext: true, wrap: false }))\n            const notWrapped = `[${elementsStr.join(', ')}]`\n            if (notWrapped.length > characterLimit && opts.wrap) {\n                const wrappedElements = node.elements.map(elem => `${indentSpaces(opts.indent! + 1)}${unparse(elem, { ...opts, inline: true, expressionalContext: true, wrap: true, indent: opts.indent! + 1 })}`)\n                return `[\\n${wrappedElements.join(',\\n')}\\n${indentSpaces(opts.indent)}]`\n            }\n            return notWrapped\n        }\n        case 'objectLiteral': {\n            const propertiesStr = node.properties.map(([key, value]) => {\n                const valueStr = unparse(value, { ...opts, inline: true, expressionalContext: true, wrap: false })\n                return `${key}: ${valueStr}`\n            })\n            const notWrapped = `{${propertiesStr.join(', ')}}`\n            if (notWrapped.length > characterLimit && opts.wrap) {\n                const wrappedProperties = node.properties.map(([key, value]) => {\n                    const valueStr = unparse(value, { ...opts, inline: true, expressionalContext: true, wrap: true })\n                    return `${indentSpaces(opts.indent! + 1)}${key}: ${valueStr}`\n                })\n                return `{\\n${wrappedProperties.join(',\\n')}\\n${indentSpaces(opts.indent)}}`\n            }\n            return notWrapped\n        }\n        case 'assignment':\n            const lhsStr = unparse(node.lhs, { ...opts, expressionalContext: true })\n            const valueStr = unparse(node.value, { ...opts, expressionalContext: true })\n            return opts.inline ? `${lhsStr} = ${valueStr}` : `${indentSpaces(opts.indent)}${lhsStr} = ${valueStr}`\n        case 'expression':\n            // despite being an expression, it is not in an expressional context if its parent is not\n            return opts.inline ? unparse(node.value, opts) : `${indentSpaces(opts.indent)}${unparse(node.value, opts)}`\n        case 'statements':\n            const statementsStr = node.result\n                .map(stmt => unparse(stmt, opts))\n                .filter(s => s !== '' && s !== 'do {  }')\n            return statementsStr.join(opts.inline ? '; ' : ';\\n')\n        case 'if':\n            const conditionStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const thenStr = unparse(node.then, { ...opts, indent: opts.indent + 1 })\n            let ifStr = opts.inline\n                ? `if (${conditionStr}) { ${thenStr} }`\n                : `if (${conditionStr}) {\\n${thenStr}\\n${indentSpaces(opts.indent)}}`\n            if (node.else) {\n                const elseStr = unparse(node.else, { ...opts, indent: opts.indent + 1 })\n                ifStr += opts.inline\n                    ? ` else { ${elseStr} }`\n                    : ` else {\\n${elseStr}\\n${indentSpaces(opts.indent)}}`\n            }\n            return ifStr\n        case 'do':\n            const doStatements = { type: 'statements' as const, result: node.statements, entireLoc: node.entireLoc }\n            const doStr = unparse(doStatements, { ...opts, indent: opts.indent + 1 })\n            return opts.inline\n                ? `do { ${doStr} }`\n                : `do {\\n${doStr}\\n${indentSpaces(opts.indent)}}`\n        case 'condition':\n            const condStr = unparse(node.condition, { ...opts, expressionalContext: true })\n            const restStatements = { type: 'statements' as const, result: node.rest, entireLoc: node.entireLoc }\n            const restStr = unparse(restStatements, opts)\n            // If condition is literal \"true\", elide it\n            if (opts.simplify && node.condition.type === 'identifier' && node.condition.name.node === 'true') {\n                return restStr\n            }\n            return `${indentSpaces(opts.indent)}condition (${condStr})\\n${restStr}`\n    }\n}\n\nexport function parseNoError(uss: string, blockId: string): UrbanStatsASTStatement {\n    const result = parse(uss, { type: 'single', ident: blockId }, true)\n    assert(result.type !== 'error', `Should not have an error`)\n    return result\n}\n\nexport function parseNoErrorAsCustomNode(uss: string, blockId: string, expectedType?: USSType[]): Extract<UrbanStatsASTExpression, { type: 'customNode' }> {\n    assert(!blockId.startsWith('undefined'), 'blockId must not start with \"undefined\"')\n    const result = parseNoError(uss, blockId)\n    return {\n        type: 'customNode',\n        expr: result,\n        originalCode: uss,\n        expectedType,\n        entireLoc: emptyLocation(blockId),\n    }\n}\n\nexport function parseNoErrorAsExpression(uss: string, blockId: string): UrbanStatsASTExpression {\n    const result = parseNoError(uss, blockId)\n    assert(result.type === 'expression', `Must be expression, got ${JSON.stringify(result)}`)\n    return result.value\n}\n","import { Basemap } from '../mapper/settings/utils'\nimport { assert } from '../utils/defensive'\n\nimport { UrbanStatsASTExpression } from './ast'\nimport { Color, deconstructColor, hexToColor } from './constants/color-utils'\nimport { CMap, CMapRGB, Outline, PMap } from './constants/map'\nimport { RampT } from './constants/ramp'\nimport { RichTextAttributes, RichTextDocument, RichTextSegment } from './constants/rich-text'\nimport { Scale } from './constants/scale'\nimport { TextBox } from './constants/text-box'\nimport { Context } from './context'\nimport { noLocation } from './location'\nimport { unparse } from './parser'\n\n// Define Inset and Insets types locally to avoid import issues\ninterface Inset { bottomLeft: [number, number], topRight: [number, number], coordBox?: [number, number, number, number], mainMap: boolean, name?: string }\ntype Insets = Inset[]\n\n// Define the tagged union for opaque values\nexport type USSOpaqueValue =\n    | { type: 'opaque', opaqueType: 'color', value: Color }\n    | { type: 'opaque', opaqueType: 'scale', value: Scale }\n    | { type: 'opaque', opaqueType: 'inset', value: Inset }\n    | { type: 'opaque', opaqueType: 'insets', value: Insets }\n    | { type: 'opaque', opaqueType: 'cMap', value: CMap }\n    | { type: 'opaque', opaqueType: 'cMapRGB', value: CMapRGB }\n    | { type: 'opaque', opaqueType: 'pMap', value: PMap }\n    | { type: 'opaque', opaqueType: 'outline', value: Outline }\n    | { type: 'opaque', opaqueType: 'unit', value: { unit: string } }\n    | { type: 'opaque', opaqueType: 'ramp', value: RampT }\n    | { type: 'opaque', opaqueType: 'basemap', value: Basemap }\n    | { type: 'opaque', opaqueType: 'geoFeatureHandle', value: string }\n    | { type: 'opaque', opaqueType: 'geoCentroidHandle', value: string }\n    | { type: 'opaque', opaqueType: 'textBox', value: TextBox }\n    | { type: 'opaque', opaqueType: 'richTextDocument', value: RichTextDocument }\n    | { type: 'opaque', opaqueType: 'richTextSegment', value: RichTextSegment }\n    | { type: 'opaque', opaqueType: 'richTextList', value: RichTextAttributes['list'] }\n    | { type: 'opaque', opaqueType: 'richTextAlign', value: RichTextAttributes['align'] }\n\ninterface USSNumberType {\n    type: 'number'\n}\n\ninterface USSStringType {\n    type: 'string'\n}\ninterface USSBooleanType {\n    type: 'boolean'\n}\n\ninterface USSNullType {\n    type: 'null'\n}\n\nexport interface USSOpaqueType {\n    type: 'opaque'\n    name: string\n    allowCustomExpression?: boolean\n}\n\nexport interface USSVectorType {\n    type: 'vector'\n    elementType: USSType | { type: 'elementOfEmptyVector' }\n}\n\nexport interface USSObjectType {\n    type: 'object'\n    properties: Map<string, USSType>\n}\n\nexport type USSFunctionArgType = { type: 'concrete', value: USSType } | { type: 'anyPrimitive' }\nexport type USSFunctionReturnType = { type: 'concrete', value: USSType } | { type: 'inferFromPrimitive' }\n\nexport interface NamedFunctionArgumentWithDocumentation {\n    type: USSFunctionArgType\n    defaultValue?: UrbanStatsASTExpression\n    documentation?: NamedFunctionArgumentDocumentation\n}\n\nexport interface USSFunctionType {\n    type: 'function'\n    posArgs: USSFunctionArgType[]\n    namedArgs: Record<string, NamedFunctionArgumentWithDocumentation>\n    returnType: USSFunctionReturnType\n}\n\ninterface NamedFunctionArgumentDocumentation {\n    hide?: boolean\n}\n\nexport type USSType = (\n    USSNumberType\n    | USSStringType\n    | USSBooleanType\n    | USSNullType\n    | USSOpaqueType\n    | USSObjectType\n    | USSVectorType\n    | USSFunctionType\n)\n\nexport type USSPrimitiveRawValue = (\n    number |\n    string |\n    boolean |\n    null\n)\n\nexport interface OriginalFunctionArgs {\n    posArgs: USSValue[]\n    namedArgs: Record<string, USSValue>\n}\n\nexport type USSRawValue = (\n    USSPrimitiveRawValue |\n    USSRawValue[] |\n    Map<string, USSRawValue> |\n    (\n        (\n            ctx: Context,\n            posArgs: USSRawValue[],\n            namedArgs: Record<string, USSRawValue>,\n            // only used occasionally, for functions that need to access the original arguments\n            // to e.g., access their documentation\n            originalArgs: OriginalFunctionArgs\n        ) => USSRawValue\n    ) |\n    USSOpaqueValue\n)\n\nexport const constantCategories = ['basic', 'color', 'math', 'regression', 'mapper', 'logic', 'map', 'scale', 'ramp', 'unit', 'inset', 'richText'] as const\n\nexport type ConstantCategory = typeof constantCategories[number]\n\nexport type DocumentationTable = 'mapper-data-variables' | 'predefined-colors' | 'unit-types' | 'predefined-ramps' | 'predefined-insets' | 'logarithm-functions' | 'trigonometric-functions'\n\nexport type SelectorRendering = { kind: 'subtitleLongDescription' } | { kind: 'gradientBackground', ramp: RampT }\nexport interface Documentation {\n    humanReadableName: string\n    priority?: number\n    /**\n     * True if this is the canonical default value for its type (e.g., the default ramp or scale).\n     */\n    isDefault?: boolean\n    /**\n     * Human-readable names for named arguments. Maps argument name to display name.\n     */\n    namedArgs?: Record<string, string>\n    /**\n     * Should be included when a constant should be deconstructed into an expression for user editing\n     */\n    equivalentExpressions?: UrbanStatsASTExpression[]\n    /**\n     * Included for all bulit-in constants.\n     */\n    category?: ConstantCategory\n    /**\n     * Whether the constant should be grouped with other constants in a table in the documentation.\n     * If present, this field groups the constant with other similar ones.\n     */\n    documentationTable?: DocumentationTable\n    /**\n     * Included for all bulit-in constants. Will be displayed in the documentation.\n     */\n    longDescription?: string\n    /**\n     * Used when displaying this value in a selector\n     */\n    selectorRendering?: SelectorRendering\n    /**\n     * True if this is a custom constructor that should invoke edit icons elsewhere\n     */\n    customConstructor?: boolean\n    /**\n     * True if the constant is derived from a statistic column. These should all have type number[]\n     */\n    fromStatisticColumn?: boolean\n    /**\n     * True if this should be outputted in the context returned by the worker. If this is true, the value\n     * should also be serializable to JSON.\n     */\n    includedInOutputContext?: boolean\n}\n\nexport interface USSDocumentedType {\n    type: USSType\n    documentation?: Documentation\n\n}\n\nexport type TypeEnvironment = Map<string, USSDocumentedType>\n\nexport type USSValue = { value: USSRawValue } & USSDocumentedType\n\nexport function undocValue(value: USSRawValue, type: USSType): USSValue {\n    return {\n        type,\n        value,\n        documentation: undefined,\n    }\n}\n\nexport function createConstantExpression(value: number | string | boolean | null): UrbanStatsASTExpression {\n    // Create a simple constant expression for primitive values\n    if (typeof value === 'number') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'number', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'string') {\n        return {\n            type: 'constant',\n            value: { node: { type: 'string', value }, location: noLocation },\n        }\n    }\n    else if (typeof value === 'boolean') {\n        // For booleans, use identifier expressions that reference the predefined constants\n        return {\n            type: 'identifier',\n            name: { node: value.toString(), location: noLocation },\n        }\n    }\n    else {\n        // For null, use identifier expression that references the predefined null constant\n        return {\n            type: 'identifier',\n            name: { node: 'null', location: noLocation },\n        }\n    }\n}\n\nexport function unifyFunctionType(param: USSFunctionArgType, arg: USSType): boolean {\n    if (param.type === 'concrete') {\n        return renderType(param.value) === renderType(arg)\n    }\n    return arg.type === 'number' || arg.type === 'string' || arg.type === 'boolean' || arg.type === 'null'\n}\n\nexport function renderType(type: USSType): string {\n    if (type.type === 'number') {\n        return 'number'\n    }\n    if (type.type === 'string') {\n        return 'string'\n    }\n    if (type.type === 'boolean') {\n        return 'boolean'\n    }\n    if (type.type === 'vector') {\n        return `[${type.elementType.type === 'elementOfEmptyVector' ? '' : renderType(type.elementType)}]`\n    }\n    if (type.type === 'object') {\n        assert(type.properties instanceof Map, `Expected properties to be a Map, got ${typeof type.properties}`)\n        return `{${[...type.properties.entries()].sort().map(([k, v]) => `${k}: ${renderType(v)}`).join(', ')}}`\n    }\n    if (type.type === 'null') {\n        return 'null'\n    }\n    if (type.type === 'opaque') {\n        return type.name\n    }\n    return `(${type.posArgs.map(renderArgumentType).join(', ')}; ${Object.entries(type.namedArgs).map(([k, v]) => `${k}: ${renderKwargType(v)}`).join(', ')}) -> ${renderReturnType(type.returnType)}`\n}\n\nexport function renderArgumentType(arg: USSFunctionArgType): string {\n    if (arg.type === 'concrete') {\n        return renderType(arg.value)\n    }\n    return 'any'\n}\n\nexport function renderKwargType(arg: { type: USSFunctionArgType, defaultValue?: UrbanStatsASTExpression }): string {\n    const type = renderArgumentType(arg.type)\n    if (arg.defaultValue !== undefined) {\n        return `${type} = ${unparse(arg.defaultValue)}`\n    }\n    return type\n}\n\nfunction renderReturnType(ret: USSFunctionReturnType): string {\n    if (ret.type === 'concrete') {\n        return renderType(ret.value)\n    }\n    return 'any'\n}\n\nexport type ValueArg = (\n    { type: 'unnamed', value: USSValue } |\n    { type: 'named', name: string, value: USSValue }\n)\n\nexport function getPrimitiveType(value: USSRawValue, depth: number = 0): USSType {\n    if (depth === 0) {\n        if (typeof value === 'number') {\n            return { type: 'number' }\n        }\n        if (typeof value === 'string') {\n            return { type: 'string' }\n        }\n        if (typeof value === 'boolean') {\n            return { type: 'boolean' }\n        }\n        if (value === null) {\n            return { type: 'null' }\n        }\n    }\n    assert(Array.isArray(value), `Expected a primitive value, but got ${typeof value}`)\n    return getPrimitiveType(value[0], depth - 1)\n}\n\nexport function unifyType(\n    a: USSType | { type: 'elementOfEmptyVector' },\n    b: USSType | { type: 'elementOfEmptyVector' },\n    error: () => Error,\n): USSType | { type: 'elementOfEmptyVector' } {\n    if (a.type === 'elementOfEmptyVector') {\n        return b\n    }\n    if (b.type === 'elementOfEmptyVector') {\n        return a\n    }\n    if (renderType(a) === renderType(b)) {\n        return a\n    }\n    if (a.type === 'vector' && b.type === 'vector') {\n        return {\n            type: 'vector',\n            elementType: unifyType(a.elementType, b.elementType, error),\n        }\n    }\n    if (a.type === 'object' && b.type === 'object') {\n        if (JSON.stringify([...a.properties.keys()].sort()) !== JSON.stringify([...b.properties.keys()].sort())) {\n            throw error()\n        }\n        const properties = new Map<string, USSType>()\n        for (const [key, type] of a.properties) {\n            properties.set(key, type)\n        }\n        for (const [key, type] of b.properties) {\n            const res = unifyType(properties.get(key)!, type, error)\n            assert(res.type !== 'elementOfEmptyVector', `Unreachable`)\n            properties.set(key, res)\n        }\n        return {\n            type: 'object',\n            properties,\n        }\n    }\n    throw error()\n}\n\nexport function renderValue(input: USSValue): string {\n    function helper(value: USSValue, indent: string): string {\n        const type = value.type\n        switch (type.type) {\n            case 'boolean':\n            case 'null':\n            case 'number':\n                return `${value.value}`\n            case 'string':\n                return `\"${value.value}\"`\n            case 'opaque':\n                const opaqueValue = value.value as USSOpaqueValue\n                switch (opaqueValue.opaqueType) {\n                    case 'scale':\n                    case 'pMap':\n                    case 'cMap':\n                    case 'cMapRGB':\n                    case 'basemap':\n                    case 'inset':\n                    case 'insets':\n                    case 'geoFeatureHandle':\n                    case 'geoCentroidHandle':\n                    case 'unit':\n                    case 'textBox':\n                    case 'richTextDocument':\n                    case 'richTextSegment':\n                    case 'richTextAlign':\n                    case 'richTextList':\n                        return `[${opaqueValue.opaqueType} object]`\n                    case 'color':\n                        return deconstructColor(opaqueValue.value)\n                    case 'outline':\n                        const outline = opaqueValue.value\n                        return `constructOutline(color=${deconstructColor(outline.color)}, weight=${outline.weight})`\n                    case 'ramp':\n                        const ramp = opaqueValue.value\n                        const rampValue = ramp.map(\n                            ([position, color]) => {\n                                const contents: [string, USSRawValue][] = [\n                                        ['value', position] satisfies [string, USSRawValue],\n                                        ['color', { type: 'opaque', opaqueType: 'color', value: hexToColor(color) }] satisfies [string, USSRawValue],\n                                ] satisfies [string, USSRawValue][]\n                                return new Map(contents) satisfies Map<string, USSRawValue>\n                            },\n                        )\n                        const interior = undocValue(rampValue,\n                            {\n                                type: 'vector',\n                                elementType: {\n                                    type: 'object',\n                                    properties: new Map([\n                                        ['value', { type: 'number' }],\n                                        ['color', { type: 'opaque', name: 'color' }],\n                                    ]),\n                                },\n                            },\n                        )\n                        return `[ramp ${renderValue(interior)}]`\n                }\n            case 'vector':\n                const vector = value.value as USSRawValue[]\n                if (vector.length === 0) {\n                    return `[]`\n                }\n                // USSType assertion is OK since we handle zero-length vectors above\n                return `[\n${vector.map(element => `${indent}    ${helper(undocValue(element, type.elementType as USSType), `${indent}    `)}`).join(',\\n')}\n${indent}]`\n            case 'object':\n                const map = value.value as Map<string, USSRawValue>\n                if (map.size === 0) {\n                    return `{}`\n                }\n                return `{\n${Array.from(map.entries()).map(([key, element]) => `${indent}    ${key}: ${helper(undocValue(element, type.properties.get(key)!), `${indent}    `)}`).join(',\\n')}\n${indent}}`\n            case 'function':\n                return renderType(type)\n        }\n    }\n    return helper(input, '')\n}\n\nexport function canUnifyTo(a: USSType, b: USSType): boolean {\n    // returns true iff a can be used in a context where b is expected\n    if (renderType(a) === renderType(b)) {\n        return true\n    }\n    // at this point, the types are different\n    switch (b.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'null':\n        case 'opaque':\n            // these are all primitive types, so no way to substitute them\n            return false\n        case 'vector':\n            assert(b.elementType.type !== 'elementOfEmptyVector', `Unreachable`)\n            return canUnifyTo(a, b.elementType)\n        case 'object':\n            if (a.type !== 'object') {\n                return false\n            }\n            if (a.properties.size !== b.properties.size) {\n                return false\n            }\n            if (![...a.properties.keys()].every(key => b.properties.has(key))) {\n                return false\n            }\n            return [...a.properties.keys()].every(key => canUnifyTo(a.properties.get(key)!, b.properties.get(key)!))\n        case 'function':\n            return false\n    }\n}\n"],"names":["locationOfLastExpression","node","locationOf","assert","unify","_key","locations","startLine","min","loc","Math","Number","endLine","max","startCol","endCol","startChar","endChar","getAllParseErrors","errors","collectErrors","n","value","_errors","toStatement","colorType","rgbToColor","red","green","blue","alpha","tolerateError","Error","hsvToColor","hue","saturation","rgb","createConstantExpression","ctx","posArgs","namedArgs","hsv","renderColor","color","doRender","colorConstant","name","isDefault","humanReadableName","camelToHuman","capitalizedName","hexToColor","parseNoErrorAsExpression","rgbColorExpression","round","hsvColorExpression","colorConstants","Object","hueColors","insetType","insetsType","boundsType","Map","constructInsetValue","screenBounds","mapBounds","screenBoundsObj","mapBoundsObj","mainMap","constructInsetsValue","insetsList","item","computeInsetConstantName","deconstruct","inset","uss","insetConsts","insets","regionInsets","insetName","insetNameToConstantName","documentLength","document","sum","segment","colorSchema","z","c","console","richTextAttributesSchema","s","pixels","result","parseFloat","isFinite","array","undefined","richTextSegmentSchema","link","richTextDocumentType","richTextSegmentType","richTextListType","richTextAlignType","attributesFromNamedArgs","_namedArgs_color","_namedArgs_list","_namedArgs_align","_namedArgs_size","_namedArgs_font","_namedArgs_bold","_namedArgs_italic","_namedArgs_underline","_namedArgs_indent","_namedArgs_strike","entries","v","richTextSegmentConstructorType","alignIdentifierToValue","alignValueToIdentifer","listIdentifierToValue","listValueToIdentifier","richTextConstants","segmentsList","text","attributes","formula","image","id","defaults","colorThemes","textBox","doc","deconstructRichTextDocument","deconstructColor","deconstructRichTextSegment","deconstructRichTextAttributes","JSON","list","pair","textBoxType","constructTextBoxValue","backgroundColor","borderColor","borderWidth","longMessage","includeLocationInfo","renderLocInfo","renderValue","makeScript","lex","renderCode","script","colors","modfiyTokenContent","modifyTokenSpan","span","brackets","DefaultMap","basicConstants","token","content","title","style","levelColor","level","Array","next","openEquivalent","styleToString","_result","lexSpans","errorSpans","charIdx","indexInTokens","indexInErrors","errorLoc","errorLoc1","_errorSpans_spans1","_errorSpans_spans","tokenSpan","nodeContent","_node_textContent","HTMLElement","getRange","editor","selection","window","range","positionInEditor","offset","sibling","setRange","newRange","currentRange","_getContainerOffset","anchorNode","anchorOffset","_getContainerOffset1","focusNode","focusOffset","getContainerOffset","position","key","getAutocompleteOptions","typeEnvironment","tokens","currentIdentifer","allIdentifiers","Set","_iteratorError","t","_iteratorError1","option","match","isAMatch","a","b","i","matchCount","prevMatch","j","createAutocompleteMenu","TestUtils","createDocumentationPopover","elemOffset","width","tokenOffset","totalOffset","createPlaceholder","placeholderText","useUndoRedo","initialState","initialSelection","onStateChange","onSelectionChange","_ref","undoChunking","undoHistory","onlyElement","undoStack","useRef","redoStack","_useState","canUndo","setCanUndo","_useState1","canRedo","setCanRedo","addState","useCallback","state","currentUndoState","Date","updateCurrentSelection","doUndo","prevState","doRedo","futureState","getIsActive","useEffect","listener","e","isMac","navigator","_useState2","isActive","setIsActive","ui","UndoRedoControls","param","outer","inner","positionInner","_window_visualViewport_height","_window_visualViewport_width","outerBounds","offsetParent","_window_visualViewport","useMobileLayout","buttonStyle","zIndex","InterpretationError","message","location","p","evaluate","expr","env","undocValue","varName","res","lookupResult","attrLookupOrSet","func","args","arg","broadcastResult","broadcastCall","evaluateUnaryOperator","operand","operator","errLoc","operatorObj","expressionOperatorMap","broadcastApply","evaluateBinaryOperator","left","right","elements","elementType","unifyType","renderType","ts","vs","condition","splitMask","subEnv","execute","doResult","_iteratorError2","statement","canUnifyTo","evaluateLHS","lhs","err","obj","attr","orSet","type","val","_instanceof","_type_of","aT","val1","orSetLookp","addAdditionalDims","idx","resultsOrErr","x","r","results","rawValue","typ","nonExpressionOperators","operatorCharacters","keywords","isDigit","ch","isAlpha","emptyLocation","ident","parseNumber","input","isNaN","component","component1","identifierLexer","string","operatorLexer","block","lines","line","lineTokens","lexLine","lineNo","charIdxOffset","char","token1","lexNumber","numberFormat","numberStr","number","_iter","lexer","token2","lexGeneric","toks","lexOperators","_lexGeneric","finalIdx","supertok","tokenizedOperators","tokenizeOperators","allOps","allOperators","ops","op","didMatch","start","_tokens","token3","lexString","resultObj","noLocation","extendBlockIdPositionalArg","blockIdent","extendBlockIdKwarg","argName","extendBlockIdVectorElement","index","extendBlockIdObjectProperty","property","unparse","opts","isSimpleExpression","indentSpaces","_opts_expressionalContext","_opts_indent","_opts_wrap","characterLimit","exprStr","fnStr","argsStr","fnWithParens","fnNeedsParens","notWrapped","wrappedArgs","unaryExprStr","needsParens","exprWithParens","_expressionOperatorMap_get_precedence","_expressionOperatorMap_get_precedence1","_expressionOperatorMap_get_precedence2","leftStr","rightStr","opPrecedence","leftWithParens","leftOpPrecedence","rightWithParens","rightOpPrecedence","elementsStr","elem","notWrapped1","wrappedElements","propertiesStr","valueStr","notWrapped2","wrappedProperties","lhsStr","statementsStr","stmt","conditionStr","thenStr","ifStr","elseStr","doStr","condStr","restStr","ParseState","skipEOL","consumeTokenOfType","values","consumeOperator","oneOfOps","consumeBracket","oneOfBrackets","consumeIdentifier","consumeKeyword","oneOfKeywords","maybeLastNonEOLToken","parseSingleExpression","startLoc","properties","keyToken","endLoc","vectorStartLoc","element","vectorEndLoc","parseArg","exprOrName","parseParenthesizedArgs","parseFunctionalExpression","fn","done","parseExpression","operatorExpSequence","loop","unaryOperators","infixOperators","operator1","parseInfixSequence","_Math","precedences","maxPrecedence","resolveOperator","checkLHS","parseStatement","parseIfExpression","ifToken","then","elseBranch","eb","lastToken","parseDoExpression","doToken","statements","parseConditionStatement","conditionToken","parseStatements","canEnd","end","errMsg","mergeStatements","fallbackLocation","gulpRestForConditions","_stmt_rest","entireLoc","parseCustomNodeExpression","argsRes","_argsRes_args","locArg","code","parseResult","parse","returnParseErrorNode","parseTokens","originalCode","lexErrors","stmts","identifiersInExpr","expressions","identifiers","allExpressions","helper","newIdentifiers","_ctx_getVariable","dv","newId","parseNoError","blockId","parseNoErrorAsCustomNode","expectedType","getPrimitiveType","depth","indent","opaqueValue","outline","interior","ramp","vector","map","error","key1","type1","constantCategories","unifyFunctionType","ret","k","renderArgumentType","renderReturnType","renderKwargType"],"mappings":"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"}